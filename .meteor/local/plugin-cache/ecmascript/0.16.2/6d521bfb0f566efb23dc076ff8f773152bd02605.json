{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/a37/code/github/makemeahanzi-tool/lib/svg.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"lib/svg.js","filename":"/Users/a37/code/github/makemeahanzi-tool/lib/svg.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/a37/code/github/makemeahanzi-tool","root":"/Users/a37/code/github/makemeahanzi-tool","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/a37/code/github/makemeahanzi-tool/lib/svg.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"lib/svg.js"}},"code":"module.export({\n  svg: () => svg\n});\nlet assert, Point;\nmodule.link(\"/lib/base\", {\n  assert(v) {\n    assert = v;\n  },\n\n  Point(v) {\n    Point = v;\n  }\n\n}, 0);\nconst svg = {}; // A normal-form SVG path string is a data string with the following properties:\n//   - Every command in the path is in ['L', 'M', 'Q', 'Z'].\n//   - Adjacent tokens in the path are separated by exactly one space.\n//   - There is exactly one 'Z', and it is the last command.\n//\n// A segment is a section of a path, represented as an object that has a start,\n// an end, and possibly a control, all of which are valid Points (that is, pairs\n// of Numbers).\n//\n// A path is a list of segments which is non-empty and closed - that is, the end\n// of the last segment on the path is the start of the first.\n// Returns twice the area contained in the polygon. The result is positive iff\n// the polygon winds in the counter-clockwise direction.\n\nconst get2xArea = polygon => {\n  let area = 0;\n\n  for (var i = 0; i < polygon.length; i++) {\n    const p1 = polygon[i];\n    const p2 = polygon[(i + 1) % polygon.length];\n    area += (p2[0] + p1[0]) * (p2[1] - p1[1]);\n  }\n\n  return area;\n}; // Takes a list of paths and orients them so that exterior contours are oriented\n// counter-clockwise and interior contours clockwise.\n\n\nconst orientPaths = (paths, approximation_error) => {\n  const polygons = paths.map(svg.getPolygonApproximation);\n\n  for (var i = 0; i < paths.length; i++) {\n    const path = paths[i];\n    let contains = 0;\n\n    for (let j = 0; j < paths.length; j++) {\n      if (j === i) {\n        continue;\n      } else if (svg.polygonContainsPoint(polygons[j], path[0].start)) {\n        contains += 1;\n      }\n    }\n\n    const area = get2xArea(polygons[i]); // The path is an external path iff it is contained in an even number of\n    // other paths. It is counter-clockwise iff its area is positive. The path\n    // should be reversed if (CCW && internal) || (CW && external).\n\n    const should_reverse = area > 0 !== (contains % 2 === 0);\n\n    if (should_reverse) {\n      for (let segment of path) {\n        [segment.start, segment.end] = [segment.end, segment.start];\n      }\n\n      path.reverse();\n    }\n  }\n\n  return paths;\n}; // Takes a normal-form SVG path string and converts it to a list of paths.\n\n\nconst splitPath = path => {\n  assert(path.length > 0);\n  assert(path[0] === 'M', \"Path did not start with M: \".concat(path));\n  assert(path[path.length - 1] === 'Z', \"Path did not end with Z: \".concat(path));\n  const terms = path.split(' ');\n  const result = [];\n  let start = undefined;\n  let current = undefined;\n\n  for (let i = 0; i < terms.length; i++) {\n    const command = terms[i];\n    assert(command.length > 0, \"Path includes empty command: \".concat(path));\n    assert('LMQZ'.indexOf(command) >= 0, command);\n\n    if (command === 'M' || command === 'Z') {\n      if (current !== undefined) {\n        assert(Point.equal(current, start), \"Path has open contour: \".concat(path));\n        assert(result[result.length - 1].length > 0, \"Path has empty contour: \".concat(path));\n\n        if (command === 'Z') {\n          assert(i === terms.length - 1, \"Path ended early: \".concat(path));\n          return result;\n        }\n      }\n\n      result.push([]);\n      assert(i < terms.length - 2, \"Missing point on path: \".concat(path));\n      start = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n      assert(Point.valid(start));\n      i += 2;\n      current = Point.clone(start);\n      continue;\n    }\n\n    let control = undefined;\n\n    if (command === 'Q') {\n      assert(i < terms.length - 2, \"Missing point on path: \".concat(path));\n      control = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n      assert(Point.valid(control));\n      i += 2;\n    }\n\n    assert(i < terms.length - 2, \"Missing point on path: \".concat(path));\n    const end = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n    assert(Point.valid(end));\n    i += 2;\n\n    if (Point.equal(current, end)) {\n      continue;\n    }\n\n    if (control !== undefined && (Point.equal(control, current) || Point.equal(control, end))) {\n      control = undefined;\n    }\n\n    result[result.length - 1].push({\n      start: Point.clone(current),\n      control: control,\n      end: end\n    });\n    current = Point.clone(end);\n  }\n}; // Takes a TrueType font command list (as provided by opentype.js) and returns\n// a normal-form SVG path string as defined above.\n\n\nsvg.convertCommandsToPath = commands => {\n  const terms = [];\n\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    assert('LMQZ'.indexOf(command.type) >= 0, command.type);\n\n    if (command.type === 'Z') {\n      assert(i === commands.length - 1);\n      break;\n    }\n\n    terms.push(command.type);\n    assert(command.x1 !== undefined === (command.type === 'Q'));\n\n    if (command.x1 !== undefined) {\n      terms.push(command.x1);\n      terms.push(command.y1);\n    }\n\n    assert(command.x !== undefined);\n    terms.push(command.x);\n    terms.push(command.y);\n  }\n\n  terms.push('Z');\n  return terms.join(' ');\n}; // Converts a normal-form SVG path string to a list of paths. The paths obey an\n// orientation constraint: the external paths are oriented counter-clockwise,\n// while the internal paths are oriented clockwise.\n\n\nsvg.convertSVGPathToPaths = path => {\n  return orientPaths(splitPath(path));\n}; // Takes the given list of paths and returns a normal-form SVG path string.\n\n\nsvg.convertPathsToSVGPath = paths => {\n  const terms = [];\n\n  for (let path of paths) {\n    assert(path.length > 0);\n    terms.push('M');\n    terms.push(path[0].start[0]);\n    terms.push(path[0].start[1]);\n\n    for (let segment of path) {\n      if (segment.control === undefined) {\n        terms.push('L');\n      } else {\n        terms.push('Q');\n        terms.push(segment.control[0]);\n        terms.push(segment.control[1]);\n      }\n\n      terms.push(segment.end[0]);\n      terms.push(segment.end[1]);\n    }\n  }\n\n  terms.push('Z');\n  return terms.join(' ');\n}; // Takes a path (a list of segments) and returns a polygon approximation to it.\n// The polygon is given as a list of pairs of points.\n//\n// The approximation error is an upper-bound on the distance between consecutive\n// points in the polygon approximation used to compute the area. The default\n// error of 64 is chosen because the glyphs have a total size of 1024x1024.\n\n\nsvg.getPolygonApproximation = (path, approximation_error) => {\n  const result = [];\n  approximation_error = approximation_error || 64;\n\n  for (let x of path) {\n    const control = x.control || Point.midpoint(x.start, x.end);\n    const distance = Math.sqrt(Point.distance2(x.start, x.end));\n    const num_points = Math.floor(distance / approximation_error);\n\n    for (let i = 0; i < num_points; i++) {\n      const t = (i + 1) / (num_points + 1);\n      const s = 1 - t;\n      result.push([s * s * x.start[0] + 2 * s * t * control[0] + t * t * x.end[0], s * s * x.start[1] + 2 * s * t * control[1] + t * t * x.end[1]]);\n    }\n\n    result.push(x.end);\n  }\n\n  return result;\n}; // Returns true if the given point is contained inside the given polygon.\n\n\nsvg.polygonContainsPoint = (polygon, point) => {\n  const x = point[0];\n  const y = point[1];\n  let crossings = 0;\n\n  for (let i = 0; i < polygon.length; i++) {\n    const segment = {\n      start: polygon[i],\n      end: polygon[(i + 1) % polygon.length]\n    };\n\n    if (segment.start[0] < x && x < segment.end[0] || segment.start[0] > x && x > segment.end[0]) {\n      const t = (x - segment.end[0]) / (segment.start[0] - segment.end[0]);\n      const cy = t * segment.start[1] + (1 - t) * segment.end[1];\n\n      if (y > cy) {\n        crossings += 1;\n      }\n    } else if (segment.start[0] === x && segment.start[1] <= y) {\n      if (segment.end[0] > x) {\n        crossings += 1;\n      }\n\n      const last = polygon[(i + polygon.length - 1) % polygon.length];\n\n      if (last[0] > x) {\n        crossings += 1;\n      }\n    }\n  }\n\n  return crossings % 2 === 1;\n};","map":{"version":3,"sources":["lib/svg.js"],"names":["module","export","svg","assert","Point","link","v","get2xArea","polygon","area","i","length","p1","p2","orientPaths","paths","approximation_error","polygons","map","getPolygonApproximation","path","contains","j","polygonContainsPoint","start","should_reverse","segment","end","reverse","splitPath","terms","split","result","undefined","current","command","indexOf","equal","push","parseFloat","valid","clone","control","convertCommandsToPath","commands","type","x1","y1","x","y","join","convertSVGPathToPaths","convertPathsToSVGPath","midpoint","distance","Math","sqrt","distance2","num_points","floor","t","s","point","crossings","cy","last"],"mappings":"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","sourcesContent":["import {assert, Point} from '/lib/base';\n\nconst svg = {};\n\n// A normal-form SVG path string is a data string with the following properties:\n//   - Every command in the path is in ['L', 'M', 'Q', 'Z'].\n//   - Adjacent tokens in the path are separated by exactly one space.\n//   - There is exactly one 'Z', and it is the last command.\n//\n// A segment is a section of a path, represented as an object that has a start,\n// an end, and possibly a control, all of which are valid Points (that is, pairs\n// of Numbers).\n//\n// A path is a list of segments which is non-empty and closed - that is, the end\n// of the last segment on the path is the start of the first.\n\n// Returns twice the area contained in the polygon. The result is positive iff\n// the polygon winds in the counter-clockwise direction.\nconst get2xArea = (polygon) => {\n  let area = 0;\n  for (var i = 0; i < polygon.length; i++) {\n    const p1 = polygon[i];\n    const p2 = polygon[(i + 1) % polygon.length];\n    area += (p2[0] + p1[0])*(p2[1] - p1[1]);\n  }\n  return area;\n}\n\n// Takes a list of paths and orients them so that exterior contours are oriented\n// counter-clockwise and interior contours clockwise.\nconst orientPaths = (paths, approximation_error) => {\n  const polygons = paths.map(svg.getPolygonApproximation);\n  for (var i = 0; i < paths.length; i++) {\n    const path = paths[i];\n    let contains = 0;\n    for (let j = 0; j < paths.length; j++) {\n      if (j === i) {\n        continue;\n      } else if (svg.polygonContainsPoint(polygons[j], path[0].start)) {\n        contains += 1;\n      }\n    }\n    const area = get2xArea(polygons[i]);\n    // The path is an external path iff it is contained in an even number of\n    // other paths. It is counter-clockwise iff its area is positive. The path\n    // should be reversed if (CCW && internal) || (CW && external).\n    const should_reverse = (area > 0) !== (contains % 2 === 0);\n    if (should_reverse) {\n      for (let segment of path) {\n        [segment.start, segment.end] = [segment.end, segment.start];\n      }\n      path.reverse();\n    }\n  }\n  return paths;\n}\n\n// Takes a normal-form SVG path string and converts it to a list of paths.\nconst splitPath = (path) => {\n  assert(path.length > 0);\n  assert(path[0] === 'M', `Path did not start with M: ${path}`);\n  assert(path[path.length - 1] === 'Z', `Path did not end with Z: ${path}`);\n  const terms = path.split(' ');\n  const result = [];\n  let start = undefined;\n  let current = undefined;\n  for (let i = 0; i < terms.length; i++) {\n    const command = terms[i];\n    assert(command.length > 0, `Path includes empty command: ${path}`);\n    assert('LMQZ'.indexOf(command) >= 0, command);\n    if (command === 'M' || command === 'Z') {\n      if (current !== undefined) {\n        assert(Point.equal(current, start), `Path has open contour: ${path}`);\n        assert(result[result.length - 1].length > 0,\n               `Path has empty contour: ${path}`);\n        if (command === 'Z') {\n          assert(i === terms.length - 1, `Path ended early: ${path}`);\n          return result;\n        }\n      }\n      result.push([]);\n      assert(i < terms.length - 2, `Missing point on path: ${path}`);\n      start = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n      assert(Point.valid(start));\n      i += 2;\n      current = Point.clone(start);\n      continue;\n    }\n    let control = undefined;\n    if (command === 'Q') {\n      assert(i < terms.length - 2, `Missing point on path: ${path}`);\n      control = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n      assert(Point.valid(control));\n      i += 2;\n    }\n    assert(i < terms.length - 2, `Missing point on path: ${path}`);\n    const end = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n    assert(Point.valid(end));\n    i += 2;\n    if (Point.equal(current, end)) {\n      continue;\n    }\n    if (control !== undefined &&\n        (Point.equal(control, current) || Point.equal(control, end))) {\n      control = undefined;\n    }\n    result[result.length - 1].push({\n      start: Point.clone(current),\n      control: control,\n      end: end,\n    });\n    current = Point.clone(end);\n  }\n}\n\n// Takes a TrueType font command list (as provided by opentype.js) and returns\n// a normal-form SVG path string as defined above.\nsvg.convertCommandsToPath = (commands) => {\n  const terms = [];\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    assert('LMQZ'.indexOf(command.type) >= 0, command.type);\n    if (command.type === 'Z') {\n      assert(i === commands.length - 1);\n      break;\n    }\n    terms.push(command.type);\n    assert((command.x1 !== undefined) === (command.type === 'Q'));\n    if (command.x1 !== undefined) {\n      terms.push(command.x1);\n      terms.push(command.y1);\n    }\n    assert(command.x !== undefined);\n    terms.push(command.x);\n    terms.push(command.y);\n  }\n  terms.push('Z');\n  return terms.join(' ');\n}\n\n// Converts a normal-form SVG path string to a list of paths. The paths obey an\n// orientation constraint: the external paths are oriented counter-clockwise,\n// while the internal paths are oriented clockwise.\nsvg.convertSVGPathToPaths = (path) => {\n  return orientPaths(splitPath(path));\n}\n\n// Takes the given list of paths and returns a normal-form SVG path string.\nsvg.convertPathsToSVGPath = (paths) => {\n  const terms = [];\n  for (let path of paths) {\n    assert(path.length > 0);\n    terms.push('M');\n    terms.push(path[0].start[0]);\n    terms.push(path[0].start[1]);\n    for (let segment of path) {\n      if (segment.control === undefined) {\n        terms.push('L');\n      } else {\n        terms.push('Q');\n        terms.push(segment.control[0]);\n        terms.push(segment.control[1]);\n      }\n      terms.push(segment.end[0]);\n      terms.push(segment.end[1]);\n    }\n  }\n  terms.push('Z');\n  return terms.join(' ');\n}\n\n// Takes a path (a list of segments) and returns a polygon approximation to it.\n// The polygon is given as a list of pairs of points.\n//\n// The approximation error is an upper-bound on the distance between consecutive\n// points in the polygon approximation used to compute the area. The default\n// error of 64 is chosen because the glyphs have a total size of 1024x1024.\nsvg.getPolygonApproximation = (path, approximation_error) => {\n  const result = [];\n  approximation_error = approximation_error || 64;\n  for (let x of path) {\n    const control = x.control || Point.midpoint(x.start, x.end);\n    const distance = Math.sqrt(Point.distance2(x.start, x.end));\n    const num_points = Math.floor(distance/approximation_error);\n    for (let i = 0; i < num_points; i++) {\n      const t = (i + 1)/(num_points + 1);\n      const s = 1 - t;\n      result.push([s*s*x.start[0] + 2*s*t*control[0] + t*t*x.end[0],\n                   s*s*x.start[1] + 2*s*t*control[1] + t*t*x.end[1]]);\n    }\n    result.push(x.end);\n  }\n  return result;\n}\n\n// Returns true if the given point is contained inside the given polygon.\nsvg.polygonContainsPoint = (polygon, point) => {\n  const x = point[0];\n  const y = point[1];\n  let crossings = 0;\n  for (let i = 0; i < polygon.length; i++) {\n    const segment = {start: polygon[i], end: polygon[(i + 1) % polygon.length]};\n    if ((segment.start[0] < x && x < segment.end[0]) ||\n        (segment.start[0] > x && x > segment.end[0])) {\n      const t = (x - segment.end[0])/(segment.start[0] - segment.end[0]);\n      const cy = t*segment.start[1] + (1 - t)*segment.end[1];\n      if (y > cy) {\n        crossings += 1;\n      }\n    } else if (segment.start[0] === x && segment.start[1] <= y) {\n      if (segment.end[0] > x) {\n        crossings += 1;\n      }\n      const last = polygon[(i + polygon.length - 1) % (polygon.length)];\n      if (last[0] > x) {\n        crossings += 1;\n      }\n    }\n  }\n  return crossings % 2 === 1;\n}\n\nexport {svg};\n"]},"sourceType":"module","externalDependencies":{},"hash":"6d521bfb0f566efb23dc076ff8f773152bd02605"}
