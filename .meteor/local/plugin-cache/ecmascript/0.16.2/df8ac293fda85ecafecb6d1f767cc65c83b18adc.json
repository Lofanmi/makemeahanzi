{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/a37/code/github/makemeahanzi-tool/client/external/opentype/0.4.10/opentype.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"client/external/opentype/0.4.10/opentype.js","filename":"/Users/a37/code/github/makemeahanzi-tool/client/external/opentype/0.4.10/opentype.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/a37/code/github/makemeahanzi-tool","root":"/Users/a37/code/github/makemeahanzi-tool","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]}},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/a37/code/github/makemeahanzi-tool/client/external/opentype/0.4.10/opentype.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"client/external/opentype/0.4.10/opentype.js"}},"code":"!function (module1) {\n  var _typeof;\n\n  module1.link(\"@babel/runtime/helpers/typeof\", {\n    default: function (v) {\n      _typeof = v;\n    }\n  }, 0);\n\n  (function (f) {\n    if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === \"object\" && typeof module !== \"undefined\") {\n      module.exports = f();\n    } else if (typeof define === \"function\" && define.amd) {\n      define([], f);\n    } else {\n      var g;\n\n      if (typeof window !== \"undefined\") {\n        g = window;\n      } else if (typeof global !== \"undefined\") {\n        g = global;\n      } else if (typeof self !== \"undefined\") {\n        g = self;\n      } else {\n        g = this;\n      }\n\n      g.opentype = f();\n    }\n  })(function () {\n    var define, module, exports;\n    return function () {\n      function e(t, n, r) {\n        function s(o, u) {\n          if (!n[o]) {\n            if (!t[o]) {\n              var a = typeof require == \"function\" && require;\n              if (!u && a) return a(o, !0);\n              if (i) return i(o, !0);\n              var f = new Error(\"Cannot find module '\" + o + \"'\");\n              throw f.code = \"MODULE_NOT_FOUND\", f;\n            }\n\n            var l = n[o] = {\n              exports: {}\n            };\n            t[o][0].call(l.exports, function (e) {\n              var n = t[o][1][e];\n              return s(n ? n : e);\n            }, l, l.exports, e, t, n, r);\n          }\n\n          return n[o].exports;\n        }\n\n        var i = typeof require == \"function\" && require;\n\n        for (var o = 0; o < r.length; o++) {\n          s(r[o]);\n        }\n\n        return s;\n      }\n\n      return e;\n    }()({\n      1: [function (require, module, exports) {\n        // Run-time checking of preconditions.\n        'use strict'; // Precondition function that checks if the given predicate is true.\n        // If not, it will throw an error.\n\n        exports.argument = function (predicate, message) {\n          if (!predicate) {\n            throw new Error(message);\n          }\n        }; // Precondition function that checks if the given assertion is true.\n        // If not, it will throw an error.\n\n\n        exports.assert = exports.argument;\n      }, {}],\n      2: [function (require, module, exports) {\n        // Drawing utility functions.\n        'use strict'; // Draw a line on the given context from point `x1,y1` to point `x2,y2`.\n\n        function line(ctx, x1, y1, x2, y2) {\n          ctx.beginPath();\n          ctx.moveTo(x1, y1);\n          ctx.lineTo(x2, y2);\n          ctx.stroke();\n        }\n\n        exports.line = line;\n      }, {}],\n      3: [function (require, module, exports) {\n        // Glyph encoding\n        'use strict';\n\n        var cffStandardStrings = ['.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', 'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE', 'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu', 'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn', 'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright', 'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex', 'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute', 'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute', 'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute', 'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave', 'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl', 'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', 'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000', '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];\n        var cffStandardEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger', 'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron', 'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '', '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '', 'lslash', 'oslash', 'oe', 'germandbls'];\n        var cffExpertEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior', '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '', '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];\n        var standardNames = ['.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave', 'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis', 'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis', 'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section', 'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal', 'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation', 'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown', 'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright', 'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft', 'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction', 'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase', 'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex', 'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth', 'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior', 'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla', 'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat']; // This is the encoding used for fonts created from scratch.\n        // It loops through all glyphs and finds the appropriate unicode value.\n        // Since it's linear time, other encodings will be faster.\n\n        function DefaultEncoding(font) {\n          this.font = font;\n        }\n\n        DefaultEncoding.prototype.charToGlyphIndex = function (c) {\n          var code = c.charCodeAt(0);\n          var glyphs = this.font.glyphs;\n\n          if (glyphs) {\n            for (var i = 0; i < glyphs.length; i += 1) {\n              var glyph = glyphs.get(i);\n\n              for (var j = 0; j < glyph.unicodes.length; j += 1) {\n                if (glyph.unicodes[j] === code) {\n                  return i;\n                }\n              }\n            }\n          } else {\n            return null;\n          }\n        };\n\n        function CmapEncoding(cmap) {\n          this.cmap = cmap;\n        }\n\n        CmapEncoding.prototype.charToGlyphIndex = function (c) {\n          return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;\n        };\n\n        function CffEncoding(encoding, charset) {\n          this.encoding = encoding;\n          this.charset = charset;\n        }\n\n        CffEncoding.prototype.charToGlyphIndex = function (s) {\n          var code = s.charCodeAt(0);\n          var charName = this.encoding[code];\n          return this.charset.indexOf(charName);\n        };\n\n        function GlyphNames(post) {\n          var i;\n\n          switch (post.version) {\n            case 1:\n              this.names = exports.standardNames.slice();\n              break;\n\n            case 2:\n              this.names = new Array(post.numberOfGlyphs);\n\n              for (i = 0; i < post.numberOfGlyphs; i++) {\n                if (post.glyphNameIndex[i] < exports.standardNames.length) {\n                  this.names[i] = exports.standardNames[post.glyphNameIndex[i]];\n                } else {\n                  this.names[i] = post.names[post.glyphNameIndex[i] - exports.standardNames.length];\n                }\n              }\n\n              break;\n\n            case 2.5:\n              this.names = new Array(post.numberOfGlyphs);\n\n              for (i = 0; i < post.numberOfGlyphs; i++) {\n                this.names[i] = exports.standardNames[i + post.glyphNameIndex[i]];\n              }\n\n              break;\n\n            case 3:\n              this.names = [];\n              break;\n          }\n        }\n\n        GlyphNames.prototype.nameToGlyphIndex = function (name) {\n          return this.names.indexOf(name);\n        };\n\n        GlyphNames.prototype.glyphIndexToName = function (gid) {\n          return this.names[gid];\n        };\n\n        function addGlyphNames(font) {\n          var glyph;\n          var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n          var charCodes = Object.keys(glyphIndexMap);\n\n          for (var i = 0; i < charCodes.length; i += 1) {\n            var c = charCodes[i];\n            var glyphIndex = glyphIndexMap[c];\n            glyph = font.glyphs.get(glyphIndex);\n            glyph.addUnicode(parseInt(c));\n          }\n\n          for (i = 0; i < font.glyphs.length; i += 1) {\n            glyph = font.glyphs.get(i);\n\n            if (font.cffEncoding) {\n              glyph.name = font.cffEncoding.charset[i];\n            } else {\n              glyph.name = font.glyphNames.glyphIndexToName(i);\n            }\n          }\n        }\n\n        exports.cffStandardStrings = cffStandardStrings;\n        exports.cffStandardEncoding = cffStandardEncoding;\n        exports.cffExpertEncoding = cffExpertEncoding;\n        exports.standardNames = standardNames;\n        exports.DefaultEncoding = DefaultEncoding;\n        exports.CmapEncoding = CmapEncoding;\n        exports.CffEncoding = CffEncoding;\n        exports.GlyphNames = GlyphNames;\n        exports.addGlyphNames = addGlyphNames;\n      }, {}],\n      4: [function (require, module, exports) {\n        // The Font object\n        'use strict';\n\n        var path = require('./path');\n\n        var sfnt = require('./tables/sfnt');\n\n        var encoding = require('./encoding');\n\n        var glyphset = require('./glyphset'); // A Font represents a loaded OpenType font file.\n        // It contains a set of glyphs and methods to draw text on a drawing context,\n        // or to get a path representing the text.\n\n\n        function Font(options) {\n          options = options || {}; // OS X will complain if the names are empty, so we put a single space everywhere by default.\n\n          this.familyName = options.familyName || ' ';\n          this.styleName = options.styleName || ' ';\n          this.designer = options.designer || ' ';\n          this.designerURL = options.designerURL || ' ';\n          this.manufacturer = options.manufacturer || ' ';\n          this.manufacturerURL = options.manufacturerURL || ' ';\n          this.license = options.license || ' ';\n          this.licenseURL = options.licenseURL || ' ';\n          this.version = options.version || 'Version 0.1';\n          this.description = options.description || ' ';\n          this.copyright = options.copyright || ' ';\n          this.trademark = options.trademark || ' ';\n          this.unitsPerEm = options.unitsPerEm || 1000;\n          this.ascender = options.ascender;\n          this.descender = options.descender;\n          this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.\n\n          this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);\n          this.encoding = new encoding.DefaultEncoding(this);\n          this.tables = {};\n        } // Check if the font has a glyph for the given character.\n\n\n        Font.prototype.hasChar = function (c) {\n          return this.encoding.charToGlyphIndex(c) !== null;\n        }; // Convert the given character to a single glyph index.\n        // Note that this function assumes that there is a one-to-one mapping between\n        // the given character and a glyph; for complex scripts this might not be the case.\n\n\n        Font.prototype.charToGlyphIndex = function (s) {\n          return this.encoding.charToGlyphIndex(s);\n        }; // Convert the given character to a single Glyph object.\n        // Note that this function assumes that there is a one-to-one mapping between\n        // the given character and a glyph; for complex scripts this might not be the case.\n\n\n        Font.prototype.charToGlyph = function (c) {\n          var glyphIndex = this.charToGlyphIndex(c);\n          var glyph = this.glyphs.get(glyphIndex);\n\n          if (!glyph) {\n            // .notdef\n            glyph = this.glyphs.get(0);\n          }\n\n          return glyph;\n        }; // Convert the given text to a list of Glyph objects.\n        // Note that there is no strict one-to-one mapping between characters and\n        // glyphs, so the list of returned glyphs can be larger or smaller than the\n        // length of the given string.\n\n\n        Font.prototype.stringToGlyphs = function (s) {\n          var glyphs = [];\n\n          for (var i = 0; i < s.length; i += 1) {\n            var c = s[i];\n            glyphs.push(this.charToGlyph(c));\n          }\n\n          return glyphs;\n        };\n\n        Font.prototype.nameToGlyphIndex = function (name) {\n          return this.glyphNames.nameToGlyphIndex(name);\n        };\n\n        Font.prototype.nameToGlyph = function (name) {\n          var glyphIndex = this.nametoGlyphIndex(name);\n          var glyph = this.glyphs.get(glyphIndex);\n\n          if (!glyph) {\n            // .notdef\n            glyph = this.glyphs.get(0);\n          }\n\n          return glyph;\n        };\n\n        Font.prototype.glyphIndexToName = function (gid) {\n          if (!this.glyphNames.glyphIndexToName) {\n            return '';\n          }\n\n          return this.glyphNames.glyphIndexToName(gid);\n        }; // Retrieve the value of the kerning pair between the left glyph (or its index)\n        // and the right glyph (or its index). If no kerning pair is found, return 0.\n        // The kerning value gets added to the advance width when calculating the spacing\n        // between glyphs.\n\n\n        Font.prototype.getKerningValue = function (leftGlyph, rightGlyph) {\n          leftGlyph = leftGlyph.index || leftGlyph;\n          rightGlyph = rightGlyph.index || rightGlyph;\n          var gposKerning = this.getGposKerningValue;\n          return gposKerning ? gposKerning(leftGlyph, rightGlyph) : this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;\n        }; // Helper function that invokes the given callback for each glyph in the given text.\n        // The callback gets `(glyph, x, y, fontSize, options)`.\n\n\n        Font.prototype.forEachGlyph = function (text, x, y, fontSize, options, callback) {\n          x = x !== undefined ? x : 0;\n          y = y !== undefined ? y : 0;\n          fontSize = fontSize !== undefined ? fontSize : 72;\n          options = options || {};\n          var kerning = options.kerning === undefined ? true : options.kerning;\n          var fontScale = 1 / this.unitsPerEm * fontSize;\n          var glyphs = this.stringToGlyphs(text);\n\n          for (var i = 0; i < glyphs.length; i += 1) {\n            var glyph = glyphs[i];\n            callback(glyph, x, y, fontSize, options);\n\n            if (glyph.advanceWidth) {\n              x += glyph.advanceWidth * fontScale;\n            }\n\n            if (kerning && i < glyphs.length - 1) {\n              var kerningValue = this.getKerningValue(glyph, glyphs[i + 1]);\n              x += kerningValue * fontScale;\n            }\n          }\n        }; // Create a Path object that represents the given text.\n        //\n        // text - The text to create.\n        // x - Horizontal position of the beginning of the text. (default: 0)\n        // y - Vertical position of the *baseline* of the text. (default: 0)\n        // fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)\n        // Options is an optional object that contains:\n        // - kerning - Whether to take kerning information into account. (default: true)\n        //\n        // Returns a Path object.\n\n\n        Font.prototype.getPath = function (text, x, y, fontSize, options) {\n          var fullPath = new path.Path();\n          this.forEachGlyph(text, x, y, fontSize, options, function (glyph, gX, gY, gFontSize) {\n            var glyphPath = glyph.getPath(gX, gY, gFontSize);\n            fullPath.extend(glyphPath);\n          });\n          return fullPath;\n        }; // Draw the text on the given drawing context.\n        //\n        // ctx - A 2D drawing context, like Canvas.\n        // text - The text to create.\n        // x - Horizontal position of the beginning of the text. (default: 0)\n        // y - Vertical position of the *baseline* of the text. (default: 0)\n        // fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)\n        // Options is an optional object that contains:\n        // - kerning - Whether to take kerning information into account. (default: true)\n\n\n        Font.prototype.draw = function (ctx, text, x, y, fontSize, options) {\n          this.getPath(text, x, y, fontSize, options).draw(ctx);\n        }; // Draw the points of all glyphs in the text.\n        // On-curve points will be drawn in blue, off-curve points will be drawn in red.\n        //\n        // ctx - A 2D drawing context, like Canvas.\n        // text - The text to create.\n        // x - Horizontal position of the beginning of the text. (default: 0)\n        // y - Vertical position of the *baseline* of the text. (default: 0)\n        // fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)\n        // Options is an optional object that contains:\n        // - kerning - Whether to take kerning information into account. (default: true)\n\n\n        Font.prototype.drawPoints = function (ctx, text, x, y, fontSize, options) {\n          this.forEachGlyph(text, x, y, fontSize, options, function (glyph, gX, gY, gFontSize) {\n            glyph.drawPoints(ctx, gX, gY, gFontSize);\n          });\n        }; // Draw lines indicating important font measurements for all glyphs in the text.\n        // Black lines indicate the origin of the coordinate system (point 0,0).\n        // Blue lines indicate the glyph bounding box.\n        // Green line indicates the advance width of the glyph.\n        //\n        // ctx - A 2D drawing context, like Canvas.\n        // text - The text to create.\n        // x - Horizontal position of the beginning of the text. (default: 0)\n        // y - Vertical position of the *baseline* of the text. (default: 0)\n        // fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)\n        // Options is an optional object that contains:\n        // - kerning - Whether to take kerning information into account. (default: true)\n\n\n        Font.prototype.drawMetrics = function (ctx, text, x, y, fontSize, options) {\n          this.forEachGlyph(text, x, y, fontSize, options, function (glyph, gX, gY, gFontSize) {\n            glyph.drawMetrics(ctx, gX, gY, gFontSize);\n          });\n        }; // Validate\n\n\n        Font.prototype.validate = function () {\n          var warnings = [];\n\n          var _this = this;\n\n          function assert(predicate, message) {\n            if (!predicate) {\n              warnings.push(message);\n            }\n          }\n\n          function assertStringAttribute(attrName) {\n            assert(_this[attrName] && _this[attrName].trim().length > 0, 'No ' + attrName + ' specified.');\n          } // Identification information\n\n\n          assertStringAttribute('familyName');\n          assertStringAttribute('weightName');\n          assertStringAttribute('manufacturer');\n          assertStringAttribute('copyright');\n          assertStringAttribute('version'); // Dimension information\n\n          assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');\n        }; // Convert the font object to a SFNT data structure.\n        // This structure contains all the necessary tables and metadata to create a binary OTF file.\n\n\n        Font.prototype.toTables = function () {\n          return sfnt.fontToTable(this);\n        };\n\n        Font.prototype.toBuffer = function () {\n          var sfntTable = this.toTables();\n          var bytes = sfntTable.encode();\n          var buffer = new ArrayBuffer(bytes.length);\n          var intArray = new Uint8Array(buffer);\n\n          for (var i = 0; i < bytes.length; i++) {\n            intArray[i] = bytes[i];\n          }\n\n          return buffer;\n        }; // Initiate a download of the OpenType font.\n\n\n        Font.prototype.download = function () {\n          var fileName = this.familyName.replace(/\\s/g, '') + '-' + this.styleName + '.otf';\n          var buffer = this.toBuffer();\n          window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;\n          window.requestFileSystem(window.TEMPORARY, buffer.byteLength, function (fs) {\n            fs.root.getFile(fileName, {\n              create: true\n            }, function (fileEntry) {\n              fileEntry.createWriter(function (writer) {\n                var dataView = new DataView(buffer);\n                var blob = new Blob([dataView], {\n                  type: 'font/opentype'\n                });\n                writer.write(blob);\n                writer.addEventListener('writeend', function () {\n                  // Navigating to the file will download it.\n                  location.href = fileEntry.toURL();\n                }, false);\n              });\n            });\n          }, function (err) {\n            throw err;\n          });\n        };\n\n        exports.Font = Font;\n      }, {\n        \"./encoding\": 3,\n        \"./glyphset\": 6,\n        \"./path\": 9,\n        \"./tables/sfnt\": 24\n      }],\n      5: [function (require, module, exports) {\n        // The Glyph object\n        'use strict';\n\n        var check = require('./check');\n\n        var draw = require('./draw');\n\n        var path = require('./path');\n\n        function getPathDefinition(glyph, path) {\n          var _path = path || {\n            commands: []\n          };\n\n          return {\n            configurable: true,\n            get: function () {\n              if (typeof _path === 'function') {\n                _path = _path();\n              }\n\n              return _path;\n            },\n            set: function (p) {\n              _path = p;\n            }\n          };\n        } // A Glyph is an individual mark that often corresponds to a character.\n        // Some glyphs, such as ligatures, are a combination of many characters.\n        // Glyphs are the basic building blocks of a font.\n        //\n        // The `Glyph` class contains utility methods for drawing the path and its points.\n\n\n        function Glyph(options) {\n          // By putting all the code on a prototype function (which is only declared once)\n          // we reduce the memory requirements for larger fonts by some 2%\n          this.bindConstructorValues(options);\n        }\n\n        Glyph.prototype.bindConstructorValues = function (options) {\n          this.index = options.index || 0; // These three values cannnot be deferred for memory optimization:\n\n          this.name = options.name || null;\n          this.unicode = options.unicode || undefined;\n          this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : []; // But by binding these values only when necessary, we reduce can\n          // the memory requirements by almost 3% for larger fonts.\n\n          if (options.xMin) {\n            this.xMin = options.xMin;\n          }\n\n          if (options.yMin) {\n            this.yMin = options.yMin;\n          }\n\n          if (options.xMax) {\n            this.xMax = options.xMax;\n          }\n\n          if (options.yMax) {\n            this.yMax = options.yMax;\n          }\n\n          if (options.advanceWidth) {\n            this.advanceWidth = options.advanceWidth;\n          } // The path for a glyph is the most memory intensive, and is bound as a value\n          // with a getter/setter to ensure we actually do path parsing only once the\n          // path is actually needed by anything.\n\n\n          Object.defineProperty(this, 'path', getPathDefinition(this, options.path));\n        };\n\n        Glyph.prototype.addUnicode = function (unicode) {\n          if (this.unicodes.length === 0) {\n            this.unicode = unicode;\n          }\n\n          this.unicodes.push(unicode);\n        }; // Convert the glyph to a Path we can draw on a drawing context.\n        //\n        // x - Horizontal position of the glyph. (default: 0)\n        // y - Vertical position of the *baseline* of the glyph. (default: 0)\n        // fontSize - Font size, in pixels (default: 72).\n\n\n        Glyph.prototype.getPath = function (x, y, fontSize) {\n          x = x !== undefined ? x : 0;\n          y = y !== undefined ? y : 0;\n          fontSize = fontSize !== undefined ? fontSize : 72;\n          var scale = 1 / this.path.unitsPerEm * fontSize;\n          var p = new path.Path();\n          var commands = this.path.commands;\n\n          for (var i = 0; i < commands.length; i += 1) {\n            var cmd = commands[i];\n\n            if (cmd.type === 'M') {\n              p.moveTo(x + cmd.x * scale, y + -cmd.y * scale);\n            } else if (cmd.type === 'L') {\n              p.lineTo(x + cmd.x * scale, y + -cmd.y * scale);\n            } else if (cmd.type === 'Q') {\n              p.quadraticCurveTo(x + cmd.x1 * scale, y + -cmd.y1 * scale, x + cmd.x * scale, y + -cmd.y * scale);\n            } else if (cmd.type === 'C') {\n              p.curveTo(x + cmd.x1 * scale, y + -cmd.y1 * scale, x + cmd.x2 * scale, y + -cmd.y2 * scale, x + cmd.x * scale, y + -cmd.y * scale);\n            } else if (cmd.type === 'Z') {\n              p.closePath();\n            }\n          }\n\n          return p;\n        }; // Split the glyph into contours.\n        // This function is here for backwards compatibility, and to\n        // provide raw access to the TrueType glyph outlines.\n\n\n        Glyph.prototype.getContours = function () {\n          if (this.points === undefined) {\n            return [];\n          }\n\n          var contours = [];\n          var currentContour = [];\n\n          for (var i = 0; i < this.points.length; i += 1) {\n            var pt = this.points[i];\n            currentContour.push(pt);\n\n            if (pt.lastPointOfContour) {\n              contours.push(currentContour);\n              currentContour = [];\n            }\n          }\n\n          check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n          return contours;\n        }; // Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.\n\n\n        Glyph.prototype.getMetrics = function () {\n          var commands = this.path.commands;\n          var xCoords = [];\n          var yCoords = [];\n\n          for (var i = 0; i < commands.length; i += 1) {\n            var cmd = commands[i];\n\n            if (cmd.type !== 'Z') {\n              xCoords.push(cmd.x);\n              yCoords.push(cmd.y);\n            }\n\n            if (cmd.type === 'Q' || cmd.type === 'C') {\n              xCoords.push(cmd.x1);\n              yCoords.push(cmd.y1);\n            }\n\n            if (cmd.type === 'C') {\n              xCoords.push(cmd.x2);\n              yCoords.push(cmd.y2);\n            }\n          }\n\n          var metrics = {\n            xMin: Math.min.apply(null, xCoords),\n            yMin: Math.min.apply(null, yCoords),\n            xMax: Math.max.apply(null, xCoords),\n            yMax: Math.max.apply(null, yCoords),\n            leftSideBearing: 0\n          };\n          metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);\n          return metrics;\n        }; // Draw the glyph on the given context.\n        //\n        // ctx - The drawing context.\n        // x - Horizontal position of the glyph. (default: 0)\n        // y - Vertical position of the *baseline* of the glyph. (default: 0)\n        // fontSize - Font size, in pixels (default: 72).\n\n\n        Glyph.prototype.draw = function (ctx, x, y, fontSize) {\n          this.getPath(x, y, fontSize).draw(ctx);\n        }; // Draw the points of the glyph.\n        // On-curve points will be drawn in blue, off-curve points will be drawn in red.\n        //\n        // ctx - The drawing context.\n        // x - Horizontal position of the glyph. (default: 0)\n        // y - Vertical position of the *baseline* of the glyph. (default: 0)\n        // fontSize - Font size, in pixels (default: 72).\n\n\n        Glyph.prototype.drawPoints = function (ctx, x, y, fontSize) {\n          function drawCircles(l, x, y, scale) {\n            var PI_SQ = Math.PI * 2;\n            ctx.beginPath();\n\n            for (var j = 0; j < l.length; j += 1) {\n              ctx.moveTo(x + l[j].x * scale, y + l[j].y * scale);\n              ctx.arc(x + l[j].x * scale, y + l[j].y * scale, 2, 0, PI_SQ, false);\n            }\n\n            ctx.closePath();\n            ctx.fill();\n          }\n\n          x = x !== undefined ? x : 0;\n          y = y !== undefined ? y : 0;\n          fontSize = fontSize !== undefined ? fontSize : 24;\n          var scale = 1 / this.path.unitsPerEm * fontSize;\n          var blueCircles = [];\n          var redCircles = [];\n          var path = this.path;\n\n          for (var i = 0; i < path.commands.length; i += 1) {\n            var cmd = path.commands[i];\n\n            if (cmd.x !== undefined) {\n              blueCircles.push({\n                x: cmd.x,\n                y: -cmd.y\n              });\n            }\n\n            if (cmd.x1 !== undefined) {\n              redCircles.push({\n                x: cmd.x1,\n                y: -cmd.y1\n              });\n            }\n\n            if (cmd.x2 !== undefined) {\n              redCircles.push({\n                x: cmd.x2,\n                y: -cmd.y2\n              });\n            }\n          }\n\n          ctx.fillStyle = 'blue';\n          drawCircles(blueCircles, x, y, scale);\n          ctx.fillStyle = 'red';\n          drawCircles(redCircles, x, y, scale);\n        }; // Draw lines indicating important font measurements.\n        // Black lines indicate the origin of the coordinate system (point 0,0).\n        // Blue lines indicate the glyph bounding box.\n        // Green line indicates the advance width of the glyph.\n        //\n        // ctx - The drawing context.\n        // x - Horizontal position of the glyph. (default: 0)\n        // y - Vertical position of the *baseline* of the glyph. (default: 0)\n        // fontSize - Font size, in pixels (default: 72).\n\n\n        Glyph.prototype.drawMetrics = function (ctx, x, y, fontSize) {\n          var scale;\n          x = x !== undefined ? x : 0;\n          y = y !== undefined ? y : 0;\n          fontSize = fontSize !== undefined ? fontSize : 24;\n          scale = 1 / this.path.unitsPerEm * fontSize;\n          ctx.lineWidth = 1; // Draw the origin\n\n          ctx.strokeStyle = 'black';\n          draw.line(ctx, x, -10000, x, 10000);\n          draw.line(ctx, -10000, y, 10000, y); // This code is here due to memory optimization: by not using\n          // defaults in the constructor, we save a notable amount of memory.\n\n          var xMin = this.xMin || 0;\n          var yMin = this.yMin || 0;\n          var xMax = this.xMax || 0;\n          var yMax = this.yMax || 0;\n          var advanceWidth = this.advanceWidth || 0; // Draw the glyph box\n\n          ctx.strokeStyle = 'blue';\n          draw.line(ctx, x + xMin * scale, -10000, x + xMin * scale, 10000);\n          draw.line(ctx, x + xMax * scale, -10000, x + xMax * scale, 10000);\n          draw.line(ctx, -10000, y + -yMin * scale, 10000, y + -yMin * scale);\n          draw.line(ctx, -10000, y + -yMax * scale, 10000, y + -yMax * scale); // Draw the advance width\n\n          ctx.strokeStyle = 'green';\n          draw.line(ctx, x + advanceWidth * scale, -10000, x + advanceWidth * scale, 10000);\n        };\n\n        exports.Glyph = Glyph;\n      }, {\n        \"./check\": 1,\n        \"./draw\": 2,\n        \"./path\": 9\n      }],\n      6: [function (require, module, exports) {\n        // The GlyphSet object\n        'use strict';\n\n        var _glyph = require('./glyph'); // A GlyphSet represents all glyphs available in the font, but modelled using\n        // a deferred glyph loader, for retrieving glyphs only once they are absolutely\n        // necessary, to keep the memory footprint down.\n\n\n        function GlyphSet(font, glyphs) {\n          this.font = font;\n          this.glyphs = {};\n\n          if (Array.isArray(glyphs)) {\n            for (var i = 0; i < glyphs.length; i++) {\n              this.glyphs[i] = glyphs[i];\n            }\n          }\n\n          this.length = glyphs && glyphs.length || 0;\n        }\n\n        GlyphSet.prototype.get = function (index) {\n          if (typeof this.glyphs[index] === 'function') {\n            this.glyphs[index] = this.glyphs[index]();\n          }\n\n          return this.glyphs[index];\n        };\n\n        GlyphSet.prototype.push = function (index, loader) {\n          this.glyphs[index] = loader;\n          this.length++;\n        };\n\n        function glyphLoader(font, index) {\n          return new _glyph.Glyph({\n            index: index,\n            font: font\n          });\n        }\n        /**\n         * Generate a stub glyph that can be filled with all metadata *except*\n         * the \"points\" and \"path\" properties, which must be loaded only once\n         * the glyph's path is actually requested for text shaping.\n         */\n\n\n        function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {\n          return function () {\n            var glyph = new _glyph.Glyph({\n              index: index,\n              font: font\n            });\n\n            glyph.path = function () {\n              parseGlyph(glyph, data, position);\n              var path = buildPath(font.glyphs, glyph);\n              path.unitsPerEm = font.unitsPerEm;\n              return path;\n            };\n\n            return glyph;\n          };\n        }\n\n        function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {\n          return function () {\n            var glyph = new _glyph.Glyph({\n              index: index,\n              font: font\n            });\n\n            glyph.path = function () {\n              var path = parseCFFCharstring(font, glyph, charstring);\n              path.unitsPerEm = font.unitsPerEm;\n              return path;\n            };\n\n            return glyph;\n          };\n        }\n\n        exports.GlyphSet = GlyphSet;\n        exports.glyphLoader = glyphLoader;\n        exports.ttfGlyphLoader = ttfGlyphLoader;\n        exports.cffGlyphLoader = cffGlyphLoader;\n      }, {\n        \"./glyph\": 5\n      }],\n      7: [function (require, module, exports) {\n        // opentype.js\n        // https://github.com/nodebox/opentype.js\n        // (c) 2015 Frederik De Bleser\n        // opentype.js may be freely distributed under the MIT license.\n\n        /* global ArrayBuffer, DataView, Uint8Array, XMLHttpRequest  */\n        'use strict';\n\n        var encoding = require('./encoding');\n\n        var _font = require('./font');\n\n        var glyph = require('./glyph');\n\n        var parse = require('./parse');\n\n        var path = require('./path');\n\n        var cmap = require('./tables/cmap');\n\n        var cff = require('./tables/cff');\n\n        var glyf = require('./tables/glyf');\n\n        var gpos = require('./tables/gpos');\n\n        var head = require('./tables/head');\n\n        var hhea = require('./tables/hhea');\n\n        var hmtx = require('./tables/hmtx');\n\n        var kern = require('./tables/kern');\n\n        var loca = require('./tables/loca');\n\n        var maxp = require('./tables/maxp');\n\n        var _name = require('./tables/name');\n\n        var os2 = require('./tables/os2');\n\n        var post = require('./tables/post'); // File loaders /////////////////////////////////////////////////////////\n        // Convert a Node.js Buffer to an ArrayBuffer\n\n\n        function toArrayBuffer(buffer) {\n          var arrayBuffer = new ArrayBuffer(buffer.length);\n          var data = new Uint8Array(arrayBuffer);\n\n          for (var i = 0; i < buffer.length; i += 1) {\n            data[i] = buffer[i];\n          }\n\n          return arrayBuffer;\n        }\n\n        function loadFromFile(path, callback) {\n          var fs = require('fs');\n\n          fs.readFile(path, function (err, buffer) {\n            if (err) {\n              return callback(err.message);\n            }\n\n            callback(null, toArrayBuffer(buffer));\n          });\n        }\n\n        function loadFromUrl(url, callback) {\n          var request = new XMLHttpRequest();\n          request.open('get', url, true);\n          request.responseType = 'arraybuffer';\n\n          request.onload = function () {\n            if (request.status !== 200) {\n              return callback('Font could not be loaded: ' + request.statusText);\n            }\n\n            return callback(null, request.response);\n          };\n\n          request.send();\n        } // Public API ///////////////////////////////////////////////////////////\n        // Parse the OpenType file data (as an ArrayBuffer) and return a Font object.\n        // Throws an error if the font could not be parsed.\n\n\n        function parseBuffer(buffer) {\n          var indexToLocFormat;\n          var hmtxOffset;\n          var glyfOffset;\n          var locaOffset;\n          var cffOffset;\n          var kernOffset;\n          var gposOffset; // OpenType fonts use big endian byte ordering.\n          // We can't rely on typed array view types, because they operate with the endianness of the host computer.\n          // Instead we use DataViews where we can specify endianness.\n\n          var font = new _font.Font();\n          var data = new DataView(buffer, 0);\n          var version = parse.getFixed(data, 0);\n\n          if (version === 1.0) {\n            font.outlinesFormat = 'truetype';\n          } else {\n            version = parse.getTag(data, 0);\n\n            if (version === 'OTTO') {\n              font.outlinesFormat = 'cff';\n            } else {\n              throw new Error('Unsupported OpenType version ' + version);\n            }\n          }\n\n          var numTables = parse.getUShort(data, 4); // Offset into the table records.\n\n          var p = 12;\n\n          for (var i = 0; i < numTables; i += 1) {\n            var tag = parse.getTag(data, p);\n            var offset = parse.getULong(data, p + 8);\n\n            switch (tag) {\n              case 'cmap':\n                font.tables.cmap = cmap.parse(data, offset);\n                font.encoding = new encoding.CmapEncoding(font.tables.cmap);\n                break;\n\n              case 'head':\n                font.tables.head = head.parse(data, offset);\n                font.unitsPerEm = font.tables.head.unitsPerEm;\n                indexToLocFormat = font.tables.head.indexToLocFormat;\n                break;\n\n              case 'hhea':\n                font.tables.hhea = hhea.parse(data, offset);\n                font.ascender = font.tables.hhea.ascender;\n                font.descender = font.tables.hhea.descender;\n                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;\n                break;\n\n              case 'hmtx':\n                hmtxOffset = offset;\n                break;\n\n              case 'maxp':\n                font.tables.maxp = maxp.parse(data, offset);\n                font.numGlyphs = font.tables.maxp.numGlyphs;\n                break;\n\n              case 'name':\n                font.tables.name = _name.parse(data, offset);\n                font.familyName = font.tables.name.fontFamily;\n                font.styleName = font.tables.name.fontSubfamily;\n                break;\n\n              case 'OS/2':\n                font.tables.os2 = os2.parse(data, offset);\n                break;\n\n              case 'post':\n                font.tables.post = post.parse(data, offset);\n                font.glyphNames = new encoding.GlyphNames(font.tables.post);\n                break;\n\n              case 'glyf':\n                glyfOffset = offset;\n                break;\n\n              case 'loca':\n                locaOffset = offset;\n                break;\n\n              case 'CFF ':\n                cffOffset = offset;\n                break;\n\n              case 'kern':\n                kernOffset = offset;\n                break;\n\n              case 'GPOS':\n                gposOffset = offset;\n                break;\n            }\n\n            p += 16;\n          }\n\n          if (glyfOffset && locaOffset) {\n            var shortVersion = indexToLocFormat === 0;\n            var locaTable = loca.parse(data, locaOffset, font.numGlyphs, shortVersion);\n            font.glyphs = glyf.parse(data, glyfOffset, locaTable, font);\n            hmtx.parse(data, hmtxOffset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);\n            encoding.addGlyphNames(font);\n          } else if (cffOffset) {\n            cff.parse(data, cffOffset, font);\n            encoding.addGlyphNames(font);\n          } else {\n            throw new Error('Font doesn\\'t contain TrueType or CFF outlines.');\n          }\n\n          if (kernOffset) {\n            font.kerningPairs = kern.parse(data, kernOffset);\n          } else {\n            font.kerningPairs = {};\n          }\n\n          if (gposOffset) {\n            gpos.parse(data, gposOffset, font);\n          }\n\n          return font;\n        } // Asynchronously load the font from a URL or a filesystem. When done, call the callback\n        // with two arguments `(err, font)`. The `err` will be null on success,\n        // the `font` is a Font object.\n        //\n        // We use the node.js callback convention so that\n        // opentype.js can integrate with frameworks like async.js.\n\n\n        function load(url, callback) {\n          var isNode = typeof window === 'undefined';\n          var loadFn = isNode ? loadFromFile : loadFromUrl;\n          loadFn(url, function (err, arrayBuffer) {\n            if (err) {\n              return callback(err);\n            }\n\n            var font = parseBuffer(arrayBuffer);\n            return callback(null, font);\n          });\n        } // Syncronously load the font from a URL or file.\n        // When done, return the font object or throw an error.\n\n\n        function loadSync(url) {\n          var fs = require('fs');\n\n          var buffer = fs.readFileSync(url);\n          return parseBuffer(toArrayBuffer(buffer));\n        }\n\n        exports._parse = parse;\n        exports.Font = _font.Font;\n        exports.Glyph = glyph.Glyph;\n        exports.Path = path.Path;\n        exports.parse = parseBuffer;\n        exports.load = load;\n        exports.loadSync = loadSync;\n      }, {\n        \"./encoding\": 3,\n        \"./font\": 4,\n        \"./glyph\": 5,\n        \"./parse\": 8,\n        \"./path\": 9,\n        \"./tables/cff\": 11,\n        \"./tables/cmap\": 12,\n        \"./tables/glyf\": 13,\n        \"./tables/gpos\": 14,\n        \"./tables/head\": 15,\n        \"./tables/hhea\": 16,\n        \"./tables/hmtx\": 17,\n        \"./tables/kern\": 18,\n        \"./tables/loca\": 19,\n        \"./tables/maxp\": 20,\n        \"./tables/name\": 21,\n        \"./tables/os2\": 22,\n        \"./tables/post\": 23,\n        \"fs\": undefined\n      }],\n      8: [function (require, module, exports) {\n        // Parsing utility functions\n        'use strict'; // Retrieve an unsigned byte from the DataView.\n\n        exports.getByte = function () {\n          function getByte(dataView, offset) {\n            return dataView.getUint8(offset);\n          }\n\n          return getByte;\n        }();\n\n        exports.getCard8 = exports.getByte; // Retrieve an unsigned 16-bit short from the DataView.\n        // The value is stored in big endian.\n\n        exports.getUShort = function (dataView, offset) {\n          return dataView.getUint16(offset, false);\n        };\n\n        exports.getCard16 = exports.getUShort; // Retrieve a signed 16-bit short from the DataView.\n        // The value is stored in big endian.\n\n        exports.getShort = function (dataView, offset) {\n          return dataView.getInt16(offset, false);\n        }; // Retrieve an unsigned 32-bit long from the DataView.\n        // The value is stored in big endian.\n\n\n        exports.getULong = function (dataView, offset) {\n          return dataView.getUint32(offset, false);\n        }; // Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n        // The value is stored in big endian.\n\n\n        exports.getFixed = function (dataView, offset) {\n          var decimal = dataView.getInt16(offset, false);\n          var fraction = dataView.getUint16(offset + 2, false);\n          return decimal + fraction / 65535;\n        }; // Retrieve a 4-character tag from the DataView.\n        // Tags are used to identify tables.\n\n\n        exports.getTag = function (dataView, offset) {\n          var tag = '';\n\n          for (var i = offset; i < offset + 4; i += 1) {\n            tag += String.fromCharCode(dataView.getInt8(i));\n          }\n\n          return tag;\n        }; // Retrieve an offset from the DataView.\n        // Offsets are 1 to 4 bytes in length, depending on the offSize argument.\n\n\n        exports.getOffset = function (dataView, offset, offSize) {\n          var v = 0;\n\n          for (var i = 0; i < offSize; i += 1) {\n            v <<= 8;\n            v += dataView.getUint8(offset + i);\n          }\n\n          return v;\n        }; // Retrieve a number of bytes from start offset to the end offset from the DataView.\n\n\n        exports.getBytes = function (dataView, startOffset, endOffset) {\n          var bytes = [];\n\n          for (var i = startOffset; i < endOffset; i += 1) {\n            bytes.push(dataView.getUint8(i));\n          }\n\n          return bytes;\n        }; // Convert the list of bytes to a string.\n\n\n        exports.bytesToString = function (bytes) {\n          var s = '';\n\n          for (var i = 0; i < bytes.length; i += 1) {\n            s += String.fromCharCode(bytes[i]);\n          }\n\n          return s;\n        };\n\n        var typeOffsets = {\n          \"byte\": 1,\n          uShort: 2,\n          \"short\": 2,\n          uLong: 4,\n          fixed: 4,\n          longDateTime: 8,\n          tag: 4\n        }; // A stateful parser that changes the offset whenever a value is retrieved.\n        // The data is a DataView.\n\n        function Parser(data, offset) {\n          this.data = data;\n          this.offset = offset;\n          this.relativeOffset = 0;\n        }\n\n        Parser.prototype.parseByte = function () {\n          var v = this.data.getUint8(this.offset + this.relativeOffset);\n          this.relativeOffset += 1;\n          return v;\n        };\n\n        Parser.prototype.parseChar = function () {\n          var v = this.data.getInt8(this.offset + this.relativeOffset);\n          this.relativeOffset += 1;\n          return v;\n        };\n\n        Parser.prototype.parseCard8 = Parser.prototype.parseByte;\n\n        Parser.prototype.parseUShort = function () {\n          var v = this.data.getUint16(this.offset + this.relativeOffset);\n          this.relativeOffset += 2;\n          return v;\n        };\n\n        Parser.prototype.parseCard16 = Parser.prototype.parseUShort;\n        Parser.prototype.parseSID = Parser.prototype.parseUShort;\n        Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;\n\n        Parser.prototype.parseShort = function () {\n          var v = this.data.getInt16(this.offset + this.relativeOffset);\n          this.relativeOffset += 2;\n          return v;\n        };\n\n        Parser.prototype.parseF2Dot14 = function () {\n          var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n          this.relativeOffset += 2;\n          return v;\n        };\n\n        Parser.prototype.parseULong = function () {\n          var v = exports.getULong(this.data, this.offset + this.relativeOffset);\n          this.relativeOffset += 4;\n          return v;\n        };\n\n        Parser.prototype.parseFixed = function () {\n          var v = exports.getFixed(this.data, this.offset + this.relativeOffset);\n          this.relativeOffset += 4;\n          return v;\n        };\n\n        Parser.prototype.parseOffset16List = Parser.prototype.parseUShortList = function (count) {\n          var offsets = new Array(count);\n          var dataView = this.data;\n          var offset = this.offset + this.relativeOffset;\n\n          for (var i = 0; i < count; i++) {\n            offsets[i] = exports.getUShort(dataView, offset);\n            offset += 2;\n          }\n\n          this.relativeOffset += count * 2;\n          return offsets;\n        };\n\n        Parser.prototype.parseString = function (length) {\n          var dataView = this.data;\n          var offset = this.offset + this.relativeOffset;\n          var string = '';\n          this.relativeOffset += length;\n\n          for (var i = 0; i < length; i++) {\n            string += String.fromCharCode(dataView.getUint8(offset + i));\n          }\n\n          return string;\n        };\n\n        Parser.prototype.parseTag = function () {\n          return this.parseString(4);\n        }; // LONGDATETIME is a 64-bit integer.\n        // JavaScript and unix timestamps traditionally use 32 bits, so we\n        // only take the last 32 bits.\n\n\n        Parser.prototype.parseLongDateTime = function () {\n          var v = exports.getULong(this.data, this.offset + this.relativeOffset + 4);\n          this.relativeOffset += 8;\n          return v;\n        };\n\n        Parser.prototype.parseFixed = function () {\n          var v = exports.getULong(this.data, this.offset + this.relativeOffset);\n          this.relativeOffset += 4;\n          return v / 65536;\n        };\n\n        Parser.prototype.parseVersion = function () {\n          var major = exports.getUShort(this.data, this.offset + this.relativeOffset); // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n          // This returns the correct number if minor = 0xN000 where N is 0-9\n\n          var minor = exports.getUShort(this.data, this.offset + this.relativeOffset + 2);\n          this.relativeOffset += 4;\n          return major + minor / 0x1000 / 10;\n        };\n\n        Parser.prototype.skip = function (type, amount) {\n          if (amount === undefined) {\n            amount = 1;\n          }\n\n          this.relativeOffset += typeOffsets[type] * amount;\n        };\n\n        exports.Parser = Parser;\n      }, {}],\n      9: [function (require, module, exports) {\n        // Geometric objects\n        'use strict'; // A bézier path containing a set of path commands similar to a SVG path.\n        // Paths can be drawn on a context using `draw`.\n\n        function Path() {\n          this.commands = [];\n          this.fill = 'black';\n          this.stroke = null;\n          this.strokeWidth = 1;\n        }\n\n        Path.prototype.moveTo = function (x, y) {\n          this.commands.push({\n            type: 'M',\n            x: x,\n            y: y\n          });\n        };\n\n        Path.prototype.lineTo = function (x, y) {\n          this.commands.push({\n            type: 'L',\n            x: x,\n            y: y\n          });\n        };\n\n        Path.prototype.curveTo = Path.prototype.bezierCurveTo = function (x1, y1, x2, y2, x, y) {\n          this.commands.push({\n            type: 'C',\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2,\n            x: x,\n            y: y\n          });\n        };\n\n        Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function (x1, y1, x, y) {\n          this.commands.push({\n            type: 'Q',\n            x1: x1,\n            y1: y1,\n            x: x,\n            y: y\n          });\n        };\n\n        Path.prototype.close = Path.prototype.closePath = function () {\n          this.commands.push({\n            type: 'Z'\n          });\n        }; // Add the given path or list of commands to the commands of this path.\n\n\n        Path.prototype.extend = function (pathOrCommands) {\n          if (pathOrCommands.commands) {\n            pathOrCommands = pathOrCommands.commands;\n          }\n\n          Array.prototype.push.apply(this.commands, pathOrCommands);\n        }; // Draw the path to a 2D context.\n\n\n        Path.prototype.draw = function (ctx) {\n          ctx.beginPath();\n\n          for (var i = 0; i < this.commands.length; i += 1) {\n            var cmd = this.commands[i];\n\n            if (cmd.type === 'M') {\n              ctx.moveTo(cmd.x, cmd.y);\n            } else if (cmd.type === 'L') {\n              ctx.lineTo(cmd.x, cmd.y);\n            } else if (cmd.type === 'C') {\n              ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n            } else if (cmd.type === 'Q') {\n              ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);\n            } else if (cmd.type === 'Z') {\n              ctx.closePath();\n            }\n          }\n\n          if (this.fill) {\n            ctx.fillStyle = this.fill;\n            ctx.fill();\n          }\n\n          if (this.stroke) {\n            ctx.strokeStyle = this.stroke;\n            ctx.lineWidth = this.strokeWidth;\n            ctx.stroke();\n          }\n        }; // Convert the Path to a string of path data instructions\n        // See http://www.w3.org/TR/SVG/paths.html#PathData\n        // Parameters:\n        // - decimalPlaces: The amount of decimal places for floating-point values (default: 2)\n\n\n        Path.prototype.toPathData = function (decimalPlaces) {\n          decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;\n\n          function floatToString(v) {\n            if (Math.round(v) === v) {\n              return '' + Math.round(v);\n            } else {\n              return v.toFixed(decimalPlaces);\n            }\n          }\n\n          function packValues() {\n            var s = '';\n\n            for (var i = 0; i < arguments.length; i += 1) {\n              var v = arguments[i];\n\n              if (v >= 0 && i > 0) {\n                s += ' ';\n              }\n\n              s += floatToString(v);\n            }\n\n            return s;\n          }\n\n          var d = '';\n\n          for (var i = 0; i < this.commands.length; i += 1) {\n            var cmd = this.commands[i];\n\n            if (cmd.type === 'M') {\n              d += 'M' + packValues(cmd.x, cmd.y);\n            } else if (cmd.type === 'L') {\n              d += 'L' + packValues(cmd.x, cmd.y);\n            } else if (cmd.type === 'C') {\n              d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n            } else if (cmd.type === 'Q') {\n              d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);\n            } else if (cmd.type === 'Z') {\n              d += 'Z';\n            }\n          }\n\n          return d;\n        }; // Convert the path to a SVG <path> element, as a string.\n        // Parameters:\n        // - decimalPlaces: The amount of decimal places for floating-point values (default: 2)\n\n\n        Path.prototype.toSVG = function (decimalPlaces) {\n          var svg = '<path d=\"';\n          svg += this.toPathData(decimalPlaces);\n          svg += '\"';\n\n          if (this.fill & this.fill !== 'black') {\n            if (this.fill === null) {\n              svg += ' fill=\"none\"';\n            } else {\n              svg += ' fill=\"' + this.fill + '\"';\n            }\n          }\n\n          if (this.stroke) {\n            svg += ' stroke=\"' + this.stroke + '\" stroke-width=\"' + this.strokeWidth + '\"';\n          }\n\n          svg += '/>';\n          return svg;\n        };\n\n        exports.Path = Path;\n      }, {}],\n      10: [function (require, module, exports) {\n        // Table metadata\n        'use strict';\n\n        var check = require('./check');\n\n        var encode = require('./types').encode;\n\n        var sizeOf = require('./types').sizeOf;\n\n        function Table(tableName, fields, options) {\n          var i;\n\n          for (i = 0; i < fields.length; i += 1) {\n            var field = fields[i];\n            this[field.name] = field.value;\n          }\n\n          this.tableName = tableName;\n          this.fields = fields;\n\n          if (options) {\n            var optionKeys = Object.keys(options);\n\n            for (i = 0; i < optionKeys.length; i += 1) {\n              var k = optionKeys[i];\n              var v = options[k];\n\n              if (this[k] !== undefined) {\n                this[k] = v;\n              }\n            }\n          }\n        }\n\n        Table.prototype.sizeOf = function () {\n          var v = 0;\n\n          for (var i = 0; i < this.fields.length; i += 1) {\n            var field = this.fields[i];\n            var value = this[field.name];\n\n            if (value === undefined) {\n              value = field.value;\n            }\n\n            if (typeof value.sizeOf === 'function') {\n              v += value.sizeOf();\n            } else {\n              var sizeOfFunction = sizeOf[field.type];\n              check.assert(typeof sizeOfFunction === 'function', 'Could not find sizeOf function for field' + field.name);\n              v += sizeOfFunction(value);\n            }\n          }\n\n          return v;\n        };\n\n        Table.prototype.encode = function () {\n          return encode.TABLE(this);\n        };\n\n        exports.Table = Table;\n      }, {\n        \"./check\": 1,\n        \"./types\": 25\n      }],\n      11: [function (require, module, exports) {\n        // The `CFF` table contains the glyph outlines in PostScript format.\n        // https://www.microsoft.com/typography/OTSPEC/cff.htm\n        // http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf\n        // http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf\n        'use strict';\n\n        var encoding = require('../encoding');\n\n        var glyphset = require('../glyphset');\n\n        var parse = require('../parse');\n\n        var path = require('../path');\n\n        var table = require('../table'); // Custom equals function that can also check lists.\n\n\n        function equals(a, b) {\n          if (a === b) {\n            return true;\n          } else if (Array.isArray(a) && Array.isArray(b)) {\n            if (a.length !== b.length) {\n              return false;\n            }\n\n            for (var i = 0; i < a.length; i += 1) {\n              if (!equals(a[i], b[i])) {\n                return false;\n              }\n            }\n\n            return true;\n          } else {\n            return false;\n          }\n        } // Parse a `CFF` INDEX array.\n        // An index array consists of a list of offsets, then a list of objects at those offsets.\n\n\n        function parseCFFIndex(data, start, conversionFn) {\n          //var i, objectOffset, endOffset;\n          var offsets = [];\n          var objects = [];\n          var count = parse.getCard16(data, start);\n          var i;\n          var objectOffset;\n          var endOffset;\n\n          if (count !== 0) {\n            var offsetSize = parse.getByte(data, start + 2);\n            objectOffset = start + (count + 1) * offsetSize + 2;\n            var pos = start + 3;\n\n            for (i = 0; i < count + 1; i += 1) {\n              offsets.push(parse.getOffset(data, pos, offsetSize));\n              pos += offsetSize;\n            } // The total size of the index array is 4 header bytes + the value of the last offset.\n\n\n            endOffset = objectOffset + offsets[count];\n          } else {\n            endOffset = start + 2;\n          }\n\n          for (i = 0; i < offsets.length - 1; i += 1) {\n            var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);\n\n            if (conversionFn) {\n              value = conversionFn(value);\n            }\n\n            objects.push(value);\n          }\n\n          return {\n            objects: objects,\n            startOffset: start,\n            endOffset: endOffset\n          };\n        } // Parse a `CFF` DICT real value.\n\n\n        function parseFloatOperand(parser) {\n          var s = '';\n          var eof = 15;\n          var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];\n\n          while (true) {\n            var b = parser.parseByte();\n            var n1 = b >> 4;\n            var n2 = b & 15;\n\n            if (n1 === eof) {\n              break;\n            }\n\n            s += lookup[n1];\n\n            if (n2 === eof) {\n              break;\n            }\n\n            s += lookup[n2];\n          }\n\n          return parseFloat(s);\n        } // Parse a `CFF` DICT operand.\n\n\n        function parseOperand(parser, b0) {\n          var b1;\n          var b2;\n          var b3;\n          var b4;\n\n          if (b0 === 28) {\n            b1 = parser.parseByte();\n            b2 = parser.parseByte();\n            return b1 << 8 | b2;\n          }\n\n          if (b0 === 29) {\n            b1 = parser.parseByte();\n            b2 = parser.parseByte();\n            b3 = parser.parseByte();\n            b4 = parser.parseByte();\n            return b1 << 24 | b2 << 16 | b3 << 8 | b4;\n          }\n\n          if (b0 === 30) {\n            return parseFloatOperand(parser);\n          }\n\n          if (b0 >= 32 && b0 <= 246) {\n            return b0 - 139;\n          }\n\n          if (b0 >= 247 && b0 <= 250) {\n            b1 = parser.parseByte();\n            return (b0 - 247) * 256 + b1 + 108;\n          }\n\n          if (b0 >= 251 && b0 <= 254) {\n            b1 = parser.parseByte();\n            return -(b0 - 251) * 256 - b1 - 108;\n          }\n\n          throw new Error('Invalid b0 ' + b0);\n        } // Convert the entries returned by `parseDict` to a proper dictionary.\n        // If a value is a list of one, it is unpacked.\n\n\n        function entriesToObject(entries) {\n          var o = {};\n\n          for (var i = 0; i < entries.length; i += 1) {\n            var key = entries[i][0];\n            var values = entries[i][1];\n            var value;\n\n            if (values.length === 1) {\n              value = values[0];\n            } else {\n              value = values;\n            }\n\n            if (o.hasOwnProperty(key)) {\n              throw new Error('Object ' + o + ' already has key ' + key);\n            }\n\n            o[key] = value;\n          }\n\n          return o;\n        } // Parse a `CFF` DICT object.\n        // A dictionary contains key-value pairs in a compact tokenized format.\n\n\n        function parseCFFDict(data, start, size) {\n          start = start !== undefined ? start : 0;\n          var parser = new parse.Parser(data, start);\n          var entries = [];\n          var operands = [];\n          size = size !== undefined ? size : data.length;\n\n          while (parser.relativeOffset < size) {\n            var op = parser.parseByte(); // The first byte for each dict item distinguishes between operator (key) and operand (value).\n            // Values <= 21 are operators.\n\n            if (op <= 21) {\n              // Two-byte operators have an initial escape byte of 12.\n              if (op === 12) {\n                op = 1200 + parser.parseByte();\n              }\n\n              entries.push([op, operands]);\n              operands = [];\n            } else {\n              // Since the operands (values) come before the operators (keys), we store all operands in a list\n              // until we encounter an operator.\n              operands.push(parseOperand(parser, op));\n            }\n          }\n\n          return entriesToObject(entries);\n        } // Given a String Index (SID), return the value of the string.\n        // Strings below index 392 are standard CFF strings and are not encoded in the font.\n\n\n        function getCFFString(strings, index) {\n          if (index <= 390) {\n            index = encoding.cffStandardStrings[index];\n          } else {\n            index = strings[index - 391];\n          }\n\n          return index;\n        } // Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n        // This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\n\n\n        function interpretDict(dict, meta, strings) {\n          var newDict = {}; // Because we also want to include missing values, we start out from the meta list\n          // and lookup values in the dict.\n\n          for (var i = 0; i < meta.length; i += 1) {\n            var m = meta[i];\n            var value = dict[m.op];\n\n            if (value === undefined) {\n              value = m.value !== undefined ? m.value : null;\n            }\n\n            if (m.type === 'SID') {\n              value = getCFFString(strings, value);\n            }\n\n            newDict[m.name] = value;\n          }\n\n          return newDict;\n        } // Parse the CFF header.\n\n\n        function parseCFFHeader(data, start) {\n          var header = {};\n          header.formatMajor = parse.getCard8(data, start);\n          header.formatMinor = parse.getCard8(data, start + 1);\n          header.size = parse.getCard8(data, start + 2);\n          header.offsetSize = parse.getCard8(data, start + 3);\n          header.startOffset = start;\n          header.endOffset = start + 4;\n          return header;\n        }\n\n        var TOP_DICT_META = [{\n          name: 'version',\n          op: 0,\n          type: 'SID'\n        }, {\n          name: 'notice',\n          op: 1,\n          type: 'SID'\n        }, {\n          name: 'copyright',\n          op: 1200,\n          type: 'SID'\n        }, {\n          name: 'fullName',\n          op: 2,\n          type: 'SID'\n        }, {\n          name: 'familyName',\n          op: 3,\n          type: 'SID'\n        }, {\n          name: 'weight',\n          op: 4,\n          type: 'SID'\n        }, {\n          name: 'isFixedPitch',\n          op: 1201,\n          type: 'number',\n          value: 0\n        }, {\n          name: 'italicAngle',\n          op: 1202,\n          type: 'number',\n          value: 0\n        }, {\n          name: 'underlinePosition',\n          op: 1203,\n          type: 'number',\n          value: -100\n        }, {\n          name: 'underlineThickness',\n          op: 1204,\n          type: 'number',\n          value: 50\n        }, {\n          name: 'paintType',\n          op: 1205,\n          type: 'number',\n          value: 0\n        }, {\n          name: 'charstringType',\n          op: 1206,\n          type: 'number',\n          value: 2\n        }, {\n          name: 'fontMatrix',\n          op: 1207,\n          type: ['real', 'real', 'real', 'real', 'real', 'real'],\n          value: [0.001, 0, 0, 0.001, 0, 0]\n        }, {\n          name: 'uniqueId',\n          op: 13,\n          type: 'number'\n        }, {\n          name: 'fontBBox',\n          op: 5,\n          type: ['number', 'number', 'number', 'number'],\n          value: [0, 0, 0, 0]\n        }, {\n          name: 'strokeWidth',\n          op: 1208,\n          type: 'number',\n          value: 0\n        }, {\n          name: 'xuid',\n          op: 14,\n          type: [],\n          value: null\n        }, {\n          name: 'charset',\n          op: 15,\n          type: 'offset',\n          value: 0\n        }, {\n          name: 'encoding',\n          op: 16,\n          type: 'offset',\n          value: 0\n        }, {\n          name: 'charStrings',\n          op: 17,\n          type: 'offset',\n          value: 0\n        }, {\n          name: 'private',\n          op: 18,\n          type: ['number', 'offset'],\n          value: [0, 0]\n        }];\n        var PRIVATE_DICT_META = [{\n          name: 'subrs',\n          op: 19,\n          type: 'offset',\n          value: 0\n        }, {\n          name: 'defaultWidthX',\n          op: 20,\n          type: 'number',\n          value: 0\n        }, {\n          name: 'nominalWidthX',\n          op: 21,\n          type: 'number',\n          value: 0\n        }]; // Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n        // The top dictionary contains the essential metadata for the font, together with the private dictionary.\n\n        function parseCFFTopDict(data, strings) {\n          var dict = parseCFFDict(data, 0, data.byteLength);\n          return interpretDict(dict, TOP_DICT_META, strings);\n        } // Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\n\n\n        function parseCFFPrivateDict(data, start, size, strings) {\n          var dict = parseCFFDict(data, start, size);\n          return interpretDict(dict, PRIVATE_DICT_META, strings);\n        } // Parse the CFF charset table, which contains internal names for all the glyphs.\n        // This function will return a list of glyph names.\n        // See Adobe TN #5176 chapter 13, \"Charsets\".\n\n\n        function parseCFFCharset(data, start, nGlyphs, strings) {\n          var i;\n          var sid;\n          var count;\n          var parser = new parse.Parser(data, start); // The .notdef glyph is not included, so subtract 1.\n\n          nGlyphs -= 1;\n          var charset = ['.notdef'];\n          var format = parser.parseCard8();\n\n          if (format === 0) {\n            for (i = 0; i < nGlyphs; i += 1) {\n              sid = parser.parseSID();\n              charset.push(getCFFString(strings, sid));\n            }\n          } else if (format === 1) {\n            while (charset.length <= nGlyphs) {\n              sid = parser.parseSID();\n              count = parser.parseCard8();\n\n              for (i = 0; i <= count; i += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n              }\n            }\n          } else if (format === 2) {\n            while (charset.length <= nGlyphs) {\n              sid = parser.parseSID();\n              count = parser.parseCard16();\n\n              for (i = 0; i <= count; i += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n              }\n            }\n          } else {\n            throw new Error('Unknown charset format ' + format);\n          }\n\n          return charset;\n        } // Parse the CFF encoding data. Only one encoding can be specified per font.\n        // See Adobe TN #5176 chapter 12, \"Encodings\".\n\n\n        function parseCFFEncoding(data, start, charset) {\n          var i;\n          var code;\n          var enc = {};\n          var parser = new parse.Parser(data, start);\n          var format = parser.parseCard8();\n\n          if (format === 0) {\n            var nCodes = parser.parseCard8();\n\n            for (i = 0; i < nCodes; i += 1) {\n              code = parser.parseCard8();\n              enc[code] = i;\n            }\n          } else if (format === 1) {\n            var nRanges = parser.parseCard8();\n            code = 1;\n\n            for (i = 0; i < nRanges; i += 1) {\n              var first = parser.parseCard8();\n              var nLeft = parser.parseCard8();\n\n              for (var j = first; j <= first + nLeft; j += 1) {\n                enc[j] = code;\n                code += 1;\n              }\n            }\n          } else {\n            throw new Error('Unknown encoding format ' + format);\n          }\n\n          return new encoding.CffEncoding(enc, charset);\n        } // Take in charstring code and return a Glyph object.\n        // The encoding is described in the Type 2 Charstring Format\n        // https://www.microsoft.com/typography/OTSPEC/charstr2.htm\n\n\n        function parseCFFCharstring(font, glyph, code) {\n          var c1x;\n          var c1y;\n          var c2x;\n          var c2y;\n          var p = new path.Path();\n          var stack = [];\n          var nStems = 0;\n          var haveWidth = false;\n          var width = font.defaultWidthX;\n          var open = false;\n          var x = 0;\n          var y = 0;\n\n          function newContour(x, y) {\n            if (open) {\n              p.closePath();\n            }\n\n            p.moveTo(x, y);\n            open = true;\n          }\n\n          function parseStems() {\n            var hasWidthArg; // The number of stem operators on the stack is always even.\n            // If the value is uneven, that means a width is specified.\n\n            hasWidthArg = stack.length % 2 !== 0;\n\n            if (hasWidthArg && !haveWidth) {\n              width = stack.shift() + font.nominalWidthX;\n            }\n\n            nStems += stack.length >> 1;\n            stack.length = 0;\n            haveWidth = true;\n          }\n\n          function parse(code) {\n            var b1;\n            var b2;\n            var b3;\n            var b4;\n            var codeIndex;\n            var subrCode;\n            var jpx;\n            var jpy;\n            var c3x;\n            var c3y;\n            var c4x;\n            var c4y;\n            var i = 0;\n\n            while (i < code.length) {\n              var v = code[i];\n              i += 1;\n\n              switch (v) {\n                case 1:\n                  // hstem\n                  parseStems();\n                  break;\n\n                case 3:\n                  // vstem\n                  parseStems();\n                  break;\n\n                case 4:\n                  // vmoveto\n                  if (stack.length > 1 && !haveWidth) {\n                    width = stack.shift() + font.nominalWidthX;\n                    haveWidth = true;\n                  }\n\n                  y += stack.pop();\n                  newContour(x, y);\n                  break;\n\n                case 5:\n                  // rlineto\n                  while (stack.length > 0) {\n                    x += stack.shift();\n                    y += stack.shift();\n                    p.lineTo(x, y);\n                  }\n\n                  break;\n\n                case 6:\n                  // hlineto\n                  while (stack.length > 0) {\n                    x += stack.shift();\n                    p.lineTo(x, y);\n\n                    if (stack.length === 0) {\n                      break;\n                    }\n\n                    y += stack.shift();\n                    p.lineTo(x, y);\n                  }\n\n                  break;\n\n                case 7:\n                  // vlineto\n                  while (stack.length > 0) {\n                    y += stack.shift();\n                    p.lineTo(x, y);\n\n                    if (stack.length === 0) {\n                      break;\n                    }\n\n                    x += stack.shift();\n                    p.lineTo(x, y);\n                  }\n\n                  break;\n\n                case 8:\n                  // rrcurveto\n                  while (stack.length > 0) {\n                    c1x = x + stack.shift();\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + stack.shift();\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                  }\n\n                  break;\n\n                case 10:\n                  // callsubr\n                  codeIndex = stack.pop() + font.subrsBias;\n                  subrCode = font.subrs[codeIndex];\n\n                  if (subrCode) {\n                    parse(subrCode);\n                  }\n\n                  break;\n\n                case 11:\n                  // return\n                  return;\n\n                case 12:\n                  // flex operators\n                  v = code[i];\n                  i += 1;\n\n                  switch (v) {\n                    case 35:\n                      // flex\n                      // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n                      c1x = x + stack.shift(); // dx1\n\n                      c1y = y + stack.shift(); // dy1\n\n                      c2x = c1x + stack.shift(); // dx2\n\n                      c2y = c1y + stack.shift(); // dy2\n\n                      jpx = c2x + stack.shift(); // dx3\n\n                      jpy = c2y + stack.shift(); // dy3\n\n                      c3x = jpx + stack.shift(); // dx4\n\n                      c3y = jpy + stack.shift(); // dy4\n\n                      c4x = c3x + stack.shift(); // dx5\n\n                      c4y = c3y + stack.shift(); // dy5\n\n                      x = c4x + stack.shift(); // dx6\n\n                      y = c4y + stack.shift(); // dy6\n\n                      stack.shift(); // flex depth\n\n                      p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                      p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                      break;\n\n                    case 34:\n                      // hflex\n                      // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n                      c1x = x + stack.shift(); // dx1\n\n                      c1y = y; // dy1\n\n                      c2x = c1x + stack.shift(); // dx2\n\n                      c2y = c1y + stack.shift(); // dy2\n\n                      jpx = c2x + stack.shift(); // dx3\n\n                      jpy = c2y; // dy3\n\n                      c3x = jpx + stack.shift(); // dx4\n\n                      c3y = c2y; // dy4\n\n                      c4x = c3x + stack.shift(); // dx5\n\n                      c4y = y; // dy5\n\n                      x = c4x + stack.shift(); // dx6\n\n                      p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                      p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                      break;\n\n                    case 36:\n                      // hflex1\n                      // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n                      c1x = x + stack.shift(); // dx1\n\n                      c1y = y + stack.shift(); // dy1\n\n                      c2x = c1x + stack.shift(); // dx2\n\n                      c2y = c1y + stack.shift(); // dy2\n\n                      jpx = c2x + stack.shift(); // dx3\n\n                      jpy = c2y; // dy3\n\n                      c3x = jpx + stack.shift(); // dx4\n\n                      c3y = c2y; // dy4\n\n                      c4x = c3x + stack.shift(); // dx5\n\n                      c4y = c3y + stack.shift(); // dy5\n\n                      x = c4x + stack.shift(); // dx6\n\n                      p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                      p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                      break;\n\n                    case 37:\n                      // flex1\n                      // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n                      c1x = x + stack.shift(); // dx1\n\n                      c1y = y + stack.shift(); // dy1\n\n                      c2x = c1x + stack.shift(); // dx2\n\n                      c2y = c1y + stack.shift(); // dy2\n\n                      jpx = c2x + stack.shift(); // dx3\n\n                      jpy = c2y + stack.shift(); // dy3\n\n                      c3x = jpx + stack.shift(); // dx4\n\n                      c3y = jpy + stack.shift(); // dy4\n\n                      c4x = c3x + stack.shift(); // dx5\n\n                      c4y = c3y + stack.shift(); // dy5\n\n                      if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n                        x = c4x + stack.shift();\n                      } else {\n                        y = c4y + stack.shift();\n                      }\n\n                      p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                      p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                      break;\n\n                    default:\n                      console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);\n                      stack.length = 0;\n                  }\n\n                  break;\n\n                case 14:\n                  // endchar\n                  if (stack.length > 0 && !haveWidth) {\n                    width = stack.shift() + font.nominalWidthX;\n                    haveWidth = true;\n                  }\n\n                  if (open) {\n                    p.closePath();\n                    open = false;\n                  }\n\n                  break;\n\n                case 18:\n                  // hstemhm\n                  parseStems();\n                  break;\n\n                case 19: // hintmask\n\n                case 20:\n                  // cntrmask\n                  parseStems();\n                  i += nStems + 7 >> 3;\n                  break;\n\n                case 21:\n                  // rmoveto\n                  if (stack.length > 2 && !haveWidth) {\n                    width = stack.shift() + font.nominalWidthX;\n                    haveWidth = true;\n                  }\n\n                  y += stack.pop();\n                  x += stack.pop();\n                  newContour(x, y);\n                  break;\n\n                case 22:\n                  // hmoveto\n                  if (stack.length > 1 && !haveWidth) {\n                    width = stack.shift() + font.nominalWidthX;\n                    haveWidth = true;\n                  }\n\n                  x += stack.pop();\n                  newContour(x, y);\n                  break;\n\n                case 23:\n                  // vstemhm\n                  parseStems();\n                  break;\n\n                case 24:\n                  // rcurveline\n                  while (stack.length > 2) {\n                    c1x = x + stack.shift();\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + stack.shift();\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                  }\n\n                  x += stack.shift();\n                  y += stack.shift();\n                  p.lineTo(x, y);\n                  break;\n\n                case 25:\n                  // rlinecurve\n                  while (stack.length > 6) {\n                    x += stack.shift();\n                    y += stack.shift();\n                    p.lineTo(x, y);\n                  }\n\n                  c1x = x + stack.shift();\n                  c1y = y + stack.shift();\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  x = c2x + stack.shift();\n                  y = c2y + stack.shift();\n                  p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                  break;\n\n                case 26:\n                  // vvcurveto\n                  if (stack.length % 2) {\n                    x += stack.shift();\n                  }\n\n                  while (stack.length > 0) {\n                    c1x = x;\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x;\n                    y = c2y + stack.shift();\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                  }\n\n                  break;\n\n                case 27:\n                  // hhcurveto\n                  if (stack.length % 2) {\n                    y += stack.shift();\n                  }\n\n                  while (stack.length > 0) {\n                    c1x = x + stack.shift();\n                    c1y = y;\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y;\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                  }\n\n                  break;\n\n                case 28:\n                  // shortint\n                  b1 = code[i];\n                  b2 = code[i + 1];\n                  stack.push((b1 << 24 | b2 << 16) >> 16);\n                  i += 2;\n                  break;\n\n                case 29:\n                  // callgsubr\n                  codeIndex = stack.pop() + font.gsubrsBias;\n                  subrCode = font.gsubrs[codeIndex];\n\n                  if (subrCode) {\n                    parse(subrCode);\n                  }\n\n                  break;\n\n                case 30:\n                  // vhcurveto\n                  while (stack.length > 0) {\n                    c1x = x;\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\n                    if (stack.length === 0) {\n                      break;\n                    }\n\n                    c1x = x + stack.shift();\n                    c1y = y;\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    y = c2y + stack.shift();\n                    x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                  }\n\n                  break;\n\n                case 31:\n                  // hvcurveto\n                  while (stack.length > 0) {\n                    c1x = x + stack.shift();\n                    c1y = y;\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    y = c2y + stack.shift();\n                    x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\n                    if (stack.length === 0) {\n                      break;\n                    }\n\n                    c1x = x;\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                  }\n\n                  break;\n\n                default:\n                  if (v < 32) {\n                    console.log('Glyph ' + glyph.index + ': unknown operator ' + v);\n                  } else if (v < 247) {\n                    stack.push(v - 139);\n                  } else if (v < 251) {\n                    b1 = code[i];\n                    i += 1;\n                    stack.push((v - 247) * 256 + b1 + 108);\n                  } else if (v < 255) {\n                    b1 = code[i];\n                    i += 1;\n                    stack.push(-(v - 251) * 256 - b1 - 108);\n                  } else {\n                    b1 = code[i];\n                    b2 = code[i + 1];\n                    b3 = code[i + 2];\n                    b4 = code[i + 3];\n                    i += 4;\n                    stack.push((b1 << 24 | b2 << 16 | b3 << 8 | b4) / 65536);\n                  }\n\n              }\n            }\n          }\n\n          parse(code);\n          glyph.advanceWidth = width;\n          return p;\n        } // Subroutines are encoded using the negative half of the number space.\n        // See type 2 chapter 4.7 \"Subroutine operators\".\n\n\n        function calcCFFSubroutineBias(subrs) {\n          var bias;\n\n          if (subrs.length < 1240) {\n            bias = 107;\n          } else if (subrs.length < 33900) {\n            bias = 1131;\n          } else {\n            bias = 32768;\n          }\n\n          return bias;\n        } // Parse the `CFF` table, which contains the glyph outlines in PostScript format.\n\n\n        function parseCFFTable(data, start, font) {\n          font.tables.cff = {};\n          var header = parseCFFHeader(data, start);\n          var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);\n          var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);\n          var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);\n          var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);\n          font.gsubrs = globalSubrIndex.objects;\n          font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);\n          var topDictData = new DataView(new Uint8Array(topDictIndex.objects[0]).buffer);\n          var topDict = parseCFFTopDict(topDictData, stringIndex.objects);\n          font.tables.cff.topDict = topDict;\n          var privateDictOffset = start + topDict['private'][1];\n          var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict['private'][0], stringIndex.objects);\n          font.defaultWidthX = privateDict.defaultWidthX;\n          font.nominalWidthX = privateDict.nominalWidthX;\n\n          if (privateDict.subrs !== 0) {\n            var subrOffset = privateDictOffset + privateDict.subrs;\n            var subrIndex = parseCFFIndex(data, subrOffset);\n            font.subrs = subrIndex.objects;\n            font.subrsBias = calcCFFSubroutineBias(font.subrs);\n          } else {\n            font.subrs = [];\n            font.subrsBias = 0;\n          } // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n\n\n          var charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);\n          font.nGlyphs = charStringsIndex.objects.length;\n          var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);\n\n          if (topDict.encoding === 0) {\n            // Standard encoding\n            font.cffEncoding = new encoding.CffEncoding(encoding.cffStandardEncoding, charset);\n          } else if (topDict.encoding === 1) {\n            // Expert encoding\n            font.cffEncoding = new encoding.CffEncoding(encoding.cffExpertEncoding, charset);\n          } else {\n            font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);\n          } // Prefer the CMAP encoding to the CFF encoding.\n\n\n          font.encoding = font.encoding || font.cffEncoding;\n          font.glyphs = new glyphset.GlyphSet(font);\n\n          for (var i = 0; i < font.nGlyphs; i += 1) {\n            var charString = charStringsIndex.objects[i];\n            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n          }\n        } // Convert a string to a String ID (SID).\n        // The list of strings is modified in place.\n\n\n        function encodeString(s, strings) {\n          var sid; // Is the string in the CFF standard strings?\n\n          var i = encoding.cffStandardStrings.indexOf(s);\n\n          if (i >= 0) {\n            sid = i;\n          } // Is the string already in the string index?\n\n\n          i = strings.indexOf(s);\n\n          if (i >= 0) {\n            sid = i + encoding.cffStandardStrings.length;\n          } else {\n            sid = encoding.cffStandardStrings.length + strings.length;\n            strings.push(s);\n          }\n\n          return sid;\n        }\n\n        function makeHeader() {\n          return new table.Table('Header', [{\n            name: 'major',\n            type: 'Card8',\n            value: 1\n          }, {\n            name: 'minor',\n            type: 'Card8',\n            value: 0\n          }, {\n            name: 'hdrSize',\n            type: 'Card8',\n            value: 4\n          }, {\n            name: 'major',\n            type: 'Card8',\n            value: 1\n          }]);\n        }\n\n        function makeNameIndex(fontNames) {\n          var t = new table.Table('Name INDEX', [{\n            name: 'names',\n            type: 'INDEX',\n            value: []\n          }]);\n          t.names = [];\n\n          for (var i = 0; i < fontNames.length; i += 1) {\n            t.names.push({\n              name: 'name_' + i,\n              type: 'NAME',\n              value: fontNames[i]\n            });\n          }\n\n          return t;\n        } // Given a dictionary's metadata, create a DICT structure.\n\n\n        function makeDict(meta, attrs, strings) {\n          var m = {};\n\n          for (var i = 0; i < meta.length; i += 1) {\n            var entry = meta[i];\n            var value = attrs[entry.name];\n\n            if (value !== undefined && !equals(value, entry.value)) {\n              if (entry.type === 'SID') {\n                value = encodeString(value, strings);\n              }\n\n              m[entry.op] = {\n                name: entry.name,\n                type: entry.type,\n                value: value\n              };\n            }\n          }\n\n          return m;\n        } // The Top DICT houses the global font attributes.\n\n\n        function makeTopDict(attrs, strings) {\n          var t = new table.Table('Top DICT', [{\n            name: 'dict',\n            type: 'DICT',\n            value: {}\n          }]);\n          t.dict = makeDict(TOP_DICT_META, attrs, strings);\n          return t;\n        }\n\n        function makeTopDictIndex(topDict) {\n          var t = new table.Table('Top DICT INDEX', [{\n            name: 'topDicts',\n            type: 'INDEX',\n            value: []\n          }]);\n          t.topDicts = [{\n            name: 'topDict_0',\n            type: 'TABLE',\n            value: topDict\n          }];\n          return t;\n        }\n\n        function makeStringIndex(strings) {\n          var t = new table.Table('String INDEX', [{\n            name: 'strings',\n            type: 'INDEX',\n            value: []\n          }]);\n          t.strings = [];\n\n          for (var i = 0; i < strings.length; i += 1) {\n            t.strings.push({\n              name: 'string_' + i,\n              type: 'STRING',\n              value: strings[i]\n            });\n          }\n\n          return t;\n        }\n\n        function makeGlobalSubrIndex() {\n          // Currently we don't use subroutines.\n          return new table.Table('Global Subr INDEX', [{\n            name: 'subrs',\n            type: 'INDEX',\n            value: []\n          }]);\n        }\n\n        function makeCharsets(glyphNames, strings) {\n          var t = new table.Table('Charsets', [{\n            name: 'format',\n            type: 'Card8',\n            value: 0\n          }]);\n\n          for (var i = 0; i < glyphNames.length; i += 1) {\n            var glyphName = glyphNames[i];\n            var glyphSID = encodeString(glyphName, strings);\n            t.fields.push({\n              name: 'glyph_' + i,\n              type: 'SID',\n              value: glyphSID\n            });\n          }\n\n          return t;\n        }\n\n        function glyphToOps(glyph) {\n          var ops = [];\n          var path = glyph.path;\n          ops.push({\n            name: 'width',\n            type: 'NUMBER',\n            value: glyph.advanceWidth\n          });\n          var x = 0;\n          var y = 0;\n\n          for (var i = 0; i < path.commands.length; i += 1) {\n            var dx;\n            var dy;\n            var cmd = path.commands[i];\n\n            if (cmd.type === 'Q') {\n              // CFF only supports bézier curves, so convert the quad to a bézier.\n              var _13 = 1 / 3;\n\n              var _23 = 2 / 3; // We're going to create a new command so we don't change the original path.\n\n\n              cmd = {\n                type: 'C',\n                x: cmd.x,\n                y: cmd.y,\n                x1: _13 * x + _23 * cmd.x1,\n                y1: _13 * y + _23 * cmd.y1,\n                x2: _13 * cmd.x + _23 * cmd.x1,\n                y2: _13 * cmd.y + _23 * cmd.y1\n              };\n            }\n\n            if (cmd.type === 'M') {\n              dx = Math.round(cmd.x - x);\n              dy = Math.round(cmd.y - y);\n              ops.push({\n                name: 'dx',\n                type: 'NUMBER',\n                value: dx\n              });\n              ops.push({\n                name: 'dy',\n                type: 'NUMBER',\n                value: dy\n              });\n              ops.push({\n                name: 'rmoveto',\n                type: 'OP',\n                value: 21\n              });\n              x = Math.round(cmd.x);\n              y = Math.round(cmd.y);\n            } else if (cmd.type === 'L') {\n              dx = Math.round(cmd.x - x);\n              dy = Math.round(cmd.y - y);\n              ops.push({\n                name: 'dx',\n                type: 'NUMBER',\n                value: dx\n              });\n              ops.push({\n                name: 'dy',\n                type: 'NUMBER',\n                value: dy\n              });\n              ops.push({\n                name: 'rlineto',\n                type: 'OP',\n                value: 5\n              });\n              x = Math.round(cmd.x);\n              y = Math.round(cmd.y);\n            } else if (cmd.type === 'C') {\n              var dx1 = Math.round(cmd.x1 - x);\n              var dy1 = Math.round(cmd.y1 - y);\n              var dx2 = Math.round(cmd.x2 - cmd.x1);\n              var dy2 = Math.round(cmd.y2 - cmd.y1);\n              dx = Math.round(cmd.x - cmd.x2);\n              dy = Math.round(cmd.y - cmd.y2);\n              ops.push({\n                name: 'dx1',\n                type: 'NUMBER',\n                value: dx1\n              });\n              ops.push({\n                name: 'dy1',\n                type: 'NUMBER',\n                value: dy1\n              });\n              ops.push({\n                name: 'dx2',\n                type: 'NUMBER',\n                value: dx2\n              });\n              ops.push({\n                name: 'dy2',\n                type: 'NUMBER',\n                value: dy2\n              });\n              ops.push({\n                name: 'dx',\n                type: 'NUMBER',\n                value: dx\n              });\n              ops.push({\n                name: 'dy',\n                type: 'NUMBER',\n                value: dy\n              });\n              ops.push({\n                name: 'rrcurveto',\n                type: 'OP',\n                value: 8\n              });\n              x = Math.round(cmd.x);\n              y = Math.round(cmd.y);\n            } // Contours are closed automatically.\n\n          }\n\n          ops.push({\n            name: 'endchar',\n            type: 'OP',\n            value: 14\n          });\n          return ops;\n        }\n\n        function makeCharStringsIndex(glyphs) {\n          var t = new table.Table('CharStrings INDEX', [{\n            name: 'charStrings',\n            type: 'INDEX',\n            value: []\n          }]);\n\n          for (var i = 0; i < glyphs.length; i += 1) {\n            var glyph = glyphs.get(i);\n            var ops = glyphToOps(glyph);\n            t.charStrings.push({\n              name: glyph.name,\n              type: 'CHARSTRING',\n              value: ops\n            });\n          }\n\n          return t;\n        }\n\n        function makePrivateDict(attrs, strings) {\n          var t = new table.Table('Private DICT', [{\n            name: 'dict',\n            type: 'DICT',\n            value: {}\n          }]);\n          t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);\n          return t;\n        }\n\n        function makePrivateDictIndex(privateDict) {\n          var t = new table.Table('Private DICT INDEX', [{\n            name: 'privateDicts',\n            type: 'INDEX',\n            value: []\n          }]);\n          t.privateDicts = [{\n            name: 'privateDict_0',\n            type: 'TABLE',\n            value: privateDict\n          }];\n          return t;\n        }\n\n        function makeCFFTable(glyphs, options) {\n          var t = new table.Table('CFF ', [{\n            name: 'header',\n            type: 'TABLE'\n          }, {\n            name: 'nameIndex',\n            type: 'TABLE'\n          }, {\n            name: 'topDictIndex',\n            type: 'TABLE'\n          }, {\n            name: 'stringIndex',\n            type: 'TABLE'\n          }, {\n            name: 'globalSubrIndex',\n            type: 'TABLE'\n          }, {\n            name: 'charsets',\n            type: 'TABLE'\n          }, {\n            name: 'charStringsIndex',\n            type: 'TABLE'\n          }, {\n            name: 'privateDictIndex',\n            type: 'TABLE'\n          }]);\n          var fontScale = 1 / options.unitsPerEm; // We use non-zero values for the offsets so that the DICT encodes them.\n          // This is important because the size of the Top DICT plays a role in offset calculation,\n          // and the size shouldn't change after we've written correct offsets.\n\n          var attrs = {\n            version: options.version,\n            fullName: options.fullName,\n            familyName: options.familyName,\n            weight: options.weightName,\n            fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],\n            charset: 999,\n            encoding: 0,\n            charStrings: 999,\n            \"private\": [0, 999]\n          };\n          var privateAttrs = {};\n          var glyphNames = [];\n          var glyph; // Skip first glyph (.notdef)\n\n          for (var i = 1; i < glyphs.length; i += 1) {\n            glyph = glyphs.get(i);\n            glyphNames.push(glyph.name);\n          }\n\n          var strings = [];\n          t.header = makeHeader();\n          t.nameIndex = makeNameIndex([options.postScriptName]);\n          var topDict = makeTopDict(attrs, strings);\n          t.topDictIndex = makeTopDictIndex(topDict);\n          t.globalSubrIndex = makeGlobalSubrIndex();\n          t.charsets = makeCharsets(glyphNames, strings);\n          t.charStringsIndex = makeCharStringsIndex(glyphs);\n          var privateDict = makePrivateDict(privateAttrs, strings);\n          t.privateDictIndex = makePrivateDictIndex(privateDict); // Needs to come at the end, to encode all custom strings used in the font.\n\n          t.stringIndex = makeStringIndex(strings);\n          var startOffset = t.header.sizeOf() + t.nameIndex.sizeOf() + t.topDictIndex.sizeOf() + t.stringIndex.sizeOf() + t.globalSubrIndex.sizeOf();\n          attrs.charset = startOffset; // We use the CFF standard encoding; proper encoding will be handled in cmap.\n\n          attrs.encoding = 0;\n          attrs.charStrings = attrs.charset + t.charsets.sizeOf();\n          attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf(); // Recreate the Top DICT INDEX with the correct offsets.\n\n          topDict = makeTopDict(attrs, strings);\n          t.topDictIndex = makeTopDictIndex(topDict);\n          return t;\n        }\n\n        exports.parse = parseCFFTable;\n        exports.make = makeCFFTable;\n      }, {\n        \"../encoding\": 3,\n        \"../glyphset\": 6,\n        \"../parse\": 8,\n        \"../path\": 9,\n        \"../table\": 10\n      }],\n      12: [function (require, module, exports) {\n        // The `cmap` table stores the mappings from characters to glyphs.\n        // https://www.microsoft.com/typography/OTSPEC/cmap.htm\n        'use strict';\n\n        var check = require('../check');\n\n        var parse = require('../parse');\n\n        var table = require('../table'); // Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n        // There are many available formats, but we only support the Windows format 4.\n        // This function returns a `CmapEncoding` object or null if no supported format could be found.\n\n\n        function parseCmapTable(data, start) {\n          var i;\n          var cmap = {};\n          cmap.version = parse.getUShort(data, start);\n          check.argument(cmap.version === 0, 'cmap table version should be 0.'); // The cmap table can contain many sub-tables, each with their own format.\n          // We're only interested in a \"platform 3\" table. This is a Windows format.\n\n          cmap.numTables = parse.getUShort(data, start + 2);\n          var offset = -1;\n\n          for (i = 0; i < cmap.numTables; i += 1) {\n            var platformId = parse.getUShort(data, start + 4 + i * 8);\n            var encodingId = parse.getUShort(data, start + 4 + i * 8 + 2);\n\n            if (platformId === 3 && (encodingId === 1 || encodingId === 0)) {\n              offset = parse.getULong(data, start + 4 + i * 8 + 4);\n              break;\n            }\n          }\n\n          if (offset === -1) {\n            // There is no cmap table in the font that we support, so return null.\n            // This font will be marked as unsupported.\n            return null;\n          }\n\n          var p = new parse.Parser(data, start + offset);\n          cmap.format = p.parseUShort();\n          check.argument(cmap.format === 4, 'Only format 4 cmap tables are supported.'); // Length in bytes of the sub-tables.\n\n          cmap.length = p.parseUShort();\n          cmap.language = p.parseUShort(); // segCount is stored x 2.\n\n          var segCount;\n          cmap.segCount = segCount = p.parseUShort() >> 1; // Skip searchRange, entrySelector, rangeShift.\n\n          p.skip('uShort', 3); // The \"unrolled\" mapping from character codes to glyph indices.\n\n          cmap.glyphIndexMap = {};\n          var endCountParser = new parse.Parser(data, start + offset + 14);\n          var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);\n          var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);\n          var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);\n          var glyphIndexOffset = start + offset + 16 + segCount * 8;\n\n          for (i = 0; i < segCount - 1; i += 1) {\n            var glyphIndex;\n            var endCount = endCountParser.parseUShort();\n            var startCount = startCountParser.parseUShort();\n            var idDelta = idDeltaParser.parseShort();\n            var idRangeOffset = idRangeOffsetParser.parseUShort();\n\n            for (var c = startCount; c <= endCount; c += 1) {\n              if (idRangeOffset !== 0) {\n                // The idRangeOffset is relative to the current position in the idRangeOffset array.\n                // Take the current offset in the idRangeOffset array.\n                glyphIndexOffset = idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2; // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n\n                glyphIndexOffset += idRangeOffset; // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n\n                glyphIndexOffset += (c - startCount) * 2;\n                glyphIndex = parse.getUShort(data, glyphIndexOffset);\n\n                if (glyphIndex !== 0) {\n                  glyphIndex = glyphIndex + idDelta & 0xFFFF;\n                }\n              } else {\n                glyphIndex = c + idDelta & 0xFFFF;\n              }\n\n              cmap.glyphIndexMap[c] = glyphIndex;\n            }\n          }\n\n          return cmap;\n        }\n\n        function addSegment(t, code, glyphIndex) {\n          t.segments.push({\n            end: code,\n            start: code,\n            delta: -(code - glyphIndex),\n            offset: 0\n          });\n        }\n\n        function addTerminatorSegment(t) {\n          t.segments.push({\n            end: 0xFFFF,\n            start: 0xFFFF,\n            delta: 1,\n            offset: 0\n          });\n        }\n\n        function makeCmapTable(glyphs) {\n          var i;\n          var t = new table.Table('cmap', [{\n            name: 'version',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'numTables',\n            type: 'USHORT',\n            value: 1\n          }, {\n            name: 'platformID',\n            type: 'USHORT',\n            value: 3\n          }, {\n            name: 'encodingID',\n            type: 'USHORT',\n            value: 1\n          }, {\n            name: 'offset',\n            type: 'ULONG',\n            value: 12\n          }, {\n            name: 'format',\n            type: 'USHORT',\n            value: 4\n          }, {\n            name: 'length',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'language',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'segCountX2',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'searchRange',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'entrySelector',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'rangeShift',\n            type: 'USHORT',\n            value: 0\n          }]);\n          t.segments = [];\n\n          for (i = 0; i < glyphs.length; i += 1) {\n            var glyph = glyphs.get(i);\n\n            for (var j = 0; j < glyph.unicodes.length; j += 1) {\n              addSegment(t, glyph.unicodes[j], i);\n            }\n\n            t.segments = t.segments.sort(function (a, b) {\n              return a.start - b.start;\n            });\n          }\n\n          addTerminatorSegment(t);\n          var segCount;\n          segCount = t.segments.length;\n          t.segCountX2 = segCount * 2;\n          t.searchRange = Math.pow(2, Math.floor(Math.log(segCount) / Math.log(2))) * 2;\n          t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);\n          t.rangeShift = t.segCountX2 - t.searchRange; // Set up parallel segment arrays.\n\n          var endCounts = [];\n          var startCounts = [];\n          var idDeltas = [];\n          var idRangeOffsets = [];\n          var glyphIds = [];\n\n          for (i = 0; i < segCount; i += 1) {\n            var segment = t.segments[i];\n            endCounts = endCounts.concat({\n              name: 'end_' + i,\n              type: 'USHORT',\n              value: segment.end\n            });\n            startCounts = startCounts.concat({\n              name: 'start_' + i,\n              type: 'USHORT',\n              value: segment.start\n            });\n            idDeltas = idDeltas.concat({\n              name: 'idDelta_' + i,\n              type: 'SHORT',\n              value: segment.delta\n            });\n            idRangeOffsets = idRangeOffsets.concat({\n              name: 'idRangeOffset_' + i,\n              type: 'USHORT',\n              value: segment.offset\n            });\n\n            if (segment.glyphId !== undefined) {\n              glyphIds = glyphIds.concat({\n                name: 'glyph_' + i,\n                type: 'USHORT',\n                value: segment.glyphId\n              });\n            }\n          }\n\n          t.fields = t.fields.concat(endCounts);\n          t.fields.push({\n            name: 'reservedPad',\n            type: 'USHORT',\n            value: 0\n          });\n          t.fields = t.fields.concat(startCounts);\n          t.fields = t.fields.concat(idDeltas);\n          t.fields = t.fields.concat(idRangeOffsets);\n          t.fields = t.fields.concat(glyphIds);\n          t.length = 14 + // Subtable header\n          endCounts.length * 2 + 2 + // reservedPad\n          startCounts.length * 2 + idDeltas.length * 2 + idRangeOffsets.length * 2 + glyphIds.length * 2;\n          return t;\n        }\n\n        exports.parse = parseCmapTable;\n        exports.make = makeCmapTable;\n      }, {\n        \"../check\": 1,\n        \"../parse\": 8,\n        \"../table\": 10\n      }],\n      13: [function (require, module, exports) {\n        // The `glyf` table describes the glyphs in TrueType outline format.\n        // http://www.microsoft.com/typography/otspec/glyf.htm\n        'use strict';\n\n        var check = require('../check');\n\n        var glyphset = require('../glyphset');\n\n        var parse = require('../parse');\n\n        var path = require('../path'); // Parse the coordinate data for a glyph.\n\n\n        function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n          var v;\n\n          if ((flag & shortVectorBitMask) > 0) {\n            // The coordinate is 1 byte long.\n            v = p.parseByte(); // The `same` bit is re-used for short values to signify the sign of the value.\n\n            if ((flag & sameBitMask) === 0) {\n              v = -v;\n            }\n\n            v = previousValue + v;\n          } else {\n            //  The coordinate is 2 bytes long.\n            // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n            if ((flag & sameBitMask) > 0) {\n              v = previousValue;\n            } else {\n              // Parse the coordinate as a signed 16-bit delta value.\n              v = previousValue + p.parseShort();\n            }\n          }\n\n          return v;\n        } // Parse a TrueType glyph.\n\n\n        function parseGlyph(glyph, data, start) {\n          var p = new parse.Parser(data, start);\n          glyph.numberOfContours = p.parseShort();\n          glyph.xMin = p.parseShort();\n          glyph.yMin = p.parseShort();\n          glyph.xMax = p.parseShort();\n          glyph.yMax = p.parseShort();\n          var flags;\n          var flag;\n\n          if (glyph.numberOfContours > 0) {\n            var i; // This glyph is not a composite.\n\n            var endPointIndices = glyph.endPointIndices = [];\n\n            for (i = 0; i < glyph.numberOfContours; i += 1) {\n              endPointIndices.push(p.parseUShort());\n            }\n\n            glyph.instructionLength = p.parseUShort();\n            glyph.instructions = [];\n\n            for (i = 0; i < glyph.instructionLength; i += 1) {\n              glyph.instructions.push(p.parseByte());\n            }\n\n            var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;\n            flags = [];\n\n            for (i = 0; i < numberOfCoordinates; i += 1) {\n              flag = p.parseByte();\n              flags.push(flag); // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n\n              if ((flag & 8) > 0) {\n                var repeatCount = p.parseByte();\n\n                for (var j = 0; j < repeatCount; j += 1) {\n                  flags.push(flag);\n                  i += 1;\n                }\n              }\n            }\n\n            check.argument(flags.length === numberOfCoordinates, 'Bad flags.');\n\n            if (endPointIndices.length > 0) {\n              var points = [];\n              var point; // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n\n              if (numberOfCoordinates > 0) {\n                for (i = 0; i < numberOfCoordinates; i += 1) {\n                  flag = flags[i];\n                  point = {};\n                  point.onCurve = !!(flag & 1);\n                  point.lastPointOfContour = endPointIndices.indexOf(i) >= 0;\n                  points.push(point);\n                }\n\n                var px = 0;\n\n                for (i = 0; i < numberOfCoordinates; i += 1) {\n                  flag = flags[i];\n                  point = points[i];\n                  point.x = parseGlyphCoordinate(p, flag, px, 2, 16);\n                  px = point.x;\n                }\n\n                var py = 0;\n\n                for (i = 0; i < numberOfCoordinates; i += 1) {\n                  flag = flags[i];\n                  point = points[i];\n                  point.y = parseGlyphCoordinate(p, flag, py, 4, 32);\n                  py = point.y;\n                }\n              }\n\n              glyph.points = points;\n            } else {\n              glyph.points = [];\n            }\n          } else if (glyph.numberOfContours === 0) {\n            glyph.points = [];\n          } else {\n            glyph.isComposite = true;\n            glyph.points = [];\n            glyph.components = [];\n            var moreComponents = true;\n\n            while (moreComponents) {\n              flags = p.parseUShort();\n              var component = {\n                glyphIndex: p.parseUShort(),\n                xScale: 1,\n                scale01: 0,\n                scale10: 0,\n                yScale: 1,\n                dx: 0,\n                dy: 0\n              };\n\n              if ((flags & 1) > 0) {\n                // The arguments are words\n                component.dx = p.parseShort();\n                component.dy = p.parseShort();\n              } else {\n                // The arguments are bytes\n                component.dx = p.parseChar();\n                component.dy = p.parseChar();\n              }\n\n              if ((flags & 8) > 0) {\n                // We have a scale\n                component.xScale = component.yScale = p.parseF2Dot14();\n              } else if ((flags & 64) > 0) {\n                // We have an X / Y scale\n                component.xScale = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n              } else if ((flags & 128) > 0) {\n                // We have a 2x2 transformation\n                component.xScale = p.parseF2Dot14();\n                component.scale01 = p.parseF2Dot14();\n                component.scale10 = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n              }\n\n              glyph.components.push(component);\n              moreComponents = !!(flags & 32);\n            }\n          }\n        } // Transform an array of points and return a new array.\n\n\n        function transformPoints(points, transform) {\n          var newPoints = [];\n\n          for (var i = 0; i < points.length; i += 1) {\n            var pt = points[i];\n            var newPt = {\n              x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n              y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n              onCurve: pt.onCurve,\n              lastPointOfContour: pt.lastPointOfContour\n            };\n            newPoints.push(newPt);\n          }\n\n          return newPoints;\n        }\n\n        function getContours(points) {\n          var contours = [];\n          var currentContour = [];\n\n          for (var i = 0; i < points.length; i += 1) {\n            var pt = points[i];\n            currentContour.push(pt);\n\n            if (pt.lastPointOfContour) {\n              contours.push(currentContour);\n              currentContour = [];\n            }\n          }\n\n          check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n          return contours;\n        } // Convert the TrueType glyph outline to a Path.\n\n\n        function getPath(points) {\n          var p = new path.Path();\n\n          if (!points) {\n            return p;\n          }\n\n          var contours = getContours(points);\n\n          for (var i = 0; i < contours.length; i += 1) {\n            var contour = contours[i];\n            var firstPt = contour[0];\n            var lastPt = contour[contour.length - 1];\n            var curvePt;\n            var realFirstPoint;\n\n            if (firstPt.onCurve) {\n              curvePt = null; // The first point will be consumed by the moveTo command,\n              // so skip it in the loop.\n\n              realFirstPoint = true;\n            } else {\n              if (lastPt.onCurve) {\n                // If the first point is off-curve and the last point is on-curve,\n                // start at the last point.\n                firstPt = lastPt;\n              } else {\n                // If both first and last points are off-curve, start at their middle.\n                firstPt = {\n                  x: (firstPt.x + lastPt.x) / 2,\n                  y: (firstPt.y + lastPt.y) / 2\n                };\n              }\n\n              curvePt = firstPt; // The first point is synthesized, so don't skip the real first point.\n\n              realFirstPoint = false;\n            }\n\n            p.moveTo(firstPt.x, firstPt.y);\n\n            for (var j = realFirstPoint ? 1 : 0; j < contour.length; j += 1) {\n              var pt = contour[j];\n              var prevPt = j === 0 ? firstPt : contour[j - 1];\n\n              if (prevPt.onCurve && pt.onCurve) {\n                // This is a straight line.\n                p.lineTo(pt.x, pt.y);\n              } else if (prevPt.onCurve && !pt.onCurve) {\n                curvePt = pt;\n              } else if (!prevPt.onCurve && !pt.onCurve) {\n                var midPt = {\n                  x: (prevPt.x + pt.x) / 2,\n                  y: (prevPt.y + pt.y) / 2\n                };\n                p.quadraticCurveTo(prevPt.x, prevPt.y, midPt.x, midPt.y);\n                curvePt = pt;\n              } else if (!prevPt.onCurve && pt.onCurve) {\n                // Previous point off-curve, this point on-curve.\n                p.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);\n                curvePt = null;\n              } else {\n                throw new Error('Invalid state.');\n              }\n            }\n\n            if (firstPt !== lastPt) {\n              // Connect the last and first points\n              if (curvePt) {\n                p.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);\n              } else {\n                p.lineTo(firstPt.x, firstPt.y);\n              }\n            }\n          }\n\n          p.closePath();\n          return p;\n        }\n\n        function buildPath(glyphs, glyph) {\n          if (glyph.isComposite) {\n            for (var j = 0; j < glyph.components.length; j += 1) {\n              var component = glyph.components[j];\n              var componentGlyph = glyphs.get(component.glyphIndex);\n\n              if (componentGlyph.points) {\n                var transformedPoints = transformPoints(componentGlyph.points, component);\n                glyph.points = glyph.points.concat(transformedPoints);\n              }\n            }\n          }\n\n          return getPath(glyph.points);\n        } // Parse all the glyphs according to the offsets from the `loca` table.\n\n\n        function parseGlyfTable(data, start, loca, font) {\n          var glyphs = new glyphset.GlyphSet(font);\n          var i; // The last element of the loca table is invalid.\n\n          for (i = 0; i < loca.length - 1; i += 1) {\n            var offset = loca[i];\n            var nextOffset = loca[i + 1];\n\n            if (offset !== nextOffset) {\n              glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n            } else {\n              glyphs.push(i, glyphset.glyphLoader(font, i));\n            }\n          }\n\n          return glyphs;\n        }\n\n        exports.parse = parseGlyfTable;\n      }, {\n        \"../check\": 1,\n        \"../glyphset\": 6,\n        \"../parse\": 8,\n        \"../path\": 9\n      }],\n      14: [function (require, module, exports) {\n        // The `GPOS` table contains kerning pairs, among other things.\n        // https://www.microsoft.com/typography/OTSPEC/gpos.htm\n        'use strict';\n\n        var check = require('../check');\n\n        var parse = require('../parse'); // Parse ScriptList and FeatureList tables of GPOS, GSUB, GDEF, BASE, JSTF tables.\n        // These lists are unused by now, this function is just the basis for a real parsing.\n\n\n        function parseTaggedListTable(data, start) {\n          var p = new parse.Parser(data, start);\n          var n = p.parseUShort();\n          var list = [];\n\n          for (var i = 0; i < n; i++) {\n            list[p.parseTag()] = {\n              offset: p.parseUShort()\n            };\n          }\n\n          return list;\n        } // Parse a coverage table in a GSUB, GPOS or GDEF table.\n        // Format 1 is a simple list of glyph ids,\n        // Format 2 is a list of ranges. It is expanded in a list of glyphs, maybe not the best idea.\n\n\n        function parseCoverageTable(data, start) {\n          var p = new parse.Parser(data, start);\n          var format = p.parseUShort();\n          var count = p.parseUShort();\n\n          if (format === 1) {\n            return p.parseUShortList(count);\n          } else if (format === 2) {\n            var coverage = [];\n\n            for (; count--;) {\n              var begin = p.parseUShort();\n              var end = p.parseUShort();\n              var index = p.parseUShort();\n\n              for (var i = begin; i <= end; i++) {\n                coverage[index++] = i;\n              }\n            }\n\n            return coverage;\n          }\n        } // Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n        // Returns a function that gets a class value from a glyph ID.\n\n\n        function parseClassDefTable(data, start) {\n          var p = new parse.Parser(data, start);\n          var format = p.parseUShort();\n\n          if (format === 1) {\n            // Format 1 specifies a range of consecutive glyph indices, one class per glyph ID.\n            var startGlyph = p.parseUShort();\n            var glyphCount = p.parseUShort();\n            var classes = p.parseUShortList(glyphCount);\n            return function (glyphID) {\n              return classes[glyphID - startGlyph] || 0;\n            };\n          } else if (format === 2) {\n            // Format 2 defines multiple groups of glyph indices that belong to the same class.\n            var rangeCount = p.parseUShort();\n            var startGlyphs = [];\n            var endGlyphs = [];\n            var classValues = [];\n\n            for (var i = 0; i < rangeCount; i++) {\n              startGlyphs[i] = p.parseUShort();\n              endGlyphs[i] = p.parseUShort();\n              classValues[i] = p.parseUShort();\n            }\n\n            return function (glyphID) {\n              var l = 0;\n              var r = startGlyphs.length - 1;\n\n              while (l < r) {\n                var c = l + r + 1 >> 1;\n\n                if (glyphID < startGlyphs[c]) {\n                  r = c - 1;\n                } else {\n                  l = c;\n                }\n              }\n\n              if (startGlyphs[l] <= glyphID && glyphID <= endGlyphs[l]) {\n                return classValues[l] || 0;\n              }\n\n              return 0;\n            };\n          }\n        } // Parse a pair adjustment positioning subtable, format 1 or format 2\n        // The subtable is returned in the form of a lookup function.\n\n\n        function parsePairPosSubTable(data, start) {\n          var p = new parse.Parser(data, start); // This part is common to format 1 and format 2 subtables\n\n          var format = p.parseUShort();\n          var coverageOffset = p.parseUShort();\n          var coverage = parseCoverageTable(data, start + coverageOffset); // valueFormat 4: XAdvance only, 1: XPlacement only, 0: no ValueRecord for second glyph\n          // Only valueFormat1=4 and valueFormat2=0 is supported.\n\n          var valueFormat1 = p.parseUShort();\n          var valueFormat2 = p.parseUShort();\n          var value1;\n          var value2;\n          if (valueFormat1 !== 4 || valueFormat2 !== 0) return;\n          var sharedPairSets = {};\n\n          if (format === 1) {\n            // Pair Positioning Adjustment: Format 1\n            var pairSetCount = p.parseUShort();\n            var pairSet = []; // Array of offsets to PairSet tables-from beginning of PairPos subtable-ordered by Coverage Index\n\n            var pairSetOffsets = p.parseOffset16List(pairSetCount);\n\n            for (var firstGlyph = 0; firstGlyph < pairSetCount; firstGlyph++) {\n              var pairSetOffset = pairSetOffsets[firstGlyph];\n              var sharedPairSet = sharedPairSets[pairSetOffset];\n\n              if (!sharedPairSet) {\n                // Parse a pairset table in a pair adjustment subtable format 1\n                sharedPairSet = {};\n                p.relativeOffset = pairSetOffset;\n                var pairValueCount = p.parseUShort();\n\n                for (; pairValueCount--;) {\n                  var secondGlyph = p.parseUShort();\n                  if (valueFormat1) value1 = p.parseShort();\n                  if (valueFormat2) value2 = p.parseShort(); // We only support valueFormat1 = 4 and valueFormat2 = 0,\n                  // so value1 is the XAdvance and value2 is empty.\n\n                  sharedPairSet[secondGlyph] = value1;\n                }\n              }\n\n              pairSet[coverage[firstGlyph]] = sharedPairSet;\n            }\n\n            return function (leftGlyph, rightGlyph) {\n              var pairs = pairSet[leftGlyph];\n              if (pairs) return pairs[rightGlyph];\n            };\n          } else if (format === 2) {\n            // Pair Positioning Adjustment: Format 2\n            var classDef1Offset = p.parseUShort();\n            var classDef2Offset = p.parseUShort();\n            var class1Count = p.parseUShort();\n            var class2Count = p.parseUShort();\n            var getClass1 = parseClassDefTable(data, start + classDef1Offset);\n            var getClass2 = parseClassDefTable(data, start + classDef2Offset); // Parse kerning values by class pair.\n\n            var kerningMatrix = [];\n\n            for (var i = 0; i < class1Count; i++) {\n              var kerningRow = kerningMatrix[i] = [];\n\n              for (var j = 0; j < class2Count; j++) {\n                if (valueFormat1) value1 = p.parseShort();\n                if (valueFormat2) value2 = p.parseShort(); // We only support valueFormat1 = 4 and valueFormat2 = 0,\n                // so value1 is the XAdvance and value2 is empty.\n\n                kerningRow[j] = value1;\n              }\n            } // Convert coverage list to a hash\n\n\n            var covered = {};\n\n            for (i = 0; i < coverage.length; i++) {\n              covered[coverage[i]] = 1;\n            } // Get the kerning value for a specific glyph pair.\n\n\n            return function (leftGlyph, rightGlyph) {\n              if (!covered[leftGlyph]) return;\n              var class1 = getClass1(leftGlyph);\n              var class2 = getClass2(rightGlyph);\n              var kerningRow = kerningMatrix[class1];\n\n              if (kerningRow) {\n                return kerningRow[class2];\n              }\n            };\n          }\n        } // Parse a LookupTable (present in of GPOS, GSUB, GDEF, BASE, JSTF tables).\n\n\n        function parseLookupTable(data, start) {\n          var p = new parse.Parser(data, start);\n          var lookupType = p.parseUShort();\n          var lookupFlag = p.parseUShort();\n          var useMarkFilteringSet = lookupFlag & 0x10;\n          var subTableCount = p.parseUShort();\n          var subTableOffsets = p.parseOffset16List(subTableCount);\n          var table = {\n            lookupType: lookupType,\n            lookupFlag: lookupFlag,\n            markFilteringSet: useMarkFilteringSet ? p.parseUShort() : -1\n          }; // LookupType 2, Pair adjustment\n\n          if (lookupType === 2) {\n            var subtables = [];\n\n            for (var i = 0; i < subTableCount; i++) {\n              subtables.push(parsePairPosSubTable(data, start + subTableOffsets[i]));\n            } // Return a function which finds the kerning values in the subtables.\n\n\n            table.getKerningValue = function (leftGlyph, rightGlyph) {\n              for (var i = subtables.length; i--;) {\n                var value = subtables[i](leftGlyph, rightGlyph);\n                if (value !== undefined) return value;\n              }\n\n              return 0;\n            };\n          }\n\n          return table;\n        } // Parse the `GPOS` table which contains, among other things, kerning pairs.\n        // https://www.microsoft.com/typography/OTSPEC/gpos.htm\n\n\n        function parseGposTable(data, start, font) {\n          var p = new parse.Parser(data, start);\n          var tableVersion = p.parseFixed();\n          check.argument(tableVersion === 1, 'Unsupported GPOS table version.'); // ScriptList and FeatureList - ignored for now\n\n          parseTaggedListTable(data, start + p.parseUShort()); // 'kern' is the feature we are looking for.\n\n          parseTaggedListTable(data, start + p.parseUShort()); // LookupList\n\n          var lookupListOffset = p.parseUShort();\n          p.relativeOffset = lookupListOffset;\n          var lookupCount = p.parseUShort();\n          var lookupTableOffsets = p.parseOffset16List(lookupCount);\n          var lookupListAbsoluteOffset = start + lookupListOffset;\n\n          for (var i = 0; i < lookupCount; i++) {\n            var table = parseLookupTable(data, lookupListAbsoluteOffset + lookupTableOffsets[i]);\n            if (table.lookupType === 2 && !font.getGposKerningValue) font.getGposKerningValue = table.getKerningValue;\n          }\n        }\n\n        exports.parse = parseGposTable;\n      }, {\n        \"../check\": 1,\n        \"../parse\": 8\n      }],\n      15: [function (require, module, exports) {\n        // The `head` table contains global information about the font.\n        // https://www.microsoft.com/typography/OTSPEC/head.htm\n        'use strict';\n\n        var check = require('../check');\n\n        var parse = require('../parse');\n\n        var table = require('../table'); // Parse the header `head` table\n\n\n        function parseHeadTable(data, start) {\n          var head = {};\n          var p = new parse.Parser(data, start);\n          head.version = p.parseVersion();\n          head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;\n          head.checkSumAdjustment = p.parseULong();\n          head.magicNumber = p.parseULong();\n          check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');\n          head.flags = p.parseUShort();\n          head.unitsPerEm = p.parseUShort();\n          head.created = p.parseLongDateTime();\n          head.modified = p.parseLongDateTime();\n          head.xMin = p.parseShort();\n          head.yMin = p.parseShort();\n          head.xMax = p.parseShort();\n          head.yMax = p.parseShort();\n          head.macStyle = p.parseUShort();\n          head.lowestRecPPEM = p.parseUShort();\n          head.fontDirectionHint = p.parseShort();\n          head.indexToLocFormat = p.parseShort(); // 50\n\n          head.glyphDataFormat = p.parseShort();\n          return head;\n        }\n\n        function makeHeadTable(options) {\n          return new table.Table('head', [{\n            name: 'version',\n            type: 'FIXED',\n            value: 0x00010000\n          }, {\n            name: 'fontRevision',\n            type: 'FIXED',\n            value: 0x00010000\n          }, {\n            name: 'checkSumAdjustment',\n            type: 'ULONG',\n            value: 0\n          }, {\n            name: 'magicNumber',\n            type: 'ULONG',\n            value: 0x5F0F3CF5\n          }, {\n            name: 'flags',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'unitsPerEm',\n            type: 'USHORT',\n            value: 1000\n          }, {\n            name: 'created',\n            type: 'LONGDATETIME',\n            value: 0\n          }, {\n            name: 'modified',\n            type: 'LONGDATETIME',\n            value: 0\n          }, {\n            name: 'xMin',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'yMin',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'xMax',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'yMax',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'macStyle',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'lowestRecPPEM',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'fontDirectionHint',\n            type: 'SHORT',\n            value: 2\n          }, {\n            name: 'indexToLocFormat',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'glyphDataFormat',\n            type: 'SHORT',\n            value: 0\n          }], options);\n        }\n\n        exports.parse = parseHeadTable;\n        exports.make = makeHeadTable;\n      }, {\n        \"../check\": 1,\n        \"../parse\": 8,\n        \"../table\": 10\n      }],\n      16: [function (require, module, exports) {\n        // The `hhea` table contains information for horizontal layout.\n        // https://www.microsoft.com/typography/OTSPEC/hhea.htm\n        'use strict';\n\n        var parse = require('../parse');\n\n        var table = require('../table'); // Parse the horizontal header `hhea` table\n\n\n        function parseHheaTable(data, start) {\n          var hhea = {};\n          var p = new parse.Parser(data, start);\n          hhea.version = p.parseVersion();\n          hhea.ascender = p.parseShort();\n          hhea.descender = p.parseShort();\n          hhea.lineGap = p.parseShort();\n          hhea.advanceWidthMax = p.parseUShort();\n          hhea.minLeftSideBearing = p.parseShort();\n          hhea.minRightSideBearing = p.parseShort();\n          hhea.xMaxExtent = p.parseShort();\n          hhea.caretSlopeRise = p.parseShort();\n          hhea.caretSlopeRun = p.parseShort();\n          hhea.caretOffset = p.parseShort();\n          p.relativeOffset += 8;\n          hhea.metricDataFormat = p.parseShort();\n          hhea.numberOfHMetrics = p.parseUShort();\n          return hhea;\n        }\n\n        function makeHheaTable(options) {\n          return new table.Table('hhea', [{\n            name: 'version',\n            type: 'FIXED',\n            value: 0x00010000\n          }, {\n            name: 'ascender',\n            type: 'FWORD',\n            value: 0\n          }, {\n            name: 'descender',\n            type: 'FWORD',\n            value: 0\n          }, {\n            name: 'lineGap',\n            type: 'FWORD',\n            value: 0\n          }, {\n            name: 'advanceWidthMax',\n            type: 'UFWORD',\n            value: 0\n          }, {\n            name: 'minLeftSideBearing',\n            type: 'FWORD',\n            value: 0\n          }, {\n            name: 'minRightSideBearing',\n            type: 'FWORD',\n            value: 0\n          }, {\n            name: 'xMaxExtent',\n            type: 'FWORD',\n            value: 0\n          }, {\n            name: 'caretSlopeRise',\n            type: 'SHORT',\n            value: 1\n          }, {\n            name: 'caretSlopeRun',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'caretOffset',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'reserved1',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'reserved2',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'reserved3',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'reserved4',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'metricDataFormat',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'numberOfHMetrics',\n            type: 'USHORT',\n            value: 0\n          }], options);\n        }\n\n        exports.parse = parseHheaTable;\n        exports.make = makeHheaTable;\n      }, {\n        \"../parse\": 8,\n        \"../table\": 10\n      }],\n      17: [function (require, module, exports) {\n        // The `hmtx` table contains the horizontal metrics for all glyphs.\n        // https://www.microsoft.com/typography/OTSPEC/hmtx.htm\n        'use strict';\n\n        var parse = require('../parse');\n\n        var table = require('../table'); // Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.\n        // This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.\n\n\n        function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {\n          var advanceWidth;\n          var leftSideBearing;\n          var p = new parse.Parser(data, start);\n\n          for (var i = 0; i < numGlyphs; i += 1) {\n            // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n            if (i < numMetrics) {\n              advanceWidth = p.parseUShort();\n              leftSideBearing = p.parseShort();\n            }\n\n            var glyph = glyphs.get(i);\n            glyph.advanceWidth = advanceWidth;\n            glyph.leftSideBearing = leftSideBearing;\n          }\n        }\n\n        function makeHmtxTable(glyphs) {\n          var t = new table.Table('hmtx', []);\n\n          for (var i = 0; i < glyphs.length; i += 1) {\n            var glyph = glyphs.get(i);\n            var advanceWidth = glyph.advanceWidth || 0;\n            var leftSideBearing = glyph.leftSideBearing || 0;\n            t.fields.push({\n              name: 'advanceWidth_' + i,\n              type: 'USHORT',\n              value: advanceWidth\n            });\n            t.fields.push({\n              name: 'leftSideBearing_' + i,\n              type: 'SHORT',\n              value: leftSideBearing\n            });\n          }\n\n          return t;\n        }\n\n        exports.parse = parseHmtxTable;\n        exports.make = makeHmtxTable;\n      }, {\n        \"../parse\": 8,\n        \"../table\": 10\n      }],\n      18: [function (require, module, exports) {\n        // The `kern` table contains kerning pairs.\n        // Note that some fonts use the GPOS OpenType layout table to specify kerning.\n        // https://www.microsoft.com/typography/OTSPEC/kern.htm\n        'use strict';\n\n        var check = require('../check');\n\n        var parse = require('../parse'); // Parse the `kern` table which contains kerning pairs.\n\n\n        function parseKernTable(data, start) {\n          var pairs = {};\n          var p = new parse.Parser(data, start);\n          var tableVersion = p.parseUShort();\n          check.argument(tableVersion === 0, 'Unsupported kern table version.'); // Skip nTables.\n\n          p.skip('uShort', 1);\n          var subTableVersion = p.parseUShort();\n          check.argument(subTableVersion === 0, 'Unsupported kern sub-table version.'); // Skip subTableLength, subTableCoverage\n\n          p.skip('uShort', 2);\n          var nPairs = p.parseUShort(); // Skip searchRange, entrySelector, rangeShift.\n\n          p.skip('uShort', 3);\n\n          for (var i = 0; i < nPairs; i += 1) {\n            var leftIndex = p.parseUShort();\n            var rightIndex = p.parseUShort();\n            var value = p.parseShort();\n            pairs[leftIndex + ',' + rightIndex] = value;\n          }\n\n          return pairs;\n        }\n\n        exports.parse = parseKernTable;\n      }, {\n        \"../check\": 1,\n        \"../parse\": 8\n      }],\n      19: [function (require, module, exports) {\n        // The `loca` table stores the offsets to the locations of the glyphs in the font.\n        // https://www.microsoft.com/typography/OTSPEC/loca.htm\n        'use strict';\n\n        var parse = require('../parse'); // Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,\n        // relative to the beginning of the glyphData table.\n        // The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)\n        // The loca table has two versions: a short version where offsets are stored as uShorts, and a long\n        // version where offsets are stored as uLongs. The `head` table specifies which version to use\n        // (under indexToLocFormat).\n\n\n        function parseLocaTable(data, start, numGlyphs, shortVersion) {\n          var p = new parse.Parser(data, start);\n          var parseFn = shortVersion ? p.parseUShort : p.parseULong; // There is an extra entry after the last index element to compute the length of the last glyph.\n          // That's why we use numGlyphs + 1.\n\n          var glyphOffsets = [];\n\n          for (var i = 0; i < numGlyphs + 1; i += 1) {\n            var glyphOffset = parseFn.call(p);\n\n            if (shortVersion) {\n              // The short table version stores the actual offset divided by 2.\n              glyphOffset *= 2;\n            }\n\n            glyphOffsets.push(glyphOffset);\n          }\n\n          return glyphOffsets;\n        }\n\n        exports.parse = parseLocaTable;\n      }, {\n        \"../parse\": 8\n      }],\n      20: [function (require, module, exports) {\n        // The `maxp` table establishes the memory requirements for the font.\n        // We need it just to get the number of glyphs in the font.\n        // https://www.microsoft.com/typography/OTSPEC/maxp.htm\n        'use strict';\n\n        var parse = require('../parse');\n\n        var table = require('../table'); // Parse the maximum profile `maxp` table.\n\n\n        function parseMaxpTable(data, start) {\n          var maxp = {};\n          var p = new parse.Parser(data, start);\n          maxp.version = p.parseVersion();\n          maxp.numGlyphs = p.parseUShort();\n\n          if (maxp.version === 1.0) {\n            maxp.maxPoints = p.parseUShort();\n            maxp.maxContours = p.parseUShort();\n            maxp.maxCompositePoints = p.parseUShort();\n            maxp.maxCompositeContours = p.parseUShort();\n            maxp.maxZones = p.parseUShort();\n            maxp.maxTwilightPoints = p.parseUShort();\n            maxp.maxStorage = p.parseUShort();\n            maxp.maxFunctionDefs = p.parseUShort();\n            maxp.maxInstructionDefs = p.parseUShort();\n            maxp.maxStackElements = p.parseUShort();\n            maxp.maxSizeOfInstructions = p.parseUShort();\n            maxp.maxComponentElements = p.parseUShort();\n            maxp.maxComponentDepth = p.parseUShort();\n          }\n\n          return maxp;\n        }\n\n        function makeMaxpTable(numGlyphs) {\n          return new table.Table('maxp', [{\n            name: 'version',\n            type: 'FIXED',\n            value: 0x00005000\n          }, {\n            name: 'numGlyphs',\n            type: 'USHORT',\n            value: numGlyphs\n          }]);\n        }\n\n        exports.parse = parseMaxpTable;\n        exports.make = makeMaxpTable;\n      }, {\n        \"../parse\": 8,\n        \"../table\": 10\n      }],\n      21: [function (require, module, exports) {\n        // The `name` naming table.\n        // https://www.microsoft.com/typography/OTSPEC/name.htm\n        'use strict';\n\n        var encode = require('../types').encode;\n\n        var parse = require('../parse');\n\n        var table = require('../table'); // NameIDs for the name table.\n\n\n        var nameTableNames = ['copyright', // 0\n        'fontFamily', // 1\n        'fontSubfamily', // 2\n        'uniqueID', // 3\n        'fullName', // 4\n        'version', // 5\n        'postScriptName', // 6\n        'trademark', // 7\n        'manufacturer', // 8\n        'designer', // 9\n        'description', // 10\n        'manufacturerURL', // 11\n        'designerURL', // 12\n        'licence', // 13\n        'licenceURL', // 14\n        'reserved', // 15\n        'preferredFamily', // 16\n        'preferredSubfamily', // 17\n        'compatibleFullName', // 18\n        'sampleText', // 19\n        'postScriptFindFontName', // 20\n        'wwsFamily', // 21\n        'wwsSubfamily' // 22\n        ]; // Parse the naming `name` table\n        // Only Windows Unicode English names are supported.\n        // Format 1 additional fields are not supported\n\n        function parseNameTable(data, start) {\n          var name = {};\n          var p = new parse.Parser(data, start);\n          name.format = p.parseUShort();\n          var count = p.parseUShort();\n          var stringOffset = p.offset + p.parseUShort();\n          var unknownCount = 0;\n\n          for (var i = 0; i < count; i++) {\n            var platformID = p.parseUShort();\n            var encodingID = p.parseUShort();\n            var languageID = p.parseUShort();\n            var nameID = p.parseUShort();\n            var property = nameTableNames[nameID];\n            var byteLength = p.parseUShort();\n            var offset = p.parseUShort(); // platformID - encodingID - languageID standard combinations :\n            // 1 - 0 - 0 : Macintosh, Roman, English\n            // 3 - 1 - 0x409 : Windows, Unicode BMP (UCS-2), en-US\n\n            if (platformID === 3 && encodingID === 1 && languageID === 0x409) {\n              var codePoints = [];\n              var length = byteLength / 2;\n\n              for (var j = 0; j < length; j++, offset += 2) {\n                codePoints[j] = parse.getShort(data, stringOffset + offset);\n              }\n\n              var str = String.fromCharCode.apply(null, codePoints);\n\n              if (property) {\n                name[property] = str;\n              } else {\n                unknownCount++;\n                name['unknown' + unknownCount] = str;\n              }\n            }\n          }\n\n          if (name.format === 1) {\n            name.langTagCount = p.parseUShort();\n          }\n\n          return name;\n        }\n\n        function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {\n          return new table.Table('NameRecord', [{\n            name: 'platformID',\n            type: 'USHORT',\n            value: platformID\n          }, {\n            name: 'encodingID',\n            type: 'USHORT',\n            value: encodingID\n          }, {\n            name: 'languageID',\n            type: 'USHORT',\n            value: languageID\n          }, {\n            name: 'nameID',\n            type: 'USHORT',\n            value: nameID\n          }, {\n            name: 'length',\n            type: 'USHORT',\n            value: length\n          }, {\n            name: 'offset',\n            type: 'USHORT',\n            value: offset\n          }]);\n        }\n\n        function addMacintoshNameRecord(t, recordID, s, offset) {\n          // Macintosh, Roman, English\n          var stringBytes = encode.STRING(s);\n          t.records.push(makeNameRecord(1, 0, 0, recordID, stringBytes.length, offset));\n          t.strings.push(stringBytes);\n          offset += stringBytes.length;\n          return offset;\n        }\n\n        function addWindowsNameRecord(t, recordID, s, offset) {\n          // Windows, Unicode BMP (UCS-2), US English\n          var utf16Bytes = encode.UTF16(s);\n          t.records.push(makeNameRecord(3, 1, 0x0409, recordID, utf16Bytes.length, offset));\n          t.strings.push(utf16Bytes);\n          offset += utf16Bytes.length;\n          return offset;\n        }\n\n        function makeNameTable(options) {\n          var t = new table.Table('name', [{\n            name: 'format',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'count',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'stringOffset',\n            type: 'USHORT',\n            value: 0\n          }]);\n          t.records = [];\n          t.strings = [];\n          var offset = 0;\n          var i;\n          var s; // Add Macintosh records first\n\n          for (i = 0; i < nameTableNames.length; i += 1) {\n            if (options[nameTableNames[i]] !== undefined) {\n              s = options[nameTableNames[i]];\n              offset = addMacintoshNameRecord(t, i, s, offset);\n            }\n          } // Then add Windows records\n\n\n          for (i = 0; i < nameTableNames.length; i += 1) {\n            if (options[nameTableNames[i]] !== undefined) {\n              s = options[nameTableNames[i]];\n              offset = addWindowsNameRecord(t, i, s, offset);\n            }\n          }\n\n          t.count = t.records.length;\n          t.stringOffset = 6 + t.count * 12;\n\n          for (i = 0; i < t.records.length; i += 1) {\n            t.fields.push({\n              name: 'record_' + i,\n              type: 'TABLE',\n              value: t.records[i]\n            });\n          }\n\n          for (i = 0; i < t.strings.length; i += 1) {\n            t.fields.push({\n              name: 'string_' + i,\n              type: 'LITERAL',\n              value: t.strings[i]\n            });\n          }\n\n          return t;\n        }\n\n        exports.parse = parseNameTable;\n        exports.make = makeNameTable;\n      }, {\n        \"../parse\": 8,\n        \"../table\": 10,\n        \"../types\": 25\n      }],\n      22: [function (require, module, exports) {\n        // The `OS/2` table contains metrics required in OpenType fonts.\n        // https://www.microsoft.com/typography/OTSPEC/os2.htm\n        'use strict';\n\n        var parse = require('../parse');\n\n        var table = require('../table');\n\n        var unicodeRanges = [{\n          begin: 0x0000,\n          end: 0x007F\n        }, // Basic Latin\n        {\n          begin: 0x0080,\n          end: 0x00FF\n        }, // Latin-1 Supplement\n        {\n          begin: 0x0100,\n          end: 0x017F\n        }, // Latin Extended-A\n        {\n          begin: 0x0180,\n          end: 0x024F\n        }, // Latin Extended-B\n        {\n          begin: 0x0250,\n          end: 0x02AF\n        }, // IPA Extensions\n        {\n          begin: 0x02B0,\n          end: 0x02FF\n        }, // Spacing Modifier Letters\n        {\n          begin: 0x0300,\n          end: 0x036F\n        }, // Combining Diacritical Marks\n        {\n          begin: 0x0370,\n          end: 0x03FF\n        }, // Greek and Coptic\n        {\n          begin: 0x2C80,\n          end: 0x2CFF\n        }, // Coptic\n        {\n          begin: 0x0400,\n          end: 0x04FF\n        }, // Cyrillic\n        {\n          begin: 0x0530,\n          end: 0x058F\n        }, // Armenian\n        {\n          begin: 0x0590,\n          end: 0x05FF\n        }, // Hebrew\n        {\n          begin: 0xA500,\n          end: 0xA63F\n        }, // Vai\n        {\n          begin: 0x0600,\n          end: 0x06FF\n        }, // Arabic\n        {\n          begin: 0x07C0,\n          end: 0x07FF\n        }, // NKo\n        {\n          begin: 0x0900,\n          end: 0x097F\n        }, // Devanagari\n        {\n          begin: 0x0980,\n          end: 0x09FF\n        }, // Bengali\n        {\n          begin: 0x0A00,\n          end: 0x0A7F\n        }, // Gurmukhi\n        {\n          begin: 0x0A80,\n          end: 0x0AFF\n        }, // Gujarati\n        {\n          begin: 0x0B00,\n          end: 0x0B7F\n        }, // Oriya\n        {\n          begin: 0x0B80,\n          end: 0x0BFF\n        }, // Tamil\n        {\n          begin: 0x0C00,\n          end: 0x0C7F\n        }, // Telugu\n        {\n          begin: 0x0C80,\n          end: 0x0CFF\n        }, // Kannada\n        {\n          begin: 0x0D00,\n          end: 0x0D7F\n        }, // Malayalam\n        {\n          begin: 0x0E00,\n          end: 0x0E7F\n        }, // Thai\n        {\n          begin: 0x0E80,\n          end: 0x0EFF\n        }, // Lao\n        {\n          begin: 0x10A0,\n          end: 0x10FF\n        }, // Georgian\n        {\n          begin: 0x1B00,\n          end: 0x1B7F\n        }, // Balinese\n        {\n          begin: 0x1100,\n          end: 0x11FF\n        }, // Hangul Jamo\n        {\n          begin: 0x1E00,\n          end: 0x1EFF\n        }, // Latin Extended Additional\n        {\n          begin: 0x1F00,\n          end: 0x1FFF\n        }, // Greek Extended\n        {\n          begin: 0x2000,\n          end: 0x206F\n        }, // General Punctuation\n        {\n          begin: 0x2070,\n          end: 0x209F\n        }, // Superscripts And Subscripts\n        {\n          begin: 0x20A0,\n          end: 0x20CF\n        }, // Currency Symbol\n        {\n          begin: 0x20D0,\n          end: 0x20FF\n        }, // Combining Diacritical Marks For Symbols\n        {\n          begin: 0x2100,\n          end: 0x214F\n        }, // Letterlike Symbols\n        {\n          begin: 0x2150,\n          end: 0x218F\n        }, // Number Forms\n        {\n          begin: 0x2190,\n          end: 0x21FF\n        }, // Arrows\n        {\n          begin: 0x2200,\n          end: 0x22FF\n        }, // Mathematical Operators\n        {\n          begin: 0x2300,\n          end: 0x23FF\n        }, // Miscellaneous Technical\n        {\n          begin: 0x2400,\n          end: 0x243F\n        }, // Control Pictures\n        {\n          begin: 0x2440,\n          end: 0x245F\n        }, // Optical Character Recognition\n        {\n          begin: 0x2460,\n          end: 0x24FF\n        }, // Enclosed Alphanumerics\n        {\n          begin: 0x2500,\n          end: 0x257F\n        }, // Box Drawing\n        {\n          begin: 0x2580,\n          end: 0x259F\n        }, // Block Elements\n        {\n          begin: 0x25A0,\n          end: 0x25FF\n        }, // Geometric Shapes\n        {\n          begin: 0x2600,\n          end: 0x26FF\n        }, // Miscellaneous Symbols\n        {\n          begin: 0x2700,\n          end: 0x27BF\n        }, // Dingbats\n        {\n          begin: 0x3000,\n          end: 0x303F\n        }, // CJK Symbols And Punctuation\n        {\n          begin: 0x3040,\n          end: 0x309F\n        }, // Hiragana\n        {\n          begin: 0x30A0,\n          end: 0x30FF\n        }, // Katakana\n        {\n          begin: 0x3100,\n          end: 0x312F\n        }, // Bopomofo\n        {\n          begin: 0x3130,\n          end: 0x318F\n        }, // Hangul Compatibility Jamo\n        {\n          begin: 0xA840,\n          end: 0xA87F\n        }, // Phags-pa\n        {\n          begin: 0x3200,\n          end: 0x32FF\n        }, // Enclosed CJK Letters And Months\n        {\n          begin: 0x3300,\n          end: 0x33FF\n        }, // CJK Compatibility\n        {\n          begin: 0xAC00,\n          end: 0xD7AF\n        }, // Hangul Syllables\n        {\n          begin: 0xD800,\n          end: 0xDFFF\n        }, // Non-Plane 0 *\n        {\n          begin: 0x10900,\n          end: 0x1091F\n        }, // Phoenicia\n        {\n          begin: 0x4E00,\n          end: 0x9FFF\n        }, // CJK Unified Ideographs\n        {\n          begin: 0xE000,\n          end: 0xF8FF\n        }, // Private Use Area (plane 0)\n        {\n          begin: 0x31C0,\n          end: 0x31EF\n        }, // CJK Strokes\n        {\n          begin: 0xFB00,\n          end: 0xFB4F\n        }, // Alphabetic Presentation Forms\n        {\n          begin: 0xFB50,\n          end: 0xFDFF\n        }, // Arabic Presentation Forms-A\n        {\n          begin: 0xFE20,\n          end: 0xFE2F\n        }, // Combining Half Marks\n        {\n          begin: 0xFE10,\n          end: 0xFE1F\n        }, // Vertical Forms\n        {\n          begin: 0xFE50,\n          end: 0xFE6F\n        }, // Small Form Variants\n        {\n          begin: 0xFE70,\n          end: 0xFEFF\n        }, // Arabic Presentation Forms-B\n        {\n          begin: 0xFF00,\n          end: 0xFFEF\n        }, // Halfwidth And Fullwidth Forms\n        {\n          begin: 0xFFF0,\n          end: 0xFFFF\n        }, // Specials\n        {\n          begin: 0x0F00,\n          end: 0x0FFF\n        }, // Tibetan\n        {\n          begin: 0x0700,\n          end: 0x074F\n        }, // Syriac\n        {\n          begin: 0x0780,\n          end: 0x07BF\n        }, // Thaana\n        {\n          begin: 0x0D80,\n          end: 0x0DFF\n        }, // Sinhala\n        {\n          begin: 0x1000,\n          end: 0x109F\n        }, // Myanmar\n        {\n          begin: 0x1200,\n          end: 0x137F\n        }, // Ethiopic\n        {\n          begin: 0x13A0,\n          end: 0x13FF\n        }, // Cherokee\n        {\n          begin: 0x1400,\n          end: 0x167F\n        }, // Unified Canadian Aboriginal Syllabics\n        {\n          begin: 0x1680,\n          end: 0x169F\n        }, // Ogham\n        {\n          begin: 0x16A0,\n          end: 0x16FF\n        }, // Runic\n        {\n          begin: 0x1780,\n          end: 0x17FF\n        }, // Khmer\n        {\n          begin: 0x1800,\n          end: 0x18AF\n        }, // Mongolian\n        {\n          begin: 0x2800,\n          end: 0x28FF\n        }, // Braille Patterns\n        {\n          begin: 0xA000,\n          end: 0xA48F\n        }, // Yi Syllables\n        {\n          begin: 0x1700,\n          end: 0x171F\n        }, // Tagalog\n        {\n          begin: 0x10300,\n          end: 0x1032F\n        }, // Old Italic\n        {\n          begin: 0x10330,\n          end: 0x1034F\n        }, // Gothic\n        {\n          begin: 0x10400,\n          end: 0x1044F\n        }, // Deseret\n        {\n          begin: 0x1D000,\n          end: 0x1D0FF\n        }, // Byzantine Musical Symbols\n        {\n          begin: 0x1D400,\n          end: 0x1D7FF\n        }, // Mathematical Alphanumeric Symbols\n        {\n          begin: 0xFF000,\n          end: 0xFFFFD\n        }, // Private Use (plane 15)\n        {\n          begin: 0xFE00,\n          end: 0xFE0F\n        }, // Variation Selectors\n        {\n          begin: 0xE0000,\n          end: 0xE007F\n        }, // Tags\n        {\n          begin: 0x1900,\n          end: 0x194F\n        }, // Limbu\n        {\n          begin: 0x1950,\n          end: 0x197F\n        }, // Tai Le\n        {\n          begin: 0x1980,\n          end: 0x19DF\n        }, // New Tai Lue\n        {\n          begin: 0x1A00,\n          end: 0x1A1F\n        }, // Buginese\n        {\n          begin: 0x2C00,\n          end: 0x2C5F\n        }, // Glagolitic\n        {\n          begin: 0x2D30,\n          end: 0x2D7F\n        }, // Tifinagh\n        {\n          begin: 0x4DC0,\n          end: 0x4DFF\n        }, // Yijing Hexagram Symbols\n        {\n          begin: 0xA800,\n          end: 0xA82F\n        }, // Syloti Nagri\n        {\n          begin: 0x10000,\n          end: 0x1007F\n        }, // Linear B Syllabary\n        {\n          begin: 0x10140,\n          end: 0x1018F\n        }, // Ancient Greek Numbers\n        {\n          begin: 0x10380,\n          end: 0x1039F\n        }, // Ugaritic\n        {\n          begin: 0x103A0,\n          end: 0x103DF\n        }, // Old Persian\n        {\n          begin: 0x10450,\n          end: 0x1047F\n        }, // Shavian\n        {\n          begin: 0x10480,\n          end: 0x104AF\n        }, // Osmanya\n        {\n          begin: 0x10800,\n          end: 0x1083F\n        }, // Cypriot Syllabary\n        {\n          begin: 0x10A00,\n          end: 0x10A5F\n        }, // Kharoshthi\n        {\n          begin: 0x1D300,\n          end: 0x1D35F\n        }, // Tai Xuan Jing Symbols\n        {\n          begin: 0x12000,\n          end: 0x123FF\n        }, // Cuneiform\n        {\n          begin: 0x1D360,\n          end: 0x1D37F\n        }, // Counting Rod Numerals\n        {\n          begin: 0x1B80,\n          end: 0x1BBF\n        }, // Sundanese\n        {\n          begin: 0x1C00,\n          end: 0x1C4F\n        }, // Lepcha\n        {\n          begin: 0x1C50,\n          end: 0x1C7F\n        }, // Ol Chiki\n        {\n          begin: 0xA880,\n          end: 0xA8DF\n        }, // Saurashtra\n        {\n          begin: 0xA900,\n          end: 0xA92F\n        }, // Kayah Li\n        {\n          begin: 0xA930,\n          end: 0xA95F\n        }, // Rejang\n        {\n          begin: 0xAA00,\n          end: 0xAA5F\n        }, // Cham\n        {\n          begin: 0x10190,\n          end: 0x101CF\n        }, // Ancient Symbols\n        {\n          begin: 0x101D0,\n          end: 0x101FF\n        }, // Phaistos Disc\n        {\n          begin: 0x102A0,\n          end: 0x102DF\n        }, // Carian\n        {\n          begin: 0x1F030,\n          end: 0x1F09F\n        } // Domino Tiles\n        ];\n\n        function getUnicodeRange(unicode) {\n          for (var i = 0; i < unicodeRanges.length; i += 1) {\n            var range = unicodeRanges[i];\n\n            if (unicode >= range.begin && unicode < range.end) {\n              return i;\n            }\n          }\n\n          return -1;\n        } // Parse the OS/2 and Windows metrics `OS/2` table\n\n\n        function parseOS2Table(data, start) {\n          var os2 = {};\n          var p = new parse.Parser(data, start);\n          os2.version = p.parseUShort();\n          os2.xAvgCharWidth = p.parseShort();\n          os2.usWeightClass = p.parseUShort();\n          os2.usWidthClass = p.parseUShort();\n          os2.fsType = p.parseUShort();\n          os2.ySubscriptXSize = p.parseShort();\n          os2.ySubscriptYSize = p.parseShort();\n          os2.ySubscriptXOffset = p.parseShort();\n          os2.ySubscriptYOffset = p.parseShort();\n          os2.ySuperscriptXSize = p.parseShort();\n          os2.ySuperscriptYSize = p.parseShort();\n          os2.ySuperscriptXOffset = p.parseShort();\n          os2.ySuperscriptYOffset = p.parseShort();\n          os2.yStrikeoutSize = p.parseShort();\n          os2.yStrikeoutPosition = p.parseShort();\n          os2.sFamilyClass = p.parseShort();\n          os2.panose = [];\n\n          for (var i = 0; i < 10; i++) {\n            os2.panose[i] = p.parseByte();\n          }\n\n          os2.ulUnicodeRange1 = p.parseULong();\n          os2.ulUnicodeRange2 = p.parseULong();\n          os2.ulUnicodeRange3 = p.parseULong();\n          os2.ulUnicodeRange4 = p.parseULong();\n          os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());\n          os2.fsSelection = p.parseUShort();\n          os2.usFirstCharIndex = p.parseUShort();\n          os2.usLastCharIndex = p.parseUShort();\n          os2.sTypoAscender = p.parseShort();\n          os2.sTypoDescender = p.parseShort();\n          os2.sTypoLineGap = p.parseShort();\n          os2.usWinAscent = p.parseUShort();\n          os2.usWinDescent = p.parseUShort();\n\n          if (os2.version >= 1) {\n            os2.ulCodePageRange1 = p.parseULong();\n            os2.ulCodePageRange2 = p.parseULong();\n          }\n\n          if (os2.version >= 2) {\n            os2.sxHeight = p.parseShort();\n            os2.sCapHeight = p.parseShort();\n            os2.usDefaultChar = p.parseUShort();\n            os2.usBreakChar = p.parseUShort();\n            os2.usMaxContent = p.parseUShort();\n          }\n\n          return os2;\n        }\n\n        function makeOS2Table(options) {\n          return new table.Table('OS/2', [{\n            name: 'version',\n            type: 'USHORT',\n            value: 0x0003\n          }, {\n            name: 'xAvgCharWidth',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'usWeightClass',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'usWidthClass',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'fsType',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'ySubscriptXSize',\n            type: 'SHORT',\n            value: 650\n          }, {\n            name: 'ySubscriptYSize',\n            type: 'SHORT',\n            value: 699\n          }, {\n            name: 'ySubscriptXOffset',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'ySubscriptYOffset',\n            type: 'SHORT',\n            value: 140\n          }, {\n            name: 'ySuperscriptXSize',\n            type: 'SHORT',\n            value: 650\n          }, {\n            name: 'ySuperscriptYSize',\n            type: 'SHORT',\n            value: 699\n          }, {\n            name: 'ySuperscriptXOffset',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'ySuperscriptYOffset',\n            type: 'SHORT',\n            value: 479\n          }, {\n            name: 'yStrikeoutSize',\n            type: 'SHORT',\n            value: 49\n          }, {\n            name: 'yStrikeoutPosition',\n            type: 'SHORT',\n            value: 258\n          }, {\n            name: 'sFamilyClass',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'bFamilyType',\n            type: 'BYTE',\n            value: 0\n          }, {\n            name: 'bSerifStyle',\n            type: 'BYTE',\n            value: 0\n          }, {\n            name: 'bWeight',\n            type: 'BYTE',\n            value: 0\n          }, {\n            name: 'bProportion',\n            type: 'BYTE',\n            value: 0\n          }, {\n            name: 'bContrast',\n            type: 'BYTE',\n            value: 0\n          }, {\n            name: 'bStrokeVariation',\n            type: 'BYTE',\n            value: 0\n          }, {\n            name: 'bArmStyle',\n            type: 'BYTE',\n            value: 0\n          }, {\n            name: 'bLetterform',\n            type: 'BYTE',\n            value: 0\n          }, {\n            name: 'bMidline',\n            type: 'BYTE',\n            value: 0\n          }, {\n            name: 'bXHeight',\n            type: 'BYTE',\n            value: 0\n          }, {\n            name: 'ulUnicodeRange1',\n            type: 'ULONG',\n            value: 0\n          }, {\n            name: 'ulUnicodeRange2',\n            type: 'ULONG',\n            value: 0\n          }, {\n            name: 'ulUnicodeRange3',\n            type: 'ULONG',\n            value: 0\n          }, {\n            name: 'ulUnicodeRange4',\n            type: 'ULONG',\n            value: 0\n          }, {\n            name: 'achVendID',\n            type: 'CHARARRAY',\n            value: 'XXXX'\n          }, {\n            name: 'fsSelection',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'usFirstCharIndex',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'usLastCharIndex',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'sTypoAscender',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'sTypoDescender',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'sTypoLineGap',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'usWinAscent',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'usWinDescent',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'ulCodePageRange1',\n            type: 'ULONG',\n            value: 0\n          }, {\n            name: 'ulCodePageRange2',\n            type: 'ULONG',\n            value: 0\n          }, {\n            name: 'sxHeight',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'sCapHeight',\n            type: 'SHORT',\n            value: 0\n          }, {\n            name: 'usDefaultChar',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'usBreakChar',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'usMaxContext',\n            type: 'USHORT',\n            value: 0\n          }], options);\n        }\n\n        exports.unicodeRanges = unicodeRanges;\n        exports.getUnicodeRange = getUnicodeRange;\n        exports.parse = parseOS2Table;\n        exports.make = makeOS2Table;\n      }, {\n        \"../parse\": 8,\n        \"../table\": 10\n      }],\n      23: [function (require, module, exports) {\n        // The `post` table stores additional PostScript information, such as glyph names.\n        // https://www.microsoft.com/typography/OTSPEC/post.htm\n        'use strict';\n\n        var encoding = require('../encoding');\n\n        var parse = require('../parse');\n\n        var table = require('../table'); // Parse the PostScript `post` table\n\n\n        function parsePostTable(data, start) {\n          var post = {};\n          var p = new parse.Parser(data, start);\n          var i;\n          post.version = p.parseVersion();\n          post.italicAngle = p.parseFixed();\n          post.underlinePosition = p.parseShort();\n          post.underlineThickness = p.parseShort();\n          post.isFixedPitch = p.parseULong();\n          post.minMemType42 = p.parseULong();\n          post.maxMemType42 = p.parseULong();\n          post.minMemType1 = p.parseULong();\n          post.maxMemType1 = p.parseULong();\n\n          switch (post.version) {\n            case 1:\n              post.names = encoding.standardNames.slice();\n              break;\n\n            case 2:\n              post.numberOfGlyphs = p.parseUShort();\n              post.glyphNameIndex = new Array(post.numberOfGlyphs);\n\n              for (i = 0; i < post.numberOfGlyphs; i++) {\n                post.glyphNameIndex[i] = p.parseUShort();\n              }\n\n              post.names = [];\n\n              for (i = 0; i < post.numberOfGlyphs; i++) {\n                if (post.glyphNameIndex[i] >= encoding.standardNames.length) {\n                  var nameLength = p.parseChar();\n                  post.names.push(p.parseString(nameLength));\n                }\n              }\n\n              break;\n\n            case 2.5:\n              post.numberOfGlyphs = p.parseUShort();\n              post.offset = new Array(post.numberOfGlyphs);\n\n              for (i = 0; i < post.numberOfGlyphs; i++) {\n                post.offset[i] = p.parseChar();\n              }\n\n              break;\n          }\n\n          return post;\n        }\n\n        function makePostTable() {\n          return new table.Table('post', [{\n            name: 'version',\n            type: 'FIXED',\n            value: 0x00030000\n          }, {\n            name: 'italicAngle',\n            type: 'FIXED',\n            value: 0\n          }, {\n            name: 'underlinePosition',\n            type: 'FWORD',\n            value: 0\n          }, {\n            name: 'underlineThickness',\n            type: 'FWORD',\n            value: 0\n          }, {\n            name: 'isFixedPitch',\n            type: 'ULONG',\n            value: 0\n          }, {\n            name: 'minMemType42',\n            type: 'ULONG',\n            value: 0\n          }, {\n            name: 'maxMemType42',\n            type: 'ULONG',\n            value: 0\n          }, {\n            name: 'minMemType1',\n            type: 'ULONG',\n            value: 0\n          }, {\n            name: 'maxMemType1',\n            type: 'ULONG',\n            value: 0\n          }]);\n        }\n\n        exports.parse = parsePostTable;\n        exports.make = makePostTable;\n      }, {\n        \"../encoding\": 3,\n        \"../parse\": 8,\n        \"../table\": 10\n      }],\n      24: [function (require, module, exports) {\n        // The `sfnt` wrapper provides organization for the tables in the font.\n        // It is the top-level data structure in a font.\n        // https://www.microsoft.com/typography/OTSPEC/otff.htm\n        // Recommendations for creating OpenType Fonts:\n        // http://www.microsoft.com/typography/otspec140/recom.htm\n        'use strict';\n\n        var check = require('../check');\n\n        var table = require('../table');\n\n        var cmap = require('./cmap');\n\n        var cff = require('./cff');\n\n        var head = require('./head');\n\n        var hhea = require('./hhea');\n\n        var hmtx = require('./hmtx');\n\n        var maxp = require('./maxp');\n\n        var _name = require('./name');\n\n        var os2 = require('./os2');\n\n        var post = require('./post');\n\n        function log2(v) {\n          return Math.log(v) / Math.log(2) | 0;\n        }\n\n        function computeCheckSum(bytes) {\n          while (bytes.length % 4 !== 0) {\n            bytes.push(0);\n          }\n\n          var sum = 0;\n\n          for (var i = 0; i < bytes.length; i += 4) {\n            sum += (bytes[i] << 24) + (bytes[i + 1] << 16) + (bytes[i + 2] << 8) + bytes[i + 3];\n          }\n\n          sum %= Math.pow(2, 32);\n          return sum;\n        }\n\n        function makeTableRecord(tag, checkSum, offset, length) {\n          return new table.Table('Table Record', [{\n            name: 'tag',\n            type: 'TAG',\n            value: tag !== undefined ? tag : ''\n          }, {\n            name: 'checkSum',\n            type: 'ULONG',\n            value: checkSum !== undefined ? checkSum : 0\n          }, {\n            name: 'offset',\n            type: 'ULONG',\n            value: offset !== undefined ? offset : 0\n          }, {\n            name: 'length',\n            type: 'ULONG',\n            value: length !== undefined ? length : 0\n          }]);\n        }\n\n        function makeSfntTable(tables) {\n          var sfnt = new table.Table('sfnt', [{\n            name: 'version',\n            type: 'TAG',\n            value: 'OTTO'\n          }, {\n            name: 'numTables',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'searchRange',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'entrySelector',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'rangeShift',\n            type: 'USHORT',\n            value: 0\n          }]);\n          sfnt.tables = tables;\n          sfnt.numTables = tables.length;\n          var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));\n          sfnt.searchRange = 16 * highestPowerOf2;\n          sfnt.entrySelector = log2(highestPowerOf2);\n          sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;\n          var recordFields = [];\n          var tableFields = [];\n          var offset = sfnt.sizeOf() + makeTableRecord().sizeOf() * sfnt.numTables;\n\n          while (offset % 4 !== 0) {\n            offset += 1;\n            tableFields.push({\n              name: 'padding',\n              type: 'BYTE',\n              value: 0\n            });\n          }\n\n          for (var i = 0; i < tables.length; i += 1) {\n            var t = tables[i];\n            check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');\n            var tableLength = t.sizeOf();\n            var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);\n            recordFields.push({\n              name: tableRecord.tag + ' Table Record',\n              type: 'TABLE',\n              value: tableRecord\n            });\n            tableFields.push({\n              name: t.tableName + ' table',\n              type: 'TABLE',\n              value: t\n            });\n            offset += tableLength;\n            check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');\n\n            while (offset % 4 !== 0) {\n              offset += 1;\n              tableFields.push({\n                name: 'padding',\n                type: 'BYTE',\n                value: 0\n              });\n            }\n          } // Table records need to be sorted alphabetically.\n\n\n          recordFields.sort(function (r1, r2) {\n            if (r1.value.tag > r2.value.tag) {\n              return 1;\n            } else {\n              return -1;\n            }\n          });\n          sfnt.fields = sfnt.fields.concat(recordFields);\n          sfnt.fields = sfnt.fields.concat(tableFields);\n          return sfnt;\n        } // Get the metrics for a character. If the string has more than one character\n        // this function returns metrics for the first available character.\n        // You can provide optional fallback metrics if no characters are available.\n\n\n        function metricsForChar(font, chars, notFoundMetrics) {\n          for (var i = 0; i < chars.length; i += 1) {\n            var glyphIndex = font.charToGlyphIndex(chars[i]);\n\n            if (glyphIndex > 0) {\n              var glyph = font.glyphs.get(glyphIndex);\n              return glyph.getMetrics();\n            }\n          }\n\n          return notFoundMetrics;\n        }\n\n        function average(vs) {\n          var sum = 0;\n\n          for (var i = 0; i < vs.length; i += 1) {\n            sum += vs[i];\n          }\n\n          return sum / vs.length;\n        } // Convert the font object to a SFNT data structure.\n        // This structure contains all the necessary tables and metadata to create a binary OTF file.\n\n\n        function fontToSfntTable(font) {\n          var xMins = [];\n          var yMins = [];\n          var xMaxs = [];\n          var yMaxs = [];\n          var advanceWidths = [];\n          var leftSideBearings = [];\n          var rightSideBearings = [];\n          var firstCharIndex;\n          var lastCharIndex = 0;\n          var ulUnicodeRange1 = 0;\n          var ulUnicodeRange2 = 0;\n          var ulUnicodeRange3 = 0;\n          var ulUnicodeRange4 = 0;\n\n          for (var i = 0; i < font.glyphs.length; i += 1) {\n            var glyph = font.glyphs.get(i);\n            var unicode = glyph.unicode | 0;\n\n            if (firstCharIndex > unicode || firstCharIndex === null) {\n              firstCharIndex = unicode;\n            }\n\n            if (lastCharIndex < unicode) {\n              lastCharIndex = unicode;\n            }\n\n            var position = os2.getUnicodeRange(unicode);\n\n            if (position < 32) {\n              ulUnicodeRange1 |= 1 << position;\n            } else if (position < 64) {\n              ulUnicodeRange2 |= 1 << position - 32;\n            } else if (position < 96) {\n              ulUnicodeRange3 |= 1 << position - 64;\n            } else if (position < 123) {\n              ulUnicodeRange4 |= 1 << position - 96;\n            } else {\n              throw new Error('Unicode ranges bits > 123 are reserved for internal usage');\n            } // Skip non-important characters.\n\n\n            if (glyph.name === '.notdef') continue;\n            var metrics = glyph.getMetrics();\n            xMins.push(metrics.xMin);\n            yMins.push(metrics.yMin);\n            xMaxs.push(metrics.xMax);\n            yMaxs.push(metrics.yMax);\n            leftSideBearings.push(metrics.leftSideBearing);\n            rightSideBearings.push(metrics.rightSideBearing);\n            advanceWidths.push(glyph.advanceWidth);\n          }\n\n          var globals = {\n            xMin: Math.min.apply(null, xMins),\n            yMin: Math.min.apply(null, yMins),\n            xMax: Math.max.apply(null, xMaxs),\n            yMax: Math.max.apply(null, yMaxs),\n            advanceWidthMax: Math.max.apply(null, advanceWidths),\n            advanceWidthAvg: average(advanceWidths),\n            minLeftSideBearing: Math.min.apply(null, leftSideBearings),\n            maxLeftSideBearing: Math.max.apply(null, leftSideBearings),\n            minRightSideBearing: Math.min.apply(null, rightSideBearings)\n          };\n          globals.ascender = font.ascender !== undefined ? font.ascender : globals.yMax;\n          globals.descender = font.descender !== undefined ? font.descender : globals.yMin;\n          var headTable = head.make({\n            unitsPerEm: font.unitsPerEm,\n            xMin: globals.xMin,\n            yMin: globals.yMin,\n            xMax: globals.xMax,\n            yMax: globals.yMax\n          });\n          var hheaTable = hhea.make({\n            ascender: globals.ascender,\n            descender: globals.descender,\n            advanceWidthMax: globals.advanceWidthMax,\n            minLeftSideBearing: globals.minLeftSideBearing,\n            minRightSideBearing: globals.minRightSideBearing,\n            xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),\n            numberOfHMetrics: font.glyphs.length\n          });\n          var maxpTable = maxp.make(font.glyphs.length);\n          var os2Table = os2.make({\n            xAvgCharWidth: Math.round(globals.advanceWidthAvg),\n            usWeightClass: 500,\n            // Medium FIXME Make this configurable\n            usWidthClass: 5,\n            // Medium (normal) FIXME Make this configurable\n            usFirstCharIndex: firstCharIndex,\n            usLastCharIndex: lastCharIndex,\n            ulUnicodeRange1: ulUnicodeRange1,\n            ulUnicodeRange2: ulUnicodeRange2,\n            ulUnicodeRange3: ulUnicodeRange3,\n            ulUnicodeRange4: ulUnicodeRange4,\n            // See http://typophile.com/node/13081 for more info on vertical metrics.\n            // We get metrics for typical characters (such as \"x\" for xHeight).\n            // We provide some fallback characters if characters are unavailable: their\n            // ordering was chosen experimentally.\n            sTypoAscender: globals.ascender,\n            sTypoDescender: globals.descender,\n            sTypoLineGap: 0,\n            usWinAscent: globals.ascender,\n            usWinDescent: -globals.descender,\n            sxHeight: metricsForChar(font, 'xyvw', {\n              yMax: 0\n            }).yMax,\n            sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,\n            usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.\n\n          });\n          var hmtxTable = hmtx.make(font.glyphs);\n          var cmapTable = cmap.make(font.glyphs);\n          var fullName = font.familyName + ' ' + font.styleName;\n          var postScriptName = font.familyName.replace(/\\s/g, '') + '-' + font.styleName;\n\n          var nameTable = _name.make({\n            copyright: font.copyright,\n            fontFamily: font.familyName,\n            fontSubfamily: font.styleName,\n            uniqueID: font.manufacturer + ':' + fullName,\n            fullName: fullName,\n            version: font.version,\n            postScriptName: postScriptName,\n            trademark: font.trademark,\n            manufacturer: font.manufacturer,\n            designer: font.designer,\n            description: font.description,\n            manufacturerURL: font.manufacturerURL,\n            designerURL: font.designerURL,\n            license: font.license,\n            licenseURL: font.licenseURL,\n            preferredFamily: font.familyName,\n            preferredSubfamily: font.styleName\n          });\n\n          var postTable = post.make();\n          var cffTable = cff.make(font.glyphs, {\n            version: font.version,\n            fullName: fullName,\n            familyName: font.familyName,\n            weightName: font.styleName,\n            postScriptName: postScriptName,\n            unitsPerEm: font.unitsPerEm\n          }); // Order the tables according to the the OpenType specification 1.4.\n\n          var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];\n          var sfntTable = makeSfntTable(tables); // Compute the font's checkSum and store it in head.checkSumAdjustment.\n\n          var bytes = sfntTable.encode();\n          var checkSum = computeCheckSum(bytes);\n          var tableFields = sfntTable.fields;\n          var checkSumAdjusted = false;\n\n          for (i = 0; i < tableFields.length; i += 1) {\n            if (tableFields[i].name === 'head table') {\n              tableFields[i].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;\n              checkSumAdjusted = true;\n              break;\n            }\n          }\n\n          if (!checkSumAdjusted) {\n            throw new Error('Could not find head table with checkSum to adjust.');\n          }\n\n          return sfntTable;\n        }\n\n        exports.computeCheckSum = computeCheckSum;\n        exports.make = makeSfntTable;\n        exports.fontToTable = fontToSfntTable;\n      }, {\n        \"../check\": 1,\n        \"../table\": 10,\n        \"./cff\": 11,\n        \"./cmap\": 12,\n        \"./head\": 15,\n        \"./hhea\": 16,\n        \"./hmtx\": 17,\n        \"./maxp\": 20,\n        \"./name\": 21,\n        \"./os2\": 22,\n        \"./post\": 23\n      }],\n      25: [function (require, module, exports) {\n        // Data types used in the OpenType font file.\n        // All OpenType fonts use Motorola-style byte ordering (Big Endian)\n\n        /* global WeakMap */\n        'use strict';\n\n        var check = require('./check');\n\n        var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15\n\n        var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31\n\n        var decode = {};\n        var encode = {};\n        var sizeOf = {}; // Return a function that always returns the same value.\n\n        function constant(v) {\n          return function () {\n            return v;\n          };\n        } // OpenType data types //////////////////////////////////////////////////////\n        // Convert an 8-bit unsigned integer to a list of 1 byte.\n\n\n        encode.BYTE = function (v) {\n          check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');\n          return [v];\n        };\n\n        sizeOf.BYTE = constant(1); // Convert a 8-bit signed integer to a list of 1 byte.\n\n        encode.CHAR = function (v) {\n          return [v.charCodeAt(0)];\n        };\n\n        sizeOf.CHAR = constant(1); // Convert an ASCII string to a list of bytes.\n\n        encode.CHARARRAY = function (v) {\n          var b = [];\n\n          for (var i = 0; i < v.length; i += 1) {\n            b.push(v.charCodeAt(i));\n          }\n\n          return b;\n        };\n\n        sizeOf.CHARARRAY = function (v) {\n          return v.length;\n        }; // Convert a 16-bit unsigned integer to a list of 2 bytes.\n\n\n        encode.USHORT = function (v) {\n          return [v >> 8 & 0xFF, v & 0xFF];\n        };\n\n        sizeOf.USHORT = constant(2); // Convert a 16-bit signed integer to a list of 2 bytes.\n\n        encode.SHORT = function (v) {\n          // Two's complement\n          if (v >= LIMIT16) {\n            v = -(2 * LIMIT16 - v);\n          }\n\n          return [v >> 8 & 0xFF, v & 0xFF];\n        };\n\n        sizeOf.SHORT = constant(2); // Convert a 24-bit unsigned integer to a list of 3 bytes.\n\n        encode.UINT24 = function (v) {\n          return [v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];\n        };\n\n        sizeOf.UINT24 = constant(3); // Convert a 32-bit unsigned integer to a list of 4 bytes.\n\n        encode.ULONG = function (v) {\n          return [v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];\n        };\n\n        sizeOf.ULONG = constant(4); // Convert a 32-bit unsigned integer to a list of 4 bytes.\n\n        encode.LONG = function (v) {\n          // Two's complement\n          if (v >= LIMIT32) {\n            v = -(2 * LIMIT32 - v);\n          }\n\n          return [v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];\n        };\n\n        sizeOf.LONG = constant(4);\n        encode.FIXED = encode.ULONG;\n        sizeOf.FIXED = sizeOf.ULONG;\n        encode.FWORD = encode.SHORT;\n        sizeOf.FWORD = sizeOf.SHORT;\n        encode.UFWORD = encode.USHORT;\n        sizeOf.UFWORD = sizeOf.USHORT; // FIXME Implement LONGDATETIME\n\n        encode.LONGDATETIME = function () {\n          return [0, 0, 0, 0, 0, 0, 0, 0];\n        };\n\n        sizeOf.LONGDATETIME = constant(8); // Convert a 4-char tag to a list of 4 bytes.\n\n        encode.TAG = function (v) {\n          check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');\n          return [v.charCodeAt(0), v.charCodeAt(1), v.charCodeAt(2), v.charCodeAt(3)];\n        };\n\n        sizeOf.TAG = constant(4); // CFF data types ///////////////////////////////////////////////////////////\n\n        encode.Card8 = encode.BYTE;\n        sizeOf.Card8 = sizeOf.BYTE;\n        encode.Card16 = encode.USHORT;\n        sizeOf.Card16 = sizeOf.USHORT;\n        encode.OffSize = encode.BYTE;\n        sizeOf.OffSize = sizeOf.BYTE;\n        encode.SID = encode.USHORT;\n        sizeOf.SID = sizeOf.USHORT; // Convert a numeric operand or charstring number to a variable-size list of bytes.\n\n        encode.NUMBER = function (v) {\n          if (v >= -107 && v <= 107) {\n            return [v + 139];\n          } else if (v >= 108 && v <= 1131) {\n            v = v - 108;\n            return [(v >> 8) + 247, v & 0xFF];\n          } else if (v >= -1131 && v <= -108) {\n            v = -v - 108;\n            return [(v >> 8) + 251, v & 0xFF];\n          } else if (v >= -32768 && v <= 32767) {\n            return encode.NUMBER16(v);\n          } else {\n            return encode.NUMBER32(v);\n          }\n        };\n\n        sizeOf.NUMBER = function (v) {\n          return encode.NUMBER(v).length;\n        }; // Convert a signed number between -32768 and +32767 to a three-byte value.\n        // This ensures we always use three bytes, but is not the most compact format.\n\n\n        encode.NUMBER16 = function (v) {\n          return [28, v >> 8 & 0xFF, v & 0xFF];\n        };\n\n        sizeOf.NUMBER16 = constant(3); // Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.\n        // This is useful if you want to be sure you always use four bytes,\n        // at the expense of wasting a few bytes for smaller numbers.\n\n        encode.NUMBER32 = function (v) {\n          return [29, v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];\n        };\n\n        sizeOf.NUMBER32 = constant(5);\n\n        encode.REAL = function (v) {\n          var value = v.toString(); // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)\n          // This code converts it back to a number without the epsilon.\n\n          var m = /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/.exec(value);\n\n          if (m) {\n            var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));\n            value = (Math.round(v * epsilon) / epsilon).toString();\n          }\n\n          var nibbles = '';\n          var i;\n          var ii;\n\n          for (i = 0, ii = value.length; i < ii; i += 1) {\n            var c = value[i];\n\n            if (c === 'e') {\n              nibbles += value[++i] === '-' ? 'c' : 'b';\n            } else if (c === '.') {\n              nibbles += 'a';\n            } else if (c === '-') {\n              nibbles += 'e';\n            } else {\n              nibbles += c;\n            }\n          }\n\n          nibbles += nibbles.length & 1 ? 'f' : 'ff';\n          var out = [30];\n\n          for (i = 0, ii = nibbles.length; i < ii; i += 2) {\n            out.push(parseInt(nibbles.substr(i, 2), 16));\n          }\n\n          return out;\n        };\n\n        sizeOf.REAL = function (v) {\n          return encode.REAL(v).length;\n        };\n\n        encode.NAME = encode.CHARARRAY;\n        sizeOf.NAME = sizeOf.CHARARRAY;\n        encode.STRING = encode.CHARARRAY;\n        sizeOf.STRING = sizeOf.CHARARRAY; // Convert a JavaScript string to UTF16-BE.\n\n        encode.UTF16 = function (v) {\n          var b = [];\n\n          for (var i = 0; i < v.length; i += 1) {\n            var codepoint = v.charCodeAt(i);\n            b.push(codepoint >> 8 & 0xFF);\n            b.push(codepoint & 0xFF);\n          }\n\n          return b;\n        };\n\n        sizeOf.UTF16 = function (v) {\n          return v.length * 2;\n        }; // Convert a list of values to a CFF INDEX structure.\n        // The values should be objects containing name / type / value.\n\n\n        encode.INDEX = function (l) {\n          var i; //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,\n          //    dataSize, i, v;\n          // Because we have to know which data type to use to encode the offsets,\n          // we have to go through the values twice: once to encode the data and\n          // calculate the offets, then again to encode the offsets using the fitting data type.\n\n          var offset = 1; // First offset is always 1.\n\n          var offsets = [offset];\n          var data = [];\n          var dataSize = 0;\n\n          for (i = 0; i < l.length; i += 1) {\n            var v = encode.OBJECT(l[i]);\n            Array.prototype.push.apply(data, v);\n            dataSize += v.length;\n            offset += v.length;\n            offsets.push(offset);\n          }\n\n          if (data.length === 0) {\n            return [0, 0];\n          }\n\n          var encodedOffsets = [];\n          var offSize = 1 + Math.floor(Math.log(dataSize) / Math.log(2)) / 8 | 0;\n          var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];\n\n          for (i = 0; i < offsets.length; i += 1) {\n            var encodedOffset = offsetEncoder(offsets[i]);\n            Array.prototype.push.apply(encodedOffsets, encodedOffset);\n          }\n\n          return Array.prototype.concat(encode.Card16(l.length), encode.OffSize(offSize), encodedOffsets, data);\n        };\n\n        sizeOf.INDEX = function (v) {\n          return encode.INDEX(v).length;\n        }; // Convert an object to a CFF DICT structure.\n        // The keys should be numeric.\n        // The values should be objects containing name / type / value.\n\n\n        encode.DICT = function (m) {\n          var d = [];\n          var keys = Object.keys(m);\n          var length = keys.length;\n\n          for (var i = 0; i < length; i += 1) {\n            // Object.keys() return string keys, but our keys are always numeric.\n            var k = parseInt(keys[i], 0);\n            var v = m[k]; // Value comes before the key.\n\n            d = d.concat(encode.OPERAND(v.value, v.type));\n            d = d.concat(encode.OPERATOR(k));\n          }\n\n          return d;\n        };\n\n        sizeOf.DICT = function (m) {\n          return encode.DICT(m).length;\n        };\n\n        encode.OPERATOR = function (v) {\n          if (v < 1200) {\n            return [v];\n          } else {\n            return [12, v - 1200];\n          }\n        };\n\n        encode.OPERAND = function (v, type) {\n          var d = [];\n\n          if (Array.isArray(type)) {\n            for (var i = 0; i < type.length; i += 1) {\n              check.argument(v.length === type.length, 'Not enough arguments given for type' + type);\n              d = d.concat(encode.OPERAND(v[i], type[i]));\n            }\n          } else {\n            if (type === 'SID') {\n              d = d.concat(encode.NUMBER(v));\n            } else if (type === 'offset') {\n              // We make it easy for ourselves and always encode offsets as\n              // 4 bytes. This makes offset calculation for the top dict easier.\n              d = d.concat(encode.NUMBER32(v));\n            } else if (type === 'number') {\n              d = d.concat(encode.NUMBER(v));\n            } else if (type === 'real') {\n              d = d.concat(encode.REAL(v));\n            } else {\n              throw new Error('Unknown operand type ' + type); // FIXME Add support for booleans\n            }\n          }\n\n          return d;\n        };\n\n        encode.OP = encode.BYTE;\n        sizeOf.OP = sizeOf.BYTE; // memoize charstring encoding using WeakMap if available\n\n        var wmm = typeof WeakMap === 'function' && new WeakMap(); // Convert a list of CharString operations to bytes.\n\n        encode.CHARSTRING = function (ops) {\n          if (wmm && wmm.has(ops)) {\n            return wmm.get(ops);\n          }\n\n          var d = [];\n          var length = ops.length;\n\n          for (var i = 0; i < length; i += 1) {\n            var op = ops[i];\n            d = d.concat(encode[op.type](op.value));\n          }\n\n          if (wmm) {\n            wmm.set(ops, d);\n          }\n\n          return d;\n        };\n\n        sizeOf.CHARSTRING = function (ops) {\n          return encode.CHARSTRING(ops).length;\n        }; // Utility functions ////////////////////////////////////////////////////////\n        // Convert an object containing name / type / value to bytes.\n\n\n        encode.OBJECT = function (v) {\n          var encodingFunction = encode[v.type];\n          check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);\n          return encodingFunction(v.value);\n        };\n\n        sizeOf.OBJECT = function (v) {\n          var sizeOfFunction = sizeOf[v.type];\n          check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);\n          return sizeOfFunction(v.value);\n        }; // Convert a table object to bytes.\n        // A table contains a list of fields containing the metadata (name, type and default value).\n        // The table itself has the field values set as attributes.\n\n\n        encode.TABLE = function (table) {\n          var d = [];\n          var length = table.fields.length;\n\n          for (var i = 0; i < length; i += 1) {\n            var field = table.fields[i];\n            var encodingFunction = encode[field.type];\n            check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type);\n            var value = table[field.name];\n\n            if (value === undefined) {\n              value = field.value;\n            }\n\n            var bytes = encodingFunction(value);\n            d = d.concat(bytes);\n          }\n\n          return d;\n        };\n\n        sizeOf.TABLE = function (table) {\n          var numBytes = 0;\n          var length = table.fields.length;\n\n          for (var i = 0; i < length; i += 1) {\n            var field = table.fields[i];\n            var sizeOfFunction = sizeOf[field.type];\n            check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type);\n            var value = table[field.name];\n\n            if (value === undefined) {\n              value = field.value;\n            }\n\n            numBytes += sizeOfFunction(value);\n          }\n\n          return numBytes;\n        }; // Merge in a list of bytes.\n\n\n        encode.LITERAL = function (v) {\n          return v;\n        };\n\n        sizeOf.LITERAL = function (v) {\n          return v.length;\n        };\n\n        exports.decode = decode;\n        exports.encode = encode;\n        exports.sizeOf = sizeOf;\n      }, {\n        \"./check\": 1\n      }]\n    }, {}, [7])(7);\n  });\n}.call(this, module);","map":{"version":3,"sources":["client/external/opentype/0.4.10/opentype.js"],"names":["_typeof","module1","link","default","v","f","exports","module","define","amd","g","window","global","self","opentype","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","argument","predicate","message","assert","line","ctx","x1","y1","x2","y2","beginPath","moveTo","lineTo","stroke","cffStandardStrings","cffStandardEncoding","cffExpertEncoding","standardNames","DefaultEncoding","font","prototype","charToGlyphIndex","c","charCodeAt","glyphs","glyph","get","j","unicodes","CmapEncoding","cmap","glyphIndexMap","CffEncoding","encoding","charset","charName","indexOf","GlyphNames","post","version","names","slice","Array","numberOfGlyphs","glyphNameIndex","nameToGlyphIndex","name","glyphIndexToName","gid","addGlyphNames","tables","charCodes","Object","keys","glyphIndex","addUnicode","parseInt","cffEncoding","glyphNames","path","sfnt","glyphset","Font","options","familyName","styleName","designer","designerURL","manufacturer","manufacturerURL","license","licenseURL","description","copyright","trademark","unitsPerEm","ascender","descender","supported","GlyphSet","hasChar","charToGlyph","stringToGlyphs","push","nameToGlyph","nametoGlyphIndex","getKerningValue","leftGlyph","rightGlyph","index","gposKerning","getGposKerningValue","kerningPairs","forEachGlyph","text","x","y","fontSize","callback","undefined","kerning","fontScale","advanceWidth","kerningValue","getPath","fullPath","Path","gX","gY","gFontSize","glyphPath","extend","draw","drawPoints","drawMetrics","validate","warnings","_this","assertStringAttribute","attrName","trim","toTables","fontToTable","toBuffer","sfntTable","bytes","encode","buffer","ArrayBuffer","intArray","Uint8Array","download","fileName","replace","requestFileSystem","webkitRequestFileSystem","TEMPORARY","byteLength","fs","root","getFile","create","fileEntry","createWriter","writer","dataView","DataView","blob","Blob","type","write","addEventListener","location","href","toURL","err","check","getPathDefinition","_path","commands","configurable","set","p","Glyph","bindConstructorValues","unicode","xMin","yMin","xMax","yMax","defineProperty","scale","cmd","quadraticCurveTo","curveTo","closePath","getContours","points","contours","currentContour","pt","lastPointOfContour","getMetrics","xCoords","yCoords","metrics","Math","min","apply","max","leftSideBearing","rightSideBearing","drawCircles","PI_SQ","PI","arc","fill","blueCircles","redCircles","fillStyle","lineWidth","strokeStyle","_glyph","isArray","loader","glyphLoader","ttfGlyphLoader","parseGlyph","data","position","buildPath","cffGlyphLoader","parseCFFCharstring","charstring","_font","parse","cff","glyf","gpos","head","hhea","hmtx","kern","loca","maxp","_name","os2","toArrayBuffer","arrayBuffer","loadFromFile","readFile","loadFromUrl","url","request","XMLHttpRequest","open","responseType","onload","status","statusText","response","send","parseBuffer","indexToLocFormat","hmtxOffset","glyfOffset","locaOffset","cffOffset","kernOffset","gposOffset","getFixed","outlinesFormat","getTag","numTables","getUShort","tag","offset","getULong","numberOfHMetrics","numGlyphs","fontFamily","fontSubfamily","shortVersion","locaTable","load","isNode","loadFn","loadSync","readFileSync","_parse","getByte","getUint8","getCard8","getUint16","getCard16","getShort","getInt16","getUint32","decimal","fraction","String","fromCharCode","getInt8","getOffset","offSize","getBytes","startOffset","endOffset","bytesToString","typeOffsets","uShort","uLong","fixed","longDateTime","Parser","relativeOffset","parseByte","parseChar","parseCard8","parseUShort","parseCard16","parseSID","parseOffset16","parseShort","parseF2Dot14","parseULong","parseFixed","parseOffset16List","parseUShortList","count","offsets","parseString","string","parseTag","parseLongDateTime","parseVersion","major","minor","skip","amount","strokeWidth","bezierCurveTo","quadTo","close","pathOrCommands","toPathData","decimalPlaces","floatToString","round","toFixed","packValues","arguments","d","toSVG","svg","sizeOf","Table","tableName","fields","field","value","optionKeys","k","sizeOfFunction","TABLE","table","equals","b","parseCFFIndex","start","conversionFn","objects","objectOffset","offsetSize","pos","parseFloatOperand","parser","eof","lookup","n1","n2","parseFloat","parseOperand","b0","b1","b2","b3","b4","entriesToObject","entries","key","values","hasOwnProperty","parseCFFDict","size","operands","op","getCFFString","strings","interpretDict","dict","meta","newDict","m","parseCFFHeader","header","formatMajor","formatMinor","TOP_DICT_META","PRIVATE_DICT_META","parseCFFTopDict","parseCFFPrivateDict","parseCFFCharset","nGlyphs","sid","format","parseCFFEncoding","enc","nCodes","nRanges","first","nLeft","c1x","c1y","c2x","c2y","stack","nStems","haveWidth","width","defaultWidthX","newContour","parseStems","hasWidthArg","shift","nominalWidthX","codeIndex","subrCode","jpx","jpy","c3x","c3y","c4x","c4y","pop","subrsBias","subrs","abs","console","log","gsubrsBias","gsubrs","calcCFFSubroutineBias","bias","parseCFFTable","nameIndex","topDictIndex","stringIndex","globalSubrIndex","topDictData","topDict","privateDictOffset","privateDict","subrOffset","subrIndex","charStringsIndex","charStrings","charString","encodeString","makeHeader","makeNameIndex","fontNames","makeDict","attrs","entry","makeTopDict","makeTopDictIndex","topDicts","makeStringIndex","makeGlobalSubrIndex","makeCharsets","glyphName","glyphSID","glyphToOps","ops","dx","dy","_13","_23","dx1","dy1","dx2","dy2","makeCharStringsIndex","makePrivateDict","makePrivateDictIndex","privateDicts","makeCFFTable","fullName","weight","weightName","fontMatrix","privateAttrs","postScriptName","charsets","privateDictIndex","private","make","parseCmapTable","platformId","encodingId","language","segCount","endCountParser","startCountParser","idDeltaParser","idRangeOffsetParser","glyphIndexOffset","endCount","startCount","idDelta","idRangeOffset","addSegment","segments","end","delta","addTerminatorSegment","makeCmapTable","sort","segCountX2","searchRange","pow","floor","entrySelector","rangeShift","endCounts","startCounts","idDeltas","idRangeOffsets","glyphIds","segment","concat","glyphId","parseGlyphCoordinate","flag","previousValue","shortVectorBitMask","sameBitMask","numberOfContours","flags","endPointIndices","instructionLength","instructions","numberOfCoordinates","repeatCount","point","onCurve","px","py","isComposite","components","moreComponents","component","xScale","scale01","scale10","yScale","transformPoints","transform","newPoints","newPt","contour","firstPt","lastPt","curvePt","realFirstPoint","prevPt","midPt","componentGlyph","transformedPoints","parseGlyfTable","nextOffset","parseTaggedListTable","list","parseCoverageTable","coverage","begin","parseClassDefTable","startGlyph","glyphCount","classes","glyphID","rangeCount","startGlyphs","endGlyphs","classValues","parsePairPosSubTable","coverageOffset","valueFormat1","valueFormat2","value1","value2","sharedPairSets","pairSetCount","pairSet","pairSetOffsets","firstGlyph","pairSetOffset","sharedPairSet","pairValueCount","secondGlyph","pairs","classDef1Offset","classDef2Offset","class1Count","class2Count","getClass1","getClass2","kerningMatrix","kerningRow","covered","class1","class2","parseLookupTable","lookupType","lookupFlag","useMarkFilteringSet","subTableCount","subTableOffsets","markFilteringSet","subtables","parseGposTable","tableVersion","lookupListOffset","lookupCount","lookupTableOffsets","lookupListAbsoluteOffset","parseHeadTable","fontRevision","checkSumAdjustment","magicNumber","created","modified","macStyle","lowestRecPPEM","fontDirectionHint","glyphDataFormat","makeHeadTable","parseHheaTable","lineGap","advanceWidthMax","minLeftSideBearing","minRightSideBearing","xMaxExtent","caretSlopeRise","caretSlopeRun","caretOffset","metricDataFormat","makeHheaTable","parseHmtxTable","numMetrics","makeHmtxTable","parseKernTable","subTableVersion","nPairs","leftIndex","rightIndex","parseLocaTable","parseFn","glyphOffsets","glyphOffset","parseMaxpTable","maxPoints","maxContours","maxCompositePoints","maxCompositeContours","maxZones","maxTwilightPoints","maxStorage","maxFunctionDefs","maxInstructionDefs","maxStackElements","maxSizeOfInstructions","maxComponentElements","maxComponentDepth","makeMaxpTable","nameTableNames","parseNameTable","stringOffset","unknownCount","platformID","encodingID","languageID","nameID","property","codePoints","str","langTagCount","makeNameRecord","addMacintoshNameRecord","recordID","stringBytes","STRING","records","addWindowsNameRecord","utf16Bytes","UTF16","makeNameTable","unicodeRanges","getUnicodeRange","range","parseOS2Table","xAvgCharWidth","usWeightClass","usWidthClass","fsType","ySubscriptXSize","ySubscriptYSize","ySubscriptXOffset","ySubscriptYOffset","ySuperscriptXSize","ySuperscriptYSize","ySuperscriptXOffset","ySuperscriptYOffset","yStrikeoutSize","yStrikeoutPosition","sFamilyClass","panose","ulUnicodeRange1","ulUnicodeRange2","ulUnicodeRange3","ulUnicodeRange4","achVendID","fsSelection","usFirstCharIndex","usLastCharIndex","sTypoAscender","sTypoDescender","sTypoLineGap","usWinAscent","usWinDescent","ulCodePageRange1","ulCodePageRange2","sxHeight","sCapHeight","usDefaultChar","usBreakChar","usMaxContent","makeOS2Table","parsePostTable","italicAngle","underlinePosition","underlineThickness","isFixedPitch","minMemType42","maxMemType42","minMemType1","maxMemType1","nameLength","makePostTable","log2","computeCheckSum","sum","makeTableRecord","checkSum","makeSfntTable","highestPowerOf2","recordFields","tableFields","tableLength","tableRecord","isNaN","r1","r2","metricsForChar","chars","notFoundMetrics","average","vs","fontToSfntTable","xMins","yMins","xMaxs","yMaxs","advanceWidths","leftSideBearings","rightSideBearings","firstCharIndex","lastCharIndex","globals","advanceWidthAvg","maxLeftSideBearing","headTable","hheaTable","maxpTable","os2Table","hmtxTable","cmapTable","nameTable","uniqueID","preferredFamily","preferredSubfamily","postTable","cffTable","checkSumAdjusted","LIMIT16","LIMIT32","decode","constant","BYTE","CHAR","CHARARRAY","USHORT","SHORT","UINT24","ULONG","LONG","FIXED","FWORD","UFWORD","LONGDATETIME","TAG","Card8","Card16","OffSize","SID","NUMBER","NUMBER16","NUMBER32","REAL","toString","exec","epsilon","nibbles","ii","out","substr","NAME","codepoint","INDEX","dataSize","OBJECT","encodedOffsets","offsetEncoder","encodedOffset","DICT","OPERAND","OPERATOR","OP","wmm","WeakMap","CHARSTRING","has","encodingFunction","numBytes","LITERAL"],"mappings":"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","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.opentype = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// Run-time checking of preconditions.\n\n'use strict';\n\n// Precondition function that checks if the given predicate is true.\n// If not, it will throw an error.\nexports.argument = function(predicate, message) {\n    if (!predicate) {\n        throw new Error(message);\n    }\n};\n\n// Precondition function that checks if the given assertion is true.\n// If not, it will throw an error.\nexports.assert = exports.argument;\n\n},{}],2:[function(require,module,exports){\n// Drawing utility functions.\n\n'use strict';\n\n// Draw a line on the given context from point `x1,y1` to point `x2,y2`.\nfunction line(ctx, x1, y1, x2, y2) {\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n}\n\nexports.line = line;\n\n},{}],3:[function(require,module,exports){\n// Glyph encoding\n\n'use strict';\n\nvar cffStandardStrings = [\n    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',\n    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',\n    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',\n    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',\n    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',\n    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',\n    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',\n    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',\n    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',\n    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',\n    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',\n    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',\n    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',\n    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',\n    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',\n    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',\n    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',\n    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',\n    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',\n    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',\n    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',\n    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',\n    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',\n    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',\n    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',\n    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',\n    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',\n    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',\n    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',\n    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',\n    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',\n    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',\n    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',\n    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];\n\nvar cffStandardEncoding = [\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',\n    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',\n    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',\n    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',\n    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',\n    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',\n    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',\n    'lslash', 'oslash', 'oe', 'germandbls'];\n\nvar cffExpertEncoding = [\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',\n    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',\n    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',\n    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',\n    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',\n    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',\n    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',\n    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',\n    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',\n    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',\n    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',\n    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\n    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',\n    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',\n    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',\n    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',\n    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',\n    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',\n    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',\n    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];\n\nvar standardNames = [\n    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',\n    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',\n    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',\n    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\n    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',\n    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',\n    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',\n    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',\n    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',\n    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',\n    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',\n    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',\n    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',\n    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',\n    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',\n    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',\n    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',\n    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',\n    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',\n    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',\n    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',\n    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',\n    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',\n    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];\n\n// This is the encoding used for fonts created from scratch.\n// It loops through all glyphs and finds the appropriate unicode value.\n// Since it's linear time, other encodings will be faster.\nfunction DefaultEncoding(font) {\n    this.font = font;\n}\n\nDefaultEncoding.prototype.charToGlyphIndex = function(c) {\n    var code = c.charCodeAt(0);\n    var glyphs = this.font.glyphs;\n    if (glyphs) {\n        for (var i = 0; i < glyphs.length; i += 1) {\n            var glyph = glyphs.get(i);\n            for (var j = 0; j < glyph.unicodes.length; j += 1) {\n                if (glyph.unicodes[j] === code) {\n                    return i;\n                }\n            }\n        }\n    } else {\n        return null;\n    }\n};\n\nfunction CmapEncoding(cmap) {\n    this.cmap = cmap;\n}\n\nCmapEncoding.prototype.charToGlyphIndex = function(c) {\n    return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;\n};\n\nfunction CffEncoding(encoding, charset) {\n    this.encoding = encoding;\n    this.charset = charset;\n}\n\nCffEncoding.prototype.charToGlyphIndex = function(s) {\n    var code = s.charCodeAt(0);\n    var charName = this.encoding[code];\n    return this.charset.indexOf(charName);\n};\n\nfunction GlyphNames(post) {\n    var i;\n    switch (post.version) {\n    case 1:\n        this.names = exports.standardNames.slice();\n        break;\n    case 2:\n        this.names = new Array(post.numberOfGlyphs);\n        for (i = 0; i < post.numberOfGlyphs; i++) {\n            if (post.glyphNameIndex[i] < exports.standardNames.length) {\n                this.names[i] = exports.standardNames[post.glyphNameIndex[i]];\n            } else {\n                this.names[i] = post.names[post.glyphNameIndex[i] - exports.standardNames.length];\n            }\n        }\n\n        break;\n    case 2.5:\n        this.names = new Array(post.numberOfGlyphs);\n        for (i = 0; i < post.numberOfGlyphs; i++) {\n            this.names[i] = exports.standardNames[i + post.glyphNameIndex[i]];\n        }\n\n        break;\n    case 3:\n        this.names = [];\n        break;\n    }\n}\n\nGlyphNames.prototype.nameToGlyphIndex = function(name) {\n    return this.names.indexOf(name);\n};\n\nGlyphNames.prototype.glyphIndexToName = function(gid) {\n    return this.names[gid];\n};\n\nfunction addGlyphNames(font) {\n    var glyph;\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n    var charCodes = Object.keys(glyphIndexMap);\n\n    for (var i = 0; i < charCodes.length; i += 1) {\n        var c = charCodes[i];\n        var glyphIndex = glyphIndexMap[c];\n        glyph = font.glyphs.get(glyphIndex);\n        glyph.addUnicode(parseInt(c));\n    }\n\n    for (i = 0; i < font.glyphs.length; i += 1) {\n        glyph = font.glyphs.get(i);\n        if (font.cffEncoding) {\n            glyph.name = font.cffEncoding.charset[i];\n        } else {\n            glyph.name = font.glyphNames.glyphIndexToName(i);\n        }\n    }\n}\n\nexports.cffStandardStrings = cffStandardStrings;\nexports.cffStandardEncoding = cffStandardEncoding;\nexports.cffExpertEncoding = cffExpertEncoding;\nexports.standardNames = standardNames;\nexports.DefaultEncoding = DefaultEncoding;\nexports.CmapEncoding = CmapEncoding;\nexports.CffEncoding = CffEncoding;\nexports.GlyphNames = GlyphNames;\nexports.addGlyphNames = addGlyphNames;\n\n},{}],4:[function(require,module,exports){\n// The Font object\n\n'use strict';\n\nvar path = require('./path');\nvar sfnt = require('./tables/sfnt');\nvar encoding = require('./encoding');\nvar glyphset = require('./glyphset');\n\n// A Font represents a loaded OpenType font file.\n// It contains a set of glyphs and methods to draw text on a drawing context,\n// or to get a path representing the text.\nfunction Font(options) {\n    options = options || {};\n\n    // OS X will complain if the names are empty, so we put a single space everywhere by default.\n    this.familyName = options.familyName || ' ';\n    this.styleName = options.styleName || ' ';\n    this.designer = options.designer || ' ';\n    this.designerURL = options.designerURL || ' ';\n    this.manufacturer = options.manufacturer || ' ';\n    this.manufacturerURL = options.manufacturerURL || ' ';\n    this.license = options.license || ' ';\n    this.licenseURL = options.licenseURL || ' ';\n    this.version = options.version || 'Version 0.1';\n    this.description = options.description || ' ';\n    this.copyright = options.copyright || ' ';\n    this.trademark = options.trademark || ' ';\n    this.unitsPerEm = options.unitsPerEm || 1000;\n    this.ascender = options.ascender;\n    this.descender = options.descender;\n    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.\n    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);\n    this.encoding = new encoding.DefaultEncoding(this);\n    this.tables = {};\n}\n\n// Check if the font has a glyph for the given character.\nFont.prototype.hasChar = function(c) {\n    return this.encoding.charToGlyphIndex(c) !== null;\n};\n\n// Convert the given character to a single glyph index.\n// Note that this function assumes that there is a one-to-one mapping between\n// the given character and a glyph; for complex scripts this might not be the case.\nFont.prototype.charToGlyphIndex = function(s) {\n    return this.encoding.charToGlyphIndex(s);\n};\n\n// Convert the given character to a single Glyph object.\n// Note that this function assumes that there is a one-to-one mapping between\n// the given character and a glyph; for complex scripts this might not be the case.\nFont.prototype.charToGlyph = function(c) {\n    var glyphIndex = this.charToGlyphIndex(c);\n    var glyph = this.glyphs.get(glyphIndex);\n    if (!glyph) {\n        // .notdef\n        glyph = this.glyphs.get(0);\n    }\n\n    return glyph;\n};\n\n// Convert the given text to a list of Glyph objects.\n// Note that there is no strict one-to-one mapping between characters and\n// glyphs, so the list of returned glyphs can be larger or smaller than the\n// length of the given string.\nFont.prototype.stringToGlyphs = function(s) {\n    var glyphs = [];\n    for (var i = 0; i < s.length; i += 1) {\n        var c = s[i];\n        glyphs.push(this.charToGlyph(c));\n    }\n\n    return glyphs;\n};\n\nFont.prototype.nameToGlyphIndex = function(name) {\n    return this.glyphNames.nameToGlyphIndex(name);\n};\n\nFont.prototype.nameToGlyph = function(name) {\n    var glyphIndex = this.nametoGlyphIndex(name);\n    var glyph = this.glyphs.get(glyphIndex);\n    if (!glyph) {\n        // .notdef\n        glyph = this.glyphs.get(0);\n    }\n\n    return glyph;\n};\n\nFont.prototype.glyphIndexToName = function(gid) {\n    if (!this.glyphNames.glyphIndexToName) {\n        return '';\n    }\n\n    return this.glyphNames.glyphIndexToName(gid);\n};\n\n// Retrieve the value of the kerning pair between the left glyph (or its index)\n// and the right glyph (or its index). If no kerning pair is found, return 0.\n// The kerning value gets added to the advance width when calculating the spacing\n// between glyphs.\nFont.prototype.getKerningValue = function(leftGlyph, rightGlyph) {\n    leftGlyph = leftGlyph.index || leftGlyph;\n    rightGlyph = rightGlyph.index || rightGlyph;\n    var gposKerning = this.getGposKerningValue;\n    return gposKerning ? gposKerning(leftGlyph, rightGlyph) :\n        (this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0);\n};\n\n// Helper function that invokes the given callback for each glyph in the given text.\n// The callback gets `(glyph, x, y, fontSize, options)`.\nFont.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    options = options || {};\n    var kerning = options.kerning === undefined ? true : options.kerning;\n    var fontScale = 1 / this.unitsPerEm * fontSize;\n    var glyphs = this.stringToGlyphs(text);\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs[i];\n        callback(glyph, x, y, fontSize, options);\n        if (glyph.advanceWidth) {\n            x += glyph.advanceWidth * fontScale;\n        }\n\n        if (kerning && i < glyphs.length - 1) {\n            var kerningValue = this.getKerningValue(glyph, glyphs[i + 1]);\n            x += kerningValue * fontScale;\n        }\n    }\n};\n\n// Create a Path object that represents the given text.\n//\n// text - The text to create.\n// x - Horizontal position of the beginning of the text. (default: 0)\n// y - Vertical position of the *baseline* of the text. (default: 0)\n// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)\n// Options is an optional object that contains:\n// - kerning - Whether to take kerning information into account. (default: true)\n//\n// Returns a Path object.\nFont.prototype.getPath = function(text, x, y, fontSize, options) {\n    var fullPath = new path.Path();\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        var glyphPath = glyph.getPath(gX, gY, gFontSize);\n        fullPath.extend(glyphPath);\n    });\n\n    return fullPath;\n};\n\n// Draw the text on the given drawing context.\n//\n// ctx - A 2D drawing context, like Canvas.\n// text - The text to create.\n// x - Horizontal position of the beginning of the text. (default: 0)\n// y - Vertical position of the *baseline* of the text. (default: 0)\n// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)\n// Options is an optional object that contains:\n// - kerning - Whether to take kerning information into account. (default: true)\nFont.prototype.draw = function(ctx, text, x, y, fontSize, options) {\n    this.getPath(text, x, y, fontSize, options).draw(ctx);\n};\n\n// Draw the points of all glyphs in the text.\n// On-curve points will be drawn in blue, off-curve points will be drawn in red.\n//\n// ctx - A 2D drawing context, like Canvas.\n// text - The text to create.\n// x - Horizontal position of the beginning of the text. (default: 0)\n// y - Vertical position of the *baseline* of the text. (default: 0)\n// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)\n// Options is an optional object that contains:\n// - kerning - Whether to take kerning information into account. (default: true)\nFont.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        glyph.drawPoints(ctx, gX, gY, gFontSize);\n    });\n};\n\n// Draw lines indicating important font measurements for all glyphs in the text.\n// Black lines indicate the origin of the coordinate system (point 0,0).\n// Blue lines indicate the glyph bounding box.\n// Green line indicates the advance width of the glyph.\n//\n// ctx - A 2D drawing context, like Canvas.\n// text - The text to create.\n// x - Horizontal position of the beginning of the text. (default: 0)\n// y - Vertical position of the *baseline* of the text. (default: 0)\n// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)\n// Options is an optional object that contains:\n// - kerning - Whether to take kerning information into account. (default: true)\nFont.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        glyph.drawMetrics(ctx, gX, gY, gFontSize);\n    });\n};\n\n// Validate\nFont.prototype.validate = function() {\n    var warnings = [];\n    var _this = this;\n\n    function assert(predicate, message) {\n        if (!predicate) {\n            warnings.push(message);\n        }\n    }\n\n    function assertStringAttribute(attrName) {\n        assert(_this[attrName] && _this[attrName].trim().length > 0, 'No ' + attrName + ' specified.');\n    }\n\n    // Identification information\n    assertStringAttribute('familyName');\n    assertStringAttribute('weightName');\n    assertStringAttribute('manufacturer');\n    assertStringAttribute('copyright');\n    assertStringAttribute('version');\n\n    // Dimension information\n    assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');\n};\n\n// Convert the font object to a SFNT data structure.\n// This structure contains all the necessary tables and metadata to create a binary OTF file.\nFont.prototype.toTables = function() {\n    return sfnt.fontToTable(this);\n};\n\nFont.prototype.toBuffer = function() {\n    var sfntTable = this.toTables();\n    var bytes = sfntTable.encode();\n    var buffer = new ArrayBuffer(bytes.length);\n    var intArray = new Uint8Array(buffer);\n    for (var i = 0; i < bytes.length; i++) {\n        intArray[i] = bytes[i];\n    }\n\n    return buffer;\n};\n\n// Initiate a download of the OpenType font.\nFont.prototype.download = function() {\n    var fileName = this.familyName.replace(/\\s/g, '') + '-' + this.styleName + '.otf';\n    var buffer = this.toBuffer();\n\n    window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;\n    window.requestFileSystem(window.TEMPORARY, buffer.byteLength, function(fs) {\n        fs.root.getFile(fileName, {create: true}, function(fileEntry) {\n            fileEntry.createWriter(function(writer) {\n                var dataView = new DataView(buffer);\n                var blob = new Blob([dataView], {type: 'font/opentype'});\n                writer.write(blob);\n\n                writer.addEventListener('writeend', function() {\n                    // Navigating to the file will download it.\n                    location.href = fileEntry.toURL();\n                }, false);\n            });\n        });\n    },\n\n    function(err) {\n        throw err;\n    });\n};\n\nexports.Font = Font;\n\n},{\"./encoding\":3,\"./glyphset\":6,\"./path\":9,\"./tables/sfnt\":24}],5:[function(require,module,exports){\n// The Glyph object\n\n'use strict';\n\nvar check = require('./check');\nvar draw = require('./draw');\nvar path = require('./path');\n\nfunction getPathDefinition(glyph, path) {\n    var _path = path || { commands: [] };\n    return {\n        configurable: true,\n\n        get: function() {\n            if (typeof _path === 'function') {\n                _path = _path();\n            }\n\n            return _path;\n        },\n\n        set: function(p) {\n            _path = p;\n        }\n    };\n}\n\n// A Glyph is an individual mark that often corresponds to a character.\n// Some glyphs, such as ligatures, are a combination of many characters.\n// Glyphs are the basic building blocks of a font.\n//\n// The `Glyph` class contains utility methods for drawing the path and its points.\nfunction Glyph(options) {\n    // By putting all the code on a prototype function (which is only declared once)\n    // we reduce the memory requirements for larger fonts by some 2%\n    this.bindConstructorValues(options);\n}\n\nGlyph.prototype.bindConstructorValues = function(options) {\n    this.index = options.index || 0;\n\n    // These three values cannnot be deferred for memory optimization:\n    this.name = options.name || null;\n    this.unicode = options.unicode || undefined;\n    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];\n\n    // But by binding these values only when necessary, we reduce can\n    // the memory requirements by almost 3% for larger fonts.\n    if (options.xMin) {\n        this.xMin = options.xMin;\n    }\n\n    if (options.yMin) {\n        this.yMin = options.yMin;\n    }\n\n    if (options.xMax) {\n        this.xMax = options.xMax;\n    }\n\n    if (options.yMax) {\n        this.yMax = options.yMax;\n    }\n\n    if (options.advanceWidth) {\n        this.advanceWidth = options.advanceWidth;\n    }\n\n    // The path for a glyph is the most memory intensive, and is bound as a value\n    // with a getter/setter to ensure we actually do path parsing only once the\n    // path is actually needed by anything.\n    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));\n};\n\nGlyph.prototype.addUnicode = function(unicode) {\n    if (this.unicodes.length === 0) {\n        this.unicode = unicode;\n    }\n\n    this.unicodes.push(unicode);\n};\n\n// Convert the glyph to a Path we can draw on a drawing context.\n//\n// x - Horizontal position of the glyph. (default: 0)\n// y - Vertical position of the *baseline* of the glyph. (default: 0)\n// fontSize - Font size, in pixels (default: 72).\nGlyph.prototype.getPath = function(x, y, fontSize) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    var scale = 1 / this.path.unitsPerEm * fontSize;\n    var p = new path.Path();\n    var commands = this.path.commands;\n    for (var i = 0; i < commands.length; i += 1) {\n        var cmd = commands[i];\n        if (cmd.type === 'M') {\n            p.moveTo(x + (cmd.x * scale), y + (-cmd.y * scale));\n        } else if (cmd.type === 'L') {\n            p.lineTo(x + (cmd.x * scale), y + (-cmd.y * scale));\n        } else if (cmd.type === 'Q') {\n            p.quadraticCurveTo(x + (cmd.x1 * scale), y + (-cmd.y1 * scale),\n                               x + (cmd.x * scale), y + (-cmd.y * scale));\n        } else if (cmd.type === 'C') {\n            p.curveTo(x + (cmd.x1 * scale), y + (-cmd.y1 * scale),\n                      x + (cmd.x2 * scale), y + (-cmd.y2 * scale),\n                      x + (cmd.x * scale), y + (-cmd.y * scale));\n        } else if (cmd.type === 'Z') {\n            p.closePath();\n        }\n    }\n\n    return p;\n};\n\n// Split the glyph into contours.\n// This function is here for backwards compatibility, and to\n// provide raw access to the TrueType glyph outlines.\nGlyph.prototype.getContours = function() {\n    if (this.points === undefined) {\n        return [];\n    }\n\n    var contours = [];\n    var currentContour = [];\n    for (var i = 0; i < this.points.length; i += 1) {\n        var pt = this.points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n    return contours;\n};\n\n// Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.\nGlyph.prototype.getMetrics = function() {\n    var commands = this.path.commands;\n    var xCoords = [];\n    var yCoords = [];\n    for (var i = 0; i < commands.length; i += 1) {\n        var cmd = commands[i];\n        if (cmd.type !== 'Z') {\n            xCoords.push(cmd.x);\n            yCoords.push(cmd.y);\n        }\n\n        if (cmd.type === 'Q' || cmd.type === 'C') {\n            xCoords.push(cmd.x1);\n            yCoords.push(cmd.y1);\n        }\n\n        if (cmd.type === 'C') {\n            xCoords.push(cmd.x2);\n            yCoords.push(cmd.y2);\n        }\n    }\n\n    var metrics = {\n        xMin: Math.min.apply(null, xCoords),\n        yMin: Math.min.apply(null, yCoords),\n        xMax: Math.max.apply(null, xCoords),\n        yMax: Math.max.apply(null, yCoords),\n        leftSideBearing: 0\n    };\n    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);\n    return metrics;\n};\n\n// Draw the glyph on the given context.\n//\n// ctx - The drawing context.\n// x - Horizontal position of the glyph. (default: 0)\n// y - Vertical position of the *baseline* of the glyph. (default: 0)\n// fontSize - Font size, in pixels (default: 72).\nGlyph.prototype.draw = function(ctx, x, y, fontSize) {\n    this.getPath(x, y, fontSize).draw(ctx);\n};\n\n// Draw the points of the glyph.\n// On-curve points will be drawn in blue, off-curve points will be drawn in red.\n//\n// ctx - The drawing context.\n// x - Horizontal position of the glyph. (default: 0)\n// y - Vertical position of the *baseline* of the glyph. (default: 0)\n// fontSize - Font size, in pixels (default: 72).\nGlyph.prototype.drawPoints = function(ctx, x, y, fontSize) {\n\n    function drawCircles(l, x, y, scale) {\n        var PI_SQ = Math.PI * 2;\n        ctx.beginPath();\n        for (var j = 0; j < l.length; j += 1) {\n            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));\n            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);\n        }\n\n        ctx.closePath();\n        ctx.fill();\n    }\n\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 24;\n    var scale = 1 / this.path.unitsPerEm * fontSize;\n\n    var blueCircles = [];\n    var redCircles = [];\n    var path = this.path;\n    for (var i = 0; i < path.commands.length; i += 1) {\n        var cmd = path.commands[i];\n        if (cmd.x !== undefined) {\n            blueCircles.push({x: cmd.x, y: -cmd.y});\n        }\n\n        if (cmd.x1 !== undefined) {\n            redCircles.push({x: cmd.x1, y: -cmd.y1});\n        }\n\n        if (cmd.x2 !== undefined) {\n            redCircles.push({x: cmd.x2, y: -cmd.y2});\n        }\n    }\n\n    ctx.fillStyle = 'blue';\n    drawCircles(blueCircles, x, y, scale);\n    ctx.fillStyle = 'red';\n    drawCircles(redCircles, x, y, scale);\n};\n\n// Draw lines indicating important font measurements.\n// Black lines indicate the origin of the coordinate system (point 0,0).\n// Blue lines indicate the glyph bounding box.\n// Green line indicates the advance width of the glyph.\n//\n// ctx - The drawing context.\n// x - Horizontal position of the glyph. (default: 0)\n// y - Vertical position of the *baseline* of the glyph. (default: 0)\n// fontSize - Font size, in pixels (default: 72).\nGlyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {\n    var scale;\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 24;\n    scale = 1 / this.path.unitsPerEm * fontSize;\n    ctx.lineWidth = 1;\n\n    // Draw the origin\n    ctx.strokeStyle = 'black';\n    draw.line(ctx, x, -10000, x, 10000);\n    draw.line(ctx, -10000, y, 10000, y);\n\n    // This code is here due to memory optimization: by not using\n    // defaults in the constructor, we save a notable amount of memory.\n    var xMin = this.xMin || 0;\n    var yMin = this.yMin || 0;\n    var xMax = this.xMax || 0;\n    var yMax = this.yMax || 0;\n    var advanceWidth = this.advanceWidth || 0;\n\n    // Draw the glyph box\n    ctx.strokeStyle = 'blue';\n    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);\n    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);\n    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));\n    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));\n\n    // Draw the advance width\n    ctx.strokeStyle = 'green';\n    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);\n};\n\nexports.Glyph = Glyph;\n\n},{\"./check\":1,\"./draw\":2,\"./path\":9}],6:[function(require,module,exports){\n// The GlyphSet object\n\n'use strict';\n\nvar _glyph = require('./glyph');\n\n// A GlyphSet represents all glyphs available in the font, but modelled using\n// a deferred glyph loader, for retrieving glyphs only once they are absolutely\n// necessary, to keep the memory footprint down.\nfunction GlyphSet(font, glyphs) {\n    this.font = font;\n    this.glyphs = {};\n    if (Array.isArray(glyphs)) {\n        for (var i = 0; i < glyphs.length; i++) {\n            this.glyphs[i] = glyphs[i];\n        }\n    }\n\n    this.length = (glyphs && glyphs.length) || 0;\n}\n\nGlyphSet.prototype.get = function(index) {\n    if (typeof this.glyphs[index] === 'function') {\n        this.glyphs[index] = this.glyphs[index]();\n    }\n\n    return this.glyphs[index];\n};\n\nGlyphSet.prototype.push = function(index, loader) {\n    this.glyphs[index] = loader;\n    this.length++;\n};\n\nfunction glyphLoader(font, index) {\n    return new _glyph.Glyph({index: index, font: font});\n}\n\n/**\n * Generate a stub glyph that can be filled with all metadata *except*\n * the \"points\" and \"path\" properties, which must be loaded only once\n * the glyph's path is actually requested for text shaping.\n */\n\nfunction ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {\n    return function() {\n        var glyph = new _glyph.Glyph({index: index, font: font});\n\n        glyph.path = function() {\n            parseGlyph(glyph, data, position);\n            var path = buildPath(font.glyphs, glyph);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n\n        return glyph;\n    };\n}\n\nfunction cffGlyphLoader(font, index, parseCFFCharstring, charstring) {\n    return function() {\n        var glyph = new _glyph.Glyph({index: index, font: font});\n\n        glyph.path = function() {\n            var path = parseCFFCharstring(font, glyph, charstring);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n\n        return glyph;\n    };\n}\n\nexports.GlyphSet = GlyphSet;\nexports.glyphLoader = glyphLoader;\nexports.ttfGlyphLoader = ttfGlyphLoader;\nexports.cffGlyphLoader = cffGlyphLoader;\n\n},{\"./glyph\":5}],7:[function(require,module,exports){\n// opentype.js\n// https://github.com/nodebox/opentype.js\n// (c) 2015 Frederik De Bleser\n// opentype.js may be freely distributed under the MIT license.\n\n/* global ArrayBuffer, DataView, Uint8Array, XMLHttpRequest  */\n\n'use strict';\n\nvar encoding = require('./encoding');\nvar _font = require('./font');\nvar glyph = require('./glyph');\nvar parse = require('./parse');\nvar path = require('./path');\n\nvar cmap = require('./tables/cmap');\nvar cff = require('./tables/cff');\nvar glyf = require('./tables/glyf');\nvar gpos = require('./tables/gpos');\nvar head = require('./tables/head');\nvar hhea = require('./tables/hhea');\nvar hmtx = require('./tables/hmtx');\nvar kern = require('./tables/kern');\nvar loca = require('./tables/loca');\nvar maxp = require('./tables/maxp');\nvar _name = require('./tables/name');\nvar os2 = require('./tables/os2');\nvar post = require('./tables/post');\n\n// File loaders /////////////////////////////////////////////////////////\n\n// Convert a Node.js Buffer to an ArrayBuffer\nfunction toArrayBuffer(buffer) {\n    var arrayBuffer = new ArrayBuffer(buffer.length);\n    var data = new Uint8Array(arrayBuffer);\n    for (var i = 0; i < buffer.length; i += 1) {\n        data[i] = buffer[i];\n    }\n\n    return arrayBuffer;\n}\n\nfunction loadFromFile(path, callback) {\n    var fs = require('fs');\n    fs.readFile(path, function(err, buffer) {\n        if (err) {\n            return callback(err.message);\n        }\n\n        callback(null, toArrayBuffer(buffer));\n    });\n}\n\nfunction loadFromUrl(url, callback) {\n    var request = new XMLHttpRequest();\n    request.open('get', url, true);\n    request.responseType = 'arraybuffer';\n    request.onload = function() {\n        if (request.status !== 200) {\n            return callback('Font could not be loaded: ' + request.statusText);\n        }\n\n        return callback(null, request.response);\n    };\n\n    request.send();\n}\n\n// Public API ///////////////////////////////////////////////////////////\n\n// Parse the OpenType file data (as an ArrayBuffer) and return a Font object.\n// Throws an error if the font could not be parsed.\nfunction parseBuffer(buffer) {\n    var indexToLocFormat;\n    var hmtxOffset;\n    var glyfOffset;\n    var locaOffset;\n    var cffOffset;\n    var kernOffset;\n    var gposOffset;\n\n    // OpenType fonts use big endian byte ordering.\n    // We can't rely on typed array view types, because they operate with the endianness of the host computer.\n    // Instead we use DataViews where we can specify endianness.\n\n    var font = new _font.Font();\n    var data = new DataView(buffer, 0);\n\n    var version = parse.getFixed(data, 0);\n    if (version === 1.0) {\n        font.outlinesFormat = 'truetype';\n    } else {\n        version = parse.getTag(data, 0);\n        if (version === 'OTTO') {\n            font.outlinesFormat = 'cff';\n        } else {\n            throw new Error('Unsupported OpenType version ' + version);\n        }\n    }\n\n    var numTables = parse.getUShort(data, 4);\n\n    // Offset into the table records.\n    var p = 12;\n    for (var i = 0; i < numTables; i += 1) {\n        var tag = parse.getTag(data, p);\n        var offset = parse.getULong(data, p + 8);\n        switch (tag) {\n        case 'cmap':\n            font.tables.cmap = cmap.parse(data, offset);\n            font.encoding = new encoding.CmapEncoding(font.tables.cmap);\n            break;\n        case 'head':\n            font.tables.head = head.parse(data, offset);\n            font.unitsPerEm = font.tables.head.unitsPerEm;\n            indexToLocFormat = font.tables.head.indexToLocFormat;\n            break;\n        case 'hhea':\n            font.tables.hhea = hhea.parse(data, offset);\n            font.ascender = font.tables.hhea.ascender;\n            font.descender = font.tables.hhea.descender;\n            font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;\n            break;\n        case 'hmtx':\n            hmtxOffset = offset;\n            break;\n        case 'maxp':\n            font.tables.maxp = maxp.parse(data, offset);\n            font.numGlyphs = font.tables.maxp.numGlyphs;\n            break;\n        case 'name':\n            font.tables.name = _name.parse(data, offset);\n            font.familyName = font.tables.name.fontFamily;\n            font.styleName = font.tables.name.fontSubfamily;\n            break;\n        case 'OS/2':\n            font.tables.os2 = os2.parse(data, offset);\n            break;\n        case 'post':\n            font.tables.post = post.parse(data, offset);\n            font.glyphNames = new encoding.GlyphNames(font.tables.post);\n            break;\n        case 'glyf':\n            glyfOffset = offset;\n            break;\n        case 'loca':\n            locaOffset = offset;\n            break;\n        case 'CFF ':\n            cffOffset = offset;\n            break;\n        case 'kern':\n            kernOffset = offset;\n            break;\n        case 'GPOS':\n            gposOffset = offset;\n            break;\n        }\n        p += 16;\n    }\n\n    if (glyfOffset && locaOffset) {\n        var shortVersion = indexToLocFormat === 0;\n        var locaTable = loca.parse(data, locaOffset, font.numGlyphs, shortVersion);\n        font.glyphs = glyf.parse(data, glyfOffset, locaTable, font);\n        hmtx.parse(data, hmtxOffset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);\n        encoding.addGlyphNames(font);\n    } else if (cffOffset) {\n        cff.parse(data, cffOffset, font);\n        encoding.addGlyphNames(font);\n    } else {\n        throw new Error('Font doesn\\'t contain TrueType or CFF outlines.');\n    }\n\n    if (kernOffset) {\n        font.kerningPairs = kern.parse(data, kernOffset);\n    } else {\n        font.kerningPairs = {};\n    }\n\n    if (gposOffset) {\n        gpos.parse(data, gposOffset, font);\n    }\n\n    return font;\n}\n\n// Asynchronously load the font from a URL or a filesystem. When done, call the callback\n// with two arguments `(err, font)`. The `err` will be null on success,\n// the `font` is a Font object.\n//\n// We use the node.js callback convention so that\n// opentype.js can integrate with frameworks like async.js.\nfunction load(url, callback) {\n    var isNode = typeof window === 'undefined';\n    var loadFn = isNode ? loadFromFile : loadFromUrl;\n    loadFn(url, function(err, arrayBuffer) {\n        if (err) {\n            return callback(err);\n        }\n\n        var font = parseBuffer(arrayBuffer);\n        return callback(null, font);\n    });\n}\n\n// Syncronously load the font from a URL or file.\n// When done, return the font object or throw an error.\nfunction loadSync(url) {\n    var fs = require('fs');\n    var buffer = fs.readFileSync(url);\n    return parseBuffer(toArrayBuffer(buffer));\n}\n\nexports._parse = parse;\nexports.Font = _font.Font;\nexports.Glyph = glyph.Glyph;\nexports.Path = path.Path;\nexports.parse = parseBuffer;\nexports.load = load;\nexports.loadSync = loadSync;\n\n},{\"./encoding\":3,\"./font\":4,\"./glyph\":5,\"./parse\":8,\"./path\":9,\"./tables/cff\":11,\"./tables/cmap\":12,\"./tables/glyf\":13,\"./tables/gpos\":14,\"./tables/head\":15,\"./tables/hhea\":16,\"./tables/hmtx\":17,\"./tables/kern\":18,\"./tables/loca\":19,\"./tables/maxp\":20,\"./tables/name\":21,\"./tables/os2\":22,\"./tables/post\":23,\"fs\":undefined}],8:[function(require,module,exports){\n// Parsing utility functions\n\n'use strict';\n\n// Retrieve an unsigned byte from the DataView.\nexports.getByte = function getByte(dataView, offset) {\n    return dataView.getUint8(offset);\n};\n\nexports.getCard8 = exports.getByte;\n\n// Retrieve an unsigned 16-bit short from the DataView.\n// The value is stored in big endian.\nexports.getUShort = function(dataView, offset) {\n    return dataView.getUint16(offset, false);\n};\n\nexports.getCard16 = exports.getUShort;\n\n// Retrieve a signed 16-bit short from the DataView.\n// The value is stored in big endian.\nexports.getShort = function(dataView, offset) {\n    return dataView.getInt16(offset, false);\n};\n\n// Retrieve an unsigned 32-bit long from the DataView.\n// The value is stored in big endian.\nexports.getULong = function(dataView, offset) {\n    return dataView.getUint32(offset, false);\n};\n\n// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n// The value is stored in big endian.\nexports.getFixed = function(dataView, offset) {\n    var decimal = dataView.getInt16(offset, false);\n    var fraction = dataView.getUint16(offset + 2, false);\n    return decimal + fraction / 65535;\n};\n\n// Retrieve a 4-character tag from the DataView.\n// Tags are used to identify tables.\nexports.getTag = function(dataView, offset) {\n    var tag = '';\n    for (var i = offset; i < offset + 4; i += 1) {\n        tag += String.fromCharCode(dataView.getInt8(i));\n    }\n\n    return tag;\n};\n\n// Retrieve an offset from the DataView.\n// Offsets are 1 to 4 bytes in length, depending on the offSize argument.\nexports.getOffset = function(dataView, offset, offSize) {\n    var v = 0;\n    for (var i = 0; i < offSize; i += 1) {\n        v <<= 8;\n        v += dataView.getUint8(offset + i);\n    }\n\n    return v;\n};\n\n// Retrieve a number of bytes from start offset to the end offset from the DataView.\nexports.getBytes = function(dataView, startOffset, endOffset) {\n    var bytes = [];\n    for (var i = startOffset; i < endOffset; i += 1) {\n        bytes.push(dataView.getUint8(i));\n    }\n\n    return bytes;\n};\n\n// Convert the list of bytes to a string.\nexports.bytesToString = function(bytes) {\n    var s = '';\n    for (var i = 0; i < bytes.length; i += 1) {\n        s += String.fromCharCode(bytes[i]);\n    }\n\n    return s;\n};\n\nvar typeOffsets = {\n    byte: 1,\n    uShort: 2,\n    short: 2,\n    uLong: 4,\n    fixed: 4,\n    longDateTime: 8,\n    tag: 4\n};\n\n// A stateful parser that changes the offset whenever a value is retrieved.\n// The data is a DataView.\nfunction Parser(data, offset) {\n    this.data = data;\n    this.offset = offset;\n    this.relativeOffset = 0;\n}\n\nParser.prototype.parseByte = function() {\n    var v = this.data.getUint8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseChar = function() {\n    var v = this.data.getInt8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseCard8 = Parser.prototype.parseByte;\n\nParser.prototype.parseUShort = function() {\n    var v = this.data.getUint16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseCard16 = Parser.prototype.parseUShort;\nParser.prototype.parseSID = Parser.prototype.parseUShort;\nParser.prototype.parseOffset16 = Parser.prototype.parseUShort;\n\nParser.prototype.parseShort = function() {\n    var v = this.data.getInt16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseF2Dot14 = function() {\n    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseULong = function() {\n    var v = exports.getULong(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseFixed = function() {\n    var v = exports.getFixed(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseOffset16List =\nParser.prototype.parseUShortList = function(count) {\n    var offsets = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        offsets[i] = exports.getUShort(dataView, offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return offsets;\n};\n\nParser.prototype.parseString = function(length) {\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    var string = '';\n    this.relativeOffset += length;\n    for (var i = 0; i < length; i++) {\n        string += String.fromCharCode(dataView.getUint8(offset + i));\n    }\n\n    return string;\n};\n\nParser.prototype.parseTag = function() {\n    return this.parseString(4);\n};\n\n// LONGDATETIME is a 64-bit integer.\n// JavaScript and unix timestamps traditionally use 32 bits, so we\n// only take the last 32 bits.\nParser.prototype.parseLongDateTime = function() {\n    var v = exports.getULong(this.data, this.offset + this.relativeOffset + 4);\n    this.relativeOffset += 8;\n    return v;\n};\n\nParser.prototype.parseFixed = function() {\n    var v = exports.getULong(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v / 65536;\n};\n\nParser.prototype.parseVersion = function() {\n    var major = exports.getUShort(this.data, this.offset + this.relativeOffset);\n\n    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n    // This returns the correct number if minor = 0xN000 where N is 0-9\n    var minor = exports.getUShort(this.data, this.offset + this.relativeOffset + 2);\n    this.relativeOffset += 4;\n    return major + minor / 0x1000 / 10;\n};\n\nParser.prototype.skip = function(type, amount) {\n    if (amount === undefined) {\n        amount = 1;\n    }\n\n    this.relativeOffset += typeOffsets[type] * amount;\n};\n\nexports.Parser = Parser;\n\n},{}],9:[function(require,module,exports){\n// Geometric objects\n\n'use strict';\n\n// A bézier path containing a set of path commands similar to a SVG path.\n// Paths can be drawn on a context using `draw`.\nfunction Path() {\n    this.commands = [];\n    this.fill = 'black';\n    this.stroke = null;\n    this.strokeWidth = 1;\n}\n\nPath.prototype.moveTo = function(x, y) {\n    this.commands.push({\n        type: 'M',\n        x: x,\n        y: y\n    });\n};\n\nPath.prototype.lineTo = function(x, y) {\n    this.commands.push({\n        type: 'L',\n        x: x,\n        y: y\n    });\n};\n\nPath.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {\n    this.commands.push({\n        type: 'C',\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        x: x,\n        y: y\n    });\n};\n\nPath.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {\n    this.commands.push({\n        type: 'Q',\n        x1: x1,\n        y1: y1,\n        x: x,\n        y: y\n    });\n};\n\nPath.prototype.close = Path.prototype.closePath = function() {\n    this.commands.push({\n        type: 'Z'\n    });\n};\n\n// Add the given path or list of commands to the commands of this path.\nPath.prototype.extend = function(pathOrCommands) {\n    if (pathOrCommands.commands) {\n        pathOrCommands = pathOrCommands.commands;\n    }\n\n    Array.prototype.push.apply(this.commands, pathOrCommands);\n};\n\n// Draw the path to a 2D context.\nPath.prototype.draw = function(ctx) {\n    ctx.beginPath();\n    for (var i = 0; i < this.commands.length; i += 1) {\n        var cmd = this.commands[i];\n        if (cmd.type === 'M') {\n            ctx.moveTo(cmd.x, cmd.y);\n        } else if (cmd.type === 'L') {\n            ctx.lineTo(cmd.x, cmd.y);\n        } else if (cmd.type === 'C') {\n            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n        } else if (cmd.type === 'Q') {\n            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);\n        } else if (cmd.type === 'Z') {\n            ctx.closePath();\n        }\n    }\n\n    if (this.fill) {\n        ctx.fillStyle = this.fill;\n        ctx.fill();\n    }\n\n    if (this.stroke) {\n        ctx.strokeStyle = this.stroke;\n        ctx.lineWidth = this.strokeWidth;\n        ctx.stroke();\n    }\n};\n\n// Convert the Path to a string of path data instructions\n// See http://www.w3.org/TR/SVG/paths.html#PathData\n// Parameters:\n// - decimalPlaces: The amount of decimal places for floating-point values (default: 2)\nPath.prototype.toPathData = function(decimalPlaces) {\n    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;\n\n    function floatToString(v) {\n        if (Math.round(v) === v) {\n            return '' + Math.round(v);\n        } else {\n            return v.toFixed(decimalPlaces);\n        }\n    }\n\n    function packValues() {\n        var s = '';\n        for (var i = 0; i < arguments.length; i += 1) {\n            var v = arguments[i];\n            if (v >= 0 && i > 0) {\n                s += ' ';\n            }\n\n            s += floatToString(v);\n        }\n\n        return s;\n    }\n\n    var d = '';\n    for (var i = 0; i < this.commands.length; i += 1) {\n        var cmd = this.commands[i];\n        if (cmd.type === 'M') {\n            d += 'M' + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === 'L') {\n            d += 'L' + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === 'C') {\n            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n        } else if (cmd.type === 'Q') {\n            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);\n        } else if (cmd.type === 'Z') {\n            d += 'Z';\n        }\n    }\n\n    return d;\n};\n\n// Convert the path to a SVG <path> element, as a string.\n// Parameters:\n// - decimalPlaces: The amount of decimal places for floating-point values (default: 2)\nPath.prototype.toSVG = function(decimalPlaces) {\n    var svg = '<path d=\"';\n    svg += this.toPathData(decimalPlaces);\n    svg += '\"';\n    if (this.fill & this.fill !== 'black') {\n        if (this.fill === null) {\n            svg += ' fill=\"none\"';\n        } else {\n            svg += ' fill=\"' + this.fill + '\"';\n        }\n    }\n\n    if (this.stroke) {\n        svg += ' stroke=\"' + this.stroke + '\" stroke-width=\"' + this.strokeWidth + '\"';\n    }\n\n    svg += '/>';\n    return svg;\n};\n\nexports.Path = Path;\n\n},{}],10:[function(require,module,exports){\n// Table metadata\n\n'use strict';\n\nvar check = require('./check');\nvar encode = require('./types').encode;\nvar sizeOf = require('./types').sizeOf;\n\nfunction Table(tableName, fields, options) {\n    var i;\n    for (i = 0; i < fields.length; i += 1) {\n        var field = fields[i];\n        this[field.name] = field.value;\n    }\n\n    this.tableName = tableName;\n    this.fields = fields;\n    if (options) {\n        var optionKeys = Object.keys(options);\n        for (i = 0; i < optionKeys.length; i += 1) {\n            var k = optionKeys[i];\n            var v = options[k];\n            if (this[k] !== undefined) {\n                this[k] = v;\n            }\n        }\n    }\n}\n\nTable.prototype.sizeOf = function() {\n    var v = 0;\n    for (var i = 0; i < this.fields.length; i += 1) {\n        var field = this.fields[i];\n        var value = this[field.name];\n        if (value === undefined) {\n            value = field.value;\n        }\n\n        if (typeof value.sizeOf === 'function') {\n            v += value.sizeOf();\n        } else {\n            var sizeOfFunction = sizeOf[field.type];\n            check.assert(typeof sizeOfFunction === 'function', 'Could not find sizeOf function for field' + field.name);\n            v += sizeOfFunction(value);\n        }\n    }\n\n    return v;\n};\n\nTable.prototype.encode = function() {\n    return encode.TABLE(this);\n};\n\nexports.Table = Table;\n\n},{\"./check\":1,\"./types\":25}],11:[function(require,module,exports){\n// The `CFF` table contains the glyph outlines in PostScript format.\n// https://www.microsoft.com/typography/OTSPEC/cff.htm\n// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf\n// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf\n\n'use strict';\n\nvar encoding = require('../encoding');\nvar glyphset = require('../glyphset');\nvar parse = require('../parse');\nvar path = require('../path');\nvar table = require('../table');\n\n// Custom equals function that can also check lists.\nfunction equals(a, b) {\n    if (a === b) {\n        return true;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n\n        for (var i = 0; i < a.length; i += 1) {\n            if (!equals(a[i], b[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// Parse a `CFF` INDEX array.\n// An index array consists of a list of offsets, then a list of objects at those offsets.\nfunction parseCFFIndex(data, start, conversionFn) {\n    //var i, objectOffset, endOffset;\n    var offsets = [];\n    var objects = [];\n    var count = parse.getCard16(data, start);\n    var i;\n    var objectOffset;\n    var endOffset;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + ((count + 1) * offsetSize) + 2;\n        var pos = start + 3;\n        for (i = 0; i < count + 1; i += 1) {\n            offsets.push(parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n\n    for (i = 0; i < offsets.length - 1; i += 1) {\n        var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);\n        if (conversionFn) {\n            value = conversionFn(value);\n        }\n\n        objects.push(value);\n    }\n\n    return {objects: objects, startOffset: start, endOffset: endOffset};\n}\n\n// Parse a `CFF` DICT real value.\nfunction parseFloatOperand(parser) {\n    var s = '';\n    var eof = 15;\n    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];\n    while (true) {\n        var b = parser.parseByte();\n        var n1 = b >> 4;\n        var n2 = b & 15;\n\n        if (n1 === eof) {\n            break;\n        }\n\n        s += lookup[n1];\n\n        if (n2 === eof) {\n            break;\n        }\n\n        s += lookup[n2];\n    }\n\n    return parseFloat(s);\n}\n\n// Parse a `CFF` DICT operand.\nfunction parseOperand(parser, b0) {\n    var b1;\n    var b2;\n    var b3;\n    var b4;\n    if (b0 === 28) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        return b1 << 8 | b2;\n    }\n\n    if (b0 === 29) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        b3 = parser.parseByte();\n        b4 = parser.parseByte();\n        return b1 << 24 | b2 << 16 | b3 << 8 | b4;\n    }\n\n    if (b0 === 30) {\n        return parseFloatOperand(parser);\n    }\n\n    if (b0 >= 32 && b0 <= 246) {\n        return b0 - 139;\n    }\n\n    if (b0 >= 247 && b0 <= 250) {\n        b1 = parser.parseByte();\n        return (b0 - 247) * 256 + b1 + 108;\n    }\n\n    if (b0 >= 251 && b0 <= 254) {\n        b1 = parser.parseByte();\n        return -(b0 - 251) * 256 - b1 - 108;\n    }\n\n    throw new Error('Invalid b0 ' + b0);\n}\n\n// Convert the entries returned by `parseDict` to a proper dictionary.\n// If a value is a list of one, it is unpacked.\nfunction entriesToObject(entries) {\n    var o = {};\n    for (var i = 0; i < entries.length; i += 1) {\n        var key = entries[i][0];\n        var values = entries[i][1];\n        var value;\n        if (values.length === 1) {\n            value = values[0];\n        } else {\n            value = values;\n        }\n\n        if (o.hasOwnProperty(key)) {\n            throw new Error('Object ' + o + ' already has key ' + key);\n        }\n\n        o[key] = value;\n    }\n\n    return o;\n}\n\n// Parse a `CFF` DICT object.\n// A dictionary contains key-value pairs in a compact tokenized format.\nfunction parseCFFDict(data, start, size) {\n    start = start !== undefined ? start : 0;\n    var parser = new parse.Parser(data, start);\n    var entries = [];\n    var operands = [];\n    size = size !== undefined ? size : data.length;\n\n    while (parser.relativeOffset < size) {\n        var op = parser.parseByte();\n\n        // The first byte for each dict item distinguishes between operator (key) and operand (value).\n        // Values <= 21 are operators.\n        if (op <= 21) {\n            // Two-byte operators have an initial escape byte of 12.\n            if (op === 12) {\n                op = 1200 + parser.parseByte();\n            }\n\n            entries.push([op, operands]);\n            operands = [];\n        } else {\n            // Since the operands (values) come before the operators (keys), we store all operands in a list\n            // until we encounter an operator.\n            operands.push(parseOperand(parser, op));\n        }\n    }\n\n    return entriesToObject(entries);\n}\n\n// Given a String Index (SID), return the value of the string.\n// Strings below index 392 are standard CFF strings and are not encoded in the font.\nfunction getCFFString(strings, index) {\n    if (index <= 390) {\n        index = encoding.cffStandardStrings[index];\n    } else {\n        index = strings[index - 391];\n    }\n\n    return index;\n}\n\n// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\nfunction interpretDict(dict, meta, strings) {\n    var newDict = {};\n\n    // Because we also want to include missing values, we start out from the meta list\n    // and lookup values in the dict.\n    for (var i = 0; i < meta.length; i += 1) {\n        var m = meta[i];\n        var value = dict[m.op];\n        if (value === undefined) {\n            value = m.value !== undefined ? m.value : null;\n        }\n\n        if (m.type === 'SID') {\n            value = getCFFString(strings, value);\n        }\n\n        newDict[m.name] = value;\n    }\n\n    return newDict;\n}\n\n// Parse the CFF header.\nfunction parseCFFHeader(data, start) {\n    var header = {};\n    header.formatMajor = parse.getCard8(data, start);\n    header.formatMinor = parse.getCard8(data, start + 1);\n    header.size = parse.getCard8(data, start + 2);\n    header.offsetSize = parse.getCard8(data, start + 3);\n    header.startOffset = start;\n    header.endOffset = start + 4;\n    return header;\n}\n\nvar TOP_DICT_META = [\n    {name: 'version', op: 0, type: 'SID'},\n    {name: 'notice', op: 1, type: 'SID'},\n    {name: 'copyright', op: 1200, type: 'SID'},\n    {name: 'fullName', op: 2, type: 'SID'},\n    {name: 'familyName', op: 3, type: 'SID'},\n    {name: 'weight', op: 4, type: 'SID'},\n    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},\n    {name: 'italicAngle', op: 1202, type: 'number', value: 0},\n    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},\n    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},\n    {name: 'paintType', op: 1205, type: 'number', value: 0},\n    {name: 'charstringType', op: 1206, type: 'number', value: 2},\n    {name: 'fontMatrix', op: 1207, type: ['real', 'real', 'real', 'real', 'real', 'real'], value: [0.001, 0, 0, 0.001, 0, 0]},\n    {name: 'uniqueId', op: 13, type: 'number'},\n    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},\n    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},\n    {name: 'xuid', op: 14, type: [], value: null},\n    {name: 'charset', op: 15, type: 'offset', value: 0},\n    {name: 'encoding', op: 16, type: 'offset', value: 0},\n    {name: 'charStrings', op: 17, type: 'offset', value: 0},\n    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]}\n];\n\nvar PRIVATE_DICT_META = [\n    {name: 'subrs', op: 19, type: 'offset', value: 0},\n    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},\n    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}\n];\n\n// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n// The top dictionary contains the essential metadata for the font, together with the private dictionary.\nfunction parseCFFTopDict(data, strings) {\n    var dict = parseCFFDict(data, 0, data.byteLength);\n    return interpretDict(dict, TOP_DICT_META, strings);\n}\n\n// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\nfunction parseCFFPrivateDict(data, start, size, strings) {\n    var dict = parseCFFDict(data, start, size);\n    return interpretDict(dict, PRIVATE_DICT_META, strings);\n}\n\n// Parse the CFF charset table, which contains internal names for all the glyphs.\n// This function will return a list of glyph names.\n// See Adobe TN #5176 chapter 13, \"Charsets\".\nfunction parseCFFCharset(data, start, nGlyphs, strings) {\n    var i;\n    var sid;\n    var count;\n    var parser = new parse.Parser(data, start);\n\n    // The .notdef glyph is not included, so subtract 1.\n    nGlyphs -= 1;\n    var charset = ['.notdef'];\n\n    var format = parser.parseCard8();\n    if (format === 0) {\n        for (i = 0; i < nGlyphs; i += 1) {\n            sid = parser.parseSID();\n            charset.push(getCFFString(strings, sid));\n        }\n    } else if (format === 1) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard8();\n            for (i = 0; i <= count; i += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else if (format === 2) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard16();\n            for (i = 0; i <= count; i += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown charset format ' + format);\n    }\n\n    return charset;\n}\n\n// Parse the CFF encoding data. Only one encoding can be specified per font.\n// See Adobe TN #5176 chapter 12, \"Encodings\".\nfunction parseCFFEncoding(data, start, charset) {\n    var i;\n    var code;\n    var enc = {};\n    var parser = new parse.Parser(data, start);\n    var format = parser.parseCard8();\n    if (format === 0) {\n        var nCodes = parser.parseCard8();\n        for (i = 0; i < nCodes; i += 1) {\n            code = parser.parseCard8();\n            enc[code] = i;\n        }\n    } else if (format === 1) {\n        var nRanges = parser.parseCard8();\n        code = 1;\n        for (i = 0; i < nRanges; i += 1) {\n            var first = parser.parseCard8();\n            var nLeft = parser.parseCard8();\n            for (var j = first; j <= first + nLeft; j += 1) {\n                enc[j] = code;\n                code += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown encoding format ' + format);\n    }\n\n    return new encoding.CffEncoding(enc, charset);\n}\n\n// Take in charstring code and return a Glyph object.\n// The encoding is described in the Type 2 Charstring Format\n// https://www.microsoft.com/typography/OTSPEC/charstr2.htm\nfunction parseCFFCharstring(font, glyph, code) {\n    var c1x;\n    var c1y;\n    var c2x;\n    var c2y;\n    var p = new path.Path();\n    var stack = [];\n    var nStems = 0;\n    var haveWidth = false;\n    var width = font.defaultWidthX;\n    var open = false;\n    var x = 0;\n    var y = 0;\n\n    function newContour(x, y) {\n        if (open) {\n            p.closePath();\n        }\n\n        p.moveTo(x, y);\n        open = true;\n    }\n\n    function parseStems() {\n        var hasWidthArg;\n\n        // The number of stem operators on the stack is always even.\n        // If the value is uneven, that means a width is specified.\n        hasWidthArg = stack.length % 2 !== 0;\n        if (hasWidthArg && !haveWidth) {\n            width = stack.shift() + font.nominalWidthX;\n        }\n\n        nStems += stack.length >> 1;\n        stack.length = 0;\n        haveWidth = true;\n    }\n\n    function parse(code) {\n        var b1;\n        var b2;\n        var b3;\n        var b4;\n        var codeIndex;\n        var subrCode;\n        var jpx;\n        var jpy;\n        var c3x;\n        var c3y;\n        var c4x;\n        var c4y;\n\n        var i = 0;\n        while (i < code.length) {\n            var v = code[i];\n            i += 1;\n            switch (v) {\n            case 1: // hstem\n                parseStems();\n                break;\n            case 3: // vstem\n                parseStems();\n                break;\n            case 4: // vmoveto\n                if (stack.length > 1 && !haveWidth) {\n                    width = stack.shift() + font.nominalWidthX;\n                    haveWidth = true;\n                }\n\n                y += stack.pop();\n                newContour(x, y);\n                break;\n            case 5: // rlineto\n                while (stack.length > 0) {\n                    x += stack.shift();\n                    y += stack.shift();\n                    p.lineTo(x, y);\n                }\n\n                break;\n            case 6: // hlineto\n                while (stack.length > 0) {\n                    x += stack.shift();\n                    p.lineTo(x, y);\n                    if (stack.length === 0) {\n                        break;\n                    }\n\n                    y += stack.shift();\n                    p.lineTo(x, y);\n                }\n\n                break;\n            case 7: // vlineto\n                while (stack.length > 0) {\n                    y += stack.shift();\n                    p.lineTo(x, y);\n                    if (stack.length === 0) {\n                        break;\n                    }\n\n                    x += stack.shift();\n                    p.lineTo(x, y);\n                }\n\n                break;\n            case 8: // rrcurveto\n                while (stack.length > 0) {\n                    c1x = x + stack.shift();\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + stack.shift();\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                }\n\n                break;\n            case 10: // callsubr\n                codeIndex = stack.pop() + font.subrsBias;\n                subrCode = font.subrs[codeIndex];\n                if (subrCode) {\n                    parse(subrCode);\n                }\n\n                break;\n            case 11: // return\n                return;\n            case 12: // flex operators\n                v = code[i];\n                i += 1;\n                switch (v) {\n                case 35: // flex\n                    // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n                    c1x = x   + stack.shift();    // dx1\n                    c1y = y   + stack.shift();    // dy1\n                    c2x = c1x + stack.shift();    // dx2\n                    c2y = c1y + stack.shift();    // dy2\n                    jpx = c2x + stack.shift();    // dx3\n                    jpy = c2y + stack.shift();    // dy3\n                    c3x = jpx + stack.shift();    // dx4\n                    c3y = jpy + stack.shift();    // dy4\n                    c4x = c3x + stack.shift();    // dx5\n                    c4y = c3y + stack.shift();    // dy5\n                    x = c4x + stack.shift();      // dx6\n                    y = c4y + stack.shift();      // dy6\n                    stack.shift();                // flex depth\n                    p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                    p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                    break;\n                case 34: // hflex\n                    // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n                    c1x = x   + stack.shift();    // dx1\n                    c1y = y;                      // dy1\n                    c2x = c1x + stack.shift();    // dx2\n                    c2y = c1y + stack.shift();    // dy2\n                    jpx = c2x + stack.shift();    // dx3\n                    jpy = c2y;                    // dy3\n                    c3x = jpx + stack.shift();    // dx4\n                    c3y = c2y;                    // dy4\n                    c4x = c3x + stack.shift();    // dx5\n                    c4y = y;                      // dy5\n                    x = c4x + stack.shift();      // dx6\n                    p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                    p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                    break;\n                case 36: // hflex1\n                    // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n                    c1x = x   + stack.shift();    // dx1\n                    c1y = y   + stack.shift();    // dy1\n                    c2x = c1x + stack.shift();    // dx2\n                    c2y = c1y + stack.shift();    // dy2\n                    jpx = c2x + stack.shift();    // dx3\n                    jpy = c2y;                    // dy3\n                    c3x = jpx + stack.shift();    // dx4\n                    c3y = c2y;                    // dy4\n                    c4x = c3x + stack.shift();    // dx5\n                    c4y = c3y + stack.shift();    // dy5\n                    x = c4x + stack.shift();      // dx6\n                    p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                    p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                    break;\n                case 37: // flex1\n                    // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n                    c1x = x   + stack.shift();    // dx1\n                    c1y = y   + stack.shift();    // dy1\n                    c2x = c1x + stack.shift();    // dx2\n                    c2y = c1y + stack.shift();    // dy2\n                    jpx = c2x + stack.shift();    // dx3\n                    jpy = c2y + stack.shift();    // dy3\n                    c3x = jpx + stack.shift();    // dx4\n                    c3y = jpy + stack.shift();    // dy4\n                    c4x = c3x + stack.shift();    // dx5\n                    c4y = c3y + stack.shift();    // dy5\n                    if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n                        x = c4x + stack.shift();\n                    } else {\n                        y = c4y + stack.shift();\n                    }\n\n                    p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                    p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                    break;\n                default:\n                    console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);\n                    stack.length = 0;\n                }\n                break;\n            case 14: // endchar\n                if (stack.length > 0 && !haveWidth) {\n                    width = stack.shift() + font.nominalWidthX;\n                    haveWidth = true;\n                }\n\n                if (open) {\n                    p.closePath();\n                    open = false;\n                }\n\n                break;\n            case 18: // hstemhm\n                parseStems();\n                break;\n            case 19: // hintmask\n            case 20: // cntrmask\n                parseStems();\n                i += (nStems + 7) >> 3;\n                break;\n            case 21: // rmoveto\n                if (stack.length > 2 && !haveWidth) {\n                    width = stack.shift() + font.nominalWidthX;\n                    haveWidth = true;\n                }\n\n                y += stack.pop();\n                x += stack.pop();\n                newContour(x, y);\n                break;\n            case 22: // hmoveto\n                if (stack.length > 1 && !haveWidth) {\n                    width = stack.shift() + font.nominalWidthX;\n                    haveWidth = true;\n                }\n\n                x += stack.pop();\n                newContour(x, y);\n                break;\n            case 23: // vstemhm\n                parseStems();\n                break;\n            case 24: // rcurveline\n                while (stack.length > 2) {\n                    c1x = x + stack.shift();\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + stack.shift();\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                }\n\n                x += stack.shift();\n                y += stack.shift();\n                p.lineTo(x, y);\n                break;\n            case 25: // rlinecurve\n                while (stack.length > 6) {\n                    x += stack.shift();\n                    y += stack.shift();\n                    p.lineTo(x, y);\n                }\n\n                c1x = x + stack.shift();\n                c1y = y + stack.shift();\n                c2x = c1x + stack.shift();\n                c2y = c1y + stack.shift();\n                x = c2x + stack.shift();\n                y = c2y + stack.shift();\n                p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                break;\n            case 26: // vvcurveto\n                if (stack.length % 2) {\n                    x += stack.shift();\n                }\n\n                while (stack.length > 0) {\n                    c1x = x;\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x;\n                    y = c2y + stack.shift();\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                }\n\n                break;\n            case 27: // hhcurveto\n                if (stack.length % 2) {\n                    y += stack.shift();\n                }\n\n                while (stack.length > 0) {\n                    c1x = x + stack.shift();\n                    c1y = y;\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y;\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                }\n\n                break;\n            case 28: // shortint\n                b1 = code[i];\n                b2 = code[i + 1];\n                stack.push(((b1 << 24) | (b2 << 16)) >> 16);\n                i += 2;\n                break;\n            case 29: // callgsubr\n                codeIndex = stack.pop() + font.gsubrsBias;\n                subrCode = font.gsubrs[codeIndex];\n                if (subrCode) {\n                    parse(subrCode);\n                }\n\n                break;\n            case 30: // vhcurveto\n                while (stack.length > 0) {\n                    c1x = x;\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    if (stack.length === 0) {\n                        break;\n                    }\n\n                    c1x = x + stack.shift();\n                    c1y = y;\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    y = c2y + stack.shift();\n                    x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                }\n\n                break;\n            case 31: // hvcurveto\n                while (stack.length > 0) {\n                    c1x = x + stack.shift();\n                    c1y = y;\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    y = c2y + stack.shift();\n                    x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    if (stack.length === 0) {\n                        break;\n                    }\n\n                    c1x = x;\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                }\n\n                break;\n            default:\n                if (v < 32) {\n                    console.log('Glyph ' + glyph.index + ': unknown operator ' + v);\n                } else if (v < 247) {\n                    stack.push(v - 139);\n                } else if (v < 251) {\n                    b1 = code[i];\n                    i += 1;\n                    stack.push((v - 247) * 256 + b1 + 108);\n                } else if (v < 255) {\n                    b1 = code[i];\n                    i += 1;\n                    stack.push(-(v - 251) * 256 - b1 - 108);\n                } else {\n                    b1 = code[i];\n                    b2 = code[i + 1];\n                    b3 = code[i + 2];\n                    b4 = code[i + 3];\n                    i += 4;\n                    stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);\n                }\n            }\n        }\n    }\n\n    parse(code);\n\n    glyph.advanceWidth = width;\n    return p;\n}\n\n// Subroutines are encoded using the negative half of the number space.\n// See type 2 chapter 4.7 \"Subroutine operators\".\nfunction calcCFFSubroutineBias(subrs) {\n    var bias;\n    if (subrs.length < 1240) {\n        bias = 107;\n    } else if (subrs.length < 33900) {\n        bias = 1131;\n    } else {\n        bias = 32768;\n    }\n\n    return bias;\n}\n\n// Parse the `CFF` table, which contains the glyph outlines in PostScript format.\nfunction parseCFFTable(data, start, font) {\n    font.tables.cff = {};\n    var header = parseCFFHeader(data, start);\n    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);\n    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);\n    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);\n    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);\n    font.gsubrs = globalSubrIndex.objects;\n    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);\n\n    var topDictData = new DataView(new Uint8Array(topDictIndex.objects[0]).buffer);\n    var topDict = parseCFFTopDict(topDictData, stringIndex.objects);\n    font.tables.cff.topDict = topDict;\n\n    var privateDictOffset = start + topDict['private'][1];\n    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict['private'][0], stringIndex.objects);\n    font.defaultWidthX = privateDict.defaultWidthX;\n    font.nominalWidthX = privateDict.nominalWidthX;\n\n    if (privateDict.subrs !== 0) {\n        var subrOffset = privateDictOffset + privateDict.subrs;\n        var subrIndex = parseCFFIndex(data, subrOffset);\n        font.subrs = subrIndex.objects;\n        font.subrsBias = calcCFFSubroutineBias(font.subrs);\n    } else {\n        font.subrs = [];\n        font.subrsBias = 0;\n    }\n\n    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n    var charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);\n    font.nGlyphs = charStringsIndex.objects.length;\n\n    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);\n    if (topDict.encoding === 0) { // Standard encoding\n        font.cffEncoding = new encoding.CffEncoding(encoding.cffStandardEncoding, charset);\n    } else if (topDict.encoding === 1) { // Expert encoding\n        font.cffEncoding = new encoding.CffEncoding(encoding.cffExpertEncoding, charset);\n    } else {\n        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);\n    }\n\n    // Prefer the CMAP encoding to the CFF encoding.\n    font.encoding = font.encoding || font.cffEncoding;\n\n    font.glyphs = new glyphset.GlyphSet(font);\n    for (var i = 0; i < font.nGlyphs; i += 1) {\n        var charString = charStringsIndex.objects[i];\n        font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n    }\n}\n\n// Convert a string to a String ID (SID).\n// The list of strings is modified in place.\nfunction encodeString(s, strings) {\n    var sid;\n\n    // Is the string in the CFF standard strings?\n    var i = encoding.cffStandardStrings.indexOf(s);\n    if (i >= 0) {\n        sid = i;\n    }\n\n    // Is the string already in the string index?\n    i = strings.indexOf(s);\n    if (i >= 0) {\n        sid = i + encoding.cffStandardStrings.length;\n    } else {\n        sid = encoding.cffStandardStrings.length + strings.length;\n        strings.push(s);\n    }\n\n    return sid;\n}\n\nfunction makeHeader() {\n    return new table.Table('Header', [\n        {name: 'major', type: 'Card8', value: 1},\n        {name: 'minor', type: 'Card8', value: 0},\n        {name: 'hdrSize', type: 'Card8', value: 4},\n        {name: 'major', type: 'Card8', value: 1}\n    ]);\n}\n\nfunction makeNameIndex(fontNames) {\n    var t = new table.Table('Name INDEX', [\n        {name: 'names', type: 'INDEX', value: []}\n    ]);\n    t.names = [];\n    for (var i = 0; i < fontNames.length; i += 1) {\n        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});\n    }\n\n    return t;\n}\n\n// Given a dictionary's metadata, create a DICT structure.\nfunction makeDict(meta, attrs, strings) {\n    var m = {};\n    for (var i = 0; i < meta.length; i += 1) {\n        var entry = meta[i];\n        var value = attrs[entry.name];\n        if (value !== undefined && !equals(value, entry.value)) {\n            if (entry.type === 'SID') {\n                value = encodeString(value, strings);\n            }\n\n            m[entry.op] = {name: entry.name, type: entry.type, value: value};\n        }\n    }\n\n    return m;\n}\n\n// The Top DICT houses the global font attributes.\nfunction makeTopDict(attrs, strings) {\n    var t = new table.Table('Top DICT', [\n        {name: 'dict', type: 'DICT', value: {}}\n    ]);\n    t.dict = makeDict(TOP_DICT_META, attrs, strings);\n    return t;\n}\n\nfunction makeTopDictIndex(topDict) {\n    var t = new table.Table('Top DICT INDEX', [\n        {name: 'topDicts', type: 'INDEX', value: []}\n    ]);\n    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];\n    return t;\n}\n\nfunction makeStringIndex(strings) {\n    var t = new table.Table('String INDEX', [\n        {name: 'strings', type: 'INDEX', value: []}\n    ]);\n    t.strings = [];\n    for (var i = 0; i < strings.length; i += 1) {\n        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});\n    }\n\n    return t;\n}\n\nfunction makeGlobalSubrIndex() {\n    // Currently we don't use subroutines.\n    return new table.Table('Global Subr INDEX', [\n        {name: 'subrs', type: 'INDEX', value: []}\n    ]);\n}\n\nfunction makeCharsets(glyphNames, strings) {\n    var t = new table.Table('Charsets', [\n        {name: 'format', type: 'Card8', value: 0}\n    ]);\n    for (var i = 0; i < glyphNames.length; i += 1) {\n        var glyphName = glyphNames[i];\n        var glyphSID = encodeString(glyphName, strings);\n        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});\n    }\n\n    return t;\n}\n\nfunction glyphToOps(glyph) {\n    var ops = [];\n    var path = glyph.path;\n    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});\n    var x = 0;\n    var y = 0;\n    for (var i = 0; i < path.commands.length; i += 1) {\n        var dx;\n        var dy;\n        var cmd = path.commands[i];\n        if (cmd.type === 'Q') {\n            // CFF only supports bézier curves, so convert the quad to a bézier.\n            var _13 = 1 / 3;\n            var _23 = 2 / 3;\n\n            // We're going to create a new command so we don't change the original path.\n            cmd = {\n                type: 'C',\n                x: cmd.x,\n                y: cmd.y,\n                x1: _13 * x + _23 * cmd.x1,\n                y1: _13 * y + _23 * cmd.y1,\n                x2: _13 * cmd.x + _23 * cmd.x1,\n                y2: _13 * cmd.y + _23 * cmd.y1\n            };\n        }\n\n        if (cmd.type === 'M') {\n            dx = Math.round(cmd.x - x);\n            dy = Math.round(cmd.y - y);\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rmoveto', type: 'OP', value: 21});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        } else if (cmd.type === 'L') {\n            dx = Math.round(cmd.x - x);\n            dy = Math.round(cmd.y - y);\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rlineto', type: 'OP', value: 5});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        } else if (cmd.type === 'C') {\n            var dx1 = Math.round(cmd.x1 - x);\n            var dy1 = Math.round(cmd.y1 - y);\n            var dx2 = Math.round(cmd.x2 - cmd.x1);\n            var dy2 = Math.round(cmd.y2 - cmd.y1);\n            dx = Math.round(cmd.x - cmd.x2);\n            dy = Math.round(cmd.y - cmd.y2);\n            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});\n            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});\n            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});\n            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rrcurveto', type: 'OP', value: 8});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        }\n\n        // Contours are closed automatically.\n\n    }\n\n    ops.push({name: 'endchar', type: 'OP', value: 14});\n    return ops;\n}\n\nfunction makeCharStringsIndex(glyphs) {\n    var t = new table.Table('CharStrings INDEX', [\n        {name: 'charStrings', type: 'INDEX', value: []}\n    ]);\n\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs.get(i);\n        var ops = glyphToOps(glyph);\n        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});\n    }\n\n    return t;\n}\n\nfunction makePrivateDict(attrs, strings) {\n    var t = new table.Table('Private DICT', [\n        {name: 'dict', type: 'DICT', value: {}}\n    ]);\n    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);\n    return t;\n}\n\nfunction makePrivateDictIndex(privateDict) {\n    var t = new table.Table('Private DICT INDEX', [\n        {name: 'privateDicts', type: 'INDEX', value: []}\n    ]);\n    t.privateDicts = [{name: 'privateDict_0', type: 'TABLE', value: privateDict}];\n    return t;\n}\n\nfunction makeCFFTable(glyphs, options) {\n    var t = new table.Table('CFF ', [\n        {name: 'header', type: 'TABLE'},\n        {name: 'nameIndex', type: 'TABLE'},\n        {name: 'topDictIndex', type: 'TABLE'},\n        {name: 'stringIndex', type: 'TABLE'},\n        {name: 'globalSubrIndex', type: 'TABLE'},\n        {name: 'charsets', type: 'TABLE'},\n        {name: 'charStringsIndex', type: 'TABLE'},\n        {name: 'privateDictIndex', type: 'TABLE'}\n    ]);\n\n    var fontScale = 1 / options.unitsPerEm;\n    // We use non-zero values for the offsets so that the DICT encodes them.\n    // This is important because the size of the Top DICT plays a role in offset calculation,\n    // and the size shouldn't change after we've written correct offsets.\n    var attrs = {\n        version: options.version,\n        fullName: options.fullName,\n        familyName: options.familyName,\n        weight: options.weightName,\n        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],\n        charset: 999,\n        encoding: 0,\n        charStrings: 999,\n        private: [0, 999]\n    };\n\n    var privateAttrs = {};\n\n    var glyphNames = [];\n    var glyph;\n\n    // Skip first glyph (.notdef)\n    for (var i = 1; i < glyphs.length; i += 1) {\n        glyph = glyphs.get(i);\n        glyphNames.push(glyph.name);\n    }\n\n    var strings = [];\n\n    t.header = makeHeader();\n    t.nameIndex = makeNameIndex([options.postScriptName]);\n    var topDict = makeTopDict(attrs, strings);\n    t.topDictIndex = makeTopDictIndex(topDict);\n    t.globalSubrIndex = makeGlobalSubrIndex();\n    t.charsets = makeCharsets(glyphNames, strings);\n    t.charStringsIndex = makeCharStringsIndex(glyphs);\n    var privateDict = makePrivateDict(privateAttrs, strings);\n    t.privateDictIndex = makePrivateDictIndex(privateDict);\n\n    // Needs to come at the end, to encode all custom strings used in the font.\n    t.stringIndex = makeStringIndex(strings);\n\n    var startOffset = t.header.sizeOf() +\n        t.nameIndex.sizeOf() +\n        t.topDictIndex.sizeOf() +\n        t.stringIndex.sizeOf() +\n        t.globalSubrIndex.sizeOf();\n    attrs.charset = startOffset;\n\n    // We use the CFF standard encoding; proper encoding will be handled in cmap.\n    attrs.encoding = 0;\n    attrs.charStrings = attrs.charset + t.charsets.sizeOf();\n    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();\n\n    // Recreate the Top DICT INDEX with the correct offsets.\n    topDict = makeTopDict(attrs, strings);\n    t.topDictIndex = makeTopDictIndex(topDict);\n\n    return t;\n}\n\nexports.parse = parseCFFTable;\nexports.make = makeCFFTable;\n\n},{\"../encoding\":3,\"../glyphset\":6,\"../parse\":8,\"../path\":9,\"../table\":10}],12:[function(require,module,exports){\n// The `cmap` table stores the mappings from characters to glyphs.\n// https://www.microsoft.com/typography/OTSPEC/cmap.htm\n\n'use strict';\n\nvar check = require('../check');\nvar parse = require('../parse');\nvar table = require('../table');\n\n// Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n// There are many available formats, but we only support the Windows format 4.\n// This function returns a `CmapEncoding` object or null if no supported format could be found.\nfunction parseCmapTable(data, start) {\n    var i;\n    var cmap = {};\n    cmap.version = parse.getUShort(data, start);\n    check.argument(cmap.version === 0, 'cmap table version should be 0.');\n\n    // The cmap table can contain many sub-tables, each with their own format.\n    // We're only interested in a \"platform 3\" table. This is a Windows format.\n    cmap.numTables = parse.getUShort(data, start + 2);\n    var offset = -1;\n    for (i = 0; i < cmap.numTables; i += 1) {\n        var platformId = parse.getUShort(data, start + 4 + (i * 8));\n        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);\n        if (platformId === 3 && (encodingId === 1 || encodingId === 0)) {\n            offset = parse.getULong(data, start + 4 + (i * 8) + 4);\n            break;\n        }\n    }\n\n    if (offset === -1) {\n        // There is no cmap table in the font that we support, so return null.\n        // This font will be marked as unsupported.\n        return null;\n    }\n\n    var p = new parse.Parser(data, start + offset);\n    cmap.format = p.parseUShort();\n    check.argument(cmap.format === 4, 'Only format 4 cmap tables are supported.');\n\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseUShort();\n    cmap.language = p.parseUShort();\n\n    // segCount is stored x 2.\n    var segCount;\n    cmap.segCount = segCount = p.parseUShort() >> 1;\n\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n\n    // The \"unrolled\" mapping from character codes to glyph indices.\n    cmap.glyphIndexMap = {};\n\n    var endCountParser = new parse.Parser(data, start + offset + 14);\n    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);\n    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);\n    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);\n    var glyphIndexOffset = start + offset + 16 + segCount * 8;\n    for (i = 0; i < segCount - 1; i += 1) {\n        var glyphIndex;\n        var endCount = endCountParser.parseUShort();\n        var startCount = startCountParser.parseUShort();\n        var idDelta = idDeltaParser.parseShort();\n        var idRangeOffset = idRangeOffsetParser.parseUShort();\n        for (var c = startCount; c <= endCount; c += 1) {\n            if (idRangeOffset !== 0) {\n                // The idRangeOffset is relative to the current position in the idRangeOffset array.\n                // Take the current offset in the idRangeOffset array.\n                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);\n\n                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n                glyphIndexOffset += idRangeOffset;\n\n                // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n                glyphIndexOffset += (c - startCount) * 2;\n                glyphIndex = parse.getUShort(data, glyphIndexOffset);\n                if (glyphIndex !== 0) {\n                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;\n                }\n            } else {\n                glyphIndex = (c + idDelta) & 0xFFFF;\n            }\n\n            cmap.glyphIndexMap[c] = glyphIndex;\n        }\n    }\n\n    return cmap;\n}\n\nfunction addSegment(t, code, glyphIndex) {\n    t.segments.push({\n        end: code,\n        start: code,\n        delta: -(code - glyphIndex),\n        offset: 0\n    });\n}\n\nfunction addTerminatorSegment(t) {\n    t.segments.push({\n        end: 0xFFFF,\n        start: 0xFFFF,\n        delta: 1,\n        offset: 0\n    });\n}\n\nfunction makeCmapTable(glyphs) {\n    var i;\n    var t = new table.Table('cmap', [\n        {name: 'version', type: 'USHORT', value: 0},\n        {name: 'numTables', type: 'USHORT', value: 1},\n        {name: 'platformID', type: 'USHORT', value: 3},\n        {name: 'encodingID', type: 'USHORT', value: 1},\n        {name: 'offset', type: 'ULONG', value: 12},\n        {name: 'format', type: 'USHORT', value: 4},\n        {name: 'length', type: 'USHORT', value: 0},\n        {name: 'language', type: 'USHORT', value: 0},\n        {name: 'segCountX2', type: 'USHORT', value: 0},\n        {name: 'searchRange', type: 'USHORT', value: 0},\n        {name: 'entrySelector', type: 'USHORT', value: 0},\n        {name: 'rangeShift', type: 'USHORT', value: 0}\n    ]);\n\n    t.segments = [];\n    for (i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs.get(i);\n        for (var j = 0; j < glyph.unicodes.length; j += 1) {\n            addSegment(t, glyph.unicodes[j], i);\n        }\n\n        t.segments = t.segments.sort(function(a, b) {\n            return a.start - b.start;\n        });\n    }\n\n    addTerminatorSegment(t);\n\n    var segCount;\n    segCount = t.segments.length;\n    t.segCountX2 = segCount * 2;\n    t.searchRange = Math.pow(2, Math.floor(Math.log(segCount) / Math.log(2))) * 2;\n    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);\n    t.rangeShift = t.segCountX2 - t.searchRange;\n\n    // Set up parallel segment arrays.\n    var endCounts = [];\n    var startCounts = [];\n    var idDeltas = [];\n    var idRangeOffsets = [];\n    var glyphIds = [];\n\n    for (i = 0; i < segCount; i += 1) {\n        var segment = t.segments[i];\n        endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});\n        startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});\n        idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});\n        idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});\n        if (segment.glyphId !== undefined) {\n            glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});\n        }\n    }\n\n    t.fields = t.fields.concat(endCounts);\n    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});\n    t.fields = t.fields.concat(startCounts);\n    t.fields = t.fields.concat(idDeltas);\n    t.fields = t.fields.concat(idRangeOffsets);\n    t.fields = t.fields.concat(glyphIds);\n\n    t.length = 14 + // Subtable header\n        endCounts.length * 2 +\n        2 + // reservedPad\n        startCounts.length * 2 +\n        idDeltas.length * 2 +\n        idRangeOffsets.length * 2 +\n        glyphIds.length * 2;\n\n    return t;\n}\n\nexports.parse = parseCmapTable;\nexports.make = makeCmapTable;\n\n},{\"../check\":1,\"../parse\":8,\"../table\":10}],13:[function(require,module,exports){\n// The `glyf` table describes the glyphs in TrueType outline format.\n// http://www.microsoft.com/typography/otspec/glyf.htm\n\n'use strict';\n\nvar check = require('../check');\nvar glyphset = require('../glyphset');\nvar parse = require('../parse');\nvar path = require('../path');\n\n// Parse the coordinate data for a glyph.\nfunction parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n    var v;\n    if ((flag & shortVectorBitMask) > 0) {\n        // The coordinate is 1 byte long.\n        v = p.parseByte();\n        // The `same` bit is re-used for short values to signify the sign of the value.\n        if ((flag & sameBitMask) === 0) {\n            v = -v;\n        }\n\n        v = previousValue + v;\n    } else {\n        //  The coordinate is 2 bytes long.\n        // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n        if ((flag & sameBitMask) > 0) {\n            v = previousValue;\n        } else {\n            // Parse the coordinate as a signed 16-bit delta value.\n            v = previousValue + p.parseShort();\n        }\n    }\n\n    return v;\n}\n\n// Parse a TrueType glyph.\nfunction parseGlyph(glyph, data, start) {\n    var p = new parse.Parser(data, start);\n    glyph.numberOfContours = p.parseShort();\n    glyph.xMin = p.parseShort();\n    glyph.yMin = p.parseShort();\n    glyph.xMax = p.parseShort();\n    glyph.yMax = p.parseShort();\n    var flags;\n    var flag;\n    if (glyph.numberOfContours > 0) {\n        var i;\n        // This glyph is not a composite.\n        var endPointIndices = glyph.endPointIndices = [];\n        for (i = 0; i < glyph.numberOfContours; i += 1) {\n            endPointIndices.push(p.parseUShort());\n        }\n\n        glyph.instructionLength = p.parseUShort();\n        glyph.instructions = [];\n        for (i = 0; i < glyph.instructionLength; i += 1) {\n            glyph.instructions.push(p.parseByte());\n        }\n\n        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;\n        flags = [];\n        for (i = 0; i < numberOfCoordinates; i += 1) {\n            flag = p.parseByte();\n            flags.push(flag);\n            // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n            if ((flag & 8) > 0) {\n                var repeatCount = p.parseByte();\n                for (var j = 0; j < repeatCount; j += 1) {\n                    flags.push(flag);\n                    i += 1;\n                }\n            }\n        }\n\n        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');\n\n        if (endPointIndices.length > 0) {\n            var points = [];\n            var point;\n            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n            if (numberOfCoordinates > 0) {\n                for (i = 0; i < numberOfCoordinates; i += 1) {\n                    flag = flags[i];\n                    point = {};\n                    point.onCurve = !!(flag & 1);\n                    point.lastPointOfContour = endPointIndices.indexOf(i) >= 0;\n                    points.push(point);\n                }\n\n                var px = 0;\n                for (i = 0; i < numberOfCoordinates; i += 1) {\n                    flag = flags[i];\n                    point = points[i];\n                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);\n                    px = point.x;\n                }\n\n                var py = 0;\n                for (i = 0; i < numberOfCoordinates; i += 1) {\n                    flag = flags[i];\n                    point = points[i];\n                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);\n                    py = point.y;\n                }\n            }\n\n            glyph.points = points;\n        } else {\n            glyph.points = [];\n        }\n    } else if (glyph.numberOfContours === 0) {\n        glyph.points = [];\n    } else {\n        glyph.isComposite = true;\n        glyph.points = [];\n        glyph.components = [];\n        var moreComponents = true;\n        while (moreComponents) {\n            flags = p.parseUShort();\n            var component = {\n                glyphIndex: p.parseUShort(),\n                xScale: 1,\n                scale01: 0,\n                scale10: 0,\n                yScale: 1,\n                dx: 0,\n                dy: 0\n            };\n            if ((flags & 1) > 0) {\n                // The arguments are words\n                component.dx = p.parseShort();\n                component.dy = p.parseShort();\n            } else {\n                // The arguments are bytes\n                component.dx = p.parseChar();\n                component.dy = p.parseChar();\n            }\n\n            if ((flags & 8) > 0) {\n                // We have a scale\n                component.xScale = component.yScale = p.parseF2Dot14();\n            } else if ((flags & 64) > 0) {\n                // We have an X / Y scale\n                component.xScale = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            } else if ((flags & 128) > 0) {\n                // We have a 2x2 transformation\n                component.xScale = p.parseF2Dot14();\n                component.scale01 = p.parseF2Dot14();\n                component.scale10 = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            }\n\n            glyph.components.push(component);\n            moreComponents = !!(flags & 32);\n        }\n    }\n}\n\n// Transform an array of points and return a new array.\nfunction transformPoints(points, transform) {\n    var newPoints = [];\n    for (var i = 0; i < points.length; i += 1) {\n        var pt = points[i];\n        var newPt = {\n            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n            onCurve: pt.onCurve,\n            lastPointOfContour: pt.lastPointOfContour\n        };\n        newPoints.push(newPt);\n    }\n\n    return newPoints;\n}\n\nfunction getContours(points) {\n    var contours = [];\n    var currentContour = [];\n    for (var i = 0; i < points.length; i += 1) {\n        var pt = points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n    return contours;\n}\n\n// Convert the TrueType glyph outline to a Path.\nfunction getPath(points) {\n    var p = new path.Path();\n    if (!points) {\n        return p;\n    }\n\n    var contours = getContours(points);\n    for (var i = 0; i < contours.length; i += 1) {\n        var contour = contours[i];\n        var firstPt = contour[0];\n        var lastPt = contour[contour.length - 1];\n        var curvePt;\n        var realFirstPoint;\n        if (firstPt.onCurve) {\n            curvePt = null;\n            // The first point will be consumed by the moveTo command,\n            // so skip it in the loop.\n            realFirstPoint = true;\n        } else {\n            if (lastPt.onCurve) {\n                // If the first point is off-curve and the last point is on-curve,\n                // start at the last point.\n                firstPt = lastPt;\n            } else {\n                // If both first and last points are off-curve, start at their middle.\n                firstPt = { x: (firstPt.x + lastPt.x) / 2, y: (firstPt.y + lastPt.y) / 2 };\n            }\n\n            curvePt = firstPt;\n            // The first point is synthesized, so don't skip the real first point.\n            realFirstPoint = false;\n        }\n\n        p.moveTo(firstPt.x, firstPt.y);\n\n        for (var j = realFirstPoint ? 1 : 0; j < contour.length; j += 1) {\n            var pt = contour[j];\n            var prevPt = j === 0 ? firstPt : contour[j - 1];\n            if (prevPt.onCurve && pt.onCurve) {\n                // This is a straight line.\n                p.lineTo(pt.x, pt.y);\n            } else if (prevPt.onCurve && !pt.onCurve) {\n                curvePt = pt;\n            } else if (!prevPt.onCurve && !pt.onCurve) {\n                var midPt = { x: (prevPt.x + pt.x) / 2, y: (prevPt.y + pt.y) / 2 };\n                p.quadraticCurveTo(prevPt.x, prevPt.y, midPt.x, midPt.y);\n                curvePt = pt;\n            } else if (!prevPt.onCurve && pt.onCurve) {\n                // Previous point off-curve, this point on-curve.\n                p.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);\n                curvePt = null;\n            } else {\n                throw new Error('Invalid state.');\n            }\n        }\n\n        if (firstPt !== lastPt) {\n            // Connect the last and first points\n            if (curvePt) {\n                p.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);\n            } else {\n                p.lineTo(firstPt.x, firstPt.y);\n            }\n        }\n    }\n\n    p.closePath();\n    return p;\n}\n\nfunction buildPath(glyphs, glyph) {\n    if (glyph.isComposite) {\n        for (var j = 0; j < glyph.components.length; j += 1) {\n            var component = glyph.components[j];\n            var componentGlyph = glyphs.get(component.glyphIndex);\n            if (componentGlyph.points) {\n                var transformedPoints = transformPoints(componentGlyph.points, component);\n                glyph.points = glyph.points.concat(transformedPoints);\n            }\n        }\n    }\n\n    return getPath(glyph.points);\n}\n\n// Parse all the glyphs according to the offsets from the `loca` table.\nfunction parseGlyfTable(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font);\n    var i;\n\n    // The last element of the loca table is invalid.\n    for (i = 0; i < loca.length - 1; i += 1) {\n        var offset = loca[i];\n        var nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    }\n\n    return glyphs;\n}\n\nexports.parse = parseGlyfTable;\n\n},{\"../check\":1,\"../glyphset\":6,\"../parse\":8,\"../path\":9}],14:[function(require,module,exports){\n// The `GPOS` table contains kerning pairs, among other things.\n// https://www.microsoft.com/typography/OTSPEC/gpos.htm\n\n'use strict';\n\nvar check = require('../check');\nvar parse = require('../parse');\n\n// Parse ScriptList and FeatureList tables of GPOS, GSUB, GDEF, BASE, JSTF tables.\n// These lists are unused by now, this function is just the basis for a real parsing.\nfunction parseTaggedListTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var n = p.parseUShort();\n    var list = [];\n    for (var i = 0; i < n; i++) {\n        list[p.parseTag()] = { offset: p.parseUShort() };\n    }\n\n    return list;\n}\n\n// Parse a coverage table in a GSUB, GPOS or GDEF table.\n// Format 1 is a simple list of glyph ids,\n// Format 2 is a list of ranges. It is expanded in a list of glyphs, maybe not the best idea.\nfunction parseCoverageTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var format = p.parseUShort();\n    var count =  p.parseUShort();\n    if (format === 1) {\n        return p.parseUShortList(count);\n    }\n    else if (format === 2) {\n        var coverage = [];\n        for (; count--;) {\n            var begin = p.parseUShort();\n            var end = p.parseUShort();\n            var index = p.parseUShort();\n            for (var i = begin; i <= end; i++) {\n                coverage[index++] = i;\n            }\n        }\n\n        return coverage;\n    }\n}\n\n// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n// Returns a function that gets a class value from a glyph ID.\nfunction parseClassDefTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var format = p.parseUShort();\n    if (format === 1) {\n        // Format 1 specifies a range of consecutive glyph indices, one class per glyph ID.\n        var startGlyph = p.parseUShort();\n        var glyphCount = p.parseUShort();\n        var classes = p.parseUShortList(glyphCount);\n        return function(glyphID) {\n            return classes[glyphID - startGlyph] || 0;\n        };\n    }\n    else if (format === 2) {\n        // Format 2 defines multiple groups of glyph indices that belong to the same class.\n        var rangeCount = p.parseUShort();\n        var startGlyphs = [];\n        var endGlyphs = [];\n        var classValues = [];\n        for (var i = 0; i < rangeCount; i++) {\n            startGlyphs[i] = p.parseUShort();\n            endGlyphs[i] = p.parseUShort();\n            classValues[i] = p.parseUShort();\n        }\n\n        return function(glyphID) {\n            var l = 0;\n            var r = startGlyphs.length - 1;\n            while (l < r) {\n                var c = (l + r + 1) >> 1;\n                if (glyphID < startGlyphs[c]) {\n                    r = c - 1;\n                } else {\n                    l = c;\n                }\n            }\n\n            if (startGlyphs[l] <= glyphID && glyphID <= endGlyphs[l]) {\n                return classValues[l] || 0;\n            }\n\n            return 0;\n        };\n    }\n}\n\n// Parse a pair adjustment positioning subtable, format 1 or format 2\n// The subtable is returned in the form of a lookup function.\nfunction parsePairPosSubTable(data, start) {\n    var p = new parse.Parser(data, start);\n    // This part is common to format 1 and format 2 subtables\n    var format = p.parseUShort();\n    var coverageOffset = p.parseUShort();\n    var coverage = parseCoverageTable(data, start + coverageOffset);\n    // valueFormat 4: XAdvance only, 1: XPlacement only, 0: no ValueRecord for second glyph\n    // Only valueFormat1=4 and valueFormat2=0 is supported.\n    var valueFormat1 = p.parseUShort();\n    var valueFormat2 = p.parseUShort();\n    var value1;\n    var value2;\n    if (valueFormat1 !== 4 || valueFormat2 !== 0) return;\n    var sharedPairSets = {};\n    if (format === 1) {\n        // Pair Positioning Adjustment: Format 1\n        var pairSetCount = p.parseUShort();\n        var pairSet = [];\n        // Array of offsets to PairSet tables-from beginning of PairPos subtable-ordered by Coverage Index\n        var pairSetOffsets = p.parseOffset16List(pairSetCount);\n        for (var firstGlyph = 0; firstGlyph < pairSetCount; firstGlyph++) {\n            var pairSetOffset = pairSetOffsets[firstGlyph];\n            var sharedPairSet = sharedPairSets[pairSetOffset];\n            if (!sharedPairSet) {\n                // Parse a pairset table in a pair adjustment subtable format 1\n                sharedPairSet = {};\n                p.relativeOffset = pairSetOffset;\n                var pairValueCount = p.parseUShort();\n                for (; pairValueCount--;) {\n                    var secondGlyph = p.parseUShort();\n                    if (valueFormat1) value1 = p.parseShort();\n                    if (valueFormat2) value2 = p.parseShort();\n                    // We only support valueFormat1 = 4 and valueFormat2 = 0,\n                    // so value1 is the XAdvance and value2 is empty.\n                    sharedPairSet[secondGlyph] = value1;\n                }\n            }\n\n            pairSet[coverage[firstGlyph]] = sharedPairSet;\n        }\n\n        return function(leftGlyph, rightGlyph) {\n            var pairs = pairSet[leftGlyph];\n            if (pairs) return pairs[rightGlyph];\n        };\n    }\n    else if (format === 2) {\n        // Pair Positioning Adjustment: Format 2\n        var classDef1Offset = p.parseUShort();\n        var classDef2Offset = p.parseUShort();\n        var class1Count = p.parseUShort();\n        var class2Count = p.parseUShort();\n        var getClass1 = parseClassDefTable(data, start + classDef1Offset);\n        var getClass2 = parseClassDefTable(data, start + classDef2Offset);\n\n        // Parse kerning values by class pair.\n        var kerningMatrix = [];\n        for (var i = 0; i < class1Count; i++) {\n            var kerningRow = kerningMatrix[i] = [];\n            for (var j = 0; j < class2Count; j++) {\n                if (valueFormat1) value1 = p.parseShort();\n                if (valueFormat2) value2 = p.parseShort();\n                // We only support valueFormat1 = 4 and valueFormat2 = 0,\n                // so value1 is the XAdvance and value2 is empty.\n                kerningRow[j] = value1;\n            }\n        }\n\n        // Convert coverage list to a hash\n        var covered = {};\n        for (i = 0; i < coverage.length; i++) covered[coverage[i]] = 1;\n\n        // Get the kerning value for a specific glyph pair.\n        return function(leftGlyph, rightGlyph) {\n            if (!covered[leftGlyph]) return;\n            var class1 = getClass1(leftGlyph);\n            var class2 = getClass2(rightGlyph);\n            var kerningRow = kerningMatrix[class1];\n\n            if (kerningRow) {\n                return kerningRow[class2];\n            }\n        };\n    }\n}\n\n// Parse a LookupTable (present in of GPOS, GSUB, GDEF, BASE, JSTF tables).\nfunction parseLookupTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var lookupType = p.parseUShort();\n    var lookupFlag = p.parseUShort();\n    var useMarkFilteringSet = lookupFlag & 0x10;\n    var subTableCount = p.parseUShort();\n    var subTableOffsets = p.parseOffset16List(subTableCount);\n    var table = {\n        lookupType: lookupType,\n        lookupFlag: lookupFlag,\n        markFilteringSet: useMarkFilteringSet ? p.parseUShort() : -1\n    };\n    // LookupType 2, Pair adjustment\n    if (lookupType === 2) {\n        var subtables = [];\n        for (var i = 0; i < subTableCount; i++) {\n            subtables.push(parsePairPosSubTable(data, start + subTableOffsets[i]));\n        }\n        // Return a function which finds the kerning values in the subtables.\n        table.getKerningValue = function(leftGlyph, rightGlyph) {\n            for (var i = subtables.length; i--;) {\n                var value = subtables[i](leftGlyph, rightGlyph);\n                if (value !== undefined) return value;\n            }\n\n            return 0;\n        };\n    }\n\n    return table;\n}\n\n// Parse the `GPOS` table which contains, among other things, kerning pairs.\n// https://www.microsoft.com/typography/OTSPEC/gpos.htm\nfunction parseGposTable(data, start, font) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseFixed();\n    check.argument(tableVersion === 1, 'Unsupported GPOS table version.');\n\n    // ScriptList and FeatureList - ignored for now\n    parseTaggedListTable(data, start + p.parseUShort());\n    // 'kern' is the feature we are looking for.\n    parseTaggedListTable(data, start + p.parseUShort());\n\n    // LookupList\n    var lookupListOffset = p.parseUShort();\n    p.relativeOffset = lookupListOffset;\n    var lookupCount = p.parseUShort();\n    var lookupTableOffsets = p.parseOffset16List(lookupCount);\n    var lookupListAbsoluteOffset = start + lookupListOffset;\n    for (var i = 0; i < lookupCount; i++) {\n        var table = parseLookupTable(data, lookupListAbsoluteOffset + lookupTableOffsets[i]);\n        if (table.lookupType === 2 && !font.getGposKerningValue) font.getGposKerningValue = table.getKerningValue;\n    }\n}\n\nexports.parse = parseGposTable;\n\n},{\"../check\":1,\"../parse\":8}],15:[function(require,module,exports){\n// The `head` table contains global information about the font.\n// https://www.microsoft.com/typography/OTSPEC/head.htm\n\n'use strict';\n\nvar check = require('../check');\nvar parse = require('../parse');\nvar table = require('../table');\n\n// Parse the header `head` table\nfunction parseHeadTable(data, start) {\n    var head = {};\n    var p = new parse.Parser(data, start);\n    head.version = p.parseVersion();\n    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;\n    head.checkSumAdjustment = p.parseULong();\n    head.magicNumber = p.parseULong();\n    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');\n    head.flags = p.parseUShort();\n    head.unitsPerEm = p.parseUShort();\n    head.created = p.parseLongDateTime();\n    head.modified = p.parseLongDateTime();\n    head.xMin = p.parseShort();\n    head.yMin = p.parseShort();\n    head.xMax = p.parseShort();\n    head.yMax = p.parseShort();\n    head.macStyle = p.parseUShort();\n    head.lowestRecPPEM = p.parseUShort();\n    head.fontDirectionHint = p.parseShort();\n    head.indexToLocFormat = p.parseShort();     // 50\n    head.glyphDataFormat = p.parseShort();\n    return head;\n}\n\nfunction makeHeadTable(options) {\n    return new table.Table('head', [\n        {name: 'version', type: 'FIXED', value: 0x00010000},\n        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},\n        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},\n        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},\n        {name: 'flags', type: 'USHORT', value: 0},\n        {name: 'unitsPerEm', type: 'USHORT', value: 1000},\n        {name: 'created', type: 'LONGDATETIME', value: 0},\n        {name: 'modified', type: 'LONGDATETIME', value: 0},\n        {name: 'xMin', type: 'SHORT', value: 0},\n        {name: 'yMin', type: 'SHORT', value: 0},\n        {name: 'xMax', type: 'SHORT', value: 0},\n        {name: 'yMax', type: 'SHORT', value: 0},\n        {name: 'macStyle', type: 'USHORT', value: 0},\n        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},\n        {name: 'fontDirectionHint', type: 'SHORT', value: 2},\n        {name: 'indexToLocFormat', type: 'SHORT', value: 0},\n        {name: 'glyphDataFormat', type: 'SHORT', value: 0}\n    ], options);\n}\n\nexports.parse = parseHeadTable;\nexports.make = makeHeadTable;\n\n},{\"../check\":1,\"../parse\":8,\"../table\":10}],16:[function(require,module,exports){\n// The `hhea` table contains information for horizontal layout.\n// https://www.microsoft.com/typography/OTSPEC/hhea.htm\n\n'use strict';\n\nvar parse = require('../parse');\nvar table = require('../table');\n\n// Parse the horizontal header `hhea` table\nfunction parseHheaTable(data, start) {\n    var hhea = {};\n    var p = new parse.Parser(data, start);\n    hhea.version = p.parseVersion();\n    hhea.ascender = p.parseShort();\n    hhea.descender = p.parseShort();\n    hhea.lineGap = p.parseShort();\n    hhea.advanceWidthMax = p.parseUShort();\n    hhea.minLeftSideBearing = p.parseShort();\n    hhea.minRightSideBearing = p.parseShort();\n    hhea.xMaxExtent = p.parseShort();\n    hhea.caretSlopeRise = p.parseShort();\n    hhea.caretSlopeRun = p.parseShort();\n    hhea.caretOffset = p.parseShort();\n    p.relativeOffset += 8;\n    hhea.metricDataFormat = p.parseShort();\n    hhea.numberOfHMetrics = p.parseUShort();\n    return hhea;\n}\n\nfunction makeHheaTable(options) {\n    return new table.Table('hhea', [\n        {name: 'version', type: 'FIXED', value: 0x00010000},\n        {name: 'ascender', type: 'FWORD', value: 0},\n        {name: 'descender', type: 'FWORD', value: 0},\n        {name: 'lineGap', type: 'FWORD', value: 0},\n        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},\n        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},\n        {name: 'minRightSideBearing', type: 'FWORD', value: 0},\n        {name: 'xMaxExtent', type: 'FWORD', value: 0},\n        {name: 'caretSlopeRise', type: 'SHORT', value: 1},\n        {name: 'caretSlopeRun', type: 'SHORT', value: 0},\n        {name: 'caretOffset', type: 'SHORT', value: 0},\n        {name: 'reserved1', type: 'SHORT', value: 0},\n        {name: 'reserved2', type: 'SHORT', value: 0},\n        {name: 'reserved3', type: 'SHORT', value: 0},\n        {name: 'reserved4', type: 'SHORT', value: 0},\n        {name: 'metricDataFormat', type: 'SHORT', value: 0},\n        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}\n    ], options);\n}\n\nexports.parse = parseHheaTable;\nexports.make = makeHheaTable;\n\n},{\"../parse\":8,\"../table\":10}],17:[function(require,module,exports){\n// The `hmtx` table contains the horizontal metrics for all glyphs.\n// https://www.microsoft.com/typography/OTSPEC/hmtx.htm\n\n'use strict';\n\nvar parse = require('../parse');\nvar table = require('../table');\n\n// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.\n// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.\nfunction parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {\n    var advanceWidth;\n    var leftSideBearing;\n    var p = new parse.Parser(data, start);\n    for (var i = 0; i < numGlyphs; i += 1) {\n        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n        if (i < numMetrics) {\n            advanceWidth = p.parseUShort();\n            leftSideBearing = p.parseShort();\n        }\n\n        var glyph = glyphs.get(i);\n        glyph.advanceWidth = advanceWidth;\n        glyph.leftSideBearing = leftSideBearing;\n    }\n}\n\nfunction makeHmtxTable(glyphs) {\n    var t = new table.Table('hmtx', []);\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs.get(i);\n        var advanceWidth = glyph.advanceWidth || 0;\n        var leftSideBearing = glyph.leftSideBearing || 0;\n        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});\n        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});\n    }\n\n    return t;\n}\n\nexports.parse = parseHmtxTable;\nexports.make = makeHmtxTable;\n\n},{\"../parse\":8,\"../table\":10}],18:[function(require,module,exports){\n// The `kern` table contains kerning pairs.\n// Note that some fonts use the GPOS OpenType layout table to specify kerning.\n// https://www.microsoft.com/typography/OTSPEC/kern.htm\n\n'use strict';\n\nvar check = require('../check');\nvar parse = require('../parse');\n\n// Parse the `kern` table which contains kerning pairs.\nfunction parseKernTable(data, start) {\n    var pairs = {};\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseUShort();\n    check.argument(tableVersion === 0, 'Unsupported kern table version.');\n    // Skip nTables.\n    p.skip('uShort', 1);\n    var subTableVersion = p.parseUShort();\n    check.argument(subTableVersion === 0, 'Unsupported kern sub-table version.');\n    // Skip subTableLength, subTableCoverage\n    p.skip('uShort', 2);\n    var nPairs = p.parseUShort();\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n    for (var i = 0; i < nPairs; i += 1) {\n        var leftIndex = p.parseUShort();\n        var rightIndex = p.parseUShort();\n        var value = p.parseShort();\n        pairs[leftIndex + ',' + rightIndex] = value;\n    }\n\n    return pairs;\n}\n\nexports.parse = parseKernTable;\n\n},{\"../check\":1,\"../parse\":8}],19:[function(require,module,exports){\n// The `loca` table stores the offsets to the locations of the glyphs in the font.\n// https://www.microsoft.com/typography/OTSPEC/loca.htm\n\n'use strict';\n\nvar parse = require('../parse');\n\n// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,\n// relative to the beginning of the glyphData table.\n// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)\n// The loca table has two versions: a short version where offsets are stored as uShorts, and a long\n// version where offsets are stored as uLongs. The `head` table specifies which version to use\n// (under indexToLocFormat).\nfunction parseLocaTable(data, start, numGlyphs, shortVersion) {\n    var p = new parse.Parser(data, start);\n    var parseFn = shortVersion ? p.parseUShort : p.parseULong;\n    // There is an extra entry after the last index element to compute the length of the last glyph.\n    // That's why we use numGlyphs + 1.\n    var glyphOffsets = [];\n    for (var i = 0; i < numGlyphs + 1; i += 1) {\n        var glyphOffset = parseFn.call(p);\n        if (shortVersion) {\n            // The short table version stores the actual offset divided by 2.\n            glyphOffset *= 2;\n        }\n\n        glyphOffsets.push(glyphOffset);\n    }\n\n    return glyphOffsets;\n}\n\nexports.parse = parseLocaTable;\n\n},{\"../parse\":8}],20:[function(require,module,exports){\n// The `maxp` table establishes the memory requirements for the font.\n// We need it just to get the number of glyphs in the font.\n// https://www.microsoft.com/typography/OTSPEC/maxp.htm\n\n'use strict';\n\nvar parse = require('../parse');\nvar table = require('../table');\n\n// Parse the maximum profile `maxp` table.\nfunction parseMaxpTable(data, start) {\n    var maxp = {};\n    var p = new parse.Parser(data, start);\n    maxp.version = p.parseVersion();\n    maxp.numGlyphs = p.parseUShort();\n    if (maxp.version === 1.0) {\n        maxp.maxPoints = p.parseUShort();\n        maxp.maxContours = p.parseUShort();\n        maxp.maxCompositePoints = p.parseUShort();\n        maxp.maxCompositeContours = p.parseUShort();\n        maxp.maxZones = p.parseUShort();\n        maxp.maxTwilightPoints = p.parseUShort();\n        maxp.maxStorage = p.parseUShort();\n        maxp.maxFunctionDefs = p.parseUShort();\n        maxp.maxInstructionDefs = p.parseUShort();\n        maxp.maxStackElements = p.parseUShort();\n        maxp.maxSizeOfInstructions = p.parseUShort();\n        maxp.maxComponentElements = p.parseUShort();\n        maxp.maxComponentDepth = p.parseUShort();\n    }\n\n    return maxp;\n}\n\nfunction makeMaxpTable(numGlyphs) {\n    return new table.Table('maxp', [\n        {name: 'version', type: 'FIXED', value: 0x00005000},\n        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}\n    ]);\n}\n\nexports.parse = parseMaxpTable;\nexports.make = makeMaxpTable;\n\n},{\"../parse\":8,\"../table\":10}],21:[function(require,module,exports){\n// The `name` naming table.\n// https://www.microsoft.com/typography/OTSPEC/name.htm\n\n'use strict';\n\nvar encode = require('../types').encode;\nvar parse = require('../parse');\nvar table = require('../table');\n\n// NameIDs for the name table.\nvar nameTableNames = [\n    'copyright',              // 0\n    'fontFamily',             // 1\n    'fontSubfamily',          // 2\n    'uniqueID',               // 3\n    'fullName',               // 4\n    'version',                // 5\n    'postScriptName',         // 6\n    'trademark',              // 7\n    'manufacturer',           // 8\n    'designer',               // 9\n    'description',            // 10\n    'manufacturerURL',        // 11\n    'designerURL',            // 12\n    'licence',                // 13\n    'licenceURL',             // 14\n    'reserved',               // 15\n    'preferredFamily',        // 16\n    'preferredSubfamily',     // 17\n    'compatibleFullName',     // 18\n    'sampleText',             // 19\n    'postScriptFindFontName', // 20\n    'wwsFamily',              // 21\n    'wwsSubfamily'            // 22\n];\n\n// Parse the naming `name` table\n// Only Windows Unicode English names are supported.\n// Format 1 additional fields are not supported\nfunction parseNameTable(data, start) {\n    var name = {};\n    var p = new parse.Parser(data, start);\n    name.format = p.parseUShort();\n    var count = p.parseUShort();\n    var stringOffset = p.offset + p.parseUShort();\n    var unknownCount = 0;\n    for (var i = 0; i < count; i++) {\n        var platformID = p.parseUShort();\n        var encodingID = p.parseUShort();\n        var languageID = p.parseUShort();\n        var nameID = p.parseUShort();\n        var property = nameTableNames[nameID];\n        var byteLength = p.parseUShort();\n        var offset = p.parseUShort();\n        // platformID - encodingID - languageID standard combinations :\n        // 1 - 0 - 0 : Macintosh, Roman, English\n        // 3 - 1 - 0x409 : Windows, Unicode BMP (UCS-2), en-US\n        if (platformID === 3 && encodingID === 1 && languageID === 0x409) {\n            var codePoints = [];\n            var length = byteLength / 2;\n            for (var j = 0; j < length; j++, offset += 2) {\n                codePoints[j] = parse.getShort(data, stringOffset + offset);\n            }\n\n            var str = String.fromCharCode.apply(null, codePoints);\n            if (property) {\n                name[property] = str;\n            }\n            else {\n                unknownCount++;\n                name['unknown' + unknownCount] = str;\n            }\n        }\n\n    }\n\n    if (name.format === 1) {\n        name.langTagCount = p.parseUShort();\n    }\n\n    return name;\n}\n\nfunction makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {\n    return new table.Table('NameRecord', [\n        {name: 'platformID', type: 'USHORT', value: platformID},\n        {name: 'encodingID', type: 'USHORT', value: encodingID},\n        {name: 'languageID', type: 'USHORT', value: languageID},\n        {name: 'nameID', type: 'USHORT', value: nameID},\n        {name: 'length', type: 'USHORT', value: length},\n        {name: 'offset', type: 'USHORT', value: offset}\n    ]);\n}\n\nfunction addMacintoshNameRecord(t, recordID, s, offset) {\n    // Macintosh, Roman, English\n    var stringBytes = encode.STRING(s);\n    t.records.push(makeNameRecord(1, 0, 0, recordID, stringBytes.length, offset));\n    t.strings.push(stringBytes);\n    offset += stringBytes.length;\n    return offset;\n}\n\nfunction addWindowsNameRecord(t, recordID, s, offset) {\n    // Windows, Unicode BMP (UCS-2), US English\n    var utf16Bytes = encode.UTF16(s);\n    t.records.push(makeNameRecord(3, 1, 0x0409, recordID, utf16Bytes.length, offset));\n    t.strings.push(utf16Bytes);\n    offset += utf16Bytes.length;\n    return offset;\n}\n\nfunction makeNameTable(options) {\n    var t = new table.Table('name', [\n        {name: 'format', type: 'USHORT', value: 0},\n        {name: 'count', type: 'USHORT', value: 0},\n        {name: 'stringOffset', type: 'USHORT', value: 0}\n    ]);\n    t.records = [];\n    t.strings = [];\n    var offset = 0;\n    var i;\n    var s;\n    // Add Macintosh records first\n    for (i = 0; i < nameTableNames.length; i += 1) {\n        if (options[nameTableNames[i]] !== undefined) {\n            s = options[nameTableNames[i]];\n            offset = addMacintoshNameRecord(t, i, s, offset);\n        }\n    }\n    // Then add Windows records\n    for (i = 0; i < nameTableNames.length; i += 1) {\n        if (options[nameTableNames[i]] !== undefined) {\n            s = options[nameTableNames[i]];\n            offset = addWindowsNameRecord(t, i, s, offset);\n        }\n    }\n\n    t.count = t.records.length;\n    t.stringOffset = 6 + t.count * 12;\n    for (i = 0; i < t.records.length; i += 1) {\n        t.fields.push({name: 'record_' + i, type: 'TABLE', value: t.records[i]});\n    }\n\n    for (i = 0; i < t.strings.length; i += 1) {\n        t.fields.push({name: 'string_' + i, type: 'LITERAL', value: t.strings[i]});\n    }\n\n    return t;\n}\n\nexports.parse = parseNameTable;\nexports.make = makeNameTable;\n\n},{\"../parse\":8,\"../table\":10,\"../types\":25}],22:[function(require,module,exports){\n// The `OS/2` table contains metrics required in OpenType fonts.\n// https://www.microsoft.com/typography/OTSPEC/os2.htm\n\n'use strict';\n\nvar parse = require('../parse');\nvar table = require('../table');\n\nvar unicodeRanges = [\n    {begin: 0x0000, end: 0x007F}, // Basic Latin\n    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement\n    {begin: 0x0100, end: 0x017F}, // Latin Extended-A\n    {begin: 0x0180, end: 0x024F}, // Latin Extended-B\n    {begin: 0x0250, end: 0x02AF}, // IPA Extensions\n    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters\n    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks\n    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic\n    {begin: 0x2C80, end: 0x2CFF}, // Coptic\n    {begin: 0x0400, end: 0x04FF}, // Cyrillic\n    {begin: 0x0530, end: 0x058F}, // Armenian\n    {begin: 0x0590, end: 0x05FF}, // Hebrew\n    {begin: 0xA500, end: 0xA63F}, // Vai\n    {begin: 0x0600, end: 0x06FF}, // Arabic\n    {begin: 0x07C0, end: 0x07FF}, // NKo\n    {begin: 0x0900, end: 0x097F}, // Devanagari\n    {begin: 0x0980, end: 0x09FF}, // Bengali\n    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi\n    {begin: 0x0A80, end: 0x0AFF}, // Gujarati\n    {begin: 0x0B00, end: 0x0B7F}, // Oriya\n    {begin: 0x0B80, end: 0x0BFF}, // Tamil\n    {begin: 0x0C00, end: 0x0C7F}, // Telugu\n    {begin: 0x0C80, end: 0x0CFF}, // Kannada\n    {begin: 0x0D00, end: 0x0D7F}, // Malayalam\n    {begin: 0x0E00, end: 0x0E7F}, // Thai\n    {begin: 0x0E80, end: 0x0EFF}, // Lao\n    {begin: 0x10A0, end: 0x10FF}, // Georgian\n    {begin: 0x1B00, end: 0x1B7F}, // Balinese\n    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo\n    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional\n    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended\n    {begin: 0x2000, end: 0x206F}, // General Punctuation\n    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts\n    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol\n    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols\n    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols\n    {begin: 0x2150, end: 0x218F}, // Number Forms\n    {begin: 0x2190, end: 0x21FF}, // Arrows\n    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators\n    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical\n    {begin: 0x2400, end: 0x243F}, // Control Pictures\n    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition\n    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics\n    {begin: 0x2500, end: 0x257F}, // Box Drawing\n    {begin: 0x2580, end: 0x259F}, // Block Elements\n    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes\n    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols\n    {begin: 0x2700, end: 0x27BF}, // Dingbats\n    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation\n    {begin: 0x3040, end: 0x309F}, // Hiragana\n    {begin: 0x30A0, end: 0x30FF}, // Katakana\n    {begin: 0x3100, end: 0x312F}, // Bopomofo\n    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo\n    {begin: 0xA840, end: 0xA87F}, // Phags-pa\n    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months\n    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility\n    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables\n    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *\n    {begin: 0x10900, end: 0x1091F}, // Phoenicia\n    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs\n    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)\n    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes\n    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms\n    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A\n    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks\n    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms\n    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants\n    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B\n    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms\n    {begin: 0xFFF0, end: 0xFFFF}, // Specials\n    {begin: 0x0F00, end: 0x0FFF}, // Tibetan\n    {begin: 0x0700, end: 0x074F}, // Syriac\n    {begin: 0x0780, end: 0x07BF}, // Thaana\n    {begin: 0x0D80, end: 0x0DFF}, // Sinhala\n    {begin: 0x1000, end: 0x109F}, // Myanmar\n    {begin: 0x1200, end: 0x137F}, // Ethiopic\n    {begin: 0x13A0, end: 0x13FF}, // Cherokee\n    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics\n    {begin: 0x1680, end: 0x169F}, // Ogham\n    {begin: 0x16A0, end: 0x16FF}, // Runic\n    {begin: 0x1780, end: 0x17FF}, // Khmer\n    {begin: 0x1800, end: 0x18AF}, // Mongolian\n    {begin: 0x2800, end: 0x28FF}, // Braille Patterns\n    {begin: 0xA000, end: 0xA48F}, // Yi Syllables\n    {begin: 0x1700, end: 0x171F}, // Tagalog\n    {begin: 0x10300, end: 0x1032F}, // Old Italic\n    {begin: 0x10330, end: 0x1034F}, // Gothic\n    {begin: 0x10400, end: 0x1044F}, // Deseret\n    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols\n    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols\n    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)\n    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors\n    {begin: 0xE0000, end: 0xE007F}, // Tags\n    {begin: 0x1900, end: 0x194F}, // Limbu\n    {begin: 0x1950, end: 0x197F}, // Tai Le\n    {begin: 0x1980, end: 0x19DF}, // New Tai Lue\n    {begin: 0x1A00, end: 0x1A1F}, // Buginese\n    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic\n    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh\n    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols\n    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri\n    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary\n    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers\n    {begin: 0x10380, end: 0x1039F}, // Ugaritic\n    {begin: 0x103A0, end: 0x103DF}, // Old Persian\n    {begin: 0x10450, end: 0x1047F}, // Shavian\n    {begin: 0x10480, end: 0x104AF}, // Osmanya\n    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary\n    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi\n    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols\n    {begin: 0x12000, end: 0x123FF}, // Cuneiform\n    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals\n    {begin: 0x1B80, end: 0x1BBF}, // Sundanese\n    {begin: 0x1C00, end: 0x1C4F}, // Lepcha\n    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki\n    {begin: 0xA880, end: 0xA8DF}, // Saurashtra\n    {begin: 0xA900, end: 0xA92F}, // Kayah Li\n    {begin: 0xA930, end: 0xA95F}, // Rejang\n    {begin: 0xAA00, end: 0xAA5F}, // Cham\n    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols\n    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc\n    {begin: 0x102A0, end: 0x102DF}, // Carian\n    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles\n];\n\nfunction getUnicodeRange(unicode) {\n    for (var i = 0; i < unicodeRanges.length; i += 1) {\n        var range = unicodeRanges[i];\n        if (unicode >= range.begin && unicode < range.end) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n// Parse the OS/2 and Windows metrics `OS/2` table\nfunction parseOS2Table(data, start) {\n    var os2 = {};\n    var p = new parse.Parser(data, start);\n    os2.version = p.parseUShort();\n    os2.xAvgCharWidth = p.parseShort();\n    os2.usWeightClass = p.parseUShort();\n    os2.usWidthClass = p.parseUShort();\n    os2.fsType = p.parseUShort();\n    os2.ySubscriptXSize = p.parseShort();\n    os2.ySubscriptYSize = p.parseShort();\n    os2.ySubscriptXOffset = p.parseShort();\n    os2.ySubscriptYOffset = p.parseShort();\n    os2.ySuperscriptXSize = p.parseShort();\n    os2.ySuperscriptYSize = p.parseShort();\n    os2.ySuperscriptXOffset = p.parseShort();\n    os2.ySuperscriptYOffset = p.parseShort();\n    os2.yStrikeoutSize = p.parseShort();\n    os2.yStrikeoutPosition = p.parseShort();\n    os2.sFamilyClass = p.parseShort();\n    os2.panose = [];\n    for (var i = 0; i < 10; i++) {\n        os2.panose[i] = p.parseByte();\n    }\n\n    os2.ulUnicodeRange1 = p.parseULong();\n    os2.ulUnicodeRange2 = p.parseULong();\n    os2.ulUnicodeRange3 = p.parseULong();\n    os2.ulUnicodeRange4 = p.parseULong();\n    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());\n    os2.fsSelection = p.parseUShort();\n    os2.usFirstCharIndex = p.parseUShort();\n    os2.usLastCharIndex = p.parseUShort();\n    os2.sTypoAscender = p.parseShort();\n    os2.sTypoDescender = p.parseShort();\n    os2.sTypoLineGap = p.parseShort();\n    os2.usWinAscent = p.parseUShort();\n    os2.usWinDescent = p.parseUShort();\n    if (os2.version >= 1) {\n        os2.ulCodePageRange1 = p.parseULong();\n        os2.ulCodePageRange2 = p.parseULong();\n    }\n\n    if (os2.version >= 2) {\n        os2.sxHeight = p.parseShort();\n        os2.sCapHeight = p.parseShort();\n        os2.usDefaultChar = p.parseUShort();\n        os2.usBreakChar = p.parseUShort();\n        os2.usMaxContent = p.parseUShort();\n    }\n\n    return os2;\n}\n\nfunction makeOS2Table(options) {\n    return new table.Table('OS/2', [\n        {name: 'version', type: 'USHORT', value: 0x0003},\n        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},\n        {name: 'usWeightClass', type: 'USHORT', value: 0},\n        {name: 'usWidthClass', type: 'USHORT', value: 0},\n        {name: 'fsType', type: 'USHORT', value: 0},\n        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},\n        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},\n        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},\n        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},\n        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},\n        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},\n        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},\n        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},\n        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},\n        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},\n        {name: 'sFamilyClass', type: 'SHORT', value: 0},\n        {name: 'bFamilyType', type: 'BYTE', value: 0},\n        {name: 'bSerifStyle', type: 'BYTE', value: 0},\n        {name: 'bWeight', type: 'BYTE', value: 0},\n        {name: 'bProportion', type: 'BYTE', value: 0},\n        {name: 'bContrast', type: 'BYTE', value: 0},\n        {name: 'bStrokeVariation', type: 'BYTE', value: 0},\n        {name: 'bArmStyle', type: 'BYTE', value: 0},\n        {name: 'bLetterform', type: 'BYTE', value: 0},\n        {name: 'bMidline', type: 'BYTE', value: 0},\n        {name: 'bXHeight', type: 'BYTE', value: 0},\n        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},\n        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},\n        {name: 'fsSelection', type: 'USHORT', value: 0},\n        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},\n        {name: 'usLastCharIndex', type: 'USHORT', value: 0},\n        {name: 'sTypoAscender', type: 'SHORT', value: 0},\n        {name: 'sTypoDescender', type: 'SHORT', value: 0},\n        {name: 'sTypoLineGap', type: 'SHORT', value: 0},\n        {name: 'usWinAscent', type: 'USHORT', value: 0},\n        {name: 'usWinDescent', type: 'USHORT', value: 0},\n        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},\n        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},\n        {name: 'sxHeight', type: 'SHORT', value: 0},\n        {name: 'sCapHeight', type: 'SHORT', value: 0},\n        {name: 'usDefaultChar', type: 'USHORT', value: 0},\n        {name: 'usBreakChar', type: 'USHORT', value: 0},\n        {name: 'usMaxContext', type: 'USHORT', value: 0}\n    ], options);\n}\n\nexports.unicodeRanges = unicodeRanges;\nexports.getUnicodeRange = getUnicodeRange;\nexports.parse = parseOS2Table;\nexports.make = makeOS2Table;\n\n},{\"../parse\":8,\"../table\":10}],23:[function(require,module,exports){\n// The `post` table stores additional PostScript information, such as glyph names.\n// https://www.microsoft.com/typography/OTSPEC/post.htm\n\n'use strict';\n\nvar encoding = require('../encoding');\nvar parse = require('../parse');\nvar table = require('../table');\n\n// Parse the PostScript `post` table\nfunction parsePostTable(data, start) {\n    var post = {};\n    var p = new parse.Parser(data, start);\n    var i;\n    post.version = p.parseVersion();\n    post.italicAngle = p.parseFixed();\n    post.underlinePosition = p.parseShort();\n    post.underlineThickness = p.parseShort();\n    post.isFixedPitch = p.parseULong();\n    post.minMemType42 = p.parseULong();\n    post.maxMemType42 = p.parseULong();\n    post.minMemType1 = p.parseULong();\n    post.maxMemType1 = p.parseULong();\n    switch (post.version) {\n    case 1:\n        post.names = encoding.standardNames.slice();\n        break;\n    case 2:\n        post.numberOfGlyphs = p.parseUShort();\n        post.glyphNameIndex = new Array(post.numberOfGlyphs);\n        for (i = 0; i < post.numberOfGlyphs; i++) {\n            post.glyphNameIndex[i] = p.parseUShort();\n        }\n\n        post.names = [];\n        for (i = 0; i < post.numberOfGlyphs; i++) {\n            if (post.glyphNameIndex[i] >= encoding.standardNames.length) {\n                var nameLength = p.parseChar();\n                post.names.push(p.parseString(nameLength));\n            }\n        }\n\n        break;\n    case 2.5:\n        post.numberOfGlyphs = p.parseUShort();\n        post.offset = new Array(post.numberOfGlyphs);\n        for (i = 0; i < post.numberOfGlyphs; i++) {\n            post.offset[i] = p.parseChar();\n        }\n\n        break;\n    }\n    return post;\n}\n\nfunction makePostTable() {\n    return new table.Table('post', [\n        {name: 'version', type: 'FIXED', value: 0x00030000},\n        {name: 'italicAngle', type: 'FIXED', value: 0},\n        {name: 'underlinePosition', type: 'FWORD', value: 0},\n        {name: 'underlineThickness', type: 'FWORD', value: 0},\n        {name: 'isFixedPitch', type: 'ULONG', value: 0},\n        {name: 'minMemType42', type: 'ULONG', value: 0},\n        {name: 'maxMemType42', type: 'ULONG', value: 0},\n        {name: 'minMemType1', type: 'ULONG', value: 0},\n        {name: 'maxMemType1', type: 'ULONG', value: 0}\n    ]);\n}\n\nexports.parse = parsePostTable;\nexports.make = makePostTable;\n\n},{\"../encoding\":3,\"../parse\":8,\"../table\":10}],24:[function(require,module,exports){\n// The `sfnt` wrapper provides organization for the tables in the font.\n// It is the top-level data structure in a font.\n// https://www.microsoft.com/typography/OTSPEC/otff.htm\n// Recommendations for creating OpenType Fonts:\n// http://www.microsoft.com/typography/otspec140/recom.htm\n\n'use strict';\n\nvar check = require('../check');\nvar table = require('../table');\n\nvar cmap = require('./cmap');\nvar cff = require('./cff');\nvar head = require('./head');\nvar hhea = require('./hhea');\nvar hmtx = require('./hmtx');\nvar maxp = require('./maxp');\nvar _name = require('./name');\nvar os2 = require('./os2');\nvar post = require('./post');\n\nfunction log2(v) {\n    return Math.log(v) / Math.log(2) | 0;\n}\n\nfunction computeCheckSum(bytes) {\n    while (bytes.length % 4 !== 0) {\n        bytes.push(0);\n    }\n\n    var sum = 0;\n    for (var i = 0; i < bytes.length; i += 4) {\n        sum += (bytes[i] << 24) +\n            (bytes[i + 1] << 16) +\n            (bytes[i + 2] << 8) +\n            (bytes[i + 3]);\n    }\n\n    sum %= Math.pow(2, 32);\n    return sum;\n}\n\nfunction makeTableRecord(tag, checkSum, offset, length) {\n    return new table.Table('Table Record', [\n        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},\n        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},\n        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},\n        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}\n    ]);\n}\n\nfunction makeSfntTable(tables) {\n    var sfnt = new table.Table('sfnt', [\n        {name: 'version', type: 'TAG', value: 'OTTO'},\n        {name: 'numTables', type: 'USHORT', value: 0},\n        {name: 'searchRange', type: 'USHORT', value: 0},\n        {name: 'entrySelector', type: 'USHORT', value: 0},\n        {name: 'rangeShift', type: 'USHORT', value: 0}\n    ]);\n    sfnt.tables = tables;\n    sfnt.numTables = tables.length;\n    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));\n    sfnt.searchRange = 16 * highestPowerOf2;\n    sfnt.entrySelector = log2(highestPowerOf2);\n    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;\n\n    var recordFields = [];\n    var tableFields = [];\n\n    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);\n    while (offset % 4 !== 0) {\n        offset += 1;\n        tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n    }\n\n    for (var i = 0; i < tables.length; i += 1) {\n        var t = tables[i];\n        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');\n        var tableLength = t.sizeOf();\n        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);\n        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'TABLE', value: tableRecord});\n        tableFields.push({name: t.tableName + ' table', type: 'TABLE', value: t});\n        offset += tableLength;\n        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');\n        while (offset % 4 !== 0) {\n            offset += 1;\n            tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n        }\n    }\n\n    // Table records need to be sorted alphabetically.\n    recordFields.sort(function(r1, r2) {\n        if (r1.value.tag > r2.value.tag) {\n            return 1;\n        } else {\n            return -1;\n        }\n    });\n\n    sfnt.fields = sfnt.fields.concat(recordFields);\n    sfnt.fields = sfnt.fields.concat(tableFields);\n    return sfnt;\n}\n\n// Get the metrics for a character. If the string has more than one character\n// this function returns metrics for the first available character.\n// You can provide optional fallback metrics if no characters are available.\nfunction metricsForChar(font, chars, notFoundMetrics) {\n    for (var i = 0; i < chars.length; i += 1) {\n        var glyphIndex = font.charToGlyphIndex(chars[i]);\n        if (glyphIndex > 0) {\n            var glyph = font.glyphs.get(glyphIndex);\n            return glyph.getMetrics();\n        }\n    }\n\n    return notFoundMetrics;\n}\n\nfunction average(vs) {\n    var sum = 0;\n    for (var i = 0; i < vs.length; i += 1) {\n        sum += vs[i];\n    }\n\n    return sum / vs.length;\n}\n\n// Convert the font object to a SFNT data structure.\n// This structure contains all the necessary tables and metadata to create a binary OTF file.\nfunction fontToSfntTable(font) {\n    var xMins = [];\n    var yMins = [];\n    var xMaxs = [];\n    var yMaxs = [];\n    var advanceWidths = [];\n    var leftSideBearings = [];\n    var rightSideBearings = [];\n    var firstCharIndex;\n    var lastCharIndex = 0;\n    var ulUnicodeRange1 = 0;\n    var ulUnicodeRange2 = 0;\n    var ulUnicodeRange3 = 0;\n    var ulUnicodeRange4 = 0;\n\n    for (var i = 0; i < font.glyphs.length; i += 1) {\n        var glyph = font.glyphs.get(i);\n        var unicode = glyph.unicode | 0;\n        if (firstCharIndex > unicode || firstCharIndex === null) {\n            firstCharIndex = unicode;\n        }\n\n        if (lastCharIndex < unicode) {\n            lastCharIndex = unicode;\n        }\n\n        var position = os2.getUnicodeRange(unicode);\n        if (position < 32) {\n            ulUnicodeRange1 |= 1 << position;\n        } else if (position < 64) {\n            ulUnicodeRange2 |= 1 << position - 32;\n        } else if (position < 96) {\n            ulUnicodeRange3 |= 1 << position - 64;\n        } else if (position < 123) {\n            ulUnicodeRange4 |= 1 << position - 96;\n        } else {\n            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');\n        }\n        // Skip non-important characters.\n        if (glyph.name === '.notdef') continue;\n        var metrics = glyph.getMetrics();\n        xMins.push(metrics.xMin);\n        yMins.push(metrics.yMin);\n        xMaxs.push(metrics.xMax);\n        yMaxs.push(metrics.yMax);\n        leftSideBearings.push(metrics.leftSideBearing);\n        rightSideBearings.push(metrics.rightSideBearing);\n        advanceWidths.push(glyph.advanceWidth);\n    }\n\n    var globals = {\n        xMin: Math.min.apply(null, xMins),\n        yMin: Math.min.apply(null, yMins),\n        xMax: Math.max.apply(null, xMaxs),\n        yMax: Math.max.apply(null, yMaxs),\n        advanceWidthMax: Math.max.apply(null, advanceWidths),\n        advanceWidthAvg: average(advanceWidths),\n        minLeftSideBearing: Math.min.apply(null, leftSideBearings),\n        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),\n        minRightSideBearing: Math.min.apply(null, rightSideBearings)\n    };\n    globals.ascender = font.ascender !== undefined ? font.ascender : globals.yMax;\n    globals.descender = font.descender !== undefined ? font.descender : globals.yMin;\n\n    var headTable = head.make({\n        unitsPerEm: font.unitsPerEm,\n        xMin: globals.xMin,\n        yMin: globals.yMin,\n        xMax: globals.xMax,\n        yMax: globals.yMax\n    });\n\n    var hheaTable = hhea.make({\n        ascender: globals.ascender,\n        descender: globals.descender,\n        advanceWidthMax: globals.advanceWidthMax,\n        minLeftSideBearing: globals.minLeftSideBearing,\n        minRightSideBearing: globals.minRightSideBearing,\n        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),\n        numberOfHMetrics: font.glyphs.length\n    });\n\n    var maxpTable = maxp.make(font.glyphs.length);\n\n    var os2Table = os2.make({\n        xAvgCharWidth: Math.round(globals.advanceWidthAvg),\n        usWeightClass: 500, // Medium FIXME Make this configurable\n        usWidthClass: 5, // Medium (normal) FIXME Make this configurable\n        usFirstCharIndex: firstCharIndex,\n        usLastCharIndex: lastCharIndex,\n        ulUnicodeRange1: ulUnicodeRange1,\n        ulUnicodeRange2: ulUnicodeRange2,\n        ulUnicodeRange3: ulUnicodeRange3,\n        ulUnicodeRange4: ulUnicodeRange4,\n        // See http://typophile.com/node/13081 for more info on vertical metrics.\n        // We get metrics for typical characters (such as \"x\" for xHeight).\n        // We provide some fallback characters if characters are unavailable: their\n        // ordering was chosen experimentally.\n        sTypoAscender: globals.ascender,\n        sTypoDescender: globals.descender,\n        sTypoLineGap: 0,\n        usWinAscent: globals.ascender,\n        usWinDescent: -globals.descender,\n        sxHeight: metricsForChar(font, 'xyvw', {yMax: 0}).yMax,\n        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,\n        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.\n    });\n\n    var hmtxTable = hmtx.make(font.glyphs);\n    var cmapTable = cmap.make(font.glyphs);\n\n    var fullName = font.familyName + ' ' + font.styleName;\n    var postScriptName = font.familyName.replace(/\\s/g, '') + '-' + font.styleName;\n    var nameTable = _name.make({\n        copyright: font.copyright,\n        fontFamily: font.familyName,\n        fontSubfamily: font.styleName,\n        uniqueID: font.manufacturer + ':' + fullName,\n        fullName: fullName,\n        version: font.version,\n        postScriptName: postScriptName,\n        trademark: font.trademark,\n        manufacturer: font.manufacturer,\n        designer: font.designer,\n        description: font.description,\n        manufacturerURL: font.manufacturerURL,\n        designerURL: font.designerURL,\n        license: font.license,\n        licenseURL: font.licenseURL,\n        preferredFamily: font.familyName,\n        preferredSubfamily: font.styleName\n    });\n    var postTable = post.make();\n    var cffTable = cff.make(font.glyphs, {\n        version: font.version,\n        fullName: fullName,\n        familyName: font.familyName,\n        weightName: font.styleName,\n        postScriptName: postScriptName,\n        unitsPerEm: font.unitsPerEm\n    });\n    // Order the tables according to the the OpenType specification 1.4.\n    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];\n\n    var sfntTable = makeSfntTable(tables);\n\n    // Compute the font's checkSum and store it in head.checkSumAdjustment.\n    var bytes = sfntTable.encode();\n    var checkSum = computeCheckSum(bytes);\n    var tableFields = sfntTable.fields;\n    var checkSumAdjusted = false;\n    for (i = 0; i < tableFields.length; i += 1) {\n        if (tableFields[i].name === 'head table') {\n            tableFields[i].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;\n            checkSumAdjusted = true;\n            break;\n        }\n    }\n\n    if (!checkSumAdjusted) {\n        throw new Error('Could not find head table with checkSum to adjust.');\n    }\n\n    return sfntTable;\n}\n\nexports.computeCheckSum = computeCheckSum;\nexports.make = makeSfntTable;\nexports.fontToTable = fontToSfntTable;\n\n},{\"../check\":1,\"../table\":10,\"./cff\":11,\"./cmap\":12,\"./head\":15,\"./hhea\":16,\"./hmtx\":17,\"./maxp\":20,\"./name\":21,\"./os2\":22,\"./post\":23}],25:[function(require,module,exports){\n// Data types used in the OpenType font file.\n// All OpenType fonts use Motorola-style byte ordering (Big Endian)\n\n/* global WeakMap */\n\n'use strict';\n\nvar check = require('./check');\n\nvar LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15\nvar LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31\n\nvar decode = {};\nvar encode = {};\nvar sizeOf = {};\n\n// Return a function that always returns the same value.\nfunction constant(v) {\n    return function() {\n        return v;\n    };\n}\n\n// OpenType data types //////////////////////////////////////////////////////\n\n// Convert an 8-bit unsigned integer to a list of 1 byte.\nencode.BYTE = function(v) {\n    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');\n    return [v];\n};\n\nsizeOf.BYTE = constant(1);\n\n// Convert a 8-bit signed integer to a list of 1 byte.\nencode.CHAR = function(v) {\n    return [v.charCodeAt(0)];\n};\n\nsizeOf.CHAR = constant(1);\n\n// Convert an ASCII string to a list of bytes.\nencode.CHARARRAY = function(v) {\n    var b = [];\n    for (var i = 0; i < v.length; i += 1) {\n        b.push(v.charCodeAt(i));\n    }\n\n    return b;\n};\n\nsizeOf.CHARARRAY = function(v) {\n    return v.length;\n};\n\n// Convert a 16-bit unsigned integer to a list of 2 bytes.\nencode.USHORT = function(v) {\n    return [(v >> 8) & 0xFF, v & 0xFF];\n};\n\nsizeOf.USHORT = constant(2);\n\n// Convert a 16-bit signed integer to a list of 2 bytes.\nencode.SHORT = function(v) {\n    // Two's complement\n    if (v >= LIMIT16) {\n        v = -(2 * LIMIT16 - v);\n    }\n\n    return [(v >> 8) & 0xFF, v & 0xFF];\n};\n\nsizeOf.SHORT = constant(2);\n\n// Convert a 24-bit unsigned integer to a list of 3 bytes.\nencode.UINT24 = function(v) {\n    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\nsizeOf.UINT24 = constant(3);\n\n// Convert a 32-bit unsigned integer to a list of 4 bytes.\nencode.ULONG = function(v) {\n    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\nsizeOf.ULONG = constant(4);\n\n// Convert a 32-bit unsigned integer to a list of 4 bytes.\nencode.LONG = function(v) {\n    // Two's complement\n    if (v >= LIMIT32) {\n        v = -(2 * LIMIT32 - v);\n    }\n\n    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\nsizeOf.LONG = constant(4);\n\nencode.FIXED = encode.ULONG;\nsizeOf.FIXED = sizeOf.ULONG;\n\nencode.FWORD = encode.SHORT;\nsizeOf.FWORD = sizeOf.SHORT;\n\nencode.UFWORD = encode.USHORT;\nsizeOf.UFWORD = sizeOf.USHORT;\n\n// FIXME Implement LONGDATETIME\nencode.LONGDATETIME = function() {\n    return [0, 0, 0, 0, 0, 0, 0, 0];\n};\n\nsizeOf.LONGDATETIME = constant(8);\n\n// Convert a 4-char tag to a list of 4 bytes.\nencode.TAG = function(v) {\n    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');\n    return [v.charCodeAt(0),\n            v.charCodeAt(1),\n            v.charCodeAt(2),\n            v.charCodeAt(3)];\n};\n\nsizeOf.TAG = constant(4);\n\n// CFF data types ///////////////////////////////////////////////////////////\n\nencode.Card8 = encode.BYTE;\nsizeOf.Card8 = sizeOf.BYTE;\n\nencode.Card16 = encode.USHORT;\nsizeOf.Card16 = sizeOf.USHORT;\n\nencode.OffSize = encode.BYTE;\nsizeOf.OffSize = sizeOf.BYTE;\n\nencode.SID = encode.USHORT;\nsizeOf.SID = sizeOf.USHORT;\n\n// Convert a numeric operand or charstring number to a variable-size list of bytes.\nencode.NUMBER = function(v) {\n    if (v >= -107 && v <= 107) {\n        return [v + 139];\n    } else if (v >= 108 && v <= 1131) {\n        v = v - 108;\n        return [(v >> 8) + 247, v & 0xFF];\n    } else if (v >= -1131 && v <= -108) {\n        v = -v - 108;\n        return [(v >> 8) + 251, v & 0xFF];\n    } else if (v >= -32768 && v <= 32767) {\n        return encode.NUMBER16(v);\n    } else {\n        return encode.NUMBER32(v);\n    }\n};\n\nsizeOf.NUMBER = function(v) {\n    return encode.NUMBER(v).length;\n};\n\n// Convert a signed number between -32768 and +32767 to a three-byte value.\n// This ensures we always use three bytes, but is not the most compact format.\nencode.NUMBER16 = function(v) {\n    return [28, (v >> 8) & 0xFF, v & 0xFF];\n};\n\nsizeOf.NUMBER16 = constant(3);\n\n// Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.\n// This is useful if you want to be sure you always use four bytes,\n// at the expense of wasting a few bytes for smaller numbers.\nencode.NUMBER32 = function(v) {\n    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\nsizeOf.NUMBER32 = constant(5);\n\nencode.REAL = function(v) {\n    var value = v.toString();\n\n    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)\n    // This code converts it back to a number without the epsilon.\n    var m = /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/.exec(value);\n    if (m) {\n        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));\n        value = (Math.round(v * epsilon) / epsilon).toString();\n    }\n\n    var nibbles = '';\n    var i;\n    var ii;\n    for (i = 0, ii = value.length; i < ii; i += 1) {\n        var c = value[i];\n        if (c === 'e') {\n            nibbles += value[++i] === '-' ? 'c' : 'b';\n        } else if (c === '.') {\n            nibbles += 'a';\n        } else if (c === '-') {\n            nibbles += 'e';\n        } else {\n            nibbles += c;\n        }\n    }\n\n    nibbles += (nibbles.length & 1) ? 'f' : 'ff';\n    var out = [30];\n    for (i = 0, ii = nibbles.length; i < ii; i += 2) {\n        out.push(parseInt(nibbles.substr(i, 2), 16));\n    }\n\n    return out;\n};\n\nsizeOf.REAL = function(v) {\n    return encode.REAL(v).length;\n};\n\nencode.NAME = encode.CHARARRAY;\nsizeOf.NAME = sizeOf.CHARARRAY;\n\nencode.STRING = encode.CHARARRAY;\nsizeOf.STRING = sizeOf.CHARARRAY;\n\n// Convert a JavaScript string to UTF16-BE.\nencode.UTF16 = function(v) {\n    var b = [];\n    for (var i = 0; i < v.length; i += 1) {\n        var codepoint = v.charCodeAt(i);\n        b.push((codepoint >> 8) & 0xFF);\n        b.push(codepoint & 0xFF);\n    }\n\n    return b;\n};\n\nsizeOf.UTF16 = function(v) {\n    return v.length * 2;\n};\n\n// Convert a list of values to a CFF INDEX structure.\n// The values should be objects containing name / type / value.\nencode.INDEX = function(l) {\n    var i;\n    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,\n    //    dataSize, i, v;\n    // Because we have to know which data type to use to encode the offsets,\n    // we have to go through the values twice: once to encode the data and\n    // calculate the offets, then again to encode the offsets using the fitting data type.\n    var offset = 1; // First offset is always 1.\n    var offsets = [offset];\n    var data = [];\n    var dataSize = 0;\n    for (i = 0; i < l.length; i += 1) {\n        var v = encode.OBJECT(l[i]);\n        Array.prototype.push.apply(data, v);\n        dataSize += v.length;\n        offset += v.length;\n        offsets.push(offset);\n    }\n\n    if (data.length === 0) {\n        return [0, 0];\n    }\n\n    var encodedOffsets = [];\n    var offSize = (1 + Math.floor(Math.log(dataSize) / Math.log(2)) / 8) | 0;\n    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];\n    for (i = 0; i < offsets.length; i += 1) {\n        var encodedOffset = offsetEncoder(offsets[i]);\n        Array.prototype.push.apply(encodedOffsets, encodedOffset);\n    }\n\n    return Array.prototype.concat(encode.Card16(l.length),\n                           encode.OffSize(offSize),\n                           encodedOffsets,\n                           data);\n};\n\nsizeOf.INDEX = function(v) {\n    return encode.INDEX(v).length;\n};\n\n// Convert an object to a CFF DICT structure.\n// The keys should be numeric.\n// The values should be objects containing name / type / value.\nencode.DICT = function(m) {\n    var d = [];\n    var keys = Object.keys(m);\n    var length = keys.length;\n\n    for (var i = 0; i < length; i += 1) {\n        // Object.keys() return string keys, but our keys are always numeric.\n        var k = parseInt(keys[i], 0);\n        var v = m[k];\n        // Value comes before the key.\n        d = d.concat(encode.OPERAND(v.value, v.type));\n        d = d.concat(encode.OPERATOR(k));\n    }\n\n    return d;\n};\n\nsizeOf.DICT = function(m) {\n    return encode.DICT(m).length;\n};\n\nencode.OPERATOR = function(v) {\n    if (v < 1200) {\n        return [v];\n    } else {\n        return [12, v - 1200];\n    }\n};\n\nencode.OPERAND = function(v, type) {\n    var d = [];\n    if (Array.isArray(type)) {\n        for (var i = 0; i < type.length; i += 1) {\n            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);\n            d = d.concat(encode.OPERAND(v[i], type[i]));\n        }\n    } else {\n        if (type === 'SID') {\n            d = d.concat(encode.NUMBER(v));\n        } else if (type === 'offset') {\n            // We make it easy for ourselves and always encode offsets as\n            // 4 bytes. This makes offset calculation for the top dict easier.\n            d = d.concat(encode.NUMBER32(v));\n        } else if (type === 'number') {\n            d = d.concat(encode.NUMBER(v));\n        } else if (type === 'real') {\n            d = d.concat(encode.REAL(v));\n        } else {\n            throw new Error('Unknown operand type ' + type);\n            // FIXME Add support for booleans\n        }\n    }\n\n    return d;\n};\n\nencode.OP = encode.BYTE;\nsizeOf.OP = sizeOf.BYTE;\n\n// memoize charstring encoding using WeakMap if available\nvar wmm = typeof WeakMap === 'function' && new WeakMap();\n// Convert a list of CharString operations to bytes.\nencode.CHARSTRING = function(ops) {\n    if (wmm && wmm.has(ops)) {\n        return wmm.get(ops);\n    }\n\n    var d = [];\n    var length = ops.length;\n\n    for (var i = 0; i < length; i += 1) {\n        var op = ops[i];\n        d = d.concat(encode[op.type](op.value));\n    }\n\n    if (wmm) {\n        wmm.set(ops, d);\n    }\n\n    return d;\n};\n\nsizeOf.CHARSTRING = function(ops) {\n    return encode.CHARSTRING(ops).length;\n};\n\n// Utility functions ////////////////////////////////////////////////////////\n\n// Convert an object containing name / type / value to bytes.\nencode.OBJECT = function(v) {\n    var encodingFunction = encode[v.type];\n    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);\n    return encodingFunction(v.value);\n};\n\nsizeOf.OBJECT = function(v) {\n    var sizeOfFunction = sizeOf[v.type];\n    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);\n    return sizeOfFunction(v.value);\n};\n\n// Convert a table object to bytes.\n// A table contains a list of fields containing the metadata (name, type and default value).\n// The table itself has the field values set as attributes.\nencode.TABLE = function(table) {\n    var d = [];\n    var length = table.fields.length;\n\n    for (var i = 0; i < length; i += 1) {\n        var field = table.fields[i];\n        var encodingFunction = encode[field.type];\n        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type);\n        var value = table[field.name];\n        if (value === undefined) {\n            value = field.value;\n        }\n\n        var bytes = encodingFunction(value);\n        d = d.concat(bytes);\n    }\n\n    return d;\n};\n\nsizeOf.TABLE = function(table) {\n    var numBytes = 0;\n    var length = table.fields.length;\n\n    for (var i = 0; i < length; i += 1) {\n        var field = table.fields[i];\n        var sizeOfFunction = sizeOf[field.type];\n        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type);\n        var value = table[field.name];\n        if (value === undefined) {\n            value = field.value;\n        }\n\n        numBytes += sizeOfFunction(value);\n    }\n\n    return numBytes;\n};\n\n// Merge in a list of bytes.\nencode.LITERAL = function(v) {\n    return v;\n};\n\nsizeOf.LITERAL = function(v) {\n    return v.length;\n};\n\nexports.decode = decode;\nexports.encode = encode;\nexports.sizeOf = sizeOf;\n\n},{\"./check\":1}]},{},[7])(7)\n});"]},"sourceType":"module","externalDependencies":{},"hash":"df8ac293fda85ecafecb6d1f767cc65c83b18adc"}
