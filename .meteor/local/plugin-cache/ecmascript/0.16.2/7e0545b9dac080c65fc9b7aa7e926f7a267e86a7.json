{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/a37/code/github/makemeahanzi-tool/lib/svg.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"lib/svg.js","filename":"/Users/a37/code/github/makemeahanzi-tool/lib/svg.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/a37/code/github/makemeahanzi-tool","root":"/Users/a37/code/github/makemeahanzi-tool","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]}},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/a37/code/github/makemeahanzi-tool/lib/svg.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"lib/svg.js"}},"code":"var _createForOfIteratorHelperLoose;\n\nmodule.link(\"@babel/runtime/helpers/createForOfIteratorHelperLoose\", {\n  default: function (v) {\n    _createForOfIteratorHelperLoose = v;\n  }\n}, 0);\nmodule.export({\n  svg: function () {\n    return svg;\n  }\n});\nvar assert, Point;\nmodule.link(\"/lib/base\", {\n  assert: function (v) {\n    assert = v;\n  },\n  Point: function (v) {\n    Point = v;\n  }\n}, 0);\nvar svg = {}; // A normal-form SVG path string is a data string with the following properties:\n//   - Every command in the path is in ['L', 'M', 'Q', 'Z'].\n//   - Adjacent tokens in the path are separated by exactly one space.\n//   - There is exactly one 'Z', and it is the last command.\n//\n// A segment is a section of a path, represented as an object that has a start,\n// an end, and possibly a control, all of which are valid Points (that is, pairs\n// of Numbers).\n//\n// A path is a list of segments which is non-empty and closed - that is, the end\n// of the last segment on the path is the start of the first.\n// Returns twice the area contained in the polygon. The result is positive iff\n// the polygon winds in the counter-clockwise direction.\n\nvar get2xArea = function (polygon) {\n  var area = 0;\n\n  for (var i = 0; i < polygon.length; i++) {\n    var p1 = polygon[i];\n    var p2 = polygon[(i + 1) % polygon.length];\n    area += (p2[0] + p1[0]) * (p2[1] - p1[1]);\n  }\n\n  return area;\n}; // Takes a list of paths and orients them so that exterior contours are oriented\n// counter-clockwise and interior contours clockwise.\n\n\nvar orientPaths = function (paths, approximation_error) {\n  var polygons = paths.map(svg.getPolygonApproximation);\n\n  for (var i = 0; i < paths.length; i++) {\n    var path = paths[i];\n    var contains = 0;\n\n    for (var j = 0; j < paths.length; j++) {\n      if (j === i) {\n        continue;\n      } else if (svg.polygonContainsPoint(polygons[j], path[0].start)) {\n        contains += 1;\n      }\n    }\n\n    var area = get2xArea(polygons[i]); // The path is an external path iff it is contained in an even number of\n    // other paths. It is counter-clockwise iff its area is positive. The path\n    // should be reversed if (CCW && internal) || (CW && external).\n\n    var should_reverse = area > 0 !== (contains % 2 === 0);\n\n    if (should_reverse) {\n      for (var _iterator = _createForOfIteratorHelperLoose(path), _step; !(_step = _iterator()).done;) {\n        var segment = _step.value;\n        var _ref = [segment.end, segment.start];\n        segment.start = _ref[0];\n        segment.end = _ref[1];\n      }\n\n      path.reverse();\n    }\n  }\n\n  return paths;\n}; // Takes a normal-form SVG path string and converts it to a list of paths.\n\n\nvar splitPath = function (path) {\n  assert(path.length > 0);\n  assert(path[0] === 'M', \"Path did not start with M: \" + path);\n  assert(path[path.length - 1] === 'Z', \"Path did not end with Z: \" + path);\n  var terms = path.split(' ');\n  var result = [];\n  var start = undefined;\n  var current = undefined;\n\n  for (var i = 0; i < terms.length; i++) {\n    var command = terms[i];\n    assert(command.length > 0, \"Path includes empty command: \" + path);\n    assert('LMQZ'.indexOf(command) >= 0, command);\n\n    if (command === 'M' || command === 'Z') {\n      if (current !== undefined) {\n        assert(Point.equal(current, start), \"Path has open contour: \" + path);\n        assert(result[result.length - 1].length > 0, \"Path has empty contour: \" + path);\n\n        if (command === 'Z') {\n          assert(i === terms.length - 1, \"Path ended early: \" + path);\n          return result;\n        }\n      }\n\n      result.push([]);\n      assert(i < terms.length - 2, \"Missing point on path: \" + path);\n      start = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n      assert(Point.valid(start));\n      i += 2;\n      current = Point.clone(start);\n      continue;\n    }\n\n    var control = undefined;\n\n    if (command === 'Q') {\n      assert(i < terms.length - 2, \"Missing point on path: \" + path);\n      control = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n      assert(Point.valid(control));\n      i += 2;\n    }\n\n    assert(i < terms.length - 2, \"Missing point on path: \" + path);\n    var end = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n    assert(Point.valid(end));\n    i += 2;\n\n    if (Point.equal(current, end)) {\n      continue;\n    }\n\n    if (control !== undefined && (Point.equal(control, current) || Point.equal(control, end))) {\n      control = undefined;\n    }\n\n    result[result.length - 1].push({\n      start: Point.clone(current),\n      control: control,\n      end: end\n    });\n    current = Point.clone(end);\n  }\n}; // Takes a TrueType font command list (as provided by opentype.js) and returns\n// a normal-form SVG path string as defined above.\n\n\nsvg.convertCommandsToPath = function (commands) {\n  var terms = [];\n\n  for (var i = 0; i < commands.length; i++) {\n    var command = commands[i];\n    assert('LMQZ'.indexOf(command.type) >= 0, command.type);\n\n    if (command.type === 'Z') {\n      assert(i === commands.length - 1);\n      break;\n    }\n\n    terms.push(command.type);\n    assert(command.x1 !== undefined === (command.type === 'Q'));\n\n    if (command.x1 !== undefined) {\n      terms.push(command.x1);\n      terms.push(command.y1);\n    }\n\n    assert(command.x !== undefined);\n    terms.push(command.x);\n    terms.push(command.y);\n  }\n\n  terms.push('Z');\n  return terms.join(' ');\n}; // Converts a normal-form SVG path string to a list of paths. The paths obey an\n// orientation constraint: the external paths are oriented counter-clockwise,\n// while the internal paths are oriented clockwise.\n\n\nsvg.convertSVGPathToPaths = function (path) {\n  return orientPaths(splitPath(path));\n}; // Takes the given list of paths and returns a normal-form SVG path string.\n\n\nsvg.convertPathsToSVGPath = function (paths) {\n  var terms = [];\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(paths), _step2; !(_step2 = _iterator2()).done;) {\n    var path = _step2.value;\n    assert(path.length > 0);\n    terms.push('M');\n    terms.push(path[0].start[0]);\n    terms.push(path[0].start[1]);\n\n    for (var _iterator3 = _createForOfIteratorHelperLoose(path), _step3; !(_step3 = _iterator3()).done;) {\n      var segment = _step3.value;\n\n      if (segment.control === undefined) {\n        terms.push('L');\n      } else {\n        terms.push('Q');\n        terms.push(segment.control[0]);\n        terms.push(segment.control[1]);\n      }\n\n      terms.push(segment.end[0]);\n      terms.push(segment.end[1]);\n    }\n  }\n\n  terms.push('Z');\n  return terms.join(' ');\n}; // Takes a path (a list of segments) and returns a polygon approximation to it.\n// The polygon is given as a list of pairs of points.\n//\n// The approximation error is an upper-bound on the distance between consecutive\n// points in the polygon approximation used to compute the area. The default\n// error of 64 is chosen because the glyphs have a total size of 1024x1024.\n\n\nsvg.getPolygonApproximation = function (path, approximation_error) {\n  var result = [];\n  approximation_error = approximation_error || 64;\n\n  for (var _iterator4 = _createForOfIteratorHelperLoose(path), _step4; !(_step4 = _iterator4()).done;) {\n    var x = _step4.value;\n    var control = x.control || Point.midpoint(x.start, x.end);\n    var distance = Math.sqrt(Point.distance2(x.start, x.end));\n    var num_points = Math.floor(distance / approximation_error);\n\n    for (var i = 0; i < num_points; i++) {\n      var t = (i + 1) / (num_points + 1);\n      var s = 1 - t;\n      result.push([s * s * x.start[0] + 2 * s * t * control[0] + t * t * x.end[0], s * s * x.start[1] + 2 * s * t * control[1] + t * t * x.end[1]]);\n    }\n\n    result.push(x.end);\n  }\n\n  return result;\n}; // Returns true if the given point is contained inside the given polygon.\n\n\nsvg.polygonContainsPoint = function (polygon, point) {\n  var x = point[0];\n  var y = point[1];\n  var crossings = 0;\n\n  for (var i = 0; i < polygon.length; i++) {\n    var segment = {\n      start: polygon[i],\n      end: polygon[(i + 1) % polygon.length]\n    };\n\n    if (segment.start[0] < x && x < segment.end[0] || segment.start[0] > x && x > segment.end[0]) {\n      var t = (x - segment.end[0]) / (segment.start[0] - segment.end[0]);\n      var cy = t * segment.start[1] + (1 - t) * segment.end[1];\n\n      if (y > cy) {\n        crossings += 1;\n      }\n    } else if (segment.start[0] === x && segment.start[1] <= y) {\n      if (segment.end[0] > x) {\n        crossings += 1;\n      }\n\n      var last = polygon[(i + polygon.length - 1) % polygon.length];\n\n      if (last[0] > x) {\n        crossings += 1;\n      }\n    }\n  }\n\n  return crossings % 2 === 1;\n};","map":{"version":3,"sources":["lib/svg.js"],"names":["_createForOfIteratorHelperLoose","module","link","default","v","export","svg","assert","Point","get2xArea","polygon","area","i","length","p1","p2","orientPaths","paths","approximation_error","polygons","map","getPolygonApproximation","path","contains","j","polygonContainsPoint","start","should_reverse","segment","end","reverse","splitPath","terms","split","result","undefined","current","command","indexOf","equal","push","parseFloat","valid","clone","control","convertCommandsToPath","commands","type","x1","y1","x","y","join","convertSVGPathToPaths","convertPathsToSVGPath","midpoint","distance","Math","sqrt","distance2","num_points","floor","t","s","point","crossings","cy","last"],"mappings":"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","sourcesContent":["import {assert, Point} from '/lib/base';\n\nconst svg = {};\n\n// A normal-form SVG path string is a data string with the following properties:\n//   - Every command in the path is in ['L', 'M', 'Q', 'Z'].\n//   - Adjacent tokens in the path are separated by exactly one space.\n//   - There is exactly one 'Z', and it is the last command.\n//\n// A segment is a section of a path, represented as an object that has a start,\n// an end, and possibly a control, all of which are valid Points (that is, pairs\n// of Numbers).\n//\n// A path is a list of segments which is non-empty and closed - that is, the end\n// of the last segment on the path is the start of the first.\n\n// Returns twice the area contained in the polygon. The result is positive iff\n// the polygon winds in the counter-clockwise direction.\nconst get2xArea = (polygon) => {\n  let area = 0;\n  for (var i = 0; i < polygon.length; i++) {\n    const p1 = polygon[i];\n    const p2 = polygon[(i + 1) % polygon.length];\n    area += (p2[0] + p1[0])*(p2[1] - p1[1]);\n  }\n  return area;\n}\n\n// Takes a list of paths and orients them so that exterior contours are oriented\n// counter-clockwise and interior contours clockwise.\nconst orientPaths = (paths, approximation_error) => {\n  const polygons = paths.map(svg.getPolygonApproximation);\n  for (var i = 0; i < paths.length; i++) {\n    const path = paths[i];\n    let contains = 0;\n    for (let j = 0; j < paths.length; j++) {\n      if (j === i) {\n        continue;\n      } else if (svg.polygonContainsPoint(polygons[j], path[0].start)) {\n        contains += 1;\n      }\n    }\n    const area = get2xArea(polygons[i]);\n    // The path is an external path iff it is contained in an even number of\n    // other paths. It is counter-clockwise iff its area is positive. The path\n    // should be reversed if (CCW && internal) || (CW && external).\n    const should_reverse = (area > 0) !== (contains % 2 === 0);\n    if (should_reverse) {\n      for (let segment of path) {\n        [segment.start, segment.end] = [segment.end, segment.start];\n      }\n      path.reverse();\n    }\n  }\n  return paths;\n}\n\n// Takes a normal-form SVG path string and converts it to a list of paths.\nconst splitPath = (path) => {\n  assert(path.length > 0);\n  assert(path[0] === 'M', `Path did not start with M: ${path}`);\n  assert(path[path.length - 1] === 'Z', `Path did not end with Z: ${path}`);\n  const terms = path.split(' ');\n  const result = [];\n  let start = undefined;\n  let current = undefined;\n  for (let i = 0; i < terms.length; i++) {\n    const command = terms[i];\n    assert(command.length > 0, `Path includes empty command: ${path}`);\n    assert('LMQZ'.indexOf(command) >= 0, command);\n    if (command === 'M' || command === 'Z') {\n      if (current !== undefined) {\n        assert(Point.equal(current, start), `Path has open contour: ${path}`);\n        assert(result[result.length - 1].length > 0,\n               `Path has empty contour: ${path}`);\n        if (command === 'Z') {\n          assert(i === terms.length - 1, `Path ended early: ${path}`);\n          return result;\n        }\n      }\n      result.push([]);\n      assert(i < terms.length - 2, `Missing point on path: ${path}`);\n      start = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n      assert(Point.valid(start));\n      i += 2;\n      current = Point.clone(start);\n      continue;\n    }\n    let control = undefined;\n    if (command === 'Q') {\n      assert(i < terms.length - 2, `Missing point on path: ${path}`);\n      control = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n      assert(Point.valid(control));\n      i += 2;\n    }\n    assert(i < terms.length - 2, `Missing point on path: ${path}`);\n    const end = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n    assert(Point.valid(end));\n    i += 2;\n    if (Point.equal(current, end)) {\n      continue;\n    }\n    if (control !== undefined &&\n        (Point.equal(control, current) || Point.equal(control, end))) {\n      control = undefined;\n    }\n    result[result.length - 1].push({\n      start: Point.clone(current),\n      control: control,\n      end: end,\n    });\n    current = Point.clone(end);\n  }\n}\n\n// Takes a TrueType font command list (as provided by opentype.js) and returns\n// a normal-form SVG path string as defined above.\nsvg.convertCommandsToPath = (commands) => {\n  const terms = [];\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    assert('LMQZ'.indexOf(command.type) >= 0, command.type);\n    if (command.type === 'Z') {\n      assert(i === commands.length - 1);\n      break;\n    }\n    terms.push(command.type);\n    assert((command.x1 !== undefined) === (command.type === 'Q'));\n    if (command.x1 !== undefined) {\n      terms.push(command.x1);\n      terms.push(command.y1);\n    }\n    assert(command.x !== undefined);\n    terms.push(command.x);\n    terms.push(command.y);\n  }\n  terms.push('Z');\n  return terms.join(' ');\n}\n\n// Converts a normal-form SVG path string to a list of paths. The paths obey an\n// orientation constraint: the external paths are oriented counter-clockwise,\n// while the internal paths are oriented clockwise.\nsvg.convertSVGPathToPaths = (path) => {\n  return orientPaths(splitPath(path));\n}\n\n// Takes the given list of paths and returns a normal-form SVG path string.\nsvg.convertPathsToSVGPath = (paths) => {\n  const terms = [];\n  for (let path of paths) {\n    assert(path.length > 0);\n    terms.push('M');\n    terms.push(path[0].start[0]);\n    terms.push(path[0].start[1]);\n    for (let segment of path) {\n      if (segment.control === undefined) {\n        terms.push('L');\n      } else {\n        terms.push('Q');\n        terms.push(segment.control[0]);\n        terms.push(segment.control[1]);\n      }\n      terms.push(segment.end[0]);\n      terms.push(segment.end[1]);\n    }\n  }\n  terms.push('Z');\n  return terms.join(' ');\n}\n\n// Takes a path (a list of segments) and returns a polygon approximation to it.\n// The polygon is given as a list of pairs of points.\n//\n// The approximation error is an upper-bound on the distance between consecutive\n// points in the polygon approximation used to compute the area. The default\n// error of 64 is chosen because the glyphs have a total size of 1024x1024.\nsvg.getPolygonApproximation = (path, approximation_error) => {\n  const result = [];\n  approximation_error = approximation_error || 64;\n  for (let x of path) {\n    const control = x.control || Point.midpoint(x.start, x.end);\n    const distance = Math.sqrt(Point.distance2(x.start, x.end));\n    const num_points = Math.floor(distance/approximation_error);\n    for (let i = 0; i < num_points; i++) {\n      const t = (i + 1)/(num_points + 1);\n      const s = 1 - t;\n      result.push([s*s*x.start[0] + 2*s*t*control[0] + t*t*x.end[0],\n                   s*s*x.start[1] + 2*s*t*control[1] + t*t*x.end[1]]);\n    }\n    result.push(x.end);\n  }\n  return result;\n}\n\n// Returns true if the given point is contained inside the given polygon.\nsvg.polygonContainsPoint = (polygon, point) => {\n  const x = point[0];\n  const y = point[1];\n  let crossings = 0;\n  for (let i = 0; i < polygon.length; i++) {\n    const segment = {start: polygon[i], end: polygon[(i + 1) % polygon.length]};\n    if ((segment.start[0] < x && x < segment.end[0]) ||\n        (segment.start[0] > x && x > segment.end[0])) {\n      const t = (x - segment.end[0])/(segment.start[0] - segment.end[0]);\n      const cy = t*segment.start[1] + (1 - t)*segment.end[1];\n      if (y > cy) {\n        crossings += 1;\n      }\n    } else if (segment.start[0] === x && segment.start[1] <= y) {\n      if (segment.end[0] > x) {\n        crossings += 1;\n      }\n      const last = polygon[(i + polygon.length - 1) % (polygon.length)];\n      if (last[0] > x) {\n        crossings += 1;\n      }\n    }\n  }\n  return crossings % 2 === 1;\n}\n\nexport {svg};\n"]},"sourceType":"module","externalDependencies":{},"hash":"7e0545b9dac080c65fc9b7aa7e926f7a267e86a7"}
