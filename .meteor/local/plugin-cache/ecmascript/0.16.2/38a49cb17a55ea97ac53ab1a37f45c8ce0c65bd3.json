{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/a37/code/github/makemeahanzi-tool/client/lib/order.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"client/lib/order.js","filename":"/Users/a37/code/github/makemeahanzi-tool/client/lib/order.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/a37/code/github/makemeahanzi-tool","root":"/Users/a37/code/github/makemeahanzi-tool","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/a37/code/github/makemeahanzi-tool/client/lib/order.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"client/lib/order.js"}},"code":"module.export({\n  OrderStage: () => OrderStage\n});\nlet AbstractStage;\nmodule.link(\"/client/lib/abstract\", {\n  AbstractStage(v) {\n    AbstractStage = v;\n  }\n\n}, 0);\nlet assert, Point;\nmodule.link(\"/lib/base\", {\n  assert(v) {\n    assert = v;\n  },\n\n  Point(v) {\n    Point = v;\n  }\n\n}, 1);\nlet decomposition_util;\nmodule.link(\"/lib/decomposition_util\", {\n  decomposition_util(v) {\n    decomposition_util = v;\n  }\n\n}, 2);\nlet Glyphs;\nmodule.link(\"/lib/glyphs\", {\n  Glyphs(v) {\n    Glyphs = v;\n  }\n\n}, 3);\nlet Hungarian;\nmodule.link(\"/lib/hungarian\", {\n  Hungarian(v) {\n    Hungarian = v;\n  }\n\n}, 4);\nlet median_util;\nmodule.link(\"/lib/median_util\", {\n  median_util(v) {\n    median_util = v;\n  }\n\n}, 5);\nlet stage = undefined;\nconst Order = new Mongo.Collection('order')._collection; // TODO(skishore): Consider using sqrt(1/2) in place of 1/2 here. This constant\n// is used to compute bounds for components that are surrounded.\n\nconst rad2 = 1 / 2;\nconst compound_bounds = {\n  '⿰': [[[0, 0], [1 / 2, 1]], [[1 / 2, 0], [1 / 2, 1]]],\n  '⿱': [[[0, 0], [1, 1 / 2]], [[0, 1 / 2], [1, 1 / 2]]],\n  '⿴': [[[0, 0], [1, 1]], [[(1 - rad2) / 2, (1 - rad2) / 2], [rad2, rad2]]],\n  '⿵': [[[0, 0], [1, 1]], [[(1 - rad2) / 2, 1 - rad2], [rad2, rad2]]],\n  '⿶': [[[0, 0], [1, 1]], [[(1 - rad2) / 2, 0], [rad2, rad2]]],\n  '⿷': [[[0, 0], [1, 1]], [[1 - rad2, (1 - rad2) / 2], [rad2, rad2]]],\n  '⿸': [[[0, 0], [1, 1 - rad2]], [[1 - rad2, 1 - rad2], [rad2, rad2]]],\n  '⿹': [[[0, 0], [1, 1]], [[0, 1 - rad2], [rad2, rad2]]],\n  '⿺': [[[0, 0], [1, 1]], [[1 - rad2, 0], [rad2, rad2]]],\n  '⿻': [[[0, 0], [1, 1]], [[0, 0], [1, 1]]],\n  '⿳': [[[0, 0], [1, 1 / 3]], [[0, 1 / 3], [1, 1 / 3]], [[0, 2 / 3], [1, 1 / 3]]],\n  '⿲': [[[0, 0], [1 / 3, 1]], [[1 / 3, 0], [1 / 3, 1]], [[2 / 3, 0], [1 / 3, 1]]]\n};\n\nconst augmentTreeWithBoundsData = (tree, bounds) => {\n  tree.bounds = bounds;\n\n  if (tree.type === 'compound') {\n    const diff = Point.subtract(bounds[1], bounds[0]);\n    const targets = compound_bounds[tree.value];\n    assert(targets && targets.length === tree.children.length);\n\n    for (let i = 0; i < targets.length; i++) {\n      const target = [targets[i][0], Point.add(targets[i][0], targets[i][1])];\n      const child_bounds = target.map(x => [x[0] * diff[0] + bounds[0][0], x[1] * diff[1] + bounds[0][1]]);\n      augmentTreeWithBoundsData(tree.children[i], child_bounds);\n    }\n  } else {\n    assert(!tree.children);\n  }\n\n  return tree;\n};\n\nconst buildStrokeOrder = (tree, log) => {\n  if (tree.type === 'character') {\n    if (!tree.medians) {\n      log.push(\"Missing component: \".concat(tree.value));\n      return [];\n    }\n\n    return tree.medians.map(x => ({\n      median: x,\n      node: tree\n    }));\n  }\n\n  const parts = tree.children.map(x => buildStrokeOrder(x, log));\n  const child = tree.children[0].value;\n\n  if (tree.value === '⿻') {\n    log.push('Cannot infer stroke order for compound ⿻.');\n  } else if (tree.value === '⿴') {\n    assert(parts.length === 2);\n\n    if (parts[0].length !== 3) {\n      log.push('Compound ⿴ requires first component 囗. ' + \"Got \".concat(child, \" instead.\"));\n    } else {\n      return parts[0].slice(0, 2).concat(parts[1]).concat([parts[0][2]]);\n    }\n  } else if (tree.value === '⿷') {\n    assert(parts.length === 2);\n\n    if (parts[0].length !== 2) {\n      log.push('Compound ⿷ requires first component ⼕ or ⼖. ' + \"Got \".concat(child, \" instead.\"));\n    } else {\n      return parts[0].slice(0, 1).concat(parts[1]).concat([parts[0][1]]);\n    }\n  } else if (tree.value === '⿶' || tree.value === '⿺' && '辶廴乙'.indexOf(child) >= 0) {\n    assert(parts.length === 2);\n    return parts[1].concat(parts[0]);\n  }\n\n  const result = [];\n  parts.map(x => x.map(y => result.push(y)));\n  return result;\n};\n\nconst collectComponentNodes = (tree, result) => {\n  result = result || [];\n\n  if (tree.type === 'character' && tree.value !== '?') {\n    result.push(tree);\n  }\n\n  for (let child of tree.children || []) {\n    collectComponentNodes(child, result);\n  }\n\n  return result;\n};\n\nconst getAffineTransform = (source, target) => {\n  const sdiff = Point.subtract(source[1], source[0]);\n  const tdiff = Point.subtract(target[1], target[0]);\n  const ratio = [tdiff[0] / sdiff[0], tdiff[1] / sdiff[1]];\n  return point => [ratio[0] * (point[0] - source[0][0]) + target[0][0], ratio[1] * (point[1] - source[0][1]) + target[0][1]];\n};\n\nconst matchStrokes = (character, components) => {\n  const normalize = median_util.normalizeForMatch;\n  const sources = character.map(normalize);\n  const targets = [];\n  components.map(x => {\n    const transform = getAffineTransform([[0, 0], [1, 1]], x.node.bounds);\n    const target = normalize(x.median).map(transform);\n    targets.push(target);\n  });\n  const matrix = [];\n  const missing_penalty = 1024;\n  const n = Math.max(sources.length, targets.length);\n\n  for (let i = 0; i < n; i++) {\n    matrix.push([]);\n\n    for (let j = 0; j < n; j++) {\n      if (i < sources.length && j < targets.length) {\n        matrix[i].push(scoreStrokes(sources[i], targets[j]));\n      } else {\n        let top_left_penalty = 0;\n\n        if (j >= targets.length) {\n          // We want strokes that are not matched with components to be sorted\n          // by their proximity to the top-left corner of the glyph. We compute\n          // a penalty which is smaller for strokes closer to this corner,\n          // then multiply the penalty by j so that those strokes come first.\n          const direction = [0.01, 0.02];\n          top_left_penalty = -j * Math.min(Point.dot(direction, sources[i][0]), Point.dot(direction, sources[i][sources[i].length - 1]));\n        }\n\n        matrix[i].push(-missing_penalty - top_left_penalty);\n      }\n    }\n  }\n\n  return new Hungarian(matrix).x_match;\n};\n\nconst maybeReverse = (median, match) => {\n  const diff1 = Point.subtract(median[median.length - 1], median[0]);\n  let diff2 = [1, -2];\n\n  if (match) {\n    const target = match.median;\n    diff2 = Point.subtract(target[target.length - 1], target[0]);\n  }\n\n  if (Point.dot(diff1, diff2) < 0) {\n    median.reverse();\n  }\n\n  return median;\n};\n\nconst scoreStrokes = (stroke1, stroke2) => {\n  assert(stroke1.length === stroke2.length);\n  let option1 = 0;\n  let option2 = 0;\n\n  _.range(stroke1.length).map(i => {\n    option1 -= Point.distance2(stroke1[i], stroke2[i]);\n    option2 -= Point.distance2(stroke1[i], stroke2[stroke2.length - i - 1]);\n  });\n\n  return Math.max(option1, option2);\n};\n\nclass OrderStage extends AbstractStage {\n  constructor(glyph) {\n    super('order');\n    this.adjusted = glyph.stages.order;\n    this.medians = glyph.stages.strokes.raw.map(median_util.findStrokeMedian);\n    this.strokes = glyph.stages.strokes.corrected;\n    const tree = decomposition_util.convertDecompositionToTree(glyph.stages.analysis.decomposition);\n    this.tree = augmentTreeWithBoundsData(tree, [[0, 0], [1, 1]]);\n    this.indices = {\n      null: -1\n    };\n    this.components = [];\n    this.paths = [];\n    collectComponentNodes(this.tree).map((x, i) => {\n      this.indices[JSON.stringify(x.path)] = i;\n      this.components.push(x.value);\n      this.paths.push(x.path);\n    });\n    stage = this;\n  }\n\n  handleEvent(event, template) {\n    const element = this.adjusted.filter(x => x.stroke === template.stroke_index)[0];\n    const old_index = this.indices[JSON.stringify(element.match || null)];\n    const new_index = (old_index + 2) % (this.components.length + 1) - 1;\n    element.match = this.paths[new_index];\n  }\n\n  onAllComponentsReady() {\n    if (this.adjusted) {\n      return;\n    }\n\n    const nodes = collectComponentNodes(this.tree);\n    nodes.map(node => {\n      const glyph = Glyphs.findOne({\n        character: node.value\n      });\n      node.medians = glyph.stages.order.map(x => x.median);\n    });\n    const log = [];\n    const order = buildStrokeOrder(this.tree, log);\n    const matching = matchStrokes(this.medians, order);\n\n    const indices = _.range(this.medians.length).sort((a, b) => matching[a] - matching[b]);\n\n    this.adjusted = indices.map(x => {\n      const match = order[matching[x]];\n      return {\n        match: match ? match.node.path : undefined,\n        median: maybeReverse(this.medians[x], match),\n        stroke: x\n      };\n    });\n    this.forceRefresh(true\n    /* from_construct_stage */\n    );\n  }\n\n  onReverseStroke(stroke) {\n    const element = this.adjusted.filter(x => x.stroke === stroke)[0];\n    element.median.reverse();\n    this.forceRefresh();\n  }\n\n  onSort(old_index, new_index) {\n    const elements = this.adjusted.splice(old_index, 1);\n    assert(elements.length === 1);\n    this.adjusted.splice(new_index, 0, elements[0]);\n    this.forceRefresh();\n  }\n\n  refreshUI() {\n    Session.set('stage.status', this.adjusted ? [] : [{\n      cls: 'error',\n      message: 'Loading component data...'\n    }]);\n    Session.set('stages.order.colors', this.colors);\n    Session.set('stages.order.components', this.components);\n    Session.set('stages.order.indices', this.indices);\n    Session.set('stages.order.order', this.adjusted);\n    Order.remove({});\n    (this.adjusted || []).map((x, i) => {\n      const key = JSON.stringify(x.match || null);\n      const color = this.colors[this.indices[key]] || 'lightgray';\n      const glyph = {\n        lines: [{\n          x1: x.median[0][0],\n          y1: x.median[0][1],\n          x2: x.median[x.median.length - 1][0],\n          y2: x.median[x.median.length - 1][1]\n        }],\n        paths: [{\n          d: this.strokes[x.stroke]\n        }]\n      };\n\n      const lighten = (color, alpha) => {\n        const c = parseInt(color.substr(1), 16);\n        return \"rgba(\".concat(c >> 16, \", \").concat(c >> 8 & 0xFF, \", \").concat(c & 0xFF, \", \").concat(alpha, \")\");\n      };\n\n      Order.insert({\n        background: lighten(color, 0.1),\n        color: color,\n        glyph: glyph,\n        index: i,\n        stroke_index: x.stroke\n      });\n    });\n  }\n\n}\n\nTemplate.order_stage.events({\n  'click .permutation .entry .reverse': function (event) {\n    stage && stage.onReverseStroke(this.stroke_index);\n  }\n});\nTemplate.order_stage.helpers({\n  character: () => {\n    const colors = Session.get('stages.order.colors');\n    const indices = Session.get('stages.order.indices');\n    const order = Session.get('stages.order.order');\n    const character = Session.get('editor.glyph');\n    const result = {\n      paths: []\n    };\n\n    if (!colors || !indices || !order || !character) {\n      return result;\n    }\n\n    for (let element of order) {\n      const index = indices[JSON.stringify(element.match || null)];\n      const color = colors[index % colors.length];\n      result.paths.push({\n        cls: 'selectable',\n        d: character.stages.strokes.corrected[element.stroke],\n        fill: index < 0 ? 'lightgray' : color,\n        stroke: index < 0 ? 'lightgray' : 'black',\n        stroke_index: element.stroke\n      });\n    }\n\n    return result;\n  },\n  components: () => {\n    const colors = Session.get('stages.order.colors');\n    const components = Session.get('stages.order.components');\n    const result = [];\n\n    if (!colors || !components) {\n      return result;\n    }\n\n    for (let index = 0; index < components.length; index++) {\n      const color = colors[index % colors.length];\n      const glyph = Glyphs.findOne({\n        character: components[index]\n      });\n\n      if (!glyph) {\n        continue;\n      }\n\n      const component = [];\n\n      for (let stroke of glyph.stages.strokes.corrected) {\n        component.push({\n          d: stroke,\n          fill: color,\n          stroke: 'black'\n        });\n      }\n\n      result.push({\n        glyph: {\n          paths: component\n        },\n        top: \"\".concat(138 * index + 8, \"px\")\n      });\n    }\n\n    return result;\n  },\n  items: () => {\n    const order = Session.get('stages.order.order');\n    return Order.find({}, {\n      limit: (order || []).length\n    });\n  },\n  options: () => {\n    return {\n      onSort: event => {\n        // Suppress the two errors that will be printed when the Sortable\n        // plugin tries to persist the sort result to the server.\n        Meteor._suppress_log(2);\n\n        stage && stage.onSort(event.oldIndex, event.newIndex);\n      }\n    };\n  }\n});\nMeteor.startup(() => {\n  Tracker.autorun(() => {\n    const components = Session.get('stages.order.components') || [];\n    Meteor.subscribe('getAllGlyphs', components);\n  });\n  Tracker.autorun(() => {\n    const components = Session.get('stages.order.components') || [];\n    const found = components.filter(x => Glyphs.findOne({\n      character: x\n    }));\n\n    if (found.length === components.length && Session.get('stage.type') === 'order') {\n      stage.onAllComponentsReady();\n    }\n  });\n});","map":{"version":3,"sources":["client/lib/order.js"],"names":["module","export","OrderStage","AbstractStage","link","v","assert","Point","decomposition_util","Glyphs","Hungarian","median_util","stage","undefined","Order","Mongo","Collection","_collection","rad2","compound_bounds","augmentTreeWithBoundsData","tree","bounds","type","diff","subtract","targets","value","length","children","i","target","add","child_bounds","map","x","buildStrokeOrder","log","medians","push","median","node","parts","child","slice","concat","indexOf","result","y","collectComponentNodes","getAffineTransform","source","sdiff","tdiff","ratio","point","matchStrokes","character","components","normalize","normalizeForMatch","sources","transform","matrix","missing_penalty","n","Math","max","j","scoreStrokes","top_left_penalty","direction","min","dot","x_match","maybeReverse","match","diff1","diff2","reverse","stroke1","stroke2","option1","option2","_","range","distance2","constructor","glyph","adjusted","stages","order","strokes","raw","findStrokeMedian","corrected","convertDecompositionToTree","analysis","decomposition","indices","null","paths","JSON","stringify","path","handleEvent","event","template","element","filter","stroke","stroke_index","old_index","new_index","onAllComponentsReady","nodes","findOne","matching","sort","a","b","forceRefresh","onReverseStroke","onSort","elements","splice","refreshUI","Session","set","cls","message","colors","remove","key","color","lines","x1","y1","x2","y2","d","lighten","alpha","c","parseInt","substr","insert","background","index","Template","order_stage","events","helpers","get","fill","component","top","items","find","limit","options","Meteor","_suppress_log","oldIndex","newIndex","startup","Tracker","autorun","subscribe","found"],"mappings":"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","sourcesContent":["import {AbstractStage} from '/client/lib/abstract';\nimport {assert, Point} from '/lib/base';\nimport {decomposition_util} from '/lib/decomposition_util';\nimport {Glyphs} from '/lib/glyphs';\nimport {Hungarian} from '/lib/hungarian';\nimport {median_util} from '/lib/median_util';\n\nlet stage = undefined;\n\nconst Order = new Mongo.Collection('order')._collection;\n\n// TODO(skishore): Consider using sqrt(1/2) in place of 1/2 here. This constant\n// is used to compute bounds for components that are surrounded.\nconst rad2 = 1/2;\nconst compound_bounds = {\n  '⿰': [[[0, 0], [1/2, 1]], [[1/2, 0], [1/2, 1]]],\n  '⿱': [[[0, 0], [1, 1/2]], [[0, 1/2], [1, 1/2]]],\n  '⿴': [[[0, 0], [1, 1]], [[(1 - rad2)/2, (1 - rad2)/2], [rad2, rad2]]],\n  '⿵': [[[0, 0], [1, 1]], [[(1 - rad2)/2, 1 - rad2], [rad2, rad2]]],\n  '⿶': [[[0, 0], [1, 1]], [[(1 - rad2)/2, 0], [rad2, rad2]]],\n  '⿷': [[[0, 0], [1, 1]], [[1 - rad2, (1 - rad2)/2], [rad2, rad2]]],\n  '⿸': [[[0, 0], [1, 1 - rad2]], [[1 - rad2, 1 - rad2], [rad2, rad2]]],\n  '⿹': [[[0, 0], [1, 1]], [[0, 1 - rad2], [rad2, rad2]]],\n  '⿺': [[[0, 0], [1, 1]], [[1 - rad2, 0], [rad2, rad2]]],\n  '⿻': [[[0, 0], [1, 1]], [[0, 0], [1, 1]]],\n  '⿳': [[[0, 0], [1, 1/3]], [[0, 1/3], [1, 1/3]], [[0, 2/3], [1, 1/3]]],\n  '⿲': [[[0, 0], [1/3, 1]], [[1/3, 0], [1/3, 1]], [[2/3, 0], [1/3, 1]]],\n}\n\nconst augmentTreeWithBoundsData = (tree, bounds) => {\n  tree.bounds = bounds;\n  if (tree.type === 'compound') {\n    const diff = Point.subtract(bounds[1], bounds[0]);\n    const targets = compound_bounds[tree.value];\n    assert(targets && targets.length === tree.children.length);\n    for (let i = 0; i < targets.length; i++) {\n      const target = [targets[i][0], Point.add(targets[i][0], targets[i][1])];\n      const child_bounds = target.map(\n          (x) => [x[0]*diff[0] + bounds[0][0], x[1]*diff[1] + bounds[0][1]]);\n      augmentTreeWithBoundsData(tree.children[i], child_bounds);\n    }\n  } else {\n    assert(!tree.children);\n  }\n  return tree;\n}\n\nconst buildStrokeOrder = (tree, log) => {\n  if (tree.type === 'character') {\n    if (!tree.medians) {\n      log.push(`Missing component: ${tree.value}`);\n      return [];\n    }\n    return tree.medians.map((x) => ({median: x, node: tree}));\n  }\n  const parts = tree.children.map((x) => buildStrokeOrder(x, log));\n  const child = tree.children[0].value;\n  if (tree.value === '⿻') {\n    log.push('Cannot infer stroke order for compound ⿻.');\n  } else if (tree.value === '⿴') {\n    assert(parts.length === 2);\n    if (parts[0].length !== 3) {\n      log.push('Compound ⿴ requires first component 囗. ' +\n               `Got ${child} instead.`);\n    } else {\n      return parts[0].slice(0, 2).concat(parts[1]).concat([parts[0][2]]);\n    }\n  } else if (tree.value === '⿷') {\n    assert(parts.length === 2);\n    if (parts[0].length !== 2) {\n      log.push('Compound ⿷ requires first component ⼕ or ⼖. ' +\n               `Got ${child} instead.`);\n    } else {\n      return parts[0].slice(0, 1).concat(parts[1]).concat([parts[0][1]]);\n    }\n  } else if (tree.value === '⿶' ||\n             (tree.value === '⿺' && '辶廴乙'.indexOf(child) >= 0)) {\n    assert(parts.length === 2);\n    return parts[1].concat(parts[0]);\n  }\n  const result = [];\n  parts.map((x) => x.map((y) => result.push(y)));\n  return result;\n}\n\nconst collectComponentNodes = (tree, result) => {\n  result = result || [];\n  if (tree.type === 'character' && tree.value !== '?') {\n    result.push(tree);\n  }\n  for (let child of tree.children || []) {\n    collectComponentNodes(child, result);\n  }\n  return result;\n}\n\nconst getAffineTransform = (source, target) => {\n  const sdiff = Point.subtract(source[1], source[0]);\n  const tdiff = Point.subtract(target[1], target[0]);\n  const ratio = [tdiff[0]/sdiff[0], tdiff[1]/sdiff[1]];\n  return (point) => [ratio[0]*(point[0] - source[0][0]) + target[0][0],\n                     ratio[1]*(point[1] - source[0][1]) + target[0][1]];\n}\n\nconst matchStrokes = (character, components) => {\n  const normalize = median_util.normalizeForMatch;\n  const sources = character.map(normalize);\n  const targets = [];\n  components.map((x) => {\n    const transform = getAffineTransform([[0, 0], [1, 1]], x.node.bounds);\n    const target = normalize(x.median).map(transform);\n    targets.push(target);\n  });\n\n  const matrix = [];\n  const missing_penalty = 1024;\n  const n = Math.max(sources.length, targets.length);\n  for (let i = 0; i < n; i++) {\n    matrix.push([]);\n    for (let j = 0; j < n; j++) {\n      if (i < sources.length && j < targets.length) {\n        matrix[i].push(scoreStrokes(sources[i], targets[j]));\n      } else {\n        let top_left_penalty = 0;\n        if (j >= targets.length) {\n          // We want strokes that are not matched with components to be sorted\n          // by their proximity to the top-left corner of the glyph. We compute\n          // a penalty which is smaller for strokes closer to this corner,\n          // then multiply the penalty by j so that those strokes come first.\n          const direction = [0.01, 0.02];\n          top_left_penalty = -j*Math.min(\n              Point.dot(direction, sources[i][0]),\n              Point.dot(direction, sources[i][sources[i].length - 1]));\n        }\n        matrix[i].push(-missing_penalty - top_left_penalty);\n      }\n    }\n  }\n  return new Hungarian(matrix).x_match;\n}\n\nconst maybeReverse = (median, match) => {\n  const diff1 = Point.subtract(median[median.length - 1], median[0]);\n  let diff2 = [1, -2]\n  if (match) {\n    const target = match.median;\n    diff2 = Point.subtract(target[target.length - 1], target[0]);\n  }\n  if (Point.dot(diff1, diff2) < 0) {\n    median.reverse();\n  }\n  return median;\n}\n\nconst scoreStrokes = (stroke1, stroke2) => {\n  assert(stroke1.length === stroke2.length);\n  let option1 = 0;\n  let option2 = 0;\n  _.range(stroke1.length).map((i) => {\n    option1 -= Point.distance2(stroke1[i], stroke2[i]);\n    option2 -= Point.distance2(stroke1[i], stroke2[stroke2.length - i - 1]);\n  });\n  return Math.max(option1, option2);\n}\n\nclass OrderStage extends AbstractStage {\n  constructor(glyph) {\n    super('order');\n    this.adjusted = glyph.stages.order;\n    this.medians = glyph.stages.strokes.raw.map(median_util.findStrokeMedian);\n    this.strokes = glyph.stages.strokes.corrected;\n\n    const tree = decomposition_util.convertDecompositionToTree(\n        glyph.stages.analysis.decomposition);\n    this.tree = augmentTreeWithBoundsData(tree, [[0, 0], [1, 1]]);\n\n    this.indices = {null: -1};\n    this.components = [];\n    this.paths = [];\n    collectComponentNodes(this.tree).map((x, i) => {\n      this.indices[JSON.stringify(x.path)] = i;\n      this.components.push(x.value);\n      this.paths.push(x.path);\n    });\n\n    stage = this;\n  }\n  handleEvent(event, template) {\n    const element = this.adjusted.filter(\n        (x) => x.stroke === template.stroke_index)[0];\n    const old_index = this.indices[JSON.stringify(element.match || null)];\n    const new_index = ((old_index + 2) % (this.components.length + 1)) - 1;\n    element.match = this.paths[new_index];\n  }\n  onAllComponentsReady() {\n    if (this.adjusted) {\n      return;\n    }\n    const nodes = collectComponentNodes(this.tree);\n    nodes.map((node) => {\n      const glyph = Glyphs.findOne({character: node.value});\n      node.medians = glyph.stages.order.map((x) => x.median);\n    });\n    const log = [];\n    const order = buildStrokeOrder(this.tree, log);\n    const matching = matchStrokes(this.medians, order);\n    const indices = _.range(this.medians.length).sort(\n        (a, b) => matching[a] - matching[b]);\n    this.adjusted = indices.map((x) => {\n      const match = order[matching[x]];\n      return {\n        match: match ? match.node.path : undefined,\n        median: maybeReverse(this.medians[x], match),\n        stroke: x,\n      };\n    });\n    this.forceRefresh(true /* from_construct_stage */);\n  }\n  onReverseStroke(stroke) {\n    const element = this.adjusted.filter((x) => x.stroke === stroke)[0];\n    element.median.reverse();\n    this.forceRefresh();\n  }\n  onSort(old_index, new_index) {\n    const elements = this.adjusted.splice(old_index, 1);\n    assert(elements.length === 1);\n    this.adjusted.splice(new_index, 0, elements[0]);\n    this.forceRefresh();\n  }\n  refreshUI() {\n    Session.set('stage.status', this.adjusted ? [] : [{\n      cls: 'error',\n      message: 'Loading component data...',\n    }]);\n    Session.set('stages.order.colors', this.colors);\n    Session.set('stages.order.components', this.components);\n    Session.set('stages.order.indices', this.indices);\n    Session.set('stages.order.order', this.adjusted);\n    Order.remove({});\n    (this.adjusted || []).map((x, i) => {\n      const key = JSON.stringify(x.match || null);\n      const color = this.colors[this.indices[key]] || 'lightgray';\n      const glyph = {\n        lines: [{\n          x1: x.median[0][0],\n          y1: x.median[0][1],\n          x2: x.median[x.median.length - 1][0],\n          y2: x.median[x.median.length - 1][1],\n        }],\n        paths: [{d: this.strokes[x.stroke]}],\n      };\n      const lighten = (color, alpha) => {\n        const c = parseInt(color.substr(1), 16);\n        return `rgba(${c >> 16}, ${(c >> 8) & 0xFF}, ${c & 0xFF}, ${alpha})`;\n      };\n      Order.insert({\n        background: lighten(color, 0.1),\n        color: color,\n        glyph: glyph,\n        index: i,\n        stroke_index: x.stroke,\n      });\n    });\n  }\n}\n\nTemplate.order_stage.events({\n  'click .permutation .entry .reverse': function(event) {\n    stage && stage.onReverseStroke(this.stroke_index);\n  },\n});\n\nTemplate.order_stage.helpers({\n  character: () => {\n    const colors = Session.get('stages.order.colors');\n    const indices = Session.get('stages.order.indices');\n    const order = Session.get('stages.order.order');\n    const character = Session.get('editor.glyph');\n    const result = {paths: []};\n    if (!colors || !indices || !order || !character) {\n      return result;\n    }\n    for (let element of order) {\n      const index = indices[JSON.stringify(element.match || null)];\n      const color = colors[index % colors.length];\n      result.paths.push({\n        cls: 'selectable',\n        d: character.stages.strokes.corrected[element.stroke],\n        fill: index < 0 ? 'lightgray' : color,\n        stroke: index < 0 ? 'lightgray' : 'black',\n        stroke_index: element.stroke,\n      });\n    }\n    return result;\n  },\n  components: () => {\n    const colors = Session.get('stages.order.colors');\n    const components = Session.get('stages.order.components');\n    const result = [];\n    if (!colors || !components) {\n      return result;\n    }\n    for (let index = 0; index < components.length; index++) {\n      const color = colors[index % colors.length];\n      const glyph = Glyphs.findOne({character: components[index]});\n      if (!glyph) {\n        continue;\n      }\n      const component = [];\n      for (let stroke of glyph.stages.strokes.corrected) {\n        component.push({d: stroke, fill: color, stroke: 'black'});\n      }\n      result.push({glyph: {paths: component}, top: `${138*index + 8}px`});\n    }\n    return result;\n  },\n  items: () => {\n    const order = Session.get('stages.order.order');\n    return Order.find({}, {limit: (order || []).length});\n  },\n  options: () => {\n    return {\n      onSort: (event) => {\n        // Suppress the two errors that will be printed when the Sortable\n        // plugin tries to persist the sort result to the server.\n        Meteor._suppress_log(2);\n        stage && stage.onSort(event.oldIndex, event.newIndex);\n      },\n    }\n  },\n});\n\nMeteor.startup(() => {\n  Tracker.autorun(() => {\n    const components = Session.get('stages.order.components') || [];\n    Meteor.subscribe('getAllGlyphs', components);\n  });\n  Tracker.autorun(() => {\n    const components = Session.get('stages.order.components') || [];\n    const found = components.filter((x) => Glyphs.findOne({character: x}));\n    if (found.length === components.length &&\n        Session.get('stage.type') === 'order') {\n      stage.onAllComponentsReady();\n    }\n  });\n});\n\nexport {OrderStage};\n"]},"sourceType":"module","externalDependencies":{},"hash":"38a49cb17a55ea97ac53ab1a37f45c8ce0c65bd3"}
