{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/a37/code/github/makemeahanzi-tool/client/lib/order.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"client/lib/order.js","filename":"/Users/a37/code/github/makemeahanzi-tool/client/lib/order.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/a37/code/github/makemeahanzi-tool","root":"/Users/a37/code/github/makemeahanzi-tool","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]}},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/a37/code/github/makemeahanzi-tool/client/lib/order.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"client/lib/order.js"}},"code":"var _assertThisInitialized;\n\nmodule.link(\"@babel/runtime/helpers/assertThisInitialized\", {\n  default: function (v) {\n    _assertThisInitialized = v;\n  }\n}, 0);\n\nvar _inheritsLoose;\n\nmodule.link(\"@babel/runtime/helpers/inheritsLoose\", {\n  default: function (v) {\n    _inheritsLoose = v;\n  }\n}, 1);\n\nvar _createForOfIteratorHelperLoose;\n\nmodule.link(\"@babel/runtime/helpers/createForOfIteratorHelperLoose\", {\n  default: function (v) {\n    _createForOfIteratorHelperLoose = v;\n  }\n}, 2);\nmodule.export({\n  OrderStage: function () {\n    return OrderStage;\n  }\n});\nvar AbstractStage;\nmodule.link(\"/client/lib/abstract\", {\n  AbstractStage: function (v) {\n    AbstractStage = v;\n  }\n}, 0);\nvar assert, Point;\nmodule.link(\"/lib/base\", {\n  assert: function (v) {\n    assert = v;\n  },\n  Point: function (v) {\n    Point = v;\n  }\n}, 1);\nvar decomposition_util;\nmodule.link(\"/lib/decomposition_util\", {\n  decomposition_util: function (v) {\n    decomposition_util = v;\n  }\n}, 2);\nvar Glyphs;\nmodule.link(\"/lib/glyphs\", {\n  Glyphs: function (v) {\n    Glyphs = v;\n  }\n}, 3);\nvar Hungarian;\nmodule.link(\"/lib/hungarian\", {\n  Hungarian: function (v) {\n    Hungarian = v;\n  }\n}, 4);\nvar median_util;\nmodule.link(\"/lib/median_util\", {\n  median_util: function (v) {\n    median_util = v;\n  }\n}, 5);\nvar stage = undefined;\nvar Order = new Mongo.Collection('order')._collection; // TODO(skishore): Consider using sqrt(1/2) in place of 1/2 here. This constant\n// is used to compute bounds for components that are surrounded.\n\nvar rad2 = 1 / 2;\nvar compound_bounds = {\n  '⿰': [[[0, 0], [1 / 2, 1]], [[1 / 2, 0], [1 / 2, 1]]],\n  '⿱': [[[0, 0], [1, 1 / 2]], [[0, 1 / 2], [1, 1 / 2]]],\n  '⿴': [[[0, 0], [1, 1]], [[(1 - rad2) / 2, (1 - rad2) / 2], [rad2, rad2]]],\n  '⿵': [[[0, 0], [1, 1]], [[(1 - rad2) / 2, 1 - rad2], [rad2, rad2]]],\n  '⿶': [[[0, 0], [1, 1]], [[(1 - rad2) / 2, 0], [rad2, rad2]]],\n  '⿷': [[[0, 0], [1, 1]], [[1 - rad2, (1 - rad2) / 2], [rad2, rad2]]],\n  '⿸': [[[0, 0], [1, 1 - rad2]], [[1 - rad2, 1 - rad2], [rad2, rad2]]],\n  '⿹': [[[0, 0], [1, 1]], [[0, 1 - rad2], [rad2, rad2]]],\n  '⿺': [[[0, 0], [1, 1]], [[1 - rad2, 0], [rad2, rad2]]],\n  '⿻': [[[0, 0], [1, 1]], [[0, 0], [1, 1]]],\n  '⿳': [[[0, 0], [1, 1 / 3]], [[0, 1 / 3], [1, 1 / 3]], [[0, 2 / 3], [1, 1 / 3]]],\n  '⿲': [[[0, 0], [1 / 3, 1]], [[1 / 3, 0], [1 / 3, 1]], [[2 / 3, 0], [1 / 3, 1]]]\n};\n\nvar augmentTreeWithBoundsData = function (tree, bounds) {\n  tree.bounds = bounds;\n\n  if (tree.type === 'compound') {\n    (function () {\n      var diff = Point.subtract(bounds[1], bounds[0]);\n      var targets = compound_bounds[tree.value];\n      assert(targets && targets.length === tree.children.length);\n\n      for (var i = 0; i < targets.length; i++) {\n        var target = [targets[i][0], Point.add(targets[i][0], targets[i][1])];\n        var child_bounds = target.map(function (x) {\n          return [x[0] * diff[0] + bounds[0][0], x[1] * diff[1] + bounds[0][1]];\n        });\n        augmentTreeWithBoundsData(tree.children[i], child_bounds);\n      }\n    })();\n  } else {\n    assert(!tree.children);\n  }\n\n  return tree;\n};\n\nvar buildStrokeOrder = function (tree, log) {\n  if (tree.type === 'character') {\n    if (!tree.medians) {\n      log.push(\"Missing component: \" + tree.value);\n      return [];\n    }\n\n    return tree.medians.map(function (x) {\n      return {\n        median: x,\n        node: tree\n      };\n    });\n  }\n\n  var parts = tree.children.map(function (x) {\n    return buildStrokeOrder(x, log);\n  });\n  var child = tree.children[0].value;\n\n  if (tree.value === '⿻') {\n    log.push('Cannot infer stroke order for compound ⿻.');\n  } else if (tree.value === '⿴') {\n    assert(parts.length === 2);\n\n    if (parts[0].length !== 3) {\n      log.push('Compound ⿴ requires first component 囗. ' + (\"Got \" + child + \" instead.\"));\n    } else {\n      return parts[0].slice(0, 2).concat(parts[1]).concat([parts[0][2]]);\n    }\n  } else if (tree.value === '⿷') {\n    assert(parts.length === 2);\n\n    if (parts[0].length !== 2) {\n      log.push('Compound ⿷ requires first component ⼕ or ⼖. ' + (\"Got \" + child + \" instead.\"));\n    } else {\n      return parts[0].slice(0, 1).concat(parts[1]).concat([parts[0][1]]);\n    }\n  } else if (tree.value === '⿶' || tree.value === '⿺' && '辶廴乙'.indexOf(child) >= 0) {\n    assert(parts.length === 2);\n    return parts[1].concat(parts[0]);\n  }\n\n  var result = [];\n  parts.map(function (x) {\n    return x.map(function (y) {\n      return result.push(y);\n    });\n  });\n  return result;\n};\n\nvar collectComponentNodes = function (tree, result) {\n  result = result || [];\n\n  if (tree.type === 'character' && tree.value !== '?') {\n    result.push(tree);\n  }\n\n  for (var _iterator = _createForOfIteratorHelperLoose(tree.children || []), _step; !(_step = _iterator()).done;) {\n    var child = _step.value;\n    collectComponentNodes(child, result);\n  }\n\n  return result;\n};\n\nvar getAffineTransform = function (source, target) {\n  var sdiff = Point.subtract(source[1], source[0]);\n  var tdiff = Point.subtract(target[1], target[0]);\n  var ratio = [tdiff[0] / sdiff[0], tdiff[1] / sdiff[1]];\n  return function (point) {\n    return [ratio[0] * (point[0] - source[0][0]) + target[0][0], ratio[1] * (point[1] - source[0][1]) + target[0][1]];\n  };\n};\n\nvar matchStrokes = function (character, components) {\n  var normalize = median_util.normalizeForMatch;\n  var sources = character.map(normalize);\n  var targets = [];\n  components.map(function (x) {\n    var transform = getAffineTransform([[0, 0], [1, 1]], x.node.bounds);\n    var target = normalize(x.median).map(transform);\n    targets.push(target);\n  });\n  var matrix = [];\n  var missing_penalty = 1024;\n  var n = Math.max(sources.length, targets.length);\n\n  for (var i = 0; i < n; i++) {\n    matrix.push([]);\n\n    for (var j = 0; j < n; j++) {\n      if (i < sources.length && j < targets.length) {\n        matrix[i].push(scoreStrokes(sources[i], targets[j]));\n      } else {\n        var top_left_penalty = 0;\n\n        if (j >= targets.length) {\n          // We want strokes that are not matched with components to be sorted\n          // by their proximity to the top-left corner of the glyph. We compute\n          // a penalty which is smaller for strokes closer to this corner,\n          // then multiply the penalty by j so that those strokes come first.\n          var direction = [0.01, 0.02];\n          top_left_penalty = -j * Math.min(Point.dot(direction, sources[i][0]), Point.dot(direction, sources[i][sources[i].length - 1]));\n        }\n\n        matrix[i].push(-missing_penalty - top_left_penalty);\n      }\n    }\n  }\n\n  return new Hungarian(matrix).x_match;\n};\n\nvar maybeReverse = function (median, match) {\n  var diff1 = Point.subtract(median[median.length - 1], median[0]);\n  var diff2 = [1, -2];\n\n  if (match) {\n    var target = match.median;\n    diff2 = Point.subtract(target[target.length - 1], target[0]);\n  }\n\n  if (Point.dot(diff1, diff2) < 0) {\n    median.reverse();\n  }\n\n  return median;\n};\n\nvar scoreStrokes = function (stroke1, stroke2) {\n  assert(stroke1.length === stroke2.length);\n  var option1 = 0;\n  var option2 = 0;\n\n  _.range(stroke1.length).map(function (i) {\n    option1 -= Point.distance2(stroke1[i], stroke2[i]);\n    option2 -= Point.distance2(stroke1[i], stroke2[stroke2.length - i - 1]);\n  });\n\n  return Math.max(option1, option2);\n};\n\nvar OrderStage = /*#__PURE__*/function (_AbstractStage) {\n  _inheritsLoose(OrderStage, _AbstractStage);\n\n  function OrderStage(glyph) {\n    var _this;\n\n    _this = _AbstractStage.call(this, 'order') || this;\n    _this.adjusted = glyph.stages.order;\n    _this.medians = glyph.stages.strokes.raw.map(median_util.findStrokeMedian);\n    _this.strokes = glyph.stages.strokes.corrected;\n    var tree = decomposition_util.convertDecompositionToTree(glyph.stages.analysis.decomposition);\n    _this.tree = augmentTreeWithBoundsData(tree, [[0, 0], [1, 1]]);\n    _this.indices = {\n      \"null\": -1\n    };\n    _this.components = [];\n    _this.paths = [];\n    collectComponentNodes(_this.tree).map(function (x, i) {\n      _this.indices[JSON.stringify(x.path)] = i;\n\n      _this.components.push(x.value);\n\n      _this.paths.push(x.path);\n    });\n    stage = _assertThisInitialized(_this);\n    return _this;\n  }\n\n  var _proto = OrderStage.prototype;\n\n  _proto.handleEvent = function () {\n    function handleEvent(event, template) {\n      var element = this.adjusted.filter(function (x) {\n        return x.stroke === template.stroke_index;\n      })[0];\n      var old_index = this.indices[JSON.stringify(element.match || null)];\n      var new_index = (old_index + 2) % (this.components.length + 1) - 1;\n      element.match = this.paths[new_index];\n    }\n\n    return handleEvent;\n  }();\n\n  _proto.onAllComponentsReady = function () {\n    function onAllComponentsReady() {\n      var _this2 = this;\n\n      if (this.adjusted) {\n        return;\n      }\n\n      var nodes = collectComponentNodes(this.tree);\n      nodes.map(function (node) {\n        var glyph = Glyphs.findOne({\n          character: node.value\n        });\n        node.medians = glyph.stages.order.map(function (x) {\n          return x.median;\n        });\n      });\n      var log = [];\n      var order = buildStrokeOrder(this.tree, log);\n      var matching = matchStrokes(this.medians, order);\n\n      var indices = _.range(this.medians.length).sort(function (a, b) {\n        return matching[a] - matching[b];\n      });\n\n      this.adjusted = indices.map(function (x) {\n        var match = order[matching[x]];\n        return {\n          match: match ? match.node.path : undefined,\n          median: maybeReverse(_this2.medians[x], match),\n          stroke: x\n        };\n      });\n      this.forceRefresh(true\n      /* from_construct_stage */\n      );\n    }\n\n    return onAllComponentsReady;\n  }();\n\n  _proto.onReverseStroke = function () {\n    function onReverseStroke(stroke) {\n      var element = this.adjusted.filter(function (x) {\n        return x.stroke === stroke;\n      })[0];\n      element.median.reverse();\n      this.forceRefresh();\n    }\n\n    return onReverseStroke;\n  }();\n\n  _proto.onSort = function () {\n    function onSort(old_index, new_index) {\n      var elements = this.adjusted.splice(old_index, 1);\n      assert(elements.length === 1);\n      this.adjusted.splice(new_index, 0, elements[0]);\n      this.forceRefresh();\n    }\n\n    return onSort;\n  }();\n\n  _proto.refreshUI = function () {\n    function refreshUI() {\n      var _this3 = this;\n\n      Session.set('stage.status', this.adjusted ? [] : [{\n        cls: 'error',\n        message: 'Loading component data...'\n      }]);\n      Session.set('stages.order.colors', this.colors);\n      Session.set('stages.order.components', this.components);\n      Session.set('stages.order.indices', this.indices);\n      Session.set('stages.order.order', this.adjusted);\n      Order.remove({});\n      (this.adjusted || []).map(function (x, i) {\n        var key = JSON.stringify(x.match || null);\n        var color = _this3.colors[_this3.indices[key]] || 'lightgray';\n        var glyph = {\n          lines: [{\n            x1: x.median[0][0],\n            y1: x.median[0][1],\n            x2: x.median[x.median.length - 1][0],\n            y2: x.median[x.median.length - 1][1]\n          }],\n          paths: [{\n            d: _this3.strokes[x.stroke]\n          }]\n        };\n\n        var lighten = function (color, alpha) {\n          var c = parseInt(color.substr(1), 16);\n          return \"rgba(\" + (c >> 16) + \", \" + (c >> 8 & 0xFF) + \", \" + (c & 0xFF) + \", \" + alpha + \")\";\n        };\n\n        Order.insert({\n          background: lighten(color, 0.1),\n          color: color,\n          glyph: glyph,\n          index: i,\n          stroke_index: x.stroke\n        });\n      });\n    }\n\n    return refreshUI;\n  }();\n\n  return OrderStage;\n}(AbstractStage);\n\nTemplate.order_stage.events({\n  'click .permutation .entry .reverse': function (event) {\n    stage && stage.onReverseStroke(this.stroke_index);\n  }\n});\nTemplate.order_stage.helpers({\n  character: function () {\n    var colors = Session.get('stages.order.colors');\n    var indices = Session.get('stages.order.indices');\n    var order = Session.get('stages.order.order');\n    var character = Session.get('editor.glyph');\n    var result = {\n      paths: []\n    };\n\n    if (!colors || !indices || !order || !character) {\n      return result;\n    }\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(order), _step2; !(_step2 = _iterator2()).done;) {\n      var element = _step2.value;\n      var index = indices[JSON.stringify(element.match || null)];\n      var color = colors[index % colors.length];\n      result.paths.push({\n        cls: 'selectable',\n        d: character.stages.strokes.corrected[element.stroke],\n        fill: index < 0 ? 'lightgray' : color,\n        stroke: index < 0 ? 'lightgray' : 'black',\n        stroke_index: element.stroke\n      });\n    }\n\n    return result;\n  },\n  components: function () {\n    var colors = Session.get('stages.order.colors');\n    var components = Session.get('stages.order.components');\n    var result = [];\n\n    if (!colors || !components) {\n      return result;\n    }\n\n    for (var index = 0; index < components.length; index++) {\n      var color = colors[index % colors.length];\n      var glyph = Glyphs.findOne({\n        character: components[index]\n      });\n\n      if (!glyph) {\n        continue;\n      }\n\n      var component = [];\n\n      for (var _iterator3 = _createForOfIteratorHelperLoose(glyph.stages.strokes.corrected), _step3; !(_step3 = _iterator3()).done;) {\n        var stroke = _step3.value;\n        component.push({\n          d: stroke,\n          fill: color,\n          stroke: 'black'\n        });\n      }\n\n      result.push({\n        glyph: {\n          paths: component\n        },\n        top: 138 * index + 8 + \"px\"\n      });\n    }\n\n    return result;\n  },\n  items: function () {\n    var order = Session.get('stages.order.order');\n    return Order.find({}, {\n      limit: (order || []).length\n    });\n  },\n  options: function () {\n    return {\n      onSort: function (event) {\n        // Suppress the two errors that will be printed when the Sortable\n        // plugin tries to persist the sort result to the server.\n        Meteor._suppress_log(2);\n\n        stage && stage.onSort(event.oldIndex, event.newIndex);\n      }\n    };\n  }\n});\nMeteor.startup(function () {\n  Tracker.autorun(function () {\n    var components = Session.get('stages.order.components') || [];\n    Meteor.subscribe('getAllGlyphs', components);\n  });\n  Tracker.autorun(function () {\n    var components = Session.get('stages.order.components') || [];\n    var found = components.filter(function (x) {\n      return Glyphs.findOne({\n        character: x\n      });\n    });\n\n    if (found.length === components.length && Session.get('stage.type') === 'order') {\n      stage.onAllComponentsReady();\n    }\n  });\n});","map":{"version":3,"sources":["client/lib/order.js"],"names":["_assertThisInitialized","module","link","default","v","_inheritsLoose","_createForOfIteratorHelperLoose","export","OrderStage","AbstractStage","assert","Point","decomposition_util","Glyphs","Hungarian","median_util","stage","undefined","Order","Mongo","Collection","_collection","rad2","compound_bounds","augmentTreeWithBoundsData","tree","bounds","type","diff","subtract","targets","value","length","children","i","target","add","child_bounds","map","x","buildStrokeOrder","log","medians","push","median","node","parts","child","slice","concat","indexOf","result","y","collectComponentNodes","getAffineTransform","source","sdiff","tdiff","ratio","point","matchStrokes","character","components","normalize","normalizeForMatch","sources","transform","matrix","missing_penalty","n","Math","max","j","scoreStrokes","top_left_penalty","direction","min","dot","x_match","maybeReverse","match","diff1","diff2","reverse","stroke1","stroke2","option1","option2","_","range","distance2","glyph","adjusted","stages","order","strokes","raw","findStrokeMedian","corrected","convertDecompositionToTree","analysis","decomposition","indices","paths","JSON","stringify","path","handleEvent","event","template","element","filter","stroke","stroke_index","old_index","new_index","onAllComponentsReady","nodes","findOne","matching","sort","a","b","forceRefresh","onReverseStroke","onSort","elements","splice","refreshUI","Session","set","cls","message","colors","remove","key","color","lines","x1","y1","x2","y2","d","lighten","alpha","c","parseInt","substr","insert","background","index","Template","order_stage","events","helpers","get","fill","component","top","items","find","limit","options","Meteor","_suppress_log","oldIndex","newIndex","startup","Tracker","autorun","subscribe","found"],"mappings":"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","sourcesContent":["import {AbstractStage} from '/client/lib/abstract';\nimport {assert, Point} from '/lib/base';\nimport {decomposition_util} from '/lib/decomposition_util';\nimport {Glyphs} from '/lib/glyphs';\nimport {Hungarian} from '/lib/hungarian';\nimport {median_util} from '/lib/median_util';\n\nlet stage = undefined;\n\nconst Order = new Mongo.Collection('order')._collection;\n\n// TODO(skishore): Consider using sqrt(1/2) in place of 1/2 here. This constant\n// is used to compute bounds for components that are surrounded.\nconst rad2 = 1/2;\nconst compound_bounds = {\n  '⿰': [[[0, 0], [1/2, 1]], [[1/2, 0], [1/2, 1]]],\n  '⿱': [[[0, 0], [1, 1/2]], [[0, 1/2], [1, 1/2]]],\n  '⿴': [[[0, 0], [1, 1]], [[(1 - rad2)/2, (1 - rad2)/2], [rad2, rad2]]],\n  '⿵': [[[0, 0], [1, 1]], [[(1 - rad2)/2, 1 - rad2], [rad2, rad2]]],\n  '⿶': [[[0, 0], [1, 1]], [[(1 - rad2)/2, 0], [rad2, rad2]]],\n  '⿷': [[[0, 0], [1, 1]], [[1 - rad2, (1 - rad2)/2], [rad2, rad2]]],\n  '⿸': [[[0, 0], [1, 1 - rad2]], [[1 - rad2, 1 - rad2], [rad2, rad2]]],\n  '⿹': [[[0, 0], [1, 1]], [[0, 1 - rad2], [rad2, rad2]]],\n  '⿺': [[[0, 0], [1, 1]], [[1 - rad2, 0], [rad2, rad2]]],\n  '⿻': [[[0, 0], [1, 1]], [[0, 0], [1, 1]]],\n  '⿳': [[[0, 0], [1, 1/3]], [[0, 1/3], [1, 1/3]], [[0, 2/3], [1, 1/3]]],\n  '⿲': [[[0, 0], [1/3, 1]], [[1/3, 0], [1/3, 1]], [[2/3, 0], [1/3, 1]]],\n}\n\nconst augmentTreeWithBoundsData = (tree, bounds) => {\n  tree.bounds = bounds;\n  if (tree.type === 'compound') {\n    const diff = Point.subtract(bounds[1], bounds[0]);\n    const targets = compound_bounds[tree.value];\n    assert(targets && targets.length === tree.children.length);\n    for (let i = 0; i < targets.length; i++) {\n      const target = [targets[i][0], Point.add(targets[i][0], targets[i][1])];\n      const child_bounds = target.map(\n          (x) => [x[0]*diff[0] + bounds[0][0], x[1]*diff[1] + bounds[0][1]]);\n      augmentTreeWithBoundsData(tree.children[i], child_bounds);\n    }\n  } else {\n    assert(!tree.children);\n  }\n  return tree;\n}\n\nconst buildStrokeOrder = (tree, log) => {\n  if (tree.type === 'character') {\n    if (!tree.medians) {\n      log.push(`Missing component: ${tree.value}`);\n      return [];\n    }\n    return tree.medians.map((x) => ({median: x, node: tree}));\n  }\n  const parts = tree.children.map((x) => buildStrokeOrder(x, log));\n  const child = tree.children[0].value;\n  if (tree.value === '⿻') {\n    log.push('Cannot infer stroke order for compound ⿻.');\n  } else if (tree.value === '⿴') {\n    assert(parts.length === 2);\n    if (parts[0].length !== 3) {\n      log.push('Compound ⿴ requires first component 囗. ' +\n               `Got ${child} instead.`);\n    } else {\n      return parts[0].slice(0, 2).concat(parts[1]).concat([parts[0][2]]);\n    }\n  } else if (tree.value === '⿷') {\n    assert(parts.length === 2);\n    if (parts[0].length !== 2) {\n      log.push('Compound ⿷ requires first component ⼕ or ⼖. ' +\n               `Got ${child} instead.`);\n    } else {\n      return parts[0].slice(0, 1).concat(parts[1]).concat([parts[0][1]]);\n    }\n  } else if (tree.value === '⿶' ||\n             (tree.value === '⿺' && '辶廴乙'.indexOf(child) >= 0)) {\n    assert(parts.length === 2);\n    return parts[1].concat(parts[0]);\n  }\n  const result = [];\n  parts.map((x) => x.map((y) => result.push(y)));\n  return result;\n}\n\nconst collectComponentNodes = (tree, result) => {\n  result = result || [];\n  if (tree.type === 'character' && tree.value !== '?') {\n    result.push(tree);\n  }\n  for (let child of tree.children || []) {\n    collectComponentNodes(child, result);\n  }\n  return result;\n}\n\nconst getAffineTransform = (source, target) => {\n  const sdiff = Point.subtract(source[1], source[0]);\n  const tdiff = Point.subtract(target[1], target[0]);\n  const ratio = [tdiff[0]/sdiff[0], tdiff[1]/sdiff[1]];\n  return (point) => [ratio[0]*(point[0] - source[0][0]) + target[0][0],\n                     ratio[1]*(point[1] - source[0][1]) + target[0][1]];\n}\n\nconst matchStrokes = (character, components) => {\n  const normalize = median_util.normalizeForMatch;\n  const sources = character.map(normalize);\n  const targets = [];\n  components.map((x) => {\n    const transform = getAffineTransform([[0, 0], [1, 1]], x.node.bounds);\n    const target = normalize(x.median).map(transform);\n    targets.push(target);\n  });\n\n  const matrix = [];\n  const missing_penalty = 1024;\n  const n = Math.max(sources.length, targets.length);\n  for (let i = 0; i < n; i++) {\n    matrix.push([]);\n    for (let j = 0; j < n; j++) {\n      if (i < sources.length && j < targets.length) {\n        matrix[i].push(scoreStrokes(sources[i], targets[j]));\n      } else {\n        let top_left_penalty = 0;\n        if (j >= targets.length) {\n          // We want strokes that are not matched with components to be sorted\n          // by their proximity to the top-left corner of the glyph. We compute\n          // a penalty which is smaller for strokes closer to this corner,\n          // then multiply the penalty by j so that those strokes come first.\n          const direction = [0.01, 0.02];\n          top_left_penalty = -j*Math.min(\n              Point.dot(direction, sources[i][0]),\n              Point.dot(direction, sources[i][sources[i].length - 1]));\n        }\n        matrix[i].push(-missing_penalty - top_left_penalty);\n      }\n    }\n  }\n  return new Hungarian(matrix).x_match;\n}\n\nconst maybeReverse = (median, match) => {\n  const diff1 = Point.subtract(median[median.length - 1], median[0]);\n  let diff2 = [1, -2]\n  if (match) {\n    const target = match.median;\n    diff2 = Point.subtract(target[target.length - 1], target[0]);\n  }\n  if (Point.dot(diff1, diff2) < 0) {\n    median.reverse();\n  }\n  return median;\n}\n\nconst scoreStrokes = (stroke1, stroke2) => {\n  assert(stroke1.length === stroke2.length);\n  let option1 = 0;\n  let option2 = 0;\n  _.range(stroke1.length).map((i) => {\n    option1 -= Point.distance2(stroke1[i], stroke2[i]);\n    option2 -= Point.distance2(stroke1[i], stroke2[stroke2.length - i - 1]);\n  });\n  return Math.max(option1, option2);\n}\n\nclass OrderStage extends AbstractStage {\n  constructor(glyph) {\n    super('order');\n    this.adjusted = glyph.stages.order;\n    this.medians = glyph.stages.strokes.raw.map(median_util.findStrokeMedian);\n    this.strokes = glyph.stages.strokes.corrected;\n\n    const tree = decomposition_util.convertDecompositionToTree(\n        glyph.stages.analysis.decomposition);\n    this.tree = augmentTreeWithBoundsData(tree, [[0, 0], [1, 1]]);\n\n    this.indices = {null: -1};\n    this.components = [];\n    this.paths = [];\n    collectComponentNodes(this.tree).map((x, i) => {\n      this.indices[JSON.stringify(x.path)] = i;\n      this.components.push(x.value);\n      this.paths.push(x.path);\n    });\n\n    stage = this;\n  }\n  handleEvent(event, template) {\n    const element = this.adjusted.filter(\n        (x) => x.stroke === template.stroke_index)[0];\n    const old_index = this.indices[JSON.stringify(element.match || null)];\n    const new_index = ((old_index + 2) % (this.components.length + 1)) - 1;\n    element.match = this.paths[new_index];\n  }\n  onAllComponentsReady() {\n    if (this.adjusted) {\n      return;\n    }\n    const nodes = collectComponentNodes(this.tree);\n    nodes.map((node) => {\n      const glyph = Glyphs.findOne({character: node.value});\n      node.medians = glyph.stages.order.map((x) => x.median);\n    });\n    const log = [];\n    const order = buildStrokeOrder(this.tree, log);\n    const matching = matchStrokes(this.medians, order);\n    const indices = _.range(this.medians.length).sort(\n        (a, b) => matching[a] - matching[b]);\n    this.adjusted = indices.map((x) => {\n      const match = order[matching[x]];\n      return {\n        match: match ? match.node.path : undefined,\n        median: maybeReverse(this.medians[x], match),\n        stroke: x,\n      };\n    });\n    this.forceRefresh(true /* from_construct_stage */);\n  }\n  onReverseStroke(stroke) {\n    const element = this.adjusted.filter((x) => x.stroke === stroke)[0];\n    element.median.reverse();\n    this.forceRefresh();\n  }\n  onSort(old_index, new_index) {\n    const elements = this.adjusted.splice(old_index, 1);\n    assert(elements.length === 1);\n    this.adjusted.splice(new_index, 0, elements[0]);\n    this.forceRefresh();\n  }\n  refreshUI() {\n    Session.set('stage.status', this.adjusted ? [] : [{\n      cls: 'error',\n      message: 'Loading component data...',\n    }]);\n    Session.set('stages.order.colors', this.colors);\n    Session.set('stages.order.components', this.components);\n    Session.set('stages.order.indices', this.indices);\n    Session.set('stages.order.order', this.adjusted);\n    Order.remove({});\n    (this.adjusted || []).map((x, i) => {\n      const key = JSON.stringify(x.match || null);\n      const color = this.colors[this.indices[key]] || 'lightgray';\n      const glyph = {\n        lines: [{\n          x1: x.median[0][0],\n          y1: x.median[0][1],\n          x2: x.median[x.median.length - 1][0],\n          y2: x.median[x.median.length - 1][1],\n        }],\n        paths: [{d: this.strokes[x.stroke]}],\n      };\n      const lighten = (color, alpha) => {\n        const c = parseInt(color.substr(1), 16);\n        return `rgba(${c >> 16}, ${(c >> 8) & 0xFF}, ${c & 0xFF}, ${alpha})`;\n      };\n      Order.insert({\n        background: lighten(color, 0.1),\n        color: color,\n        glyph: glyph,\n        index: i,\n        stroke_index: x.stroke,\n      });\n    });\n  }\n}\n\nTemplate.order_stage.events({\n  'click .permutation .entry .reverse': function(event) {\n    stage && stage.onReverseStroke(this.stroke_index);\n  },\n});\n\nTemplate.order_stage.helpers({\n  character: () => {\n    const colors = Session.get('stages.order.colors');\n    const indices = Session.get('stages.order.indices');\n    const order = Session.get('stages.order.order');\n    const character = Session.get('editor.glyph');\n    const result = {paths: []};\n    if (!colors || !indices || !order || !character) {\n      return result;\n    }\n    for (let element of order) {\n      const index = indices[JSON.stringify(element.match || null)];\n      const color = colors[index % colors.length];\n      result.paths.push({\n        cls: 'selectable',\n        d: character.stages.strokes.corrected[element.stroke],\n        fill: index < 0 ? 'lightgray' : color,\n        stroke: index < 0 ? 'lightgray' : 'black',\n        stroke_index: element.stroke,\n      });\n    }\n    return result;\n  },\n  components: () => {\n    const colors = Session.get('stages.order.colors');\n    const components = Session.get('stages.order.components');\n    const result = [];\n    if (!colors || !components) {\n      return result;\n    }\n    for (let index = 0; index < components.length; index++) {\n      const color = colors[index % colors.length];\n      const glyph = Glyphs.findOne({character: components[index]});\n      if (!glyph) {\n        continue;\n      }\n      const component = [];\n      for (let stroke of glyph.stages.strokes.corrected) {\n        component.push({d: stroke, fill: color, stroke: 'black'});\n      }\n      result.push({glyph: {paths: component}, top: `${138*index + 8}px`});\n    }\n    return result;\n  },\n  items: () => {\n    const order = Session.get('stages.order.order');\n    return Order.find({}, {limit: (order || []).length});\n  },\n  options: () => {\n    return {\n      onSort: (event) => {\n        // Suppress the two errors that will be printed when the Sortable\n        // plugin tries to persist the sort result to the server.\n        Meteor._suppress_log(2);\n        stage && stage.onSort(event.oldIndex, event.newIndex);\n      },\n    }\n  },\n});\n\nMeteor.startup(() => {\n  Tracker.autorun(() => {\n    const components = Session.get('stages.order.components') || [];\n    Meteor.subscribe('getAllGlyphs', components);\n  });\n  Tracker.autorun(() => {\n    const components = Session.get('stages.order.components') || [];\n    const found = components.filter((x) => Glyphs.findOne({character: x}));\n    if (found.length === components.length &&\n        Session.get('stage.type') === 'order') {\n      stage.onAllComponentsReady();\n    }\n  });\n});\n\nexport {OrderStage};\n"]},"sourceType":"module","externalDependencies":{},"hash":"02c5ce7c4b2c74790d899f41f8bb1a78240e268c"}
