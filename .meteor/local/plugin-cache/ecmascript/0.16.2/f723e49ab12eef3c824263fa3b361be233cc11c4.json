{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/a37/code/github/makemeahanzi-tool/lib/stroke_extractor.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"lib/stroke_extractor.js","filename":"/Users/a37/code/github/makemeahanzi-tool/lib/stroke_extractor.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/a37/code/github/makemeahanzi-tool","root":"/Users/a37/code/github/makemeahanzi-tool","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]}},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/a37/code/github/makemeahanzi-tool/lib/stroke_extractor.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"lib/stroke_extractor.js"}},"code":"var _createForOfIteratorHelperLoose;\n\nmodule.link(\"@babel/runtime/helpers/createForOfIteratorHelperLoose\", {\n  default: function (v) {\n    _createForOfIteratorHelperLoose = v;\n  }\n}, 0);\nmodule.export({\n  stroke_extractor: function () {\n    return stroke_extractor;\n  }\n});\nvar assert, Angle, Point;\nmodule.link(\"/lib/base\", {\n  assert: function (v) {\n    assert = v;\n  },\n  Angle: function (v) {\n    Angle = v;\n  },\n  Point: function (v) {\n    Point = v;\n  }\n}, 0);\nvar Hungarian;\nmodule.link(\"/lib/hungarian\", {\n  Hungarian: function (v) {\n    Hungarian = v;\n  }\n}, 1);\nvar svg;\nmodule.link(\"/lib/svg\", {\n  svg: function (v) {\n    svg = v;\n  }\n}, 2);\nvar MAX_BRIDGE_DISTANCE = 64;\nvar MIN_CORNER_ANGLE = 0.1 * Math.PI;\nvar MIN_CORNER_TANGENT_DISTANCE = 4;\nvar REVERSAL_PENALTY = 0.5; // Errors out if the bridges are invalid in some gross way.\n\nvar checkBridge = function (bridge) {\n  assert(Point.valid(bridge[0]) && Point.valid(bridge[1]));\n  assert(!Point.equal(bridge[0], bridge[1]));\n}; // Returns the list of bridges on the path with the given endpoints. We strip\n// nearly all of the metadata out of this list to make it easy to hand-correct.\n// The list that we return is simply a list of pairs of points.\n\n\nvar getBridges = function (endpoints, classifier) {\n  var result = [];\n  var corners = endpoints.filter(function (x) {\n    return x.corner;\n  });\n  var matching = matchCorners(corners, classifier);\n\n  for (var i = 0; i < corners.length; i++) {\n    var j = matching[i];\n\n    if (j <= i && matching[j] === i) {\n      continue;\n    }\n\n    result.push([Point.clone(corners[i].point), Point.clone(corners[j].point)]);\n  }\n\n  result.map(checkBridge);\n  return result;\n}; // Returns a list of angle and distance features between two corners.\n\n\nvar getFeatures = function (ins, out) {\n  var diff = Point.subtract(out.point, ins.point);\n  var trivial = Point.equal(diff, [0, 0]);\n  var angle = Math.atan2(diff[1], diff[0]);\n  var distance = Math.sqrt(Point.distance2(out.point, ins.point));\n  return [Angle.subtract(angle, ins.angles[0]), Angle.subtract(out.angles[1], angle), Angle.subtract(ins.angles[1], angle), Angle.subtract(angle, out.angles[0]), Angle.subtract(ins.angles[1], ins.angles[0]), Angle.subtract(out.angles[1], out.angles[0]), trivial ? 1 : 0, distance / MAX_BRIDGE_DISTANCE];\n}; // A hand-tuned classifier that uses the features above to return a score for\n// connecting two corners by a bridge. This classifier throws out most data.\n\n\nvar handTunedClassifier = function (features) {\n  if (features[6] > 0) {\n    return -Angle.penalty(features[4]);\n  }\n\n  var angle_penalty = Angle.penalty(features[0]) + Angle.penalty(features[1]);\n  var distance_penalty = features[7];\n\n  if (features[0] > 0 && features[1] > 0 && features[2] + features[3] < -0.5 * Math.PI) {\n    angle_penalty = angle_penalty / 16;\n  }\n\n  return -(angle_penalty + distance_penalty);\n}; // Takes a list of corners and returns a bipartite matching between them.\n// If matching[i] === j, then corners[i] is matched with corners[j] - that is,\n// we should construct a bridge from corners[i].point to corners[j].point.\n\n\nvar matchCorners = function (corners, classifier) {\n  var matrix = [];\n\n  for (var i = 0; i < corners.length; i++) {\n    matrix.push([]);\n\n    for (var j = 0; j < corners.length; j++) {\n      matrix[i].push(scoreCorners(corners[i], corners[j], classifier));\n    }\n  }\n\n  for (var _i = 0; _i < corners.length; _i++) {\n    for (var _j = 0; _j < corners.length; _j++) {\n      var reversed_score = matrix[_j][_i] - REVERSAL_PENALTY;\n\n      if (reversed_score > matrix[_i][_j]) {\n        matrix[_i][_j] = reversed_score;\n      }\n    }\n  }\n\n  return new Hungarian(matrix).x_match;\n}; // Takes two corners and returns the score assigned to constructing a bridge\n// from one corner to the other. The score is directed: the bridge from ins to\n// out may be weighted higher than from out to ins.\n\n\nvar scoreCorners = function (ins, out, classifier) {\n  return classifier(getFeatures(ins, out));\n}; // Stores angle and distance metadata around an SVG path segment's start point.\n// This endpoint may be a 'corner', which is true if the path bends sharply in\n// the negative (clockwise) direction at that point.\n\n\nfunction Endpoint(paths, index) {\n  this.index = index;\n  var path = paths[index[0]];\n  var n = path.length;\n  this.indices = [[index[0], (index[1] + n - 1) % n], index];\n  this.segments = [path[(index[1] + n - 1) % n], path[index[1]]];\n  this.point = this.segments[0].end;\n  assert(Point.valid(this.point), this.point);\n  assert(Point.equal(this.point, this.segments[1].start), path);\n  this.tangents = [Point.subtract(this.segments[0].end, this.segments[0].start), Point.subtract(this.segments[1].end, this.segments[1].start)];\n  var threshold = Math.pow(MIN_CORNER_TANGENT_DISTANCE, 2);\n\n  if (this.segments[0].control !== undefined && Point.distance2(this.point, this.segments[0].control) > threshold) {\n    this.tangents[0] = Point.subtract(this.point, this.segments[0].control);\n  }\n\n  if (this.segments[1].control !== undefined && Point.distance2(this.point, this.segments[1].control) > threshold) {\n    this.tangents[1] = Point.subtract(this.segments[1].control, this.point);\n  }\n\n  this.angles = this.tangents.map(Point.angle);\n  var diff = Angle.subtract(this.angles[1], this.angles[0]);\n  this.corner = diff < -MIN_CORNER_ANGLE;\n  return this;\n} // Code for the stroke extraction step follows.\n\n\nvar addEdgeToAdjacency = function (edge, adjacency) {\n  assert(edge.length === 2);\n  adjacency[edge[0]] = adjacency[edge[0]] || [];\n\n  if (adjacency[edge[0]].indexOf(edge[1]) < 0) {\n    adjacency[edge[0]].push(edge[1]);\n  }\n};\n\nvar extractStroke = function (paths, endpoint_map, bridge_adjacency, log, extracted_indices, start, attempt_one) {\n  var result = [];\n  var visited = {};\n  var current = start; // A list of line segments that were added to the path but that were not\n  // part of the original stroke data. None of these should intersect.\n\n  var line_segments = [];\n  var self_intersecting = false;\n\n  var advance = function (index) {\n    return [index[0], (index[1] + 1) % paths[index[0]].length];\n  };\n\n  var angle = function (index1, index2) {\n    var diff = Point.subtract(endpoint_map[Point.key(index2)].point, endpoint_map[Point.key(index1)].point);\n    assert(diff[0] !== 0 || diff[1] !== 0);\n    var angle = Math.atan2(diff[1], diff[0]);\n    return Angle.subtract(angle, endpoint.angles[0]);\n  };\n\n  var getIntersection = function (segment1, segment2) {\n    var diff1 = Point.subtract(segment1[1], segment1[0]);\n    var diff2 = Point.subtract(segment2[1], segment2[0]);\n    var cross = diff1[0] * diff2[1] - diff1[1] * diff2[0];\n\n    if (cross === 0) {\n      return undefined;\n    }\n\n    var v = Point.subtract(segment1[0], segment2[0]);\n    var s = (diff1[0] * v[1] - diff1[1] * v[0]) / cross;\n    var t = (diff2[0] * v[1] - diff2[1] * v[0]) / cross;\n\n    if (0 < s && s < 1 && 0 < t && t < 1) {\n      return [segment1[0][0] + t * diff1[0], segment1[0][1] + t * diff1[1]];\n    }\n\n    return undefined;\n  };\n\n  var indexToPoint = function (index) {\n    return endpoint_map[Point.key(index)].point;\n  };\n\n  var pushLineSegments = function (points) {\n    var old_lines = line_segments.length;\n\n    for (var i = 0; i < points.length - 1; i++) {\n      line_segments.push([points[i], points[i + 1]]);\n      result.push({\n        start: Point.clone(points[i]),\n        end: Point.clone(points[i + 1]),\n        control: undefined\n      });\n    } // Log an error if this stroke is self-intersecting.\n\n\n    if (!self_intersecting) {\n      for (var _i2 = 0; _i2 < old_lines; _i2++) {\n        for (var j = old_lines; j < line_segments.length; j++) {\n          if (getIntersection(line_segments[_i2], line_segments[j])) {\n            self_intersecting = true;\n            return;\n          }\n        }\n      }\n    }\n  }; // Here there be dragons!\n  // TODO(skishore): Document the point of the geometry in this function.\n\n\n  var selectBridge = function (endpoint, options) {\n    if (options.length === 1 && extracted_indices[Point.key(options[0])]) {\n      // Handle star-shaped strokes where one stroke ends at the intersection\n      // of the bridges used by two other strokes.\n      var indices1 = [endpoint.index, options[0]];\n      var segment1 = indices1.map(indexToPoint);\n\n      for (var key in meteorBabelHelpers.sanitizeForInObject(bridge_adjacency)) {\n        if (Point.equal(endpoint_map[key].index, indices1[0])) {\n          continue;\n        }\n\n        for (var i = 0; i < bridge_adjacency[key].length; i++) {\n          if (Point.equal(bridge_adjacency[key][i], segment1[0])) {\n            continue;\n          } // Compute the other bridge segment and check if it intersects.\n\n\n          var indices2 = [endpoint_map[key].index, bridge_adjacency[key][i]];\n          var segment2 = indices2.map(indexToPoint);\n\n          if (Point.equal(indices2[0], indices1[1]) && !extracted_indices[Point.key(indices2[1])]) {\n            pushLineSegments([segment1[0], segment1[1], segment2[1]]);\n            return indices2[1];\n          } else if (Point.equal(indices2[1], indices1[1]) && !extracted_indices[Point.key(indices2[0])]) {\n            pushLineSegments([segment1[0], segment1[1], segment2[0]]);\n            return indices2[0];\n          }\n\n          var intersection = getIntersection(segment1, segment2);\n\n          if (intersection !== undefined) {\n            var angle1 = angle(indices1[0], indices1[1]);\n            var angle2 = angle(indices2[0], indices2[1]);\n\n            if (Angle.subtract(angle2, angle1) < 0) {\n              indices2.reverse();\n              segment2.reverse();\n            }\n\n            pushLineSegments([segment1[0], intersection, segment2[1]]);\n            return indices2[1];\n          }\n        }\n      }\n    } else {\n      // Handle segments where the correct path is to follow a dead-end bridge,\n      // even if there is another bridge that is more aligned with the stroke.\n      for (var _i3 = 0; _i3 < options.length; _i3++) {\n        var _key = Point.key(options[_i3]);\n\n        if (!extracted_indices[_key]) {\n          return options[_i3];\n        }\n      }\n    }\n\n    return options[0];\n  };\n\n  while (true) {\n    // Add the current path segment to the path.\n    result.push(paths[current[0]][current[1]]);\n    visited[Point.key(current)] = true;\n    current = advance(current); // If there are bridges at the start of the next path segment, follow the\n    // one that makes the largest angle with the current path. The ordering\n    // criterion enforce that we try to cross aligned bridges.\n\n    var key = Point.key(current);\n\n    if (bridge_adjacency.hasOwnProperty(key)) {\n      var endpoint = endpoint_map[key];\n      var options = bridge_adjacency[key].sort(function (a, b) {\n        return angle(endpoint.index, a) - angle(endpoint.index, b);\n      }); // HACK(skishore): The call to selectBridge may update the result.\n      // When a stroke is formed by computing a bridge intersection, then the\n      // two bridge fragments are added in selectBridge.\n\n      var result_length = result.length;\n      var next = attempt_one ? options[0] : selectBridge(endpoint, options);\n\n      if (result.length === result_length) {\n        pushLineSegments([endpoint.point, endpoint_map[Point.key(next)].point]);\n      }\n\n      current = next;\n    } // Check if we have either closed the loop or hit an extracted segment.\n\n\n    var new_key = Point.key(current);\n\n    if (Point.equal(current, start)) {\n      if (self_intersecting) {\n        log.push({\n          cls: 'error',\n          message: 'Extracted a self-intersecting stroke.'\n        });\n      }\n\n      var num_segments_on_path = 0;\n\n      for (var index in meteorBabelHelpers.sanitizeForInObject(visited)) {\n        extracted_indices[index] = true;\n        num_segments_on_path += 1;\n      } // Single-segment strokes may be due to graphical artifacts in the font.\n      // We drop them to remove these artifacts.\n\n\n      if (num_segments_on_path === 1) {\n        log.push({\n          cls: 'success',\n          message: 'Dropping single-segment stroke.'\n        });\n        return undefined;\n      }\n\n      return result;\n    } else if (extracted_indices[new_key] || visited[new_key]) {\n      return undefined;\n    }\n  }\n};\n\nvar extractStrokes = function (paths, endpoints, bridges, log) {\n  // Build up the necessary hash tables and adjacency lists needed to run the\n  // stroke extraction loop.\n  var endpoint_map = {};\n  var endpoint_position_map = {};\n\n  for (var _iterator = _createForOfIteratorHelperLoose(endpoints), _step; !(_step = _iterator()).done;) {\n    var _endpoint = _step.value;\n    endpoint_map[Point.key(_endpoint.index)] = _endpoint;\n    endpoint_position_map[Point.key(_endpoint.point)] = _endpoint;\n  }\n\n  bridges.map(checkBridge);\n  var bridge_adjacency = {};\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(bridges), _step2; !(_step2 = _iterator2()).done;) {\n    var bridge = _step2.value;\n    var keys = bridge.map(Point.key);\n    assert(endpoint_position_map.hasOwnProperty(keys[0]));\n    assert(endpoint_position_map.hasOwnProperty(keys[1]));\n    var xs = keys.map(function (x) {\n      return endpoint_position_map[x].index;\n    });\n    addEdgeToAdjacency([Point.key(xs[0]), xs[1]], bridge_adjacency);\n    addEdgeToAdjacency([Point.key(xs[1]), xs[0]], bridge_adjacency);\n  } // Actually extract strokes. Any given path segment index should appear on\n  // exactly one stroke; if it is not on a stroke, we log a warning.\n\n\n  var extracted_indices = {};\n  var strokes = [];\n\n  for (var attempt = 0; attempt < 3; attempt++) {\n    var missed = false;\n\n    for (var i = 0; i < paths.length; i++) {\n      for (var j = 0; j < paths[i].length; j++) {\n        var index = [i, j];\n\n        if (extracted_indices[Point.key(index)]) {\n          continue;\n        }\n\n        var attempt_one = attempt === 0;\n        var stroke = extractStroke(paths, endpoint_map, bridge_adjacency, log, extracted_indices, index, attempt_one);\n\n        if (stroke === undefined) {\n          missed = true;\n          continue;\n        }\n\n        strokes.push(stroke);\n      }\n    }\n\n    if (!missed) {\n      return strokes;\n    }\n  }\n\n  log.push({\n    cls: 'error',\n    message: 'Stroke extraction missed some path segments.'\n  });\n  return strokes;\n}; // Exports go below this fold.\n\n\nvar stroke_extractor = {};\n\nstroke_extractor.getBridges = function (path, classifier) {\n  var paths = svg.convertSVGPathToPaths(path);\n  var endpoints = [];\n\n  for (var i = 0; i < paths.length; i++) {\n    for (var j = 0; j < paths[i].length; j++) {\n      endpoints.push(new Endpoint(paths, [i, j]));\n    }\n  }\n\n  classifier = classifier || stroke_extractor.combinedClassifier;\n  var bridges = getBridges(endpoints, classifier);\n  return {\n    endpoints: endpoints,\n    bridges: bridges\n  };\n};\n\nstroke_extractor.getStrokes = function (path, bridges) {\n  var paths = svg.convertSVGPathToPaths(path);\n  var endpoints = [];\n\n  for (var i = 0; i < paths.length; i++) {\n    for (var j = 0; j < paths[i].length; j++) {\n      endpoints.push(new Endpoint(paths, [i, j]));\n    }\n  }\n\n  var log = [];\n  var stroke_paths = extractStrokes(paths, endpoints, bridges, log);\n  var strokes = stroke_paths.map(function (x) {\n    return svg.convertPathsToSVGPath([x]);\n  });\n  return {\n    log: log,\n    strokes: strokes\n  };\n};\n\nstroke_extractor.handTunedClassifier = handTunedClassifier;","map":{"version":3,"sources":["lib/stroke_extractor.js"],"names":["_createForOfIteratorHelperLoose","module","link","default","v","export","stroke_extractor","assert","Angle","Point","Hungarian","svg","MAX_BRIDGE_DISTANCE","MIN_CORNER_ANGLE","Math","PI","MIN_CORNER_TANGENT_DISTANCE","REVERSAL_PENALTY","checkBridge","bridge","valid","equal","getBridges","endpoints","classifier","result","corners","filter","x","corner","matching","matchCorners","i","length","j","push","clone","point","map","getFeatures","ins","out","diff","subtract","trivial","angle","atan2","distance","sqrt","distance2","angles","handTunedClassifier","features","penalty","angle_penalty","distance_penalty","matrix","scoreCorners","reversed_score","x_match","Endpoint","paths","index","path","n","indices","segments","end","start","tangents","threshold","pow","control","undefined","addEdgeToAdjacency","edge","adjacency","indexOf","extractStroke","endpoint_map","bridge_adjacency","log","extracted_indices","attempt_one","visited","current","line_segments","self_intersecting","advance","index1","index2","key","endpoint","getIntersection","segment1","segment2","diff1","diff2","cross","s","t","indexToPoint","pushLineSegments","points","old_lines","selectBridge","options","indices1","indices2","intersection","angle1","angle2","reverse","hasOwnProperty","sort","a","b","result_length","next","new_key","cls","message","num_segments_on_path","extractStrokes","bridges","endpoint_position_map","keys","xs","strokes","attempt","missed","stroke","convertSVGPathToPaths","combinedClassifier","getStrokes","stroke_paths","convertPathsToSVGPath"],"mappings":"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","sourcesContent":["import {assert, Angle, Point} from '/lib/base';\nimport {Hungarian} from '/lib/hungarian';\nimport {svg} from '/lib/svg';\n\nconst MAX_BRIDGE_DISTANCE = 64;\nconst MIN_CORNER_ANGLE = 0.1*Math.PI;\nconst MIN_CORNER_TANGENT_DISTANCE = 4;\nconst REVERSAL_PENALTY = 0.5;\n\n// Errors out if the bridges are invalid in some gross way.\nconst checkBridge = (bridge) => {\n  assert(Point.valid(bridge[0]) && Point.valid(bridge[1]));\n  assert(!Point.equal(bridge[0], bridge[1]));\n}\n\n// Returns the list of bridges on the path with the given endpoints. We strip\n// nearly all of the metadata out of this list to make it easy to hand-correct.\n// The list that we return is simply a list of pairs of points.\nconst getBridges = (endpoints, classifier) => {\n  const result = [];\n  const corners = endpoints.filter((x) => x.corner);\n  const matching = matchCorners(corners, classifier);\n  for (let i = 0; i < corners.length; i++) {\n    const j = matching[i];\n    if (j <= i && matching[j] === i) {\n      continue;\n    }\n    result.push([Point.clone(corners[i].point), Point.clone(corners[j].point)]);\n  }\n  result.map(checkBridge);\n  return result;\n}\n\n// Returns a list of angle and distance features between two corners.\nconst getFeatures = (ins, out) => {\n  const diff = Point.subtract(out.point, ins.point);\n  const trivial = Point.equal(diff, [0, 0]);\n  const angle = Math.atan2(diff[1], diff[0]);\n  const distance = Math.sqrt(Point.distance2(out.point, ins.point));\n  return [\n    Angle.subtract(angle, ins.angles[0]),\n    Angle.subtract(out.angles[1], angle),\n    Angle.subtract(ins.angles[1], angle),\n    Angle.subtract(angle, out.angles[0]),\n    Angle.subtract(ins.angles[1], ins.angles[0]),\n    Angle.subtract(out.angles[1], out.angles[0]),\n    (trivial ? 1 : 0),\n    distance/MAX_BRIDGE_DISTANCE,\n  ];\n}\n\n// A hand-tuned classifier that uses the features above to return a score for\n// connecting two corners by a bridge. This classifier throws out most data.\nconst handTunedClassifier = (features) => {\n  if (features[6] > 0) {\n    return -Angle.penalty(features[4]);\n  }\n  let angle_penalty = Angle.penalty(features[0]) + Angle.penalty(features[1]);\n  const distance_penalty = features[7];\n  if (features[0] > 0 && features[1] > 0 &&\n      features[2] + features[3] < -0.5*Math.PI) {\n    angle_penalty = angle_penalty/16;\n  }\n  return -(angle_penalty + distance_penalty);\n}\n\n// Takes a list of corners and returns a bipartite matching between them.\n// If matching[i] === j, then corners[i] is matched with corners[j] - that is,\n// we should construct a bridge from corners[i].point to corners[j].point.\nconst matchCorners = (corners, classifier) => {\n  const matrix = [];\n  for (let i = 0; i < corners.length; i++) {\n    matrix.push([]);\n    for (let j = 0; j < corners.length; j++) {\n      matrix[i].push(scoreCorners(corners[i], corners[j], classifier));\n    }\n  }\n  for (let i = 0; i < corners.length; i++) {\n    for (let j = 0; j < corners.length; j++) {\n      const reversed_score = matrix[j][i] - REVERSAL_PENALTY;\n      if (reversed_score > matrix[i][j]) {\n        matrix[i][j] = reversed_score;\n      }\n    }\n  }\n  return (new Hungarian(matrix)).x_match;\n}\n\n// Takes two corners and returns the score assigned to constructing a bridge\n// from one corner to the other. The score is directed: the bridge from ins to\n// out may be weighted higher than from out to ins.\nconst scoreCorners = (ins, out, classifier) => {\n  return classifier(getFeatures(ins, out));\n}\n\n// Stores angle and distance metadata around an SVG path segment's start point.\n// This endpoint may be a 'corner', which is true if the path bends sharply in\n// the negative (clockwise) direction at that point.\nfunction Endpoint(paths, index) {\n  this.index = index;\n  const path = paths[index[0]];\n  const n = path.length;\n  this.indices = [[index[0], (index[1] + n - 1) % n], index];\n  this.segments = [path[(index[1] + n - 1) % n], path[index[1]]];\n  this.point = this.segments[0].end;\n  assert(Point.valid(this.point), this.point);\n  assert(Point.equal(this.point, this.segments[1].start), path);\n  this.tangents = [\n    Point.subtract(this.segments[0].end, this.segments[0].start),\n    Point.subtract(this.segments[1].end, this.segments[1].start),\n  ];\n  const threshold = Math.pow(MIN_CORNER_TANGENT_DISTANCE, 2);\n  if (this.segments[0].control !== undefined &&\n      Point.distance2(this.point, this.segments[0].control) > threshold) {\n    this.tangents[0] = Point.subtract(this.point, this.segments[0].control);\n  }\n  if (this.segments[1].control !== undefined &&\n      Point.distance2(this.point, this.segments[1].control) > threshold) {\n    this.tangents[1] = Point.subtract(this.segments[1].control, this.point);\n  }\n  this.angles = this.tangents.map(Point.angle);\n  const diff = Angle.subtract(this.angles[1], this.angles[0]);\n  this.corner = diff < -MIN_CORNER_ANGLE;\n  return this;\n}\n\n// Code for the stroke extraction step follows.\n\nconst addEdgeToAdjacency = (edge, adjacency) => {\n  assert(edge.length === 2);\n  adjacency[edge[0]] = adjacency[edge[0]] || [];\n  if (adjacency[edge[0]].indexOf(edge[1]) < 0) {\n    adjacency[edge[0]].push(edge[1]);\n  }\n}\n\nconst extractStroke = (paths, endpoint_map, bridge_adjacency, log,\n                       extracted_indices, start, attempt_one) => {\n  const result = [];\n  const visited = {};\n  let current = start;\n\n  // A list of line segments that were added to the path but that were not\n  // part of the original stroke data. None of these should intersect.\n  const line_segments = [];\n  let self_intersecting = false;\n\n  const advance = (index) =>\n      [index[0], (index[1] + 1) % paths[index[0]].length];\n\n  const angle = (index1, index2) => {\n    const diff = Point.subtract(endpoint_map[Point.key(index2)].point,\n                                endpoint_map[Point.key(index1)].point);\n    assert(diff[0] !== 0 || diff[1] !== 0);\n    const angle = Math.atan2(diff[1], diff[0]);\n    return Angle.subtract(angle,  endpoint.angles[0]);\n  }\n\n  const getIntersection = (segment1, segment2) => {\n    const diff1 = Point.subtract(segment1[1], segment1[0]);\n    const diff2 = Point.subtract(segment2[1], segment2[0]);\n    const cross = diff1[0]*diff2[1] - diff1[1]*diff2[0];\n    if (cross === 0) {\n      return undefined;\n    }\n    const v = Point.subtract(segment1[0], segment2[0]);\n    const s = (diff1[0]*v[1] - diff1[1]*v[0])/cross;\n    const t = (diff2[0]*v[1] - diff2[1]*v[0])/cross;\n    if (0 < s && s < 1 && 0 < t && t < 1) {\n      return [segment1[0][0] + t*diff1[0], segment1[0][1] + t*diff1[1]];\n    }\n    return undefined;\n  }\n\n  const indexToPoint = (index) => endpoint_map[Point.key(index)].point;\n\n  const pushLineSegments = (points) => {\n    const old_lines = line_segments.length;\n    for (let i = 0; i < points.length - 1; i++) {\n      line_segments.push([points[i], points[i + 1]]);\n      result.push({\n        start: Point.clone(points[i]),\n        end: Point.clone(points[i + 1]),\n        control: undefined,\n      });\n    }\n    // Log an error if this stroke is self-intersecting.\n    if (!self_intersecting) {\n      for (let i = 0; i < old_lines; i++) {\n        for (let j = old_lines; j < line_segments.length; j++) {\n          if (getIntersection(line_segments[i], line_segments[j])) {\n            self_intersecting = true;\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  // Here there be dragons!\n  // TODO(skishore): Document the point of the geometry in this function.\n  const selectBridge = (endpoint, options) => {\n    if (options.length === 1 && extracted_indices[Point.key(options[0])]) {\n      // Handle star-shaped strokes where one stroke ends at the intersection\n      // of the bridges used by two other strokes.\n      const indices1 = [endpoint.index, options[0]];\n      const segment1 = indices1.map(indexToPoint);\n      for (let key in bridge_adjacency) {\n        if (Point.equal(endpoint_map[key].index, indices1[0])) {\n          continue;\n        }\n        for (let i = 0; i < bridge_adjacency[key].length; i++) {\n          if (Point.equal(bridge_adjacency[key][i], segment1[0])) {\n            continue;\n          }\n          // Compute the other bridge segment and check if it intersects.\n          const indices2 = [endpoint_map[key].index, bridge_adjacency[key][i]];\n          const segment2 = indices2.map(indexToPoint);\n          if (Point.equal(indices2[0], indices1[1]) &&\n              !extracted_indices[Point.key(indices2[1])]) {\n            pushLineSegments([segment1[0], segment1[1], segment2[1]]);\n            return indices2[1];\n          } else if (Point.equal(indices2[1], indices1[1]) &&\n                     !extracted_indices[Point.key(indices2[0])]) {\n            pushLineSegments([segment1[0], segment1[1], segment2[0]]);\n            return indices2[0];\n          }\n          const intersection = getIntersection(segment1, segment2);\n          if (intersection !== undefined) {\n            const angle1 = angle(indices1[0], indices1[1]);\n            const angle2 = angle(indices2[0], indices2[1]);\n            if (Angle.subtract(angle2, angle1) < 0) {\n              indices2.reverse();\n              segment2.reverse();\n            }\n            pushLineSegments([segment1[0], intersection, segment2[1]]);\n            return indices2[1];\n          }\n        }\n      }\n    } else {\n      // Handle segments where the correct path is to follow a dead-end bridge,\n      // even if there is another bridge that is more aligned with the stroke.\n      for (let i = 0; i < options.length; i++) {\n        const key = Point.key(options[i]);\n        if (!extracted_indices[key]) {\n          return options[i];\n        }\n      }\n    }\n    return options[0];\n  }\n\n  while (true) {\n    // Add the current path segment to the path.\n    result.push(paths[current[0]][current[1]]);\n    visited[Point.key(current)] = true;\n    current = advance(current);\n    // If there are bridges at the start of the next path segment, follow the\n    // one that makes the largest angle with the current path. The ordering\n    // criterion enforce that we try to cross aligned bridges.\n    const key = Point.key(current);\n    if (bridge_adjacency.hasOwnProperty(key)) {\n      var endpoint = endpoint_map[key];\n      const options = bridge_adjacency[key].sort(\n          (a, b) => angle(endpoint.index, a) - angle(endpoint.index, b));\n      // HACK(skishore): The call to selectBridge may update the result.\n      // When a stroke is formed by computing a bridge intersection, then the\n      // two bridge fragments are added in selectBridge.\n      const result_length = result.length;\n      const next = (attempt_one ? options[0] : selectBridge(endpoint, options));\n      if (result.length === result_length) {\n        pushLineSegments([endpoint.point, endpoint_map[Point.key(next)].point]);\n      }\n      current = next;\n    }\n    // Check if we have either closed the loop or hit an extracted segment.\n    const new_key = Point.key(current);\n    if (Point.equal(current, start)) {\n      if (self_intersecting) {\n        log.push({cls: 'error',\n                  message: 'Extracted a self-intersecting stroke.'});\n      }\n      let num_segments_on_path = 0;\n      for (let index in visited) {\n        extracted_indices[index] = true;\n        num_segments_on_path += 1;\n      }\n      // Single-segment strokes may be due to graphical artifacts in the font.\n      // We drop them to remove these artifacts.\n      if (num_segments_on_path === 1) {\n        log.push({cls: 'success', message: 'Dropping single-segment stroke.'});\n        return undefined;\n      }\n      return result;\n    } else if (extracted_indices[new_key] || visited[new_key]) {\n      return undefined;\n    }\n  }\n}\n\nconst extractStrokes = (paths, endpoints, bridges, log) => {\n  // Build up the necessary hash tables and adjacency lists needed to run the\n  // stroke extraction loop.\n  const endpoint_map = {};\n  const endpoint_position_map = {};\n  for (let endpoint of endpoints) {\n    endpoint_map[Point.key(endpoint.index)] = endpoint;\n    endpoint_position_map[Point.key(endpoint.point)] = endpoint;\n  }\n  bridges.map(checkBridge);\n  const bridge_adjacency = {};\n  for (let bridge of bridges) {\n    const keys = bridge.map(Point.key);\n    assert(endpoint_position_map.hasOwnProperty(keys[0]));\n    assert(endpoint_position_map.hasOwnProperty(keys[1]));\n    const xs = keys.map((x) => endpoint_position_map[x].index);\n    addEdgeToAdjacency([Point.key(xs[0]), xs[1]], bridge_adjacency);\n    addEdgeToAdjacency([Point.key(xs[1]), xs[0]], bridge_adjacency);\n  }\n  // Actually extract strokes. Any given path segment index should appear on\n  // exactly one stroke; if it is not on a stroke, we log a warning.\n  const extracted_indices = {};\n  const strokes = [];\n  for (let attempt = 0; attempt < 3; attempt++) {\n    let missed = false;\n    for (var i = 0; i < paths.length; i++) {\n      for (var j = 0; j < paths[i].length; j++) {\n        const index = [i, j];\n        if (extracted_indices[Point.key(index)]) {\n          continue;\n        }\n        const attempt_one = attempt === 0;\n        const stroke = extractStroke(paths, endpoint_map, bridge_adjacency, log,\n                                     extracted_indices, index, attempt_one);\n        if (stroke === undefined) {\n          missed = true;\n          continue;\n        }\n        strokes.push(stroke);\n      }\n    }\n    if (!missed) {\n      return strokes;\n    }\n  }\n  log.push({cls: 'error',\n            message: 'Stroke extraction missed some path segments.'});\n  return strokes;\n}\n\n// Exports go below this fold.\n\nconst stroke_extractor = {};\n\nstroke_extractor.getBridges = (path, classifier) => {\n  const paths = svg.convertSVGPathToPaths(path);\n  const endpoints = [];\n  for (let i = 0; i < paths.length; i++) {\n    for (let j = 0; j < paths[i].length; j++) {\n      endpoints.push(new Endpoint(paths, [i, j]));\n    }\n  }\n  classifier = classifier || stroke_extractor.combinedClassifier;\n  const bridges = getBridges(endpoints, classifier);\n  return {endpoints: endpoints, bridges: bridges};\n}\n\nstroke_extractor.getStrokes = (path, bridges) => {\n  const paths = svg.convertSVGPathToPaths(path);\n  const endpoints = [];\n  for (let i = 0; i < paths.length; i++) {\n    for (let j = 0; j < paths[i].length; j++) {\n      endpoints.push(new Endpoint(paths, [i, j]));\n    }\n  }\n  const log = [];\n  const stroke_paths = extractStrokes(paths, endpoints, bridges, log);\n  const strokes = stroke_paths.map((x) => svg.convertPathsToSVGPath([x]));\n  return {log: log, strokes: strokes};\n}\n\nstroke_extractor.handTunedClassifier = handTunedClassifier;\n\nexport {stroke_extractor};\n"]},"sourceType":"module","externalDependencies":{},"hash":"f723e49ab12eef3c824263fa3b361be233cc11c4"}
