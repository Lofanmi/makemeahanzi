{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/a37/code/github/makemeahanzi-tool/lib/median_util.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"lib/median_util.js","filename":"/Users/a37/code/github/makemeahanzi-tool/lib/median_util.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/a37/code/github/makemeahanzi-tool","root":"/Users/a37/code/github/makemeahanzi-tool","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/a37/code/github/makemeahanzi-tool/lib/median_util.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"lib/median_util.js"}},"code":"module.export({\n  median_util: () => median_util\n});\nlet simplify;\nmodule.link(\"/lib/external/simplify/1.2.2/simplify\", {\n  default(v) {\n    simplify = v;\n  }\n\n}, 0);\nlet assert, Point;\nmodule.link(\"/lib/base\", {\n  assert(v) {\n    assert = v;\n  },\n\n  Point(v) {\n    Point = v;\n  }\n\n}, 1);\nlet svg;\nmodule.link(\"/lib/svg\", {\n  svg(v) {\n    svg = v;\n  }\n\n}, 2);\nconst size = 1024;\nconst rise = 900;\nconst num_to_match = 8;\nlet voronoi = undefined;\n\nconst filterMedian = (median, n) => {\n  const distances = _.range(median.length - 1).map(i => Math.sqrt(Point.distance2(median[i], median[i + 1])));\n\n  let total = 0;\n  distances.map(x => total += x);\n  const result = [];\n  let index = 0;\n  let position = median[0];\n  let total_so_far = 0;\n\n  for (let i of _.range(n - 1)) {\n    const target = i * total / (n - 1);\n\n    while (total_so_far < target) {\n      const step = Math.sqrt(Point.distance2(position, median[index + 1]));\n\n      if (total_so_far + step < target) {\n        index += 1;\n        position = median[index];\n        total_so_far += step;\n      } else {\n        const t = (target - total_so_far) / step;\n        position = [(1 - t) * position[0] + t * median[index + 1][0], (1 - t) * position[1] + t * median[index + 1][1]];\n        total_so_far = target;\n      }\n    }\n\n    result.push(Point.clone(position));\n  }\n\n  result.push(median[median.length - 1]);\n  return result;\n};\n\nconst findLongestShortestPath = (adjacency, vertices, node) => {\n  const path = findPathFromFurthestNode(adjacency, vertices, node);\n  return findPathFromFurthestNode(adjacency, vertices, path[0]);\n};\n\nconst findPathFromFurthestNode = (adjacency, vertices, node, visited) => {\n  visited = visited || {};\n  visited[node] = true;\n  let result = [];\n  result.distance = 0;\n\n  for (let neighbor of adjacency[node] || []) {\n    if (!visited[neighbor]) {\n      const candidate = findPathFromFurthestNode(adjacency, vertices, neighbor, visited);\n      candidate.distance += Math.sqrt(Point.distance2(vertices[node], vertices[neighbor]));\n\n      if (candidate.distance > result.distance) {\n        result = candidate;\n      }\n    }\n  }\n\n  result.push(node);\n  return result;\n};\n\nconst findStrokeMedian = stroke => {\n  const paths = svg.convertSVGPathToPaths(stroke);\n  assert(paths.length === 1, \"Got stroke with multiple loops: \".concat(stroke));\n  let polygon = undefined;\n  let diagram = undefined;\n\n  for (let approximation of [16, 64]) {\n    polygon = svg.getPolygonApproximation(paths[0], approximation);\n    voronoi = voronoi || new Voronoi();\n    const sites = polygon.map(point => ({\n      x: point[0],\n      y: point[1]\n    }));\n    const bounding_box = {\n      xl: -size,\n      xr: size,\n      yt: -size,\n      yb: size\n    };\n\n    try {\n      diagram = voronoi.compute(sites, bounding_box);\n      break;\n    } catch (error) {\n      console.error(\"WARNING: Voronoi computation failed at \".concat(approximation, \".\"));\n    }\n  }\n\n  assert(diagram, 'Voronoi computation failed completely!');\n  diagram.vertices.map((x, i) => {\n    x.include = svg.polygonContainsPoint(polygon, [x.x, x.y]);\n    x.index = i;\n  });\n  const vertices = diagram.vertices.map(x => [x.x, x.y].map(Math.round));\n  const edges = diagram.edges.map(x => [x.va.index, x.vb.index]).filter(x => diagram.vertices[x[0]].include && diagram.vertices[x[1]].include);\n  voronoi.recycle(diagram);\n  assert(edges.length > 0);\n  const adjacency = {};\n\n  for (let edge of edges) {\n    adjacency[edge[0]] = adjacency[edge[0]] || [];\n    adjacency[edge[0]].push(edge[1]);\n    adjacency[edge[1]] = adjacency[edge[1]] || [];\n    adjacency[edge[1]].push(edge[0]);\n  }\n\n  const root = edges[0][0];\n  const path = findLongestShortestPath(adjacency, vertices, root);\n  const points = path.map(i => vertices[i]);\n  const tolerance = 4;\n  const simple = simplify(points.map(x => ({\n    x: x[0],\n    y: x[1]\n  })), tolerance);\n  return simple.map(x => [x.x, x.y]);\n};\n\nconst normalizeForMatch = median => {\n  return filterMedian(median, num_to_match).map(x => [x[0] / size, (rise - x[1]) / size]);\n};\n\nconst median_util = {\n  findStrokeMedian: findStrokeMedian,\n  normalizeForMatch: normalizeForMatch\n};","map":{"version":3,"sources":["lib/median_util.js"],"names":["module","export","median_util","simplify","link","default","v","assert","Point","svg","size","rise","num_to_match","voronoi","undefined","filterMedian","median","n","distances","_","range","length","map","i","Math","sqrt","distance2","total","x","result","index","position","total_so_far","target","step","t","push","clone","findLongestShortestPath","adjacency","vertices","node","path","findPathFromFurthestNode","visited","distance","neighbor","candidate","findStrokeMedian","stroke","paths","convertSVGPathToPaths","polygon","diagram","approximation","getPolygonApproximation","Voronoi","sites","point","y","bounding_box","xl","xr","yt","yb","compute","error","console","include","polygonContainsPoint","round","edges","va","vb","filter","recycle","edge","root","points","tolerance","simple","normalizeForMatch"],"mappings":"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","sourcesContent":["import simplify from '/lib/external/simplify/1.2.2/simplify';\n\nimport {assert, Point} from '/lib/base';\nimport {svg} from '/lib/svg';\n\nconst size = 1024;\nconst rise = 900;\nconst num_to_match = 8;\n\nlet voronoi = undefined;\n\nconst filterMedian = (median, n) => {\n  const distances = _.range(median.length - 1).map(\n      (i) => Math.sqrt(Point.distance2(median[i], median[i + 1])));\n  let total = 0;\n  distances.map((x) => total += x);\n  const result = [];\n  let index = 0;\n  let position = median[0];\n  let total_so_far = 0;\n  for (let i of _.range(n - 1)) {\n    const target = i*total/(n - 1);\n    while (total_so_far < target) {\n      const step = Math.sqrt(Point.distance2(position, median[index + 1]));\n      if (total_so_far + step < target) {\n        index += 1;\n        position = median[index];\n        total_so_far += step;\n      } else {\n        const t = (target - total_so_far)/step;\n        position = [(1 - t)*position[0] + t*median[index + 1][0],\n                    (1 - t)*position[1] + t*median[index + 1][1]];\n        total_so_far = target;\n      }\n    }\n    result.push(Point.clone(position));\n  }\n  result.push(median[median.length - 1]);\n  return result;\n}\n\nconst findLongestShortestPath = (adjacency, vertices, node) => {\n  const path = findPathFromFurthestNode(adjacency, vertices, node);\n  return findPathFromFurthestNode(adjacency, vertices, path[0]);\n}\n\nconst findPathFromFurthestNode = (adjacency, vertices, node, visited) => {\n  visited = visited || {};\n  visited[node] = true;\n  let result = [];\n  result.distance = 0;\n  for (let neighbor of adjacency[node] || []) {\n    if (!visited[neighbor]) {\n      const candidate = findPathFromFurthestNode(\n          adjacency, vertices, neighbor, visited);\n      candidate.distance +=\n          Math.sqrt(Point.distance2(vertices[node], vertices[neighbor]));\n      if (candidate.distance > result.distance) {\n        result = candidate;\n      }\n    }\n  }\n  result.push(node);\n  return result;\n}\n\nconst findStrokeMedian = (stroke) => {\n  const paths = svg.convertSVGPathToPaths(stroke);\n  assert(paths.length === 1, `Got stroke with multiple loops: ${stroke}`);\n\n  let polygon = undefined;\n  let diagram = undefined;\n  for (let approximation of [16, 64]) {\n    polygon = svg.getPolygonApproximation(paths[0], approximation);\n    voronoi = voronoi || new Voronoi;\n    const sites = polygon.map((point) => ({x: point[0], y: point[1]}));\n    const bounding_box = {xl: -size, xr: size, yt: -size, yb: size};\n    try {\n      diagram = voronoi.compute(sites, bounding_box);\n      break;\n    } catch(error) {\n      console.error(`WARNING: Voronoi computation failed at ${approximation}.`);\n    }\n  }\n  assert(diagram, 'Voronoi computation failed completely!');\n\n  diagram.vertices.map((x, i) => {\n    x.include = svg.polygonContainsPoint(polygon, [x.x, x.y]);\n    x.index = i;\n  });\n  const vertices = diagram.vertices.map((x) => [x.x, x.y].map(Math.round));\n  const edges = diagram.edges.map((x) => [x.va.index, x.vb.index]).filter(\n      (x) => diagram.vertices[x[0]].include && diagram.vertices[x[1]].include);\n  voronoi.recycle(diagram);\n\n  assert(edges.length > 0);\n  const adjacency = {};\n  for (let edge of edges) {\n    adjacency[edge[0]] = adjacency[edge[0]] || [];\n    adjacency[edge[0]].push(edge[1]);\n    adjacency[edge[1]] = adjacency[edge[1]] || [];\n    adjacency[edge[1]].push(edge[0]);\n  }\n  const root = edges[0][0];\n  const path = findLongestShortestPath(adjacency, vertices, root);\n  const points = path.map((i) => vertices[i]);\n\n  const tolerance = 4;\n  const simple = simplify(points.map((x) => ({x: x[0], y: x[1]})), tolerance);\n  return simple.map((x) => [x.x, x.y]);\n}\n\nconst normalizeForMatch = (median) => {\n  return filterMedian(median, num_to_match).map(\n      (x) => [x[0]/size, (rise - x[1])/size]);\n}\n\nconst median_util = {\n  findStrokeMedian: findStrokeMedian,\n  normalizeForMatch: normalizeForMatch,\n};\n\nexport {median_util};\n"]},"sourceType":"module","externalDependencies":{},"hash":"77d52fb28f81524518abc736e04b14ec234811b6"}
