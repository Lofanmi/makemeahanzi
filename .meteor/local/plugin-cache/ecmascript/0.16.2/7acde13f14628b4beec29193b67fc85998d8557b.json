{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/a37/code/github/makemeahanzi-tool/lib/stroke_caps/fixStrokes.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"lib/stroke_caps/fixStrokes.js","filename":"/Users/a37/code/github/makemeahanzi-tool/lib/stroke_caps/fixStrokes.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/a37/code/github/makemeahanzi-tool","root":"/Users/a37/code/github/makemeahanzi-tool","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]}},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/a37/code/github/makemeahanzi-tool/lib/stroke_caps/fixStrokes.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"lib/stroke_caps/fixStrokes.js"}},"code":"!function (module1) {\n  var _require = require('./utils'),\n      distToPath = _require.distToPath,\n      getCosSimAroundPoint = _require.getCosSimAroundPoint,\n      getLinesIntersectPoint = _require.getLinesIntersectPoint,\n      getOutlinePoints = _require.getOutlinePoints,\n      extendPointOnLine = _require.extendPointOnLine,\n      estimateTanPoints = _require.estimateTanPoints,\n      roundPathPoints = _require.roundPathPoints,\n      ptEq = _require.ptEq,\n      dist = _require.dist;\n\n  CLIP_THRESH = 2;\n  LOWER_COS_SIM_THRESH = 0.89;\n  UPPER_COS_SIM_THRESH = 0.97; // A bridge is a place in the pathstring where 2 strokes intersect. It can either be 1 stroke clipping\n  // another, or it can be strokes passing through each other. In the pathstring from makemeahanzi, any\n  // L # # in the pathstring is a\n\n  var Bridge = /*#__PURE__*/function () {\n    function Bridge(points, pointString, stroke) {\n      this.points = points;\n      this.pointString = pointString;\n      this.stroke = stroke;\n      this.estTanPoints = estimateTanPoints(stroke.outline, points);\n    }\n\n    var _proto = Bridge.prototype;\n\n    _proto.getClips = function () {\n      function getClips() {\n        var _this = this;\n\n        // this clip point is super tiny, it's probably just a glitch, skip it\n        if (dist(this.points[0], this.points[1]) < 3.1) return [];\n        var cosSim0 = getCosSimAroundPoint(this.points[0], this.stroke.outline);\n        var cosSim1 = getCosSimAroundPoint(this.points[1], this.stroke.outline); // If the angle around the bridge points looks flat, it's probably an intersection.\n\n        if (Math.min(cosSim0, cosSim1) > LOWER_COS_SIM_THRESH && Math.max(cosSim0, cosSim1) > UPPER_COS_SIM_THRESH) {\n          return [];\n        }\n\n        return this.stroke.character.strokes.filter(function (stroke) {\n          if (stroke === _this.stroke) return false;\n          var dist0 = distToPath(_this.points[0], stroke.outline);\n          var dist1 = distToPath(_this.points[1], stroke.outline);\n          return dist0 <= CLIP_THRESH && dist1 <= CLIP_THRESH;\n        }).map(function (clippingStroke) {\n          return new Clip(_this, clippingStroke);\n        });\n      }\n\n      return getClips;\n    }();\n\n    return Bridge;\n  }();\n\n  var Clip = /*#__PURE__*/function () {\n    function Clip(bridge, clippingStroke) {\n      this.points = bridge.points;\n      this.estTanPoints = bridge.estTanPoints;\n      this.pointString = bridge.pointString;\n      this.clippedBy = [clippingStroke];\n      this.isDouble = false;\n    }\n\n    var _proto2 = Clip.prototype;\n\n    _proto2.canMerge = function () {\n      function canMerge(otherClip) {\n        return ptEq(this.points[1], otherClip.points[0]);\n      }\n\n      return canMerge;\n    }();\n\n    _proto2.mergeIntoDouble = function () {\n      function mergeIntoDouble(otherClip) {\n        this.isDouble = true;\n        this.clippedBy = this.clippedBy.concat(otherClip.clippedBy);\n        this.middlePoint = otherClip.points[0];\n        this.points[1] = otherClip.points[1];\n        this.estTanPoints[1] = otherClip.estTanPoints[1];\n        this.pointString += otherClip.pointString.replace(/.*L/, ' L');\n      }\n\n      return mergeIntoDouble;\n    }();\n\n    _proto2.getNewStrokeTip = function () {\n      function getNewStrokeTip() {\n        var maxControlPoint = getLinesIntersectPoint(this.estTanPoints[0], this.points[0], this.estTanPoints[1], this.points[1]);\n        var maxDistControl0 = dist(maxControlPoint, this.points[0]);\n        var maxDistControl1 = dist(maxControlPoint, this.points[1]);\n        var distControl0 = Math.min(maxDistControl0, 30);\n        var distControl1 = Math.min(maxDistControl1, 30); // if the 2 lines are parallel, there will be no intersection point. Just use 30 in that case.\n\n        if (isNaN(distControl0)) distControl0 = 30;\n        if (isNaN(distControl1)) distControl1 = 30;\n\n        if (this.isDouble) {\n          var midDist0 = dist(this.middlePoint, this.points[0]);\n          var midDist1 = dist(this.middlePoint, this.points[1]);\n          distControl0 = Math.max(midDist0 * 1.4, distControl0);\n          distControl1 = Math.max(midDist1 * 1.4, distControl1);\n        }\n\n        var controlPoint0 = extendPointOnLine(this.estTanPoints[0], this.points[0], distControl0);\n        var controlPoint1 = extendPointOnLine(this.estTanPoints[1], this.points[1], distControl1);\n\n        var pString = function (point) {\n          return Math.round(point.x) + \" \" + Math.round(point.y);\n        };\n\n        return pString(this.points[0]) + \" C \" + pString(controlPoint0) + \" \" + pString(controlPoint1) + \" \" + pString(this.points[1]);\n      }\n\n      return getNewStrokeTip;\n    }();\n\n    return Clip;\n  }();\n\n  var Stroke = /*#__PURE__*/function () {\n    function Stroke(pathString, character, strokeNum) {\n      this.pathString = pathString;\n      this.outline = getOutlinePoints(pathString);\n      this.character = character;\n      this.strokeNum = strokeNum;\n    }\n\n    var _proto3 = Stroke.prototype;\n\n    _proto3.getBridges = function () {\n      function getBridges() {\n        var _this2 = this;\n\n        var pointStringParts = this.pathString.match(/-?\\d+(?:\\.\\d+)? -?\\d+(?:\\.\\d+)? L/ig);\n        if (!pointStringParts) return [];\n        return pointStringParts.map(function (pointStringPart) {\n          var fullPointStringRegex = new RegExp(pointStringPart + \" -?\\\\d+(?:\\\\.\\\\d+)? -?\\\\d+(?:\\\\.\\\\d+)?\");\n\n          var pointString = _this2.pathString.match(fullPointStringRegex)[0];\n\n          var parts = pointString.split(/\\sL?\\s?/).map(function (num) {\n            return parseFloat(num);\n          });\n          var points = [{\n            x: parts[0],\n            y: parts[1]\n          }, {\n            x: parts[2],\n            y: parts[3]\n          }];\n          return new Bridge(points, pointString, _this2);\n        });\n      }\n\n      return getBridges;\n    }();\n\n    _proto3.fixPathString = function () {\n      function fixPathString() {\n        var bridges = this.getBridges();\n        var clips = [];\n        bridges.forEach(function (bridge) {\n          bridge.getClips().forEach(function (clip) {\n            var lastClip = clips[clips.length - 1];\n\n            if (lastClip && lastClip.canMerge(clip)) {\n              lastClip.mergeIntoDouble(clip);\n            } else {\n              clips.push(clip);\n            }\n          });\n        });\n        var modifiedPathString = this.pathString;\n        clips.forEach(function (clip) {\n          var newTip = clip.getNewStrokeTip();\n          modifiedPathString = roundPathPoints(modifiedPathString.replace(clip.pointString, newTip));\n        });\n        return {\n          isModified: clips.length > 0,\n          isDoubleClipped: !!clips.find(function (clip) {\n            return clip.isDouble;\n          }),\n          pathString: modifiedPathString,\n          strokeNum: this.strokeNum\n        };\n      }\n\n      return fixPathString;\n    }();\n\n    return Stroke;\n  }();\n\n  var Character = function () {\n    function Character(pathStrings) {\n      var _this3 = this;\n\n      this.strokes = pathStrings.map(function (path, i) {\n        return new Stroke(path, _this3, i);\n      });\n    }\n\n    return Character;\n  }();\n\n  var fixStrokesWithDetails = function (strokePathStrings) {\n    var character = new Character(strokePathStrings);\n    var fixedStrokesInfo = character.strokes.map(function (stroke) {\n      return stroke.fixPathString();\n    });\n    return {\n      modified: !!fixedStrokesInfo.find(function (summary) {\n        return summary.isModified;\n      }),\n      hasDoubleClippedStroke: !!fixedStrokesInfo.find(function (summary) {\n        return summary.isDoubleClipped;\n      }),\n      modifiedStrokes: fixedStrokesInfo.filter(function (summary) {\n        return summary.isModified;\n      }).map(function (summary) {\n        return summary.strokeNum;\n      }),\n      strokes: fixedStrokesInfo.map(function (summary) {\n        return summary.pathString;\n      })\n    };\n  };\n\n  var fixStrokesOnce = function (strokes) {\n    var corrected = fixStrokesWithDetails(strokes);\n    return corrected.modified ? corrected.strokes : strokes;\n  };\n\n  var fixStrokes = function (strokes) {\n    return fixStrokesOnce(fixStrokesOnce(strokes));\n  };\n\n  module.exports = {\n    fixStrokes: fixStrokes\n  };\n}.call(this, module);","map":{"version":3,"sources":["lib/stroke_caps/fixStrokes.js"],"names":["require","distToPath","getCosSimAroundPoint","getLinesIntersectPoint","getOutlinePoints","extendPointOnLine","estimateTanPoints","roundPathPoints","ptEq","dist","CLIP_THRESH","LOWER_COS_SIM_THRESH","UPPER_COS_SIM_THRESH","Bridge","points","pointString","stroke","estTanPoints","outline","getClips","cosSim0","cosSim1","Math","min","max","character","strokes","filter","dist0","dist1","map","clippingStroke","Clip","bridge","clippedBy","isDouble","canMerge","otherClip","mergeIntoDouble","concat","middlePoint","replace","getNewStrokeTip","maxControlPoint","maxDistControl0","maxDistControl1","distControl0","distControl1","isNaN","midDist0","midDist1","controlPoint0","controlPoint1","pString","point","round","x","y","Stroke","pathString","strokeNum","getBridges","pointStringParts","match","pointStringPart","fullPointStringRegex","RegExp","parts","split","num","parseFloat","fixPathString","bridges","clips","forEach","clip","lastClip","length","push","modifiedPathString","newTip","isModified","isDoubleClipped","find","Character","pathStrings","path","i","fixStrokesWithDetails","strokePathStrings","fixedStrokesInfo","modified","summary","hasDoubleClippedStroke","modifiedStrokes","fixStrokesOnce","corrected","fixStrokes","module","exports"],"mappings":"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","sourcesContent":["const {\n  distToPath,\n  getCosSimAroundPoint,\n  getLinesIntersectPoint,\n  getOutlinePoints,\n  extendPointOnLine,\n  estimateTanPoints,\n  roundPathPoints,\n  ptEq,\n  dist,\n} = require('./utils');\n\n\nCLIP_THRESH = 2;\nLOWER_COS_SIM_THRESH = 0.89;\nUPPER_COS_SIM_THRESH = 0.97;\n\n// A bridge is a place in the pathstring where 2 strokes intersect. It can either be 1 stroke clipping\n// another, or it can be strokes passing through each other. In the pathstring from makemeahanzi, any\n// L # # in the pathstring is a\nclass Bridge {\n  constructor(points, pointString, stroke) {\n    this.points = points;\n    this.pointString = pointString;\n    this.stroke = stroke;\n    this.estTanPoints = estimateTanPoints(stroke.outline, points);\n  }\n\n  getClips() {\n    // this clip point is super tiny, it's probably just a glitch, skip it\n    if (dist(this.points[0], this.points[1]) < 3.1) return [];\n    const cosSim0 = getCosSimAroundPoint(this.points[0], this.stroke.outline);\n    const cosSim1 = getCosSimAroundPoint(this.points[1], this.stroke.outline);\n    // If the angle around the bridge points looks flat, it's probably an intersection.\n    if (Math.min(cosSim0, cosSim1) > LOWER_COS_SIM_THRESH && Math.max(cosSim0, cosSim1) > UPPER_COS_SIM_THRESH) {\n      return [];\n    }\n    return this.stroke.character.strokes.filter(stroke => {\n      if (stroke === this.stroke) return false;\n      const dist0 = distToPath(this.points[0], stroke.outline);\n      const dist1 = distToPath(this.points[1], stroke.outline);\n      return dist0 <= CLIP_THRESH && dist1 <= CLIP_THRESH;\n    }).map(clippingStroke => new Clip(this, clippingStroke));\n  }\n}\n\nclass Clip {\n  constructor(bridge, clippingStroke) {\n    this.points = bridge.points;\n    this.estTanPoints = bridge.estTanPoints;\n    this.pointString = bridge.pointString;\n    this.clippedBy = [clippingStroke];\n    this.isDouble = false;\n  }\n\n  canMerge(otherClip) {\n    return ptEq(this.points[1], otherClip.points[0]);\n  }\n\n  mergeIntoDouble(otherClip) {\n    this.isDouble = true;\n    this.clippedBy = this.clippedBy.concat(otherClip.clippedBy);\n    this.middlePoint = otherClip.points[0];\n    this.points[1] = otherClip.points[1];\n    this.estTanPoints[1] = otherClip.estTanPoints[1];\n    this.pointString += otherClip.pointString.replace(/.*L/, ' L');\n  }\n\n  getNewStrokeTip() {\n    const maxControlPoint = getLinesIntersectPoint(\n      this.estTanPoints[0],\n      this.points[0],\n      this.estTanPoints[1],\n      this.points[1],\n    );\n\n    const maxDistControl0 = dist(maxControlPoint, this.points[0]);\n    const maxDistControl1 = dist(maxControlPoint, this.points[1]);\n    let distControl0 = Math.min(maxDistControl0, 30);\n    let distControl1 = Math.min(maxDistControl1, 30);\n\n    // if the 2 lines are parallel, there will be no intersection point. Just use 30 in that case.\n    if (isNaN(distControl0)) distControl0 = 30;\n    if (isNaN(distControl1)) distControl1 = 30;\n\n    if (this.isDouble) {\n      const midDist0 = dist(this.middlePoint, this.points[0]);\n      const midDist1 = dist(this.middlePoint, this.points[1]);\n      distControl0 = Math.max(midDist0 * 1.4, distControl0);\n      distControl1 = Math.max(midDist1 * 1.4, distControl1);\n    }\n\n    const controlPoint0 = extendPointOnLine(this.estTanPoints[0], this.points[0], distControl0);\n    const controlPoint1 = extendPointOnLine(this.estTanPoints[1], this.points[1], distControl1);\n\n    const pString = point => `${Math.round(point.x)} ${Math.round(point.y)}`;\n\n    return `${pString(this.points[0])} C ${pString(controlPoint0)} ${pString(controlPoint1)} ${pString(this.points[1])}`;\n  }\n}\n\nclass Stroke {\n  constructor(pathString, character, strokeNum) {\n    this.pathString = pathString;\n    this.outline = getOutlinePoints(pathString);\n    this.character = character;\n    this.strokeNum = strokeNum;\n  }\n\n  getBridges() {\n    const pointStringParts = this.pathString.match(/-?\\d+(?:\\.\\d+)? -?\\d+(?:\\.\\d+)? L/ig);\n    if (!pointStringParts) return [];\n    return pointStringParts.map(pointStringPart => {\n      const fullPointStringRegex = new RegExp(`${pointStringPart} -?\\\\d+(?:\\\\.\\\\d+)? -?\\\\d+(?:\\\\.\\\\d+)?`);\n      const pointString = this.pathString.match(fullPointStringRegex)[0];\n      const parts = pointString.split(/\\sL?\\s?/).map(num => parseFloat(num));\n      const points = [{x: parts[0], y: parts[1]}, {x: parts[2], y: parts[3]}];\n      return new Bridge(points, pointString, this);\n    });\n  }\n\n  fixPathString() {\n    const bridges = this.getBridges();\n    let clips = [];\n    bridges.forEach(bridge => {\n      bridge.getClips().forEach(clip => {\n        const lastClip = clips[clips.length - 1];\n        if (lastClip && lastClip.canMerge(clip)) {\n          lastClip.mergeIntoDouble(clip);\n        } else {\n          clips.push(clip);\n        }\n      });\n    });\n\n    let modifiedPathString = this.pathString;\n    clips.forEach(clip => {\n      const newTip = clip.getNewStrokeTip();\n      modifiedPathString = roundPathPoints(modifiedPathString.replace(clip.pointString, newTip));\n    });\n\n    return {\n      isModified: clips.length > 0,\n      isDoubleClipped: !!clips.find(clip => clip.isDouble),\n      pathString: modifiedPathString,\n      strokeNum: this.strokeNum,\n    };\n  }\n}\n\nclass Character {\n  constructor(pathStrings) {\n    this.strokes = pathStrings.map((path, i) => new Stroke(path, this, i));\n  }\n}\n\nconst fixStrokesWithDetails = (strokePathStrings) => {\n  const character = new Character(strokePathStrings);\n  const fixedStrokesInfo = character.strokes.map(stroke => stroke.fixPathString());\n\n  return {\n    modified: !!fixedStrokesInfo.find(summary => summary.isModified),\n    hasDoubleClippedStroke: !!fixedStrokesInfo.find(summary => summary.isDoubleClipped),\n    modifiedStrokes: fixedStrokesInfo.filter(summary => summary.isModified).map(summary => summary.strokeNum),\n    strokes: fixedStrokesInfo.map(summary => summary.pathString),\n  };\n};\n\nconst fixStrokesOnce = (strokes) => {\n  const corrected = fixStrokesWithDetails(strokes);\n  return corrected.modified ? corrected.strokes : strokes;\n}\n\nconst fixStrokes = (strokes) => fixStrokesOnce(fixStrokesOnce(strokes));\n\nmodule.exports = {fixStrokes};\n"]},"sourceType":"module","externalDependencies":{},"hash":"7acde13f14628b4beec29193b67fc85998d8557b"}
