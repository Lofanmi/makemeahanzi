{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/a37/code/github/makemeahanzi-tool/lib/stroke_extractor.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"lib/stroke_extractor.js","filename":"/Users/a37/code/github/makemeahanzi-tool/lib/stroke_extractor.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/a37/code/github/makemeahanzi-tool","root":"/Users/a37/code/github/makemeahanzi-tool","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/a37/code/github/makemeahanzi-tool/lib/stroke_extractor.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"lib/stroke_extractor.js"}},"code":"module.export({\n  stroke_extractor: () => stroke_extractor\n});\nlet assert, Angle, Point;\nmodule.link(\"/lib/base\", {\n  assert(v) {\n    assert = v;\n  },\n\n  Angle(v) {\n    Angle = v;\n  },\n\n  Point(v) {\n    Point = v;\n  }\n\n}, 0);\nlet Hungarian;\nmodule.link(\"/lib/hungarian\", {\n  Hungarian(v) {\n    Hungarian = v;\n  }\n\n}, 1);\nlet svg;\nmodule.link(\"/lib/svg\", {\n  svg(v) {\n    svg = v;\n  }\n\n}, 2);\nconst MAX_BRIDGE_DISTANCE = 64;\nconst MIN_CORNER_ANGLE = 0.1 * Math.PI;\nconst MIN_CORNER_TANGENT_DISTANCE = 4;\nconst REVERSAL_PENALTY = 0.5; // Errors out if the bridges are invalid in some gross way.\n\nconst checkBridge = bridge => {\n  assert(Point.valid(bridge[0]) && Point.valid(bridge[1]));\n  assert(!Point.equal(bridge[0], bridge[1]));\n}; // Returns the list of bridges on the path with the given endpoints. We strip\n// nearly all of the metadata out of this list to make it easy to hand-correct.\n// The list that we return is simply a list of pairs of points.\n\n\nconst getBridges = (endpoints, classifier) => {\n  const result = [];\n  const corners = endpoints.filter(x => x.corner);\n  const matching = matchCorners(corners, classifier);\n\n  for (let i = 0; i < corners.length; i++) {\n    const j = matching[i];\n\n    if (j <= i && matching[j] === i) {\n      continue;\n    }\n\n    result.push([Point.clone(corners[i].point), Point.clone(corners[j].point)]);\n  }\n\n  result.map(checkBridge);\n  return result;\n}; // Returns a list of angle and distance features between two corners.\n\n\nconst getFeatures = (ins, out) => {\n  const diff = Point.subtract(out.point, ins.point);\n  const trivial = Point.equal(diff, [0, 0]);\n  const angle = Math.atan2(diff[1], diff[0]);\n  const distance = Math.sqrt(Point.distance2(out.point, ins.point));\n  return [Angle.subtract(angle, ins.angles[0]), Angle.subtract(out.angles[1], angle), Angle.subtract(ins.angles[1], angle), Angle.subtract(angle, out.angles[0]), Angle.subtract(ins.angles[1], ins.angles[0]), Angle.subtract(out.angles[1], out.angles[0]), trivial ? 1 : 0, distance / MAX_BRIDGE_DISTANCE];\n}; // A hand-tuned classifier that uses the features above to return a score for\n// connecting two corners by a bridge. This classifier throws out most data.\n\n\nconst handTunedClassifier = features => {\n  if (features[6] > 0) {\n    return -Angle.penalty(features[4]);\n  }\n\n  let angle_penalty = Angle.penalty(features[0]) + Angle.penalty(features[1]);\n  const distance_penalty = features[7];\n\n  if (features[0] > 0 && features[1] > 0 && features[2] + features[3] < -0.5 * Math.PI) {\n    angle_penalty = angle_penalty / 16;\n  }\n\n  return -(angle_penalty + distance_penalty);\n}; // Takes a list of corners and returns a bipartite matching between them.\n// If matching[i] === j, then corners[i] is matched with corners[j] - that is,\n// we should construct a bridge from corners[i].point to corners[j].point.\n\n\nconst matchCorners = (corners, classifier) => {\n  const matrix = [];\n\n  for (let i = 0; i < corners.length; i++) {\n    matrix.push([]);\n\n    for (let j = 0; j < corners.length; j++) {\n      matrix[i].push(scoreCorners(corners[i], corners[j], classifier));\n    }\n  }\n\n  for (let i = 0; i < corners.length; i++) {\n    for (let j = 0; j < corners.length; j++) {\n      const reversed_score = matrix[j][i] - REVERSAL_PENALTY;\n\n      if (reversed_score > matrix[i][j]) {\n        matrix[i][j] = reversed_score;\n      }\n    }\n  }\n\n  return new Hungarian(matrix).x_match;\n}; // Takes two corners and returns the score assigned to constructing a bridge\n// from one corner to the other. The score is directed: the bridge from ins to\n// out may be weighted higher than from out to ins.\n\n\nconst scoreCorners = (ins, out, classifier) => {\n  return classifier(getFeatures(ins, out));\n}; // Stores angle and distance metadata around an SVG path segment's start point.\n// This endpoint may be a 'corner', which is true if the path bends sharply in\n// the negative (clockwise) direction at that point.\n\n\nfunction Endpoint(paths, index) {\n  this.index = index;\n  const path = paths[index[0]];\n  const n = path.length;\n  this.indices = [[index[0], (index[1] + n - 1) % n], index];\n  this.segments = [path[(index[1] + n - 1) % n], path[index[1]]];\n  this.point = this.segments[0].end;\n  assert(Point.valid(this.point), this.point);\n  assert(Point.equal(this.point, this.segments[1].start), path);\n  this.tangents = [Point.subtract(this.segments[0].end, this.segments[0].start), Point.subtract(this.segments[1].end, this.segments[1].start)];\n  const threshold = Math.pow(MIN_CORNER_TANGENT_DISTANCE, 2);\n\n  if (this.segments[0].control !== undefined && Point.distance2(this.point, this.segments[0].control) > threshold) {\n    this.tangents[0] = Point.subtract(this.point, this.segments[0].control);\n  }\n\n  if (this.segments[1].control !== undefined && Point.distance2(this.point, this.segments[1].control) > threshold) {\n    this.tangents[1] = Point.subtract(this.segments[1].control, this.point);\n  }\n\n  this.angles = this.tangents.map(Point.angle);\n  const diff = Angle.subtract(this.angles[1], this.angles[0]);\n  this.corner = diff < -MIN_CORNER_ANGLE;\n  return this;\n} // Code for the stroke extraction step follows.\n\n\nconst addEdgeToAdjacency = (edge, adjacency) => {\n  assert(edge.length === 2);\n  adjacency[edge[0]] = adjacency[edge[0]] || [];\n\n  if (adjacency[edge[0]].indexOf(edge[1]) < 0) {\n    adjacency[edge[0]].push(edge[1]);\n  }\n};\n\nconst extractStroke = (paths, endpoint_map, bridge_adjacency, log, extracted_indices, start, attempt_one) => {\n  const result = [];\n  const visited = {};\n  let current = start; // A list of line segments that were added to the path but that were not\n  // part of the original stroke data. None of these should intersect.\n\n  const line_segments = [];\n  let self_intersecting = false;\n\n  const advance = index => [index[0], (index[1] + 1) % paths[index[0]].length];\n\n  const angle = (index1, index2) => {\n    const diff = Point.subtract(endpoint_map[Point.key(index2)].point, endpoint_map[Point.key(index1)].point);\n    assert(diff[0] !== 0 || diff[1] !== 0);\n    const angle = Math.atan2(diff[1], diff[0]);\n    return Angle.subtract(angle, endpoint.angles[0]);\n  };\n\n  const getIntersection = (segment1, segment2) => {\n    const diff1 = Point.subtract(segment1[1], segment1[0]);\n    const diff2 = Point.subtract(segment2[1], segment2[0]);\n    const cross = diff1[0] * diff2[1] - diff1[1] * diff2[0];\n\n    if (cross === 0) {\n      return undefined;\n    }\n\n    const v = Point.subtract(segment1[0], segment2[0]);\n    const s = (diff1[0] * v[1] - diff1[1] * v[0]) / cross;\n    const t = (diff2[0] * v[1] - diff2[1] * v[0]) / cross;\n\n    if (0 < s && s < 1 && 0 < t && t < 1) {\n      return [segment1[0][0] + t * diff1[0], segment1[0][1] + t * diff1[1]];\n    }\n\n    return undefined;\n  };\n\n  const indexToPoint = index => endpoint_map[Point.key(index)].point;\n\n  const pushLineSegments = points => {\n    const old_lines = line_segments.length;\n\n    for (let i = 0; i < points.length - 1; i++) {\n      line_segments.push([points[i], points[i + 1]]);\n      result.push({\n        start: Point.clone(points[i]),\n        end: Point.clone(points[i + 1]),\n        control: undefined\n      });\n    } // Log an error if this stroke is self-intersecting.\n\n\n    if (!self_intersecting) {\n      for (let i = 0; i < old_lines; i++) {\n        for (let j = old_lines; j < line_segments.length; j++) {\n          if (getIntersection(line_segments[i], line_segments[j])) {\n            self_intersecting = true;\n            return;\n          }\n        }\n      }\n    }\n  }; // Here there be dragons!\n  // TODO(skishore): Document the point of the geometry in this function.\n\n\n  const selectBridge = (endpoint, options) => {\n    if (options.length === 1 && extracted_indices[Point.key(options[0])]) {\n      // Handle star-shaped strokes where one stroke ends at the intersection\n      // of the bridges used by two other strokes.\n      const indices1 = [endpoint.index, options[0]];\n      const segment1 = indices1.map(indexToPoint);\n\n      for (let key in bridge_adjacency) {\n        if (Point.equal(endpoint_map[key].index, indices1[0])) {\n          continue;\n        }\n\n        for (let i = 0; i < bridge_adjacency[key].length; i++) {\n          if (Point.equal(bridge_adjacency[key][i], segment1[0])) {\n            continue;\n          } // Compute the other bridge segment and check if it intersects.\n\n\n          const indices2 = [endpoint_map[key].index, bridge_adjacency[key][i]];\n          const segment2 = indices2.map(indexToPoint);\n\n          if (Point.equal(indices2[0], indices1[1]) && !extracted_indices[Point.key(indices2[1])]) {\n            pushLineSegments([segment1[0], segment1[1], segment2[1]]);\n            return indices2[1];\n          } else if (Point.equal(indices2[1], indices1[1]) && !extracted_indices[Point.key(indices2[0])]) {\n            pushLineSegments([segment1[0], segment1[1], segment2[0]]);\n            return indices2[0];\n          }\n\n          const intersection = getIntersection(segment1, segment2);\n\n          if (intersection !== undefined) {\n            const angle1 = angle(indices1[0], indices1[1]);\n            const angle2 = angle(indices2[0], indices2[1]);\n\n            if (Angle.subtract(angle2, angle1) < 0) {\n              indices2.reverse();\n              segment2.reverse();\n            }\n\n            pushLineSegments([segment1[0], intersection, segment2[1]]);\n            return indices2[1];\n          }\n        }\n      }\n    } else {\n      // Handle segments where the correct path is to follow a dead-end bridge,\n      // even if there is another bridge that is more aligned with the stroke.\n      for (let i = 0; i < options.length; i++) {\n        const key = Point.key(options[i]);\n\n        if (!extracted_indices[key]) {\n          return options[i];\n        }\n      }\n    }\n\n    return options[0];\n  };\n\n  while (true) {\n    // Add the current path segment to the path.\n    result.push(paths[current[0]][current[1]]);\n    visited[Point.key(current)] = true;\n    current = advance(current); // If there are bridges at the start of the next path segment, follow the\n    // one that makes the largest angle with the current path. The ordering\n    // criterion enforce that we try to cross aligned bridges.\n\n    const key = Point.key(current);\n\n    if (bridge_adjacency.hasOwnProperty(key)) {\n      var endpoint = endpoint_map[key];\n      const options = bridge_adjacency[key].sort((a, b) => angle(endpoint.index, a) - angle(endpoint.index, b)); // HACK(skishore): The call to selectBridge may update the result.\n      // When a stroke is formed by computing a bridge intersection, then the\n      // two bridge fragments are added in selectBridge.\n\n      const result_length = result.length;\n      const next = attempt_one ? options[0] : selectBridge(endpoint, options);\n\n      if (result.length === result_length) {\n        pushLineSegments([endpoint.point, endpoint_map[Point.key(next)].point]);\n      }\n\n      current = next;\n    } // Check if we have either closed the loop or hit an extracted segment.\n\n\n    const new_key = Point.key(current);\n\n    if (Point.equal(current, start)) {\n      if (self_intersecting) {\n        log.push({\n          cls: 'error',\n          message: 'Extracted a self-intersecting stroke.'\n        });\n      }\n\n      let num_segments_on_path = 0;\n\n      for (let index in visited) {\n        extracted_indices[index] = true;\n        num_segments_on_path += 1;\n      } // Single-segment strokes may be due to graphical artifacts in the font.\n      // We drop them to remove these artifacts.\n\n\n      if (num_segments_on_path === 1) {\n        log.push({\n          cls: 'success',\n          message: 'Dropping single-segment stroke.'\n        });\n        return undefined;\n      }\n\n      return result;\n    } else if (extracted_indices[new_key] || visited[new_key]) {\n      return undefined;\n    }\n  }\n};\n\nconst extractStrokes = (paths, endpoints, bridges, log) => {\n  // Build up the necessary hash tables and adjacency lists needed to run the\n  // stroke extraction loop.\n  const endpoint_map = {};\n  const endpoint_position_map = {};\n\n  for (let endpoint of endpoints) {\n    endpoint_map[Point.key(endpoint.index)] = endpoint;\n    endpoint_position_map[Point.key(endpoint.point)] = endpoint;\n  }\n\n  bridges.map(checkBridge);\n  const bridge_adjacency = {};\n\n  for (let bridge of bridges) {\n    const keys = bridge.map(Point.key);\n    assert(endpoint_position_map.hasOwnProperty(keys[0]));\n    assert(endpoint_position_map.hasOwnProperty(keys[1]));\n    const xs = keys.map(x => endpoint_position_map[x].index);\n    addEdgeToAdjacency([Point.key(xs[0]), xs[1]], bridge_adjacency);\n    addEdgeToAdjacency([Point.key(xs[1]), xs[0]], bridge_adjacency);\n  } // Actually extract strokes. Any given path segment index should appear on\n  // exactly one stroke; if it is not on a stroke, we log a warning.\n\n\n  const extracted_indices = {};\n  const strokes = [];\n\n  for (let attempt = 0; attempt < 3; attempt++) {\n    let missed = false;\n\n    for (var i = 0; i < paths.length; i++) {\n      for (var j = 0; j < paths[i].length; j++) {\n        const index = [i, j];\n\n        if (extracted_indices[Point.key(index)]) {\n          continue;\n        }\n\n        const attempt_one = attempt === 0;\n        const stroke = extractStroke(paths, endpoint_map, bridge_adjacency, log, extracted_indices, index, attempt_one);\n\n        if (stroke === undefined) {\n          missed = true;\n          continue;\n        }\n\n        strokes.push(stroke);\n      }\n    }\n\n    if (!missed) {\n      return strokes;\n    }\n  }\n\n  log.push({\n    cls: 'error',\n    message: 'Stroke extraction missed some path segments.'\n  });\n  return strokes;\n}; // Exports go below this fold.\n\n\nconst stroke_extractor = {};\n\nstroke_extractor.getBridges = (path, classifier) => {\n  const paths = svg.convertSVGPathToPaths(path);\n  const endpoints = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    for (let j = 0; j < paths[i].length; j++) {\n      endpoints.push(new Endpoint(paths, [i, j]));\n    }\n  }\n\n  classifier = classifier || stroke_extractor.combinedClassifier;\n  const bridges = getBridges(endpoints, classifier);\n  return {\n    endpoints: endpoints,\n    bridges: bridges\n  };\n};\n\nstroke_extractor.getStrokes = (path, bridges) => {\n  const paths = svg.convertSVGPathToPaths(path);\n  const endpoints = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    for (let j = 0; j < paths[i].length; j++) {\n      endpoints.push(new Endpoint(paths, [i, j]));\n    }\n  }\n\n  const log = [];\n  const stroke_paths = extractStrokes(paths, endpoints, bridges, log);\n  const strokes = stroke_paths.map(x => svg.convertPathsToSVGPath([x]));\n  return {\n    log: log,\n    strokes: strokes\n  };\n};\n\nstroke_extractor.handTunedClassifier = handTunedClassifier;","map":{"version":3,"sources":["lib/stroke_extractor.js"],"names":["module","export","stroke_extractor","assert","Angle","Point","link","v","Hungarian","svg","MAX_BRIDGE_DISTANCE","MIN_CORNER_ANGLE","Math","PI","MIN_CORNER_TANGENT_DISTANCE","REVERSAL_PENALTY","checkBridge","bridge","valid","equal","getBridges","endpoints","classifier","result","corners","filter","x","corner","matching","matchCorners","i","length","j","push","clone","point","map","getFeatures","ins","out","diff","subtract","trivial","angle","atan2","distance","sqrt","distance2","angles","handTunedClassifier","features","penalty","angle_penalty","distance_penalty","matrix","scoreCorners","reversed_score","x_match","Endpoint","paths","index","path","n","indices","segments","end","start","tangents","threshold","pow","control","undefined","addEdgeToAdjacency","edge","adjacency","indexOf","extractStroke","endpoint_map","bridge_adjacency","log","extracted_indices","attempt_one","visited","current","line_segments","self_intersecting","advance","index1","index2","key","endpoint","getIntersection","segment1","segment2","diff1","diff2","cross","s","t","indexToPoint","pushLineSegments","points","old_lines","selectBridge","options","indices1","indices2","intersection","angle1","angle2","reverse","hasOwnProperty","sort","a","b","result_length","next","new_key","cls","message","num_segments_on_path","extractStrokes","bridges","endpoint_position_map","keys","xs","strokes","attempt","missed","stroke","convertSVGPathToPaths","combinedClassifier","getStrokes","stroke_paths","convertPathsToSVGPath"],"mappings":"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","sourcesContent":["import {assert, Angle, Point} from '/lib/base';\nimport {Hungarian} from '/lib/hungarian';\nimport {svg} from '/lib/svg';\n\nconst MAX_BRIDGE_DISTANCE = 64;\nconst MIN_CORNER_ANGLE = 0.1*Math.PI;\nconst MIN_CORNER_TANGENT_DISTANCE = 4;\nconst REVERSAL_PENALTY = 0.5;\n\n// Errors out if the bridges are invalid in some gross way.\nconst checkBridge = (bridge) => {\n  assert(Point.valid(bridge[0]) && Point.valid(bridge[1]));\n  assert(!Point.equal(bridge[0], bridge[1]));\n}\n\n// Returns the list of bridges on the path with the given endpoints. We strip\n// nearly all of the metadata out of this list to make it easy to hand-correct.\n// The list that we return is simply a list of pairs of points.\nconst getBridges = (endpoints, classifier) => {\n  const result = [];\n  const corners = endpoints.filter((x) => x.corner);\n  const matching = matchCorners(corners, classifier);\n  for (let i = 0; i < corners.length; i++) {\n    const j = matching[i];\n    if (j <= i && matching[j] === i) {\n      continue;\n    }\n    result.push([Point.clone(corners[i].point), Point.clone(corners[j].point)]);\n  }\n  result.map(checkBridge);\n  return result;\n}\n\n// Returns a list of angle and distance features between two corners.\nconst getFeatures = (ins, out) => {\n  const diff = Point.subtract(out.point, ins.point);\n  const trivial = Point.equal(diff, [0, 0]);\n  const angle = Math.atan2(diff[1], diff[0]);\n  const distance = Math.sqrt(Point.distance2(out.point, ins.point));\n  return [\n    Angle.subtract(angle, ins.angles[0]),\n    Angle.subtract(out.angles[1], angle),\n    Angle.subtract(ins.angles[1], angle),\n    Angle.subtract(angle, out.angles[0]),\n    Angle.subtract(ins.angles[1], ins.angles[0]),\n    Angle.subtract(out.angles[1], out.angles[0]),\n    (trivial ? 1 : 0),\n    distance/MAX_BRIDGE_DISTANCE,\n  ];\n}\n\n// A hand-tuned classifier that uses the features above to return a score for\n// connecting two corners by a bridge. This classifier throws out most data.\nconst handTunedClassifier = (features) => {\n  if (features[6] > 0) {\n    return -Angle.penalty(features[4]);\n  }\n  let angle_penalty = Angle.penalty(features[0]) + Angle.penalty(features[1]);\n  const distance_penalty = features[7];\n  if (features[0] > 0 && features[1] > 0 &&\n      features[2] + features[3] < -0.5*Math.PI) {\n    angle_penalty = angle_penalty/16;\n  }\n  return -(angle_penalty + distance_penalty);\n}\n\n// Takes a list of corners and returns a bipartite matching between them.\n// If matching[i] === j, then corners[i] is matched with corners[j] - that is,\n// we should construct a bridge from corners[i].point to corners[j].point.\nconst matchCorners = (corners, classifier) => {\n  const matrix = [];\n  for (let i = 0; i < corners.length; i++) {\n    matrix.push([]);\n    for (let j = 0; j < corners.length; j++) {\n      matrix[i].push(scoreCorners(corners[i], corners[j], classifier));\n    }\n  }\n  for (let i = 0; i < corners.length; i++) {\n    for (let j = 0; j < corners.length; j++) {\n      const reversed_score = matrix[j][i] - REVERSAL_PENALTY;\n      if (reversed_score > matrix[i][j]) {\n        matrix[i][j] = reversed_score;\n      }\n    }\n  }\n  return (new Hungarian(matrix)).x_match;\n}\n\n// Takes two corners and returns the score assigned to constructing a bridge\n// from one corner to the other. The score is directed: the bridge from ins to\n// out may be weighted higher than from out to ins.\nconst scoreCorners = (ins, out, classifier) => {\n  return classifier(getFeatures(ins, out));\n}\n\n// Stores angle and distance metadata around an SVG path segment's start point.\n// This endpoint may be a 'corner', which is true if the path bends sharply in\n// the negative (clockwise) direction at that point.\nfunction Endpoint(paths, index) {\n  this.index = index;\n  const path = paths[index[0]];\n  const n = path.length;\n  this.indices = [[index[0], (index[1] + n - 1) % n], index];\n  this.segments = [path[(index[1] + n - 1) % n], path[index[1]]];\n  this.point = this.segments[0].end;\n  assert(Point.valid(this.point), this.point);\n  assert(Point.equal(this.point, this.segments[1].start), path);\n  this.tangents = [\n    Point.subtract(this.segments[0].end, this.segments[0].start),\n    Point.subtract(this.segments[1].end, this.segments[1].start),\n  ];\n  const threshold = Math.pow(MIN_CORNER_TANGENT_DISTANCE, 2);\n  if (this.segments[0].control !== undefined &&\n      Point.distance2(this.point, this.segments[0].control) > threshold) {\n    this.tangents[0] = Point.subtract(this.point, this.segments[0].control);\n  }\n  if (this.segments[1].control !== undefined &&\n      Point.distance2(this.point, this.segments[1].control) > threshold) {\n    this.tangents[1] = Point.subtract(this.segments[1].control, this.point);\n  }\n  this.angles = this.tangents.map(Point.angle);\n  const diff = Angle.subtract(this.angles[1], this.angles[0]);\n  this.corner = diff < -MIN_CORNER_ANGLE;\n  return this;\n}\n\n// Code for the stroke extraction step follows.\n\nconst addEdgeToAdjacency = (edge, adjacency) => {\n  assert(edge.length === 2);\n  adjacency[edge[0]] = adjacency[edge[0]] || [];\n  if (adjacency[edge[0]].indexOf(edge[1]) < 0) {\n    adjacency[edge[0]].push(edge[1]);\n  }\n}\n\nconst extractStroke = (paths, endpoint_map, bridge_adjacency, log,\n                       extracted_indices, start, attempt_one) => {\n  const result = [];\n  const visited = {};\n  let current = start;\n\n  // A list of line segments that were added to the path but that were not\n  // part of the original stroke data. None of these should intersect.\n  const line_segments = [];\n  let self_intersecting = false;\n\n  const advance = (index) =>\n      [index[0], (index[1] + 1) % paths[index[0]].length];\n\n  const angle = (index1, index2) => {\n    const diff = Point.subtract(endpoint_map[Point.key(index2)].point,\n                                endpoint_map[Point.key(index1)].point);\n    assert(diff[0] !== 0 || diff[1] !== 0);\n    const angle = Math.atan2(diff[1], diff[0]);\n    return Angle.subtract(angle,  endpoint.angles[0]);\n  }\n\n  const getIntersection = (segment1, segment2) => {\n    const diff1 = Point.subtract(segment1[1], segment1[0]);\n    const diff2 = Point.subtract(segment2[1], segment2[0]);\n    const cross = diff1[0]*diff2[1] - diff1[1]*diff2[0];\n    if (cross === 0) {\n      return undefined;\n    }\n    const v = Point.subtract(segment1[0], segment2[0]);\n    const s = (diff1[0]*v[1] - diff1[1]*v[0])/cross;\n    const t = (diff2[0]*v[1] - diff2[1]*v[0])/cross;\n    if (0 < s && s < 1 && 0 < t && t < 1) {\n      return [segment1[0][0] + t*diff1[0], segment1[0][1] + t*diff1[1]];\n    }\n    return undefined;\n  }\n\n  const indexToPoint = (index) => endpoint_map[Point.key(index)].point;\n\n  const pushLineSegments = (points) => {\n    const old_lines = line_segments.length;\n    for (let i = 0; i < points.length - 1; i++) {\n      line_segments.push([points[i], points[i + 1]]);\n      result.push({\n        start: Point.clone(points[i]),\n        end: Point.clone(points[i + 1]),\n        control: undefined,\n      });\n    }\n    // Log an error if this stroke is self-intersecting.\n    if (!self_intersecting) {\n      for (let i = 0; i < old_lines; i++) {\n        for (let j = old_lines; j < line_segments.length; j++) {\n          if (getIntersection(line_segments[i], line_segments[j])) {\n            self_intersecting = true;\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  // Here there be dragons!\n  // TODO(skishore): Document the point of the geometry in this function.\n  const selectBridge = (endpoint, options) => {\n    if (options.length === 1 && extracted_indices[Point.key(options[0])]) {\n      // Handle star-shaped strokes where one stroke ends at the intersection\n      // of the bridges used by two other strokes.\n      const indices1 = [endpoint.index, options[0]];\n      const segment1 = indices1.map(indexToPoint);\n      for (let key in bridge_adjacency) {\n        if (Point.equal(endpoint_map[key].index, indices1[0])) {\n          continue;\n        }\n        for (let i = 0; i < bridge_adjacency[key].length; i++) {\n          if (Point.equal(bridge_adjacency[key][i], segment1[0])) {\n            continue;\n          }\n          // Compute the other bridge segment and check if it intersects.\n          const indices2 = [endpoint_map[key].index, bridge_adjacency[key][i]];\n          const segment2 = indices2.map(indexToPoint);\n          if (Point.equal(indices2[0], indices1[1]) &&\n              !extracted_indices[Point.key(indices2[1])]) {\n            pushLineSegments([segment1[0], segment1[1], segment2[1]]);\n            return indices2[1];\n          } else if (Point.equal(indices2[1], indices1[1]) &&\n                     !extracted_indices[Point.key(indices2[0])]) {\n            pushLineSegments([segment1[0], segment1[1], segment2[0]]);\n            return indices2[0];\n          }\n          const intersection = getIntersection(segment1, segment2);\n          if (intersection !== undefined) {\n            const angle1 = angle(indices1[0], indices1[1]);\n            const angle2 = angle(indices2[0], indices2[1]);\n            if (Angle.subtract(angle2, angle1) < 0) {\n              indices2.reverse();\n              segment2.reverse();\n            }\n            pushLineSegments([segment1[0], intersection, segment2[1]]);\n            return indices2[1];\n          }\n        }\n      }\n    } else {\n      // Handle segments where the correct path is to follow a dead-end bridge,\n      // even if there is another bridge that is more aligned with the stroke.\n      for (let i = 0; i < options.length; i++) {\n        const key = Point.key(options[i]);\n        if (!extracted_indices[key]) {\n          return options[i];\n        }\n      }\n    }\n    return options[0];\n  }\n\n  while (true) {\n    // Add the current path segment to the path.\n    result.push(paths[current[0]][current[1]]);\n    visited[Point.key(current)] = true;\n    current = advance(current);\n    // If there are bridges at the start of the next path segment, follow the\n    // one that makes the largest angle with the current path. The ordering\n    // criterion enforce that we try to cross aligned bridges.\n    const key = Point.key(current);\n    if (bridge_adjacency.hasOwnProperty(key)) {\n      var endpoint = endpoint_map[key];\n      const options = bridge_adjacency[key].sort(\n          (a, b) => angle(endpoint.index, a) - angle(endpoint.index, b));\n      // HACK(skishore): The call to selectBridge may update the result.\n      // When a stroke is formed by computing a bridge intersection, then the\n      // two bridge fragments are added in selectBridge.\n      const result_length = result.length;\n      const next = (attempt_one ? options[0] : selectBridge(endpoint, options));\n      if (result.length === result_length) {\n        pushLineSegments([endpoint.point, endpoint_map[Point.key(next)].point]);\n      }\n      current = next;\n    }\n    // Check if we have either closed the loop or hit an extracted segment.\n    const new_key = Point.key(current);\n    if (Point.equal(current, start)) {\n      if (self_intersecting) {\n        log.push({cls: 'error',\n                  message: 'Extracted a self-intersecting stroke.'});\n      }\n      let num_segments_on_path = 0;\n      for (let index in visited) {\n        extracted_indices[index] = true;\n        num_segments_on_path += 1;\n      }\n      // Single-segment strokes may be due to graphical artifacts in the font.\n      // We drop them to remove these artifacts.\n      if (num_segments_on_path === 1) {\n        log.push({cls: 'success', message: 'Dropping single-segment stroke.'});\n        return undefined;\n      }\n      return result;\n    } else if (extracted_indices[new_key] || visited[new_key]) {\n      return undefined;\n    }\n  }\n}\n\nconst extractStrokes = (paths, endpoints, bridges, log) => {\n  // Build up the necessary hash tables and adjacency lists needed to run the\n  // stroke extraction loop.\n  const endpoint_map = {};\n  const endpoint_position_map = {};\n  for (let endpoint of endpoints) {\n    endpoint_map[Point.key(endpoint.index)] = endpoint;\n    endpoint_position_map[Point.key(endpoint.point)] = endpoint;\n  }\n  bridges.map(checkBridge);\n  const bridge_adjacency = {};\n  for (let bridge of bridges) {\n    const keys = bridge.map(Point.key);\n    assert(endpoint_position_map.hasOwnProperty(keys[0]));\n    assert(endpoint_position_map.hasOwnProperty(keys[1]));\n    const xs = keys.map((x) => endpoint_position_map[x].index);\n    addEdgeToAdjacency([Point.key(xs[0]), xs[1]], bridge_adjacency);\n    addEdgeToAdjacency([Point.key(xs[1]), xs[0]], bridge_adjacency);\n  }\n  // Actually extract strokes. Any given path segment index should appear on\n  // exactly one stroke; if it is not on a stroke, we log a warning.\n  const extracted_indices = {};\n  const strokes = [];\n  for (let attempt = 0; attempt < 3; attempt++) {\n    let missed = false;\n    for (var i = 0; i < paths.length; i++) {\n      for (var j = 0; j < paths[i].length; j++) {\n        const index = [i, j];\n        if (extracted_indices[Point.key(index)]) {\n          continue;\n        }\n        const attempt_one = attempt === 0;\n        const stroke = extractStroke(paths, endpoint_map, bridge_adjacency, log,\n                                     extracted_indices, index, attempt_one);\n        if (stroke === undefined) {\n          missed = true;\n          continue;\n        }\n        strokes.push(stroke);\n      }\n    }\n    if (!missed) {\n      return strokes;\n    }\n  }\n  log.push({cls: 'error',\n            message: 'Stroke extraction missed some path segments.'});\n  return strokes;\n}\n\n// Exports go below this fold.\n\nconst stroke_extractor = {};\n\nstroke_extractor.getBridges = (path, classifier) => {\n  const paths = svg.convertSVGPathToPaths(path);\n  const endpoints = [];\n  for (let i = 0; i < paths.length; i++) {\n    for (let j = 0; j < paths[i].length; j++) {\n      endpoints.push(new Endpoint(paths, [i, j]));\n    }\n  }\n  classifier = classifier || stroke_extractor.combinedClassifier;\n  const bridges = getBridges(endpoints, classifier);\n  return {endpoints: endpoints, bridges: bridges};\n}\n\nstroke_extractor.getStrokes = (path, bridges) => {\n  const paths = svg.convertSVGPathToPaths(path);\n  const endpoints = [];\n  for (let i = 0; i < paths.length; i++) {\n    for (let j = 0; j < paths[i].length; j++) {\n      endpoints.push(new Endpoint(paths, [i, j]));\n    }\n  }\n  const log = [];\n  const stroke_paths = extractStrokes(paths, endpoints, bridges, log);\n  const strokes = stroke_paths.map((x) => svg.convertPathsToSVGPath([x]));\n  return {log: log, strokes: strokes};\n}\n\nstroke_extractor.handTunedClassifier = handTunedClassifier;\n\nexport {stroke_extractor};\n"]},"sourceType":"module","externalDependencies":{},"hash":"3a75107dd4886679bd43d670709936aa2cd03b5e"}
