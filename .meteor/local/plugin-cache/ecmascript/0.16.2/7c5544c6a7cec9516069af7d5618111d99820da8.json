{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/a37/code/github/makemeahanzi-tool/lib/stroke_caps/fixStrokes.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"lib/stroke_caps/fixStrokes.js","filename":"/Users/a37/code/github/makemeahanzi-tool/lib/stroke_caps/fixStrokes.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/a37/code/github/makemeahanzi-tool","root":"/Users/a37/code/github/makemeahanzi-tool","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/a37/code/github/makemeahanzi-tool/lib/stroke_caps/fixStrokes.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"lib/stroke_caps/fixStrokes.js"}},"code":"!function (module1) {\n  const {\n    distToPath,\n    getCosSimAroundPoint,\n    getLinesIntersectPoint,\n    getOutlinePoints,\n    extendPointOnLine,\n    estimateTanPoints,\n    roundPathPoints,\n    ptEq,\n    dist\n  } = require('./utils');\n\n  CLIP_THRESH = 2;\n  LOWER_COS_SIM_THRESH = 0.89;\n  UPPER_COS_SIM_THRESH = 0.97; // A bridge is a place in the pathstring where 2 strokes intersect. It can either be 1 stroke clipping\n  // another, or it can be strokes passing through each other. In the pathstring from makemeahanzi, any\n  // L # # in the pathstring is a\n\n  class Bridge {\n    constructor(points, pointString, stroke) {\n      this.points = points;\n      this.pointString = pointString;\n      this.stroke = stroke;\n      this.estTanPoints = estimateTanPoints(stroke.outline, points);\n    }\n\n    getClips() {\n      // this clip point is super tiny, it's probably just a glitch, skip it\n      if (dist(this.points[0], this.points[1]) < 3.1) return [];\n      const cosSim0 = getCosSimAroundPoint(this.points[0], this.stroke.outline);\n      const cosSim1 = getCosSimAroundPoint(this.points[1], this.stroke.outline); // If the angle around the bridge points looks flat, it's probably an intersection.\n\n      if (Math.min(cosSim0, cosSim1) > LOWER_COS_SIM_THRESH && Math.max(cosSim0, cosSim1) > UPPER_COS_SIM_THRESH) {\n        return [];\n      }\n\n      return this.stroke.character.strokes.filter(stroke => {\n        if (stroke === this.stroke) return false;\n        const dist0 = distToPath(this.points[0], stroke.outline);\n        const dist1 = distToPath(this.points[1], stroke.outline);\n        return dist0 <= CLIP_THRESH && dist1 <= CLIP_THRESH;\n      }).map(clippingStroke => new Clip(this, clippingStroke));\n    }\n\n  }\n\n  class Clip {\n    constructor(bridge, clippingStroke) {\n      this.points = bridge.points;\n      this.estTanPoints = bridge.estTanPoints;\n      this.pointString = bridge.pointString;\n      this.clippedBy = [clippingStroke];\n      this.isDouble = false;\n    }\n\n    canMerge(otherClip) {\n      return ptEq(this.points[1], otherClip.points[0]);\n    }\n\n    mergeIntoDouble(otherClip) {\n      this.isDouble = true;\n      this.clippedBy = this.clippedBy.concat(otherClip.clippedBy);\n      this.middlePoint = otherClip.points[0];\n      this.points[1] = otherClip.points[1];\n      this.estTanPoints[1] = otherClip.estTanPoints[1];\n      this.pointString += otherClip.pointString.replace(/.*L/, ' L');\n    }\n\n    getNewStrokeTip() {\n      const maxControlPoint = getLinesIntersectPoint(this.estTanPoints[0], this.points[0], this.estTanPoints[1], this.points[1]);\n      const maxDistControl0 = dist(maxControlPoint, this.points[0]);\n      const maxDistControl1 = dist(maxControlPoint, this.points[1]);\n      let distControl0 = Math.min(maxDistControl0, 30);\n      let distControl1 = Math.min(maxDistControl1, 30); // if the 2 lines are parallel, there will be no intersection point. Just use 30 in that case.\n\n      if (isNaN(distControl0)) distControl0 = 30;\n      if (isNaN(distControl1)) distControl1 = 30;\n\n      if (this.isDouble) {\n        const midDist0 = dist(this.middlePoint, this.points[0]);\n        const midDist1 = dist(this.middlePoint, this.points[1]);\n        distControl0 = Math.max(midDist0 * 1.4, distControl0);\n        distControl1 = Math.max(midDist1 * 1.4, distControl1);\n      }\n\n      const controlPoint0 = extendPointOnLine(this.estTanPoints[0], this.points[0], distControl0);\n      const controlPoint1 = extendPointOnLine(this.estTanPoints[1], this.points[1], distControl1);\n\n      const pString = point => \"\".concat(Math.round(point.x), \" \").concat(Math.round(point.y));\n\n      return \"\".concat(pString(this.points[0]), \" C \").concat(pString(controlPoint0), \" \").concat(pString(controlPoint1), \" \").concat(pString(this.points[1]));\n    }\n\n  }\n\n  class Stroke {\n    constructor(pathString, character, strokeNum) {\n      this.pathString = pathString;\n      this.outline = getOutlinePoints(pathString);\n      this.character = character;\n      this.strokeNum = strokeNum;\n    }\n\n    getBridges() {\n      const pointStringParts = this.pathString.match(/-?\\d+(?:\\.\\d+)? -?\\d+(?:\\.\\d+)? L/ig);\n      if (!pointStringParts) return [];\n      return pointStringParts.map(pointStringPart => {\n        const fullPointStringRegex = new RegExp(\"\".concat(pointStringPart, \" -?\\\\d+(?:\\\\.\\\\d+)? -?\\\\d+(?:\\\\.\\\\d+)?\"));\n        const pointString = this.pathString.match(fullPointStringRegex)[0];\n        const parts = pointString.split(/\\sL?\\s?/).map(num => parseFloat(num));\n        const points = [{\n          x: parts[0],\n          y: parts[1]\n        }, {\n          x: parts[2],\n          y: parts[3]\n        }];\n        return new Bridge(points, pointString, this);\n      });\n    }\n\n    fixPathString() {\n      const bridges = this.getBridges();\n      let clips = [];\n      bridges.forEach(bridge => {\n        bridge.getClips().forEach(clip => {\n          const lastClip = clips[clips.length - 1];\n\n          if (lastClip && lastClip.canMerge(clip)) {\n            lastClip.mergeIntoDouble(clip);\n          } else {\n            clips.push(clip);\n          }\n        });\n      });\n      let modifiedPathString = this.pathString;\n      clips.forEach(clip => {\n        const newTip = clip.getNewStrokeTip();\n        modifiedPathString = roundPathPoints(modifiedPathString.replace(clip.pointString, newTip));\n      });\n      return {\n        isModified: clips.length > 0,\n        isDoubleClipped: !!clips.find(clip => clip.isDouble),\n        pathString: modifiedPathString,\n        strokeNum: this.strokeNum\n      };\n    }\n\n  }\n\n  class Character {\n    constructor(pathStrings) {\n      this.strokes = pathStrings.map((path, i) => new Stroke(path, this, i));\n    }\n\n  }\n\n  const fixStrokesWithDetails = strokePathStrings => {\n    const character = new Character(strokePathStrings);\n    const fixedStrokesInfo = character.strokes.map(stroke => stroke.fixPathString());\n    return {\n      modified: !!fixedStrokesInfo.find(summary => summary.isModified),\n      hasDoubleClippedStroke: !!fixedStrokesInfo.find(summary => summary.isDoubleClipped),\n      modifiedStrokes: fixedStrokesInfo.filter(summary => summary.isModified).map(summary => summary.strokeNum),\n      strokes: fixedStrokesInfo.map(summary => summary.pathString)\n    };\n  };\n\n  const fixStrokesOnce = strokes => {\n    const corrected = fixStrokesWithDetails(strokes);\n    return corrected.modified ? corrected.strokes : strokes;\n  };\n\n  const fixStrokes = strokes => fixStrokesOnce(fixStrokesOnce(strokes));\n\n  module.exports = {\n    fixStrokes\n  };\n}.call(this, module);","map":{"version":3,"sources":["lib/stroke_caps/fixStrokes.js"],"names":["distToPath","getCosSimAroundPoint","getLinesIntersectPoint","getOutlinePoints","extendPointOnLine","estimateTanPoints","roundPathPoints","ptEq","dist","require","CLIP_THRESH","LOWER_COS_SIM_THRESH","UPPER_COS_SIM_THRESH","Bridge","constructor","points","pointString","stroke","estTanPoints","outline","getClips","cosSim0","cosSim1","Math","min","max","character","strokes","filter","dist0","dist1","map","clippingStroke","Clip","bridge","clippedBy","isDouble","canMerge","otherClip","mergeIntoDouble","concat","middlePoint","replace","getNewStrokeTip","maxControlPoint","maxDistControl0","maxDistControl1","distControl0","distControl1","isNaN","midDist0","midDist1","controlPoint0","controlPoint1","pString","point","round","x","y","Stroke","pathString","strokeNum","getBridges","pointStringParts","match","pointStringPart","fullPointStringRegex","RegExp","parts","split","num","parseFloat","fixPathString","bridges","clips","forEach","clip","lastClip","length","push","modifiedPathString","newTip","isModified","isDoubleClipped","find","Character","pathStrings","path","i","fixStrokesWithDetails","strokePathStrings","fixedStrokesInfo","modified","summary","hasDoubleClippedStroke","modifiedStrokes","fixStrokesOnce","corrected","fixStrokes","module","exports"],"mappings":";AAAA,QAAM;AACJA,IAAAA,UADI;AAEJC,IAAAA,oBAFI;AAGJC,IAAAA,sBAHI;AAIJC,IAAAA,gBAJI;AAKJC,IAAAA,iBALI;AAMJC,IAAAA,iBANI;AAOJC,IAAAA,eAPI;AAQJC,IAAAA,IARI;AASJC,IAAAA;AATI,MAUFC,OAAO,CAAC,SAAD,CAVX;;AAaAC,EAAAA,WAAW,GAAG,CAAd;AACAC,EAAAA,oBAAoB,GAAG,IAAvB;AACAC,EAAAA,oBAAoB,GAAG,IAAvB,C,CAEA;AACA;AACA;;AACA,QAAMC,MAAN,CAAa;AACXC,IAAAA,WAAW,CAACC,MAAD,EAASC,WAAT,EAAsBC,MAAtB,EAA8B;AACvC,WAAKF,MAAL,GAAcA,MAAd;AACA,WAAKC,WAAL,GAAmBA,WAAnB;AACA,WAAKC,MAAL,GAAcA,MAAd;AACA,WAAKC,YAAL,GAAoBb,iBAAiB,CAACY,MAAM,CAACE,OAAR,EAAiBJ,MAAjB,CAArC;AACD;;AAEDK,IAAAA,QAAQ,GAAG;AACT;AACA,UAAIZ,IAAI,CAAC,KAAKO,MAAL,CAAY,CAAZ,CAAD,EAAiB,KAAKA,MAAL,CAAY,CAAZ,CAAjB,CAAJ,GAAuC,GAA3C,EAAgD,OAAO,EAAP;AAChD,YAAMM,OAAO,GAAGpB,oBAAoB,CAAC,KAAKc,MAAL,CAAY,CAAZ,CAAD,EAAiB,KAAKE,MAAL,CAAYE,OAA7B,CAApC;AACA,YAAMG,OAAO,GAAGrB,oBAAoB,CAAC,KAAKc,MAAL,CAAY,CAAZ,CAAD,EAAiB,KAAKE,MAAL,CAAYE,OAA7B,CAApC,CAJS,CAKT;;AACA,UAAII,IAAI,CAACC,GAAL,CAASH,OAAT,EAAkBC,OAAlB,IAA6BX,oBAA7B,IAAqDY,IAAI,CAACE,GAAL,CAASJ,OAAT,EAAkBC,OAAlB,IAA6BV,oBAAtF,EAA4G;AAC1G,eAAO,EAAP;AACD;;AACD,aAAO,KAAKK,MAAL,CAAYS,SAAZ,CAAsBC,OAAtB,CAA8BC,MAA9B,CAAqCX,MAAM,IAAI;AACpD,YAAIA,MAAM,KAAK,KAAKA,MAApB,EAA4B,OAAO,KAAP;AAC5B,cAAMY,KAAK,GAAG7B,UAAU,CAAC,KAAKe,MAAL,CAAY,CAAZ,CAAD,EAAiBE,MAAM,CAACE,OAAxB,CAAxB;AACA,cAAMW,KAAK,GAAG9B,UAAU,CAAC,KAAKe,MAAL,CAAY,CAAZ,CAAD,EAAiBE,MAAM,CAACE,OAAxB,CAAxB;AACA,eAAOU,KAAK,IAAInB,WAAT,IAAwBoB,KAAK,IAAIpB,WAAxC;AACD,OALM,EAKJqB,GALI,CAKAC,cAAc,IAAI,IAAIC,IAAJ,CAAS,IAAT,EAAeD,cAAf,CALlB,CAAP;AAMD;;AAvBU;;AA0Bb,QAAMC,IAAN,CAAW;AACTnB,IAAAA,WAAW,CAACoB,MAAD,EAASF,cAAT,EAAyB;AAClC,WAAKjB,MAAL,GAAcmB,MAAM,CAACnB,MAArB;AACA,WAAKG,YAAL,GAAoBgB,MAAM,CAAChB,YAA3B;AACA,WAAKF,WAAL,GAAmBkB,MAAM,CAAClB,WAA1B;AACA,WAAKmB,SAAL,GAAiB,CAACH,cAAD,CAAjB;AACA,WAAKI,QAAL,GAAgB,KAAhB;AACD;;AAEDC,IAAAA,QAAQ,CAACC,SAAD,EAAY;AAClB,aAAO/B,IAAI,CAAC,KAAKQ,MAAL,CAAY,CAAZ,CAAD,EAAiBuB,SAAS,CAACvB,MAAV,CAAiB,CAAjB,CAAjB,CAAX;AACD;;AAEDwB,IAAAA,eAAe,CAACD,SAAD,EAAY;AACzB,WAAKF,QAAL,GAAgB,IAAhB;AACA,WAAKD,SAAL,GAAiB,KAAKA,SAAL,CAAeK,MAAf,CAAsBF,SAAS,CAACH,SAAhC,CAAjB;AACA,WAAKM,WAAL,GAAmBH,SAAS,CAACvB,MAAV,CAAiB,CAAjB,CAAnB;AACA,WAAKA,MAAL,CAAY,CAAZ,IAAiBuB,SAAS,CAACvB,MAAV,CAAiB,CAAjB,CAAjB;AACA,WAAKG,YAAL,CAAkB,CAAlB,IAAuBoB,SAAS,CAACpB,YAAV,CAAuB,CAAvB,CAAvB;AACA,WAAKF,WAAL,IAAoBsB,SAAS,CAACtB,WAAV,CAAsB0B,OAAtB,CAA8B,KAA9B,EAAqC,IAArC,CAApB;AACD;;AAEDC,IAAAA,eAAe,GAAG;AAChB,YAAMC,eAAe,GAAG1C,sBAAsB,CAC5C,KAAKgB,YAAL,CAAkB,CAAlB,CAD4C,EAE5C,KAAKH,MAAL,CAAY,CAAZ,CAF4C,EAG5C,KAAKG,YAAL,CAAkB,CAAlB,CAH4C,EAI5C,KAAKH,MAAL,CAAY,CAAZ,CAJ4C,CAA9C;AAOA,YAAM8B,eAAe,GAAGrC,IAAI,CAACoC,eAAD,EAAkB,KAAK7B,MAAL,CAAY,CAAZ,CAAlB,CAA5B;AACA,YAAM+B,eAAe,GAAGtC,IAAI,CAACoC,eAAD,EAAkB,KAAK7B,MAAL,CAAY,CAAZ,CAAlB,CAA5B;AACA,UAAIgC,YAAY,GAAGxB,IAAI,CAACC,GAAL,CAASqB,eAAT,EAA0B,EAA1B,CAAnB;AACA,UAAIG,YAAY,GAAGzB,IAAI,CAACC,GAAL,CAASsB,eAAT,EAA0B,EAA1B,CAAnB,CAXgB,CAahB;;AACA,UAAIG,KAAK,CAACF,YAAD,CAAT,EAAyBA,YAAY,GAAG,EAAf;AACzB,UAAIE,KAAK,CAACD,YAAD,CAAT,EAAyBA,YAAY,GAAG,EAAf;;AAEzB,UAAI,KAAKZ,QAAT,EAAmB;AACjB,cAAMc,QAAQ,GAAG1C,IAAI,CAAC,KAAKiC,WAAN,EAAmB,KAAK1B,MAAL,CAAY,CAAZ,CAAnB,CAArB;AACA,cAAMoC,QAAQ,GAAG3C,IAAI,CAAC,KAAKiC,WAAN,EAAmB,KAAK1B,MAAL,CAAY,CAAZ,CAAnB,CAArB;AACAgC,QAAAA,YAAY,GAAGxB,IAAI,CAACE,GAAL,CAASyB,QAAQ,GAAG,GAApB,EAAyBH,YAAzB,CAAf;AACAC,QAAAA,YAAY,GAAGzB,IAAI,CAACE,GAAL,CAAS0B,QAAQ,GAAG,GAApB,EAAyBH,YAAzB,CAAf;AACD;;AAED,YAAMI,aAAa,GAAGhD,iBAAiB,CAAC,KAAKc,YAAL,CAAkB,CAAlB,CAAD,EAAuB,KAAKH,MAAL,CAAY,CAAZ,CAAvB,EAAuCgC,YAAvC,CAAvC;AACA,YAAMM,aAAa,GAAGjD,iBAAiB,CAAC,KAAKc,YAAL,CAAkB,CAAlB,CAAD,EAAuB,KAAKH,MAAL,CAAY,CAAZ,CAAvB,EAAuCiC,YAAvC,CAAvC;;AAEA,YAAMM,OAAO,GAAGC,KAAK,cAAOhC,IAAI,CAACiC,KAAL,CAAWD,KAAK,CAACE,CAAjB,CAAP,cAA8BlC,IAAI,CAACiC,KAAL,CAAWD,KAAK,CAACG,CAAjB,CAA9B,CAArB;;AAEA,uBAAUJ,OAAO,CAAC,KAAKvC,MAAL,CAAY,CAAZ,CAAD,CAAjB,gBAAuCuC,OAAO,CAACF,aAAD,CAA9C,cAAiEE,OAAO,CAACD,aAAD,CAAxE,cAA2FC,OAAO,CAAC,KAAKvC,MAAL,CAAY,CAAZ,CAAD,CAAlG;AACD;;AApDQ;;AAuDX,QAAM4C,MAAN,CAAa;AACX7C,IAAAA,WAAW,CAAC8C,UAAD,EAAalC,SAAb,EAAwBmC,SAAxB,EAAmC;AAC5C,WAAKD,UAAL,GAAkBA,UAAlB;AACA,WAAKzC,OAAL,GAAehB,gBAAgB,CAACyD,UAAD,CAA/B;AACA,WAAKlC,SAAL,GAAiBA,SAAjB;AACA,WAAKmC,SAAL,GAAiBA,SAAjB;AACD;;AAEDC,IAAAA,UAAU,GAAG;AACX,YAAMC,gBAAgB,GAAG,KAAKH,UAAL,CAAgBI,KAAhB,CAAsB,qCAAtB,CAAzB;AACA,UAAI,CAACD,gBAAL,EAAuB,OAAO,EAAP;AACvB,aAAOA,gBAAgB,CAAChC,GAAjB,CAAqBkC,eAAe,IAAI;AAC7C,cAAMC,oBAAoB,GAAG,IAAIC,MAAJ,WAAcF,eAAd,4CAA7B;AACA,cAAMjD,WAAW,GAAG,KAAK4C,UAAL,CAAgBI,KAAhB,CAAsBE,oBAAtB,EAA4C,CAA5C,CAApB;AACA,cAAME,KAAK,GAAGpD,WAAW,CAACqD,KAAZ,CAAkB,SAAlB,EAA6BtC,GAA7B,CAAiCuC,GAAG,IAAIC,UAAU,CAACD,GAAD,CAAlD,CAAd;AACA,cAAMvD,MAAM,GAAG,CAAC;AAAC0C,UAAAA,CAAC,EAAEW,KAAK,CAAC,CAAD,CAAT;AAAcV,UAAAA,CAAC,EAAEU,KAAK,CAAC,CAAD;AAAtB,SAAD,EAA6B;AAACX,UAAAA,CAAC,EAAEW,KAAK,CAAC,CAAD,CAAT;AAAcV,UAAAA,CAAC,EAAEU,KAAK,CAAC,CAAD;AAAtB,SAA7B,CAAf;AACA,eAAO,IAAIvD,MAAJ,CAAWE,MAAX,EAAmBC,WAAnB,EAAgC,IAAhC,CAAP;AACD,OANM,CAAP;AAOD;;AAEDwD,IAAAA,aAAa,GAAG;AACd,YAAMC,OAAO,GAAG,KAAKX,UAAL,EAAhB;AACA,UAAIY,KAAK,GAAG,EAAZ;AACAD,MAAAA,OAAO,CAACE,OAAR,CAAgBzC,MAAM,IAAI;AACxBA,QAAAA,MAAM,CAACd,QAAP,GAAkBuD,OAAlB,CAA0BC,IAAI,IAAI;AAChC,gBAAMC,QAAQ,GAAGH,KAAK,CAACA,KAAK,CAACI,MAAN,GAAe,CAAhB,CAAtB;;AACA,cAAID,QAAQ,IAAIA,QAAQ,CAACxC,QAAT,CAAkBuC,IAAlB,CAAhB,EAAyC;AACvCC,YAAAA,QAAQ,CAACtC,eAAT,CAAyBqC,IAAzB;AACD,WAFD,MAEO;AACLF,YAAAA,KAAK,CAACK,IAAN,CAAWH,IAAX;AACD;AACF,SAPD;AAQD,OATD;AAWA,UAAII,kBAAkB,GAAG,KAAKpB,UAA9B;AACAc,MAAAA,KAAK,CAACC,OAAN,CAAcC,IAAI,IAAI;AACpB,cAAMK,MAAM,GAAGL,IAAI,CAACjC,eAAL,EAAf;AACAqC,QAAAA,kBAAkB,GAAG1E,eAAe,CAAC0E,kBAAkB,CAACtC,OAAnB,CAA2BkC,IAAI,CAAC5D,WAAhC,EAA6CiE,MAA7C,CAAD,CAApC;AACD,OAHD;AAKA,aAAO;AACLC,QAAAA,UAAU,EAAER,KAAK,CAACI,MAAN,GAAe,CADtB;AAELK,QAAAA,eAAe,EAAE,CAAC,CAACT,KAAK,CAACU,IAAN,CAAWR,IAAI,IAAIA,IAAI,CAACxC,QAAxB,CAFd;AAGLwB,QAAAA,UAAU,EAAEoB,kBAHP;AAILnB,QAAAA,SAAS,EAAE,KAAKA;AAJX,OAAP;AAMD;;AA9CU;;AAiDb,QAAMwB,SAAN,CAAgB;AACdvE,IAAAA,WAAW,CAACwE,WAAD,EAAc;AACvB,WAAK3D,OAAL,GAAe2D,WAAW,CAACvD,GAAZ,CAAgB,CAACwD,IAAD,EAAOC,CAAP,KAAa,IAAI7B,MAAJ,CAAW4B,IAAX,EAAiB,IAAjB,EAAuBC,CAAvB,CAA7B,CAAf;AACD;;AAHa;;AAMhB,QAAMC,qBAAqB,GAAIC,iBAAD,IAAuB;AACnD,UAAMhE,SAAS,GAAG,IAAI2D,SAAJ,CAAcK,iBAAd,CAAlB;AACA,UAAMC,gBAAgB,GAAGjE,SAAS,CAACC,OAAV,CAAkBI,GAAlB,CAAsBd,MAAM,IAAIA,MAAM,CAACuD,aAAP,EAAhC,CAAzB;AAEA,WAAO;AACLoB,MAAAA,QAAQ,EAAE,CAAC,CAACD,gBAAgB,CAACP,IAAjB,CAAsBS,OAAO,IAAIA,OAAO,CAACX,UAAzC,CADP;AAELY,MAAAA,sBAAsB,EAAE,CAAC,CAACH,gBAAgB,CAACP,IAAjB,CAAsBS,OAAO,IAAIA,OAAO,CAACV,eAAzC,CAFrB;AAGLY,MAAAA,eAAe,EAAEJ,gBAAgB,CAAC/D,MAAjB,CAAwBiE,OAAO,IAAIA,OAAO,CAACX,UAA3C,EAAuDnD,GAAvD,CAA2D8D,OAAO,IAAIA,OAAO,CAAChC,SAA9E,CAHZ;AAILlC,MAAAA,OAAO,EAAEgE,gBAAgB,CAAC5D,GAAjB,CAAqB8D,OAAO,IAAIA,OAAO,CAACjC,UAAxC;AAJJ,KAAP;AAMD,GAVD;;AAYA,QAAMoC,cAAc,GAAIrE,OAAD,IAAa;AAClC,UAAMsE,SAAS,GAAGR,qBAAqB,CAAC9D,OAAD,CAAvC;AACA,WAAOsE,SAAS,CAACL,QAAV,GAAqBK,SAAS,CAACtE,OAA/B,GAAyCA,OAAhD;AACD,GAHD;;AAKA,QAAMuE,UAAU,GAAIvE,OAAD,IAAaqE,cAAc,CAACA,cAAc,CAACrE,OAAD,CAAf,CAA9C;;AAEAwE,EAAAA,MAAM,CAACC,OAAP,GAAiB;AAACF,IAAAA;AAAD,GAAjB","sourcesContent":["const {\n  distToPath,\n  getCosSimAroundPoint,\n  getLinesIntersectPoint,\n  getOutlinePoints,\n  extendPointOnLine,\n  estimateTanPoints,\n  roundPathPoints,\n  ptEq,\n  dist,\n} = require('./utils');\n\n\nCLIP_THRESH = 2;\nLOWER_COS_SIM_THRESH = 0.89;\nUPPER_COS_SIM_THRESH = 0.97;\n\n// A bridge is a place in the pathstring where 2 strokes intersect. It can either be 1 stroke clipping\n// another, or it can be strokes passing through each other. In the pathstring from makemeahanzi, any\n// L # # in the pathstring is a\nclass Bridge {\n  constructor(points, pointString, stroke) {\n    this.points = points;\n    this.pointString = pointString;\n    this.stroke = stroke;\n    this.estTanPoints = estimateTanPoints(stroke.outline, points);\n  }\n\n  getClips() {\n    // this clip point is super tiny, it's probably just a glitch, skip it\n    if (dist(this.points[0], this.points[1]) < 3.1) return [];\n    const cosSim0 = getCosSimAroundPoint(this.points[0], this.stroke.outline);\n    const cosSim1 = getCosSimAroundPoint(this.points[1], this.stroke.outline);\n    // If the angle around the bridge points looks flat, it's probably an intersection.\n    if (Math.min(cosSim0, cosSim1) > LOWER_COS_SIM_THRESH && Math.max(cosSim0, cosSim1) > UPPER_COS_SIM_THRESH) {\n      return [];\n    }\n    return this.stroke.character.strokes.filter(stroke => {\n      if (stroke === this.stroke) return false;\n      const dist0 = distToPath(this.points[0], stroke.outline);\n      const dist1 = distToPath(this.points[1], stroke.outline);\n      return dist0 <= CLIP_THRESH && dist1 <= CLIP_THRESH;\n    }).map(clippingStroke => new Clip(this, clippingStroke));\n  }\n}\n\nclass Clip {\n  constructor(bridge, clippingStroke) {\n    this.points = bridge.points;\n    this.estTanPoints = bridge.estTanPoints;\n    this.pointString = bridge.pointString;\n    this.clippedBy = [clippingStroke];\n    this.isDouble = false;\n  }\n\n  canMerge(otherClip) {\n    return ptEq(this.points[1], otherClip.points[0]);\n  }\n\n  mergeIntoDouble(otherClip) {\n    this.isDouble = true;\n    this.clippedBy = this.clippedBy.concat(otherClip.clippedBy);\n    this.middlePoint = otherClip.points[0];\n    this.points[1] = otherClip.points[1];\n    this.estTanPoints[1] = otherClip.estTanPoints[1];\n    this.pointString += otherClip.pointString.replace(/.*L/, ' L');\n  }\n\n  getNewStrokeTip() {\n    const maxControlPoint = getLinesIntersectPoint(\n      this.estTanPoints[0],\n      this.points[0],\n      this.estTanPoints[1],\n      this.points[1],\n    );\n\n    const maxDistControl0 = dist(maxControlPoint, this.points[0]);\n    const maxDistControl1 = dist(maxControlPoint, this.points[1]);\n    let distControl0 = Math.min(maxDistControl0, 30);\n    let distControl1 = Math.min(maxDistControl1, 30);\n\n    // if the 2 lines are parallel, there will be no intersection point. Just use 30 in that case.\n    if (isNaN(distControl0)) distControl0 = 30;\n    if (isNaN(distControl1)) distControl1 = 30;\n\n    if (this.isDouble) {\n      const midDist0 = dist(this.middlePoint, this.points[0]);\n      const midDist1 = dist(this.middlePoint, this.points[1]);\n      distControl0 = Math.max(midDist0 * 1.4, distControl0);\n      distControl1 = Math.max(midDist1 * 1.4, distControl1);\n    }\n\n    const controlPoint0 = extendPointOnLine(this.estTanPoints[0], this.points[0], distControl0);\n    const controlPoint1 = extendPointOnLine(this.estTanPoints[1], this.points[1], distControl1);\n\n    const pString = point => `${Math.round(point.x)} ${Math.round(point.y)}`;\n\n    return `${pString(this.points[0])} C ${pString(controlPoint0)} ${pString(controlPoint1)} ${pString(this.points[1])}`;\n  }\n}\n\nclass Stroke {\n  constructor(pathString, character, strokeNum) {\n    this.pathString = pathString;\n    this.outline = getOutlinePoints(pathString);\n    this.character = character;\n    this.strokeNum = strokeNum;\n  }\n\n  getBridges() {\n    const pointStringParts = this.pathString.match(/-?\\d+(?:\\.\\d+)? -?\\d+(?:\\.\\d+)? L/ig);\n    if (!pointStringParts) return [];\n    return pointStringParts.map(pointStringPart => {\n      const fullPointStringRegex = new RegExp(`${pointStringPart} -?\\\\d+(?:\\\\.\\\\d+)? -?\\\\d+(?:\\\\.\\\\d+)?`);\n      const pointString = this.pathString.match(fullPointStringRegex)[0];\n      const parts = pointString.split(/\\sL?\\s?/).map(num => parseFloat(num));\n      const points = [{x: parts[0], y: parts[1]}, {x: parts[2], y: parts[3]}];\n      return new Bridge(points, pointString, this);\n    });\n  }\n\n  fixPathString() {\n    const bridges = this.getBridges();\n    let clips = [];\n    bridges.forEach(bridge => {\n      bridge.getClips().forEach(clip => {\n        const lastClip = clips[clips.length - 1];\n        if (lastClip && lastClip.canMerge(clip)) {\n          lastClip.mergeIntoDouble(clip);\n        } else {\n          clips.push(clip);\n        }\n      });\n    });\n\n    let modifiedPathString = this.pathString;\n    clips.forEach(clip => {\n      const newTip = clip.getNewStrokeTip();\n      modifiedPathString = roundPathPoints(modifiedPathString.replace(clip.pointString, newTip));\n    });\n\n    return {\n      isModified: clips.length > 0,\n      isDoubleClipped: !!clips.find(clip => clip.isDouble),\n      pathString: modifiedPathString,\n      strokeNum: this.strokeNum,\n    };\n  }\n}\n\nclass Character {\n  constructor(pathStrings) {\n    this.strokes = pathStrings.map((path, i) => new Stroke(path, this, i));\n  }\n}\n\nconst fixStrokesWithDetails = (strokePathStrings) => {\n  const character = new Character(strokePathStrings);\n  const fixedStrokesInfo = character.strokes.map(stroke => stroke.fixPathString());\n\n  return {\n    modified: !!fixedStrokesInfo.find(summary => summary.isModified),\n    hasDoubleClippedStroke: !!fixedStrokesInfo.find(summary => summary.isDoubleClipped),\n    modifiedStrokes: fixedStrokesInfo.filter(summary => summary.isModified).map(summary => summary.strokeNum),\n    strokes: fixedStrokesInfo.map(summary => summary.pathString),\n  };\n};\n\nconst fixStrokesOnce = (strokes) => {\n  const corrected = fixStrokesWithDetails(strokes);\n  return corrected.modified ? corrected.strokes : strokes;\n}\n\nconst fixStrokes = (strokes) => fixStrokesOnce(fixStrokesOnce(strokes));\n\nmodule.exports = {fixStrokes};\n"]},"sourceType":"module","externalDependencies":{},"hash":"7c5544c6a7cec9516069af7d5618111d99820da8"}
