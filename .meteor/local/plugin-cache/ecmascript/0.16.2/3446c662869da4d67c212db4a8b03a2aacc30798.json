{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/a37/code/github/makemeahanzi-tool/lib/cjklib.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"lib/cjklib.js","filename":"/Users/a37/code/github/makemeahanzi-tool/lib/cjklib.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/a37/code/github/makemeahanzi-tool","root":"/Users/a37/code/github/makemeahanzi-tool","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/a37/code/github/makemeahanzi-tool/lib/cjklib.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"lib/cjklib.js"}},"code":"module.export({\n  cjklib: () => cjklib\n});\nlet assert, getPWD, maybeRequire;\nmodule.link(\"/lib/base\", {\n  assert(v) {\n    assert = v;\n  },\n\n  getPWD(v) {\n    getPWD = v;\n  },\n\n  maybeRequire(v) {\n    maybeRequire = v;\n  }\n\n}, 0);\nconst fs = maybeRequire('fs');\nconst path = maybeRequire('path');\nconst CHARACTER_FIELDS = ['character', 'decomposition', 'definition', 'frequency', 'kangxi_index', 'pinyin', 'simplified', 'strokes', 'traditional'];\nconst cjklib = {\n  characters: {},\n  gb2312: {},\n  promise: undefined,\n  radicals: {\n    primary_radical: {},\n    index_to_radical_map: {},\n    radical_to_index_map: {},\n    radical_to_character_map: {}\n  },\n\n  getCharacterData(character) {\n    const result = {};\n    CHARACTER_FIELDS.map(field => result[field] = cjklib.characters[field][character]);\n    result.character = character;\n    result.traditional = result.traditional || [];\n    return result;\n  }\n\n};\nCHARACTER_FIELDS.map(field => cjklib.characters[field] = {}); // Input: String contents of a cjklib data file.\n// Output: a list of rows, each of which is a list of String columns.\n\nconst getCJKLibRows = data => {\n  const lines = data.split('\\n');\n  return lines.filter(line => line.length > 0 && line[0] !== '#').map(line => line.split(',').map(entry => entry.replace(/[\"']/g, '')));\n}; // Input: String contents of a TSV data file.\n// Output: a list of rows, each of which is a list of String columns.\n\n\nconst getFrequencyRows = data => {\n  const lines = data.split('\\n');\n  return lines.filter(line => line.length > 0 && line[0] !== '#').map(line => line.split('\\t'));\n}; // Input: String contents of a Unihan data file.\n// Output: a list of rows, each of which is a list of String columns.\n\n\nconst getUnihanRows = data => {\n  const lines = data.split('\\n');\n  return lines.filter(line => line.length > 0 && line[0] !== '#').map(line => line.split('\\t'));\n}; // Input: a String of the form 'U+<hex>' representing a Unicode codepoint.\n// Output: the character at that codepoint\n\n\nconst parseUnicodeStr = str => String.fromCodePoint(parseInt(str.substr(2), 16)); // Input: the path to a Unihan data file, starting from the public directory.\n// Output: Promise that resolves to the String contents of that file.\n\n\nconst readFile = filename => new Promise((resolve, reject) => {\n  if (Meteor.isServer) {\n    const filepath = path.join(getPWD(), 'public', filename);\n    fs.readFile(filepath, 'utf8', (error, data) => {\n      if (error) throw error;\n      resolve(data);\n    });\n  } else {\n    $.get(filename, (data, code) => {\n      if (code !== 'success') throw new Error(code);\n      resolve(data);\n    });\n  }\n}); // Promises that fill data from specific tables.\n// Output: Promise that fills result with a mapping character -> decomposition.\n// The decompositions are formatted using Ideographic Description Sequence\n// symbols - see the Unicode standard for more details.\n\n\nconst fillDecompositions = (decompositions, glyphs, result) => {\n  return Promise.all([decompositions, glyphs]).then(_ref => {\n    let [rows, glyphs] = _ref;\n    rows.filter(row => parseInt(row[2], 10) === (glyphs[row[0]] || 0)).map(row => result[row[0]] = row[1]);\n  });\n}; // Output: Promise that fills result with a mapping character -> Pinyin.\n\n\nconst fillDefinitions = (readings, result) => {\n  return readings.then(rows => {\n    rows.filter(row => row[1] === 'kDefinition').map(row => result[parseUnicodeStr(row[0])] = row[2]);\n  });\n}; // Output: Promise that fills result with a mapping character -> frequency rank.\n\n\nconst fillFrequencies = (readings, result) => {\n  return readings.then(rows => {\n    rows.map(row => result[row[1]] = parseInt(row[0], 10));\n  });\n}; // Output: Promise that fills result with a mapping character -> Kangxi radical-\n// stroke count, which is a pair of integers [radical, extra_strokes].\n\n\nconst fillKangxiIndex = (readings, result) => {\n  return readings.then(rows => {\n    const getIndex = adotb => adotb.split('.').map(x => parseInt(x, 10));\n\n    rows.filter(row => row[1] === 'kRSKangXi').map(row => result[parseUnicodeStr(row[0])] = getIndex(row[2]));\n  });\n}; // Output: Promise that fills result with a mapping character -> Pinyin.\n\n\nconst fillPinyin = (readings, result) => {\n  return readings.then(rows => {\n    rows.filter(row => row[1] === 'kMandarin').map(row => result[parseUnicodeStr(row[0])] = row[2]);\n  });\n}; // Output: Promise that fills result with a mapping character -> stroke count.\n\n\nconst fillStrokeCounts = (dictionary_like_data, result) => {\n  return dictionary_like_data.then(rows => {\n    rows.filter(row => row[1] === 'kTotalStrokes').map(row => result[parseUnicodeStr(row[0])] = parseInt(row[2], 10));\n  });\n}; // Output: Promise that fills multiple dictionaries in the result:\n//   - index_to_radical_map: Map from index -> list of radicals at that index\n//   - radical_to_index_map: Map from radical -> index of that radical\n//   - primary_radical: Map from index -> primary radical at that index\n\n\nconst fillRadicalData = (locale, radicals, result) => {\n  return radicals.then(rows => {\n    rows.map(row => {\n      if (!result.index_to_radical_map.hasOwnProperty(row[0])) {\n        result.index_to_radical_map[row[0]] = [];\n      }\n\n      result.index_to_radical_map[row[0]].push(row[1]);\n      result.radical_to_index_map[row[1]] = row[0];\n\n      if (row[2] === 'R' && row[3].indexOf(locale) >= 0) {\n        result.primary_radical[row[0]] = row[1];\n      }\n    });\n  });\n}; // Output: Promise that fills result with a map from Unicode radical-codeblock\n// character -> equivalent Unicode CJK-codeblock (hopefully, GB2312) character.\n// There may be Unicode radical characters without a CJK equivalent.\n\n\nconst fillRadicalToCharacterMap = (locale, radical_equivalent_characters, result) => {\n  return radical_equivalent_characters.then(rows => {\n    rows.filter(row => row[2].indexOf(locale) >= 0).map(row => result[row[0]] = row[1]);\n  });\n}; // Output: Promise that fills the two maps with pointers from a given character\n// to its simplified and traditional variants.\n\n\nconst fillVariants = (simplified, traditional, variants) => {\n  return variants.then(rows => {\n    rows.map(row => {\n      if (row[1] !== 'kSimplifiedVariant' && row[1] !== 'kTraditionalVariant' || row[0] === row[2] || row[0] === 'U+2B5B8') {\n        // Unicode introduced an extra character U+2B5B8 matching U+613F.\n        return;\n      }\n\n      let source = parseUnicodeStr(row[0]);\n      let target = parseUnicodeStr(row[2]);\n      const split = row[2].split(' '); // A number of characters have multiple simplified variants. Of these,\n      // we should only use one of them, usually the first, but in three cases,\n      // the second.\n\n      if (split.length === 2 && ['U+937E', 'U+949F', 'U+9918'].indexOf(row[0]) >= 0) {\n        target = parseUnicodeStr(split[1]);\n      }\n\n      if (source === target) {\n        return;\n      } else if (row[1] === 'kTraditionalVariant') {\n        const swap = target;\n        target = source;\n        source = swap;\n      } // The mapping from traditional characters to simplified characters is\n      // many to one, so we can only assert that simplified[source] is unique.\n\n\n      assert(!simplified[source] || simplified[source] === target);\n      simplified[source] = target;\n      traditional[target] = _.unique((traditional[target] || []).concat([source]));\n    });\n  });\n}; // Given the data from the GB2312 data file, fills the GB2312 result map.\n\n\nconst fillGB2312 = (data, result) => {\n  Array.from(data).map(character => {\n    if (character === '\\n') return;\n    assert(character.length === 1);\n    const codepoint = character.codePointAt(0);\n    assert(0x4e00 <= codepoint && codepoint <= 0x9fff);\n    result[character] = true;\n  });\n  assert(Object.keys(result).length === 6763);\n}; // Given the rows of the locale-character map from the cjklib data, returns a\n// mapping from characters to the appropriate glyph in that locale.\n\n\nconst parseLocaleGlyphMap = (locale, rows) => {\n  const result = {};\n  rows.filter(row => row[2].indexOf(locale) >= 0).map(row => result[row[0]] = parseInt(row[1], 10));\n  return result;\n}; // Methods used for final post-processing of the loaded datasets.\n\n\nconst cleanupCJKLibData = () => {\n  const characters = cjklib.characters;\n  const radicals = cjklib.radicals;\n\n  const convert_astral_characters = x => x.length === 1 ? x : '？';\n\n  const radical_to_character = x => radicals.radical_to_character_map[x] || x;\n\n  Object.keys(characters.decomposition).map(character => {\n    // Convert any 'astral characters' - that is, characters outside the Basic\n    // Multilingual Plane - to wide question marks and replace radicals with an\n    // equivalent character with that character.\n    const decomposition = characters.decomposition[character];\n    characters.decomposition[character] = Array.from(decomposition).map(convert_astral_characters).map(radical_to_character).join('');\n  });\n\n  for (let i = 1; i <= 214; i++) {\n    // All primary radicals should have an equivalent character form.\n    const primary = radicals.primary_radical[i];\n    assert(radicals.radical_to_character_map.hasOwnProperty(primary));\n    radicals.primary_radical[i] = radicals.radical_to_character_map[primary];\n    radicals.index_to_radical_map[i] = radicals.index_to_radical_map[i].map(radical_to_character).unique();\n  }\n\n  Object.keys(radicals.radical_to_index_map).map(radical => {\n    const character = radical_to_character(radical);\n\n    if (character !== radical) {\n      radicals.radical_to_index_map[character] = radicals.radical_to_index_map[radical];\n      delete radicals.radical_to_index_map[radical];\n    }\n  });\n  delete radicals.radical_to_character_map;\n};\n\nMeteor.startup(() => {\n  // cjklib database data.\n  const locale = 'C';\n  const decomposition = readFile('cjklib/characterdecomposition.csv').then(getCJKLibRows);\n  const glyphs = readFile('cjklib/localecharacterglyph.csv').then(getCJKLibRows).then(parseLocaleGlyphMap.bind(null, locale));\n  const radicals = readFile('cjklib/kangxiradical.csv').then(getCJKLibRows);\n  const radical_equivalent_characters = readFile('cjklib/radicalequivalentcharacter.csv').then(getCJKLibRows);\n  const radical_isolated_characters = readFile('cjklib/kangxiradicalisolatedcharacter.csv').then(getCJKLibRows); // Jun Da's character frequency data, used only for prioritization.\n\n  const frequencies = readFile('junda/character_frequency.tsv').then(getFrequencyRows); // Unihan database data.\n\n  const dictionary_like_data = readFile('unihan/Unihan_DictionaryLikeData.txt').then(getUnihanRows);\n  const radical_stroke_counts = readFile('unihan/Unihan_RadicalStrokeCounts.txt').then(getUnihanRows);\n  const readings = readFile('unihan/Unihan_Readings.txt').then(getUnihanRows);\n  const variants = readFile('unihan/Unihan_Variants.txt').then(getUnihanRows);\n  cjklib.promise = Promise.all([// Per-character data.\n  fillDecompositions(decomposition, glyphs, cjklib.characters.decomposition), fillDefinitions(readings, cjklib.characters.definition), fillFrequencies(frequencies, cjklib.characters.frequency), fillKangxiIndex(radical_stroke_counts, cjklib.characters.kangxi_index), fillPinyin(readings, cjklib.characters.pinyin), fillStrokeCounts(dictionary_like_data, cjklib.characters.strokes), // Per-radical data.\n  fillRadicalData(locale, radicals, cjklib.radicals), fillRadicalData(locale, radical_isolated_characters, cjklib.radicals), fillRadicalToCharacterMap(locale, radical_equivalent_characters, cjklib.radicals.radical_to_character_map), fillVariants(cjklib.characters.simplified, cjklib.characters.traditional, variants), // Extract the list of characters in the GB2312 character set.\n  readFile('gb2312').then(data => fillGB2312(data, cjklib.gb2312))]).then(cleanupCJKLibData);\n  cjklib.promise.catch(console.error.bind(console));\n});","map":{"version":3,"sources":["lib/cjklib.js"],"names":["module","export","cjklib","assert","getPWD","maybeRequire","link","v","fs","path","CHARACTER_FIELDS","characters","gb2312","promise","undefined","radicals","primary_radical","index_to_radical_map","radical_to_index_map","radical_to_character_map","getCharacterData","character","result","map","field","traditional","getCJKLibRows","data","lines","split","filter","line","length","entry","replace","getFrequencyRows","getUnihanRows","parseUnicodeStr","str","String","fromCodePoint","parseInt","substr","readFile","filename","Promise","resolve","reject","Meteor","isServer","filepath","join","error","$","get","code","Error","fillDecompositions","decompositions","glyphs","all","then","rows","row","fillDefinitions","readings","fillFrequencies","fillKangxiIndex","getIndex","adotb","x","fillPinyin","fillStrokeCounts","dictionary_like_data","fillRadicalData","locale","hasOwnProperty","push","indexOf","fillRadicalToCharacterMap","radical_equivalent_characters","fillVariants","simplified","variants","source","target","swap","_","unique","concat","fillGB2312","Array","from","codepoint","codePointAt","Object","keys","parseLocaleGlyphMap","cleanupCJKLibData","convert_astral_characters","radical_to_character","decomposition","i","primary","radical","startup","bind","radical_isolated_characters","frequencies","radical_stroke_counts","definition","frequency","kangxi_index","pinyin","strokes","catch","console"],"mappings":"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","sourcesContent":["import {assert, getPWD, maybeRequire} from '/lib/base';\n\nconst fs = maybeRequire('fs');\nconst path = maybeRequire('path');\n\nconst CHARACTER_FIELDS = ['character', 'decomposition', 'definition',\n                          'frequency', 'kangxi_index', 'pinyin',\n                          'simplified', 'strokes', 'traditional'];\n\nconst cjklib = {\n  characters: {},\n  gb2312: {},\n  promise: undefined,\n  radicals: {\n    primary_radical: {},\n    index_to_radical_map: {},\n    radical_to_index_map: {},\n    radical_to_character_map: {},\n  },\n  getCharacterData(character) {\n    const result = {};\n    CHARACTER_FIELDS.map((field) =>\n        result[field] = cjklib.characters[field][character]);\n    result.character = character;\n    result.traditional = result.traditional || [];\n    return result;\n  },\n};\n\nCHARACTER_FIELDS.map((field) => cjklib.characters[field] = {});\n\n// Input: String contents of a cjklib data file.\n// Output: a list of rows, each of which is a list of String columns.\nconst getCJKLibRows = (data) => {\n  const lines = data.split('\\n');\n  return lines.filter((line) => line.length > 0 && line[0] !== '#')\n              .map((line) => line.split(',').map(\n                  (entry) => entry.replace(/[\"']/g, '')));\n}\n\n// Input: String contents of a TSV data file.\n// Output: a list of rows, each of which is a list of String columns.\nconst getFrequencyRows = (data) => {\n  const lines = data.split('\\n');\n  return lines.filter((line) => line.length > 0 && line[0] !== '#')\n              .map((line) => line.split('\\t'));\n}\n\n// Input: String contents of a Unihan data file.\n// Output: a list of rows, each of which is a list of String columns.\nconst getUnihanRows = (data) => {\n  const lines = data.split('\\n');\n  return lines.filter((line) => line.length > 0 && line[0] !== '#')\n              .map((line) => line.split('\\t'));\n}\n\n// Input: a String of the form 'U+<hex>' representing a Unicode codepoint.\n// Output: the character at that codepoint\nconst parseUnicodeStr =\n    (str) => String.fromCodePoint(parseInt(str.substr(2), 16));\n\n// Input: the path to a Unihan data file, starting from the public directory.\n// Output: Promise that resolves to the String contents of that file.\nconst readFile = (filename) => new Promise((resolve, reject) => {\n  if (Meteor.isServer) {\n    const filepath = path.join(getPWD(), 'public', filename);\n    fs.readFile(filepath, 'utf8', (error, data) => {\n      if (error) throw error;\n      resolve(data);\n    });\n  } else {\n    $.get(filename, (data, code) => {\n      if (code !== 'success') throw new Error(code);\n      resolve(data);\n    });\n  }\n});\n\n// Promises that fill data from specific tables.\n\n// Output: Promise that fills result with a mapping character -> decomposition.\n// The decompositions are formatted using Ideographic Description Sequence\n// symbols - see the Unicode standard for more details.\nconst fillDecompositions = (decompositions, glyphs, result) => {\n  return Promise.all([decompositions, glyphs]).then(([rows, glyphs]) => {\n    rows.filter((row) => parseInt(row[2], 10) === (glyphs[row[0]] || 0))\n        .map((row) => result[row[0]] = row[1]);\n  });\n}\n\n// Output: Promise that fills result with a mapping character -> Pinyin.\nconst fillDefinitions = (readings, result) => {\n  return readings.then((rows) => {\n    rows.filter((row) => row[1] === 'kDefinition')\n        .map((row) => result[parseUnicodeStr(row[0])] = row[2]);\n  });\n}\n\n// Output: Promise that fills result with a mapping character -> frequency rank.\nconst fillFrequencies = (readings, result) => {\n  return readings.then((rows) => {\n    rows.map((row) => result[row[1]] = parseInt(row[0], 10));\n  });\n}\n\n// Output: Promise that fills result with a mapping character -> Kangxi radical-\n// stroke count, which is a pair of integers [radical, extra_strokes].\nconst fillKangxiIndex = (readings, result) => {\n  return readings.then((rows) => {\n    const getIndex = (adotb) => adotb.split('.').map((x) => parseInt(x, 10));\n    rows.filter((row) => row[1] === 'kRSKangXi')\n        .map((row) => result[parseUnicodeStr(row[0])] = getIndex(row[2]));\n  });\n}\n\n// Output: Promise that fills result with a mapping character -> Pinyin.\nconst fillPinyin = (readings, result) => {\n  return readings.then((rows) => {\n    rows.filter((row) => row[1] === 'kMandarin')\n        .map((row) => result[parseUnicodeStr(row[0])] = row[2]);\n  });\n}\n\n// Output: Promise that fills result with a mapping character -> stroke count.\nconst fillStrokeCounts = (dictionary_like_data, result) => {\n  return dictionary_like_data.then((rows) => {\n    rows.filter((row) => row[1] === 'kTotalStrokes')\n        .map((row) => result[parseUnicodeStr(row[0])] = parseInt(row[2], 10));\n  });\n}\n\n// Output: Promise that fills multiple dictionaries in the result:\n//   - index_to_radical_map: Map from index -> list of radicals at that index\n//   - radical_to_index_map: Map from radical -> index of that radical\n//   - primary_radical: Map from index -> primary radical at that index\nconst fillRadicalData = (locale, radicals, result) => {\n  return radicals.then((rows) => {\n    rows.map((row) => {\n      if (!result.index_to_radical_map.hasOwnProperty(row[0])) {\n        result.index_to_radical_map[row[0]] = [];\n      }\n      result.index_to_radical_map[row[0]].push(row[1]);\n      result.radical_to_index_map[row[1]] = row[0];\n      if (row[2] === 'R' && row[3].indexOf(locale) >= 0) {\n        result.primary_radical[row[0]] = row[1];\n      }\n    });\n  });\n}\n\n// Output: Promise that fills result with a map from Unicode radical-codeblock\n// character -> equivalent Unicode CJK-codeblock (hopefully, GB2312) character.\n// There may be Unicode radical characters without a CJK equivalent.\nconst fillRadicalToCharacterMap =\n    (locale, radical_equivalent_characters, result) => {\n  return radical_equivalent_characters.then((rows) => {\n    rows.filter((row) => row[2].indexOf(locale) >= 0)\n        .map((row) => result[row[0]] = row[1]);\n  });\n}\n\n// Output: Promise that fills the two maps with pointers from a given character\n// to its simplified and traditional variants.\nconst fillVariants = (simplified, traditional, variants) => {\n  return variants.then((rows) => {\n    rows.map((row) => {\n      if ((row[1] !== 'kSimplifiedVariant' &&\n           row[1] !== 'kTraditionalVariant') ||\n          row[0] === row[2] || row[0] === 'U+2B5B8') {\n        // Unicode introduced an extra character U+2B5B8 matching U+613F.\n        return;\n      }\n      let source = parseUnicodeStr(row[0]);\n      let target = parseUnicodeStr(row[2]);\n      const split = row[2].split(' ');\n      // A number of characters have multiple simplified variants. Of these,\n      // we should only use one of them, usually the first, but in three cases,\n      // the second.\n      if (split.length === 2 &&\n          ['U+937E', 'U+949F', 'U+9918'].indexOf(row[0]) >= 0) {\n        target = parseUnicodeStr(split[1]);\n      }\n      if (source === target) {\n        return;\n      } else if (row[1] === 'kTraditionalVariant') {\n        const swap = target;\n        target = source;\n        source = swap;\n      }\n      // The mapping from traditional characters to simplified characters is\n      // many to one, so we can only assert that simplified[source] is unique.\n      assert(!simplified[source] || simplified[source] === target);\n      simplified[source] = target;\n      traditional[target] = _.unique(\n          (traditional[target] || []).concat([source]));\n    });\n  });\n}\n\n// Given the data from the GB2312 data file, fills the GB2312 result map.\nconst fillGB2312 = (data, result) => {\n  Array.from(data).map((character) => {\n    if (character === '\\n') return;\n    assert(character.length === 1);\n    const codepoint = character.codePointAt(0);\n    assert(0x4e00 <= codepoint && codepoint <= 0x9fff);\n    result[character] = true;\n  });\n  assert(Object.keys(result).length === 6763);\n}\n\n// Given the rows of the locale-character map from the cjklib data, returns a\n// mapping from characters to the appropriate glyph in that locale.\nconst parseLocaleGlyphMap = (locale, rows) => {\n  const result = {};\n  rows.filter((row) => row[2].indexOf(locale) >= 0)\n      .map((row) => result[row[0]] = parseInt(row[1], 10));\n  return result;\n}\n\n// Methods used for final post-processing of the loaded datasets.\n\nconst cleanupCJKLibData = () => {\n  const characters = cjklib.characters;\n  const radicals = cjklib.radicals;\n  const convert_astral_characters = (x) => x.length === 1 ? x : '？'\n  const radical_to_character = (x) => radicals.radical_to_character_map[x] || x;\n  Object.keys(characters.decomposition).map((character) => {\n    // Convert any 'astral characters' - that is, characters outside the Basic\n    // Multilingual Plane - to wide question marks and replace radicals with an\n    // equivalent character with that character.\n    const decomposition = characters.decomposition[character];\n    characters.decomposition[character] =\n        Array.from(decomposition).map(convert_astral_characters)\n                                 .map(radical_to_character).join('');\n  });\n  for (let i = 1; i <= 214; i++) {\n    // All primary radicals should have an equivalent character form.\n    const primary = radicals.primary_radical[i];\n    assert(radicals.radical_to_character_map.hasOwnProperty(primary));\n    radicals.primary_radical[i] = radicals.radical_to_character_map[primary];\n    radicals.index_to_radical_map[i] =\n        radicals.index_to_radical_map[i].map(radical_to_character).unique();\n  }\n  Object.keys(radicals.radical_to_index_map).map((radical) => {\n    const character = radical_to_character(radical);\n    if (character !== radical) {\n      radicals.radical_to_index_map[character] =\n          radicals.radical_to_index_map[radical];\n      delete radicals.radical_to_index_map[radical];\n    }\n  });\n  delete radicals.radical_to_character_map;\n}\n\nMeteor.startup(() => {\n  // cjklib database data.\n  const locale = 'C';\n  const decomposition =\n      readFile('cjklib/characterdecomposition.csv').then(getCJKLibRows);\n  const glyphs = readFile('cjklib/localecharacterglyph.csv')\n                     .then(getCJKLibRows)\n                     .then(parseLocaleGlyphMap.bind(null, locale));\n  const radicals = readFile('cjklib/kangxiradical.csv').then(getCJKLibRows);\n  const radical_equivalent_characters =\n      readFile('cjklib/radicalequivalentcharacter.csv').then(getCJKLibRows);\n  const radical_isolated_characters =\n      readFile('cjklib/kangxiradicalisolatedcharacter.csv').then(getCJKLibRows);\n\n  // Jun Da's character frequency data, used only for prioritization.\n  const frequencies = readFile('junda/character_frequency.tsv')\n                          .then(getFrequencyRows);\n\n  // Unihan database data.\n  const dictionary_like_data =\n      readFile('unihan/Unihan_DictionaryLikeData.txt').then(getUnihanRows);\n  const radical_stroke_counts =\n      readFile('unihan/Unihan_RadicalStrokeCounts.txt').then(getUnihanRows);\n  const readings = readFile('unihan/Unihan_Readings.txt').then(getUnihanRows);\n  const variants = readFile('unihan/Unihan_Variants.txt').then(getUnihanRows);\n\n  cjklib.promise = Promise.all([\n      // Per-character data.\n      fillDecompositions(decomposition, glyphs,\n                         cjklib.characters.decomposition),\n      fillDefinitions(readings, cjklib.characters.definition),\n      fillFrequencies(frequencies, cjklib.characters.frequency),\n      fillKangxiIndex(radical_stroke_counts, cjklib.characters.kangxi_index),\n      fillPinyin(readings, cjklib.characters.pinyin),\n      fillStrokeCounts(dictionary_like_data, cjklib.characters.strokes),\n      // Per-radical data.\n      fillRadicalData(locale, radicals, cjklib.radicals),\n      fillRadicalData(locale, radical_isolated_characters, cjklib.radicals),\n      fillRadicalToCharacterMap(locale, radical_equivalent_characters,\n                                cjklib.radicals.radical_to_character_map),\n      fillVariants(cjklib.characters.simplified,\n                   cjklib.characters.traditional, variants),\n      // Extract the list of characters in the GB2312 character set.\n      readFile('gb2312').then((data) => fillGB2312(data, cjklib.gb2312)),\n  ]).then(cleanupCJKLibData);\n  cjklib.promise.catch(console.error.bind(console));\n});\n\nexport {cjklib};\n"]},"sourceType":"module","externalDependencies":{},"hash":"3446c662869da4d67c212db4a8b03a2aacc30798"}
