[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar HTML = Package.htmljs.HTML;\nvar meteorInstall = Package.modules.meteorInstall;\nvar meteorBabelHelpers = Package.modules.meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\nvar Symbol = Package['ecmascript-runtime-client'].Symbol;\nvar Map = Package['ecmascript-runtime-client'].Map;\nvar Set = Package['ecmascript-runtime-client'].Set;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"spacebars-compiler\":{\"preamble.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/spacebars-compiler/preamble.js                                                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  SpacebarsCompiler: function () {\n    return SpacebarsCompiler;\n  }\n});\nvar CodeGen, builtInBlockHelpers, isReservedName;\nmodule.link(\"./codegen\", {\n  CodeGen: function (v) {\n    CodeGen = v;\n  },\n  builtInBlockHelpers: function (v) {\n    builtInBlockHelpers = v;\n  },\n  isReservedName: function (v) {\n    isReservedName = v;\n  }\n}, 0);\nvar optimize;\nmodule.link(\"./optimizer\", {\n  optimize: function (v) {\n    optimize = v;\n  }\n}, 1);\nvar parse, compile, codeGen, TemplateTagReplacer, beautify;\nmodule.link(\"./compiler\", {\n  parse: function (v) {\n    parse = v;\n  },\n  compile: function (v) {\n    compile = v;\n  },\n  codeGen: function (v) {\n    codeGen = v;\n  },\n  TemplateTagReplacer: function (v) {\n    TemplateTagReplacer = v;\n  },\n  beautify: function (v) {\n    beautify = v;\n  }\n}, 2);\nvar TemplateTag;\nmodule.link(\"./templatetag\", {\n  TemplateTag: function (v) {\n    TemplateTag = v;\n  }\n}, 3);\nvar SpacebarsCompiler = {\n  CodeGen: CodeGen,\n  _builtInBlockHelpers: builtInBlockHelpers,\n  isReservedName: isReservedName,\n  optimize: optimize,\n  parse: parse,\n  compile: compile,\n  codeGen: codeGen,\n  _TemplateTagReplacer: TemplateTagReplacer,\n  _beautify: beautify,\n  TemplateTag: TemplateTag\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"codegen.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/spacebars-compiler/codegen.js                                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  CodeGen: function () {\n    return CodeGen;\n  },\n  builtInBlockHelpers: function () {\n    return builtInBlockHelpers;\n  },\n  isReservedName: function () {\n    return isReservedName;\n  }\n});\nvar HTMLTools;\nmodule.link(\"meteor/html-tools\", {\n  HTMLTools: function (v) {\n    HTMLTools = v;\n  }\n}, 0);\nvar HTML;\nmodule.link(\"meteor/htmljs\", {\n  HTML: function (v) {\n    HTML = v;\n  }\n}, 1);\nvar BlazeTools;\nmodule.link(\"meteor/blaze-tools\", {\n  BlazeTools: function (v) {\n    BlazeTools = v;\n  }\n}, 2);\nvar codeGen;\nmodule.link(\"./compiler\", {\n  codeGen: function (v) {\n    codeGen = v;\n  }\n}, 3);\n\nfunction CodeGen() {}\n\nvar builtInBlockHelpers = {\n  'if': 'Blaze.If',\n  'unless': 'Blaze.Unless',\n  'with': 'Spacebars.With',\n  'each': 'Blaze.Each',\n  'let': 'Blaze.Let'\n};\n// Mapping of \"macros\" which, when preceded by `Template.`, expand\n// to special code rather than following the lookup rules for dotted\n// symbols.\nvar builtInTemplateMacros = {\n  // `view` is a local variable defined in the generated render\n  // function for the template in which `Template.contentBlock` or\n  // `Template.elseBlock` is invoked.\n  'contentBlock': 'view.templateContentBlock',\n  'elseBlock': 'view.templateElseBlock',\n  // Confusingly, this makes `{{> Template.dynamic}}` an alias\n  // for `{{> __dynamic}}`, where \"__dynamic\" is the template that\n  // implements the dynamic template feature.\n  'dynamic': 'Template.__dynamic',\n  'subscriptionsReady': 'view.templateInstance().subscriptionsReady()'\n};\nvar additionalReservedNames = [\"body\", \"toString\", \"instance\", \"constructor\", \"toString\", \"toLocaleString\", \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"__defineGetter__\", \"__lookupGetter__\", \"__defineSetter__\", \"__lookupSetter__\", \"__proto__\", \"dynamic\", \"registerHelper\", \"currentData\", \"parentData\", \"_migrateTemplate\", \"_applyHmrChanges\", \"__pendingReplacement\"]; // A \"reserved name\" can't be used as a <template> name.  This\n// function is used by the template file scanner.\n//\n// Note that the runtime imposes additional restrictions, for example\n// banning the name \"body\" and names of built-in object properties\n// like \"toString\".\n\nfunction isReservedName(name) {\n  return builtInBlockHelpers.hasOwnProperty(name) || builtInTemplateMacros.hasOwnProperty(name) || _.indexOf(additionalReservedNames, name) > -1;\n}\n\nvar makeObjectLiteral = function (obj) {\n  var parts = [];\n\n  for (var k in meteorBabelHelpers.sanitizeForInObject(obj)) {\n    parts.push(BlazeTools.toObjectLiteralKey(k) + ': ' + obj[k]);\n  }\n\n  return '{' + parts.join(', ') + '}';\n};\n\n_.extend(CodeGen.prototype, {\n  codeGenTemplateTag: function (tag) {\n    var self = this;\n\n    if (tag.position === HTMLTools.TEMPLATE_TAG_POSITION.IN_START_TAG) {\n      // Special dynamic attributes: `<div {{attrs}}>...`\n      // only `tag.type === 'DOUBLE'` allowed (by earlier validation)\n      return BlazeTools.EmitCode('function () { return ' + self.codeGenMustache(tag.path, tag.args, 'attrMustache') + '; }');\n    } else {\n      if (tag.type === 'DOUBLE' || tag.type === 'TRIPLE') {\n        var code = self.codeGenMustache(tag.path, tag.args);\n\n        if (tag.type === 'TRIPLE') {\n          code = 'Spacebars.makeRaw(' + code + ')';\n        }\n\n        if (tag.position !== HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n          // Reactive attributes are already wrapped in a function,\n          // and there's no fine-grained reactivity.\n          // Anywhere else, we need to create a View.\n          code = 'Blaze.View(' + BlazeTools.toJSLiteral('lookup:' + tag.path.join('.')) + ', ' + 'function () { return ' + code + '; })';\n        }\n\n        return BlazeTools.EmitCode(code);\n      } else if (tag.type === 'INCLUSION' || tag.type === 'BLOCKOPEN') {\n        var path = tag.path;\n        var args = tag.args;\n\n        if (tag.type === 'BLOCKOPEN' && builtInBlockHelpers.hasOwnProperty(path[0])) {\n          // if, unless, with, each.\n          //\n          // If someone tries to do `{{> if}}`, we don't\n          // get here, but an error is thrown when we try to codegen the path.\n          // Note: If we caught these errors earlier, while scanning, we'd be able to\n          // provide nice line numbers.\n          if (path.length > 1) throw new Error(\"Unexpected dotted path beginning with \" + path[0]);\n          if (!args.length) throw new Error(\"#\" + path[0] + \" requires an argument\");\n          var dataCode = null; // #each has a special treatment as it features two different forms:\n          // - {{#each people}}\n          // - {{#each person in people}}\n\n          if (path[0] === 'each' && args.length >= 2 && args[1][0] === 'PATH' && args[1][1].length && args[1][1][0] === 'in') {\n            // minimum conditions are met for each-in.  now validate this\n            // isn't some weird case.\n            var eachUsage = \"Use either {{#each items}} or \" + \"{{#each item in items}} form of #each.\";\n            var inArg = args[1];\n\n            if (!(args.length >= 3 && inArg[1].length === 1)) {\n              // we don't have at least 3 space-separated parts after #each, or\n              // inArg doesn't look like ['PATH',['in']]\n              throw new Error(\"Malformed #each. \" + eachUsage);\n            } // split out the variable name and sequence arguments\n\n\n            var variableArg = args[0];\n\n            if (!(variableArg[0] === \"PATH\" && variableArg[1].length === 1 && variableArg[1][0].replace(/\\./g, ''))) {\n              throw new Error(\"Bad variable name in #each\");\n            }\n\n            var variable = variableArg[1][0];\n            dataCode = 'function () { return { _sequence: ' + self.codeGenInclusionData(args.slice(2)) + ', _variable: ' + BlazeTools.toJSLiteral(variable) + ' }; }';\n          } else if (path[0] === 'let') {\n            var dataProps = {};\n\n            _.each(args, function (arg) {\n              if (arg.length !== 3) {\n                // not a keyword arg (x=y)\n                throw new Error(\"Incorrect form of #let\");\n              }\n\n              var argKey = arg[2];\n              dataProps[argKey] = 'function () { return Spacebars.call(' + self.codeGenArgValue(arg) + '); }';\n            });\n\n            dataCode = makeObjectLiteral(dataProps);\n          }\n\n          if (!dataCode) {\n            // `args` must exist (tag.args.length > 0)\n            dataCode = self.codeGenInclusionDataFunc(args) || 'null';\n          } // `content` must exist\n\n\n          var contentBlock = 'content' in tag ? self.codeGenBlock(tag.content) : null; // `elseContent` may not exist\n\n          var elseContentBlock = 'elseContent' in tag ? self.codeGenBlock(tag.elseContent) : null;\n          var callArgs = [dataCode, contentBlock];\n          if (elseContentBlock) callArgs.push(elseContentBlock);\n          return BlazeTools.EmitCode(builtInBlockHelpers[path[0]] + '(' + callArgs.join(', ') + ')');\n        } else {\n          var compCode = self.codeGenPath(path, {\n            lookupTemplate: true\n          });\n\n          if (path.length > 1) {\n            // capture reactivity\n            compCode = 'function () { return Spacebars.call(' + compCode + '); }';\n          }\n\n          var dataCode = self.codeGenInclusionDataFunc(tag.args);\n          var content = 'content' in tag ? self.codeGenBlock(tag.content) : null;\n          var elseContent = 'elseContent' in tag ? self.codeGenBlock(tag.elseContent) : null;\n          var includeArgs = [compCode];\n\n          if (content) {\n            includeArgs.push(content);\n            if (elseContent) includeArgs.push(elseContent);\n          }\n\n          var includeCode = 'Spacebars.include(' + includeArgs.join(', ') + ')'; // calling convention compat -- set the data context around the\n          // entire inclusion, so that if the name of the inclusion is\n          // a helper function, it gets the data context in `this`.\n          // This makes for a pretty confusing calling convention --\n          // In `{{#foo bar}}`, `foo` is evaluated in the context of `bar`\n          // -- but it's what we shipped for 0.8.0.  The rationale is that\n          // `{{#foo bar}}` is sugar for `{{#with bar}}{{#foo}}...`.\n\n          if (dataCode) {\n            includeCode = 'Blaze._TemplateWith(' + dataCode + ', function () { return ' + includeCode + '; })';\n          } // XXX BACK COMPAT - UI is the old name, Template is the new\n\n\n          if ((path[0] === 'UI' || path[0] === 'Template') && (path[1] === 'contentBlock' || path[1] === 'elseBlock')) {\n            // Call contentBlock and elseBlock in the appropriate scope\n            includeCode = 'Blaze._InOuterTemplateScope(view, function () { return ' + includeCode + '; })';\n          }\n\n          return BlazeTools.EmitCode(includeCode);\n        }\n      } else if (tag.type === 'ESCAPE') {\n        return tag.value;\n      } else {\n        // Can't get here; TemplateTag validation should catch any\n        // inappropriate tag types that might come out of the parser.\n        throw new Error(\"Unexpected template tag type: \" + tag.type);\n      }\n    }\n  },\n  // `path` is an array of at least one string.\n  //\n  // If `path.length > 1`, the generated code may be reactive\n  // (i.e. it may invalidate the current computation).\n  //\n  // No code is generated to call the result if it's a function.\n  //\n  // Options:\n  //\n  // - lookupTemplate {Boolean} If true, generated code also looks in\n  //   the list of templates. (After helpers, before data context).\n  //   Used when generating code for `{{> foo}}` or `{{#foo}}`. Only\n  //   used for non-dotted paths.\n  codeGenPath: function (path, opts) {\n    if (builtInBlockHelpers.hasOwnProperty(path[0])) throw new Error(\"Can't use the built-in '\" + path[0] + \"' here\"); // Let `{{#if Template.contentBlock}}` check whether this template was\n    // invoked via inclusion or as a block helper, in addition to supporting\n    // `{{> Template.contentBlock}}`.\n    // XXX BACK COMPAT - UI is the old name, Template is the new\n\n    if (path.length >= 2 && (path[0] === 'UI' || path[0] === 'Template') && builtInTemplateMacros.hasOwnProperty(path[1])) {\n      if (path.length > 2) throw new Error(\"Unexpected dotted path beginning with \" + path[0] + '.' + path[1]);\n      return builtInTemplateMacros[path[1]];\n    }\n\n    var firstPathItem = BlazeTools.toJSLiteral(path[0]);\n    var lookupMethod = 'lookup';\n    if (opts && opts.lookupTemplate && path.length === 1) lookupMethod = 'lookupTemplate';\n    var code = 'view.' + lookupMethod + '(' + firstPathItem + ')';\n\n    if (path.length > 1) {\n      code = 'Spacebars.dot(' + code + ', ' + _.map(path.slice(1), BlazeTools.toJSLiteral).join(', ') + ')';\n    }\n\n    return code;\n  },\n  // Generates code for an `[argType, argValue]` argument spec,\n  // ignoring the third element (keyword argument name) if present.\n  //\n  // The resulting code may be reactive (in the case of a PATH of\n  // more than one element) and is not wrapped in a closure.\n  codeGenArgValue: function (arg) {\n    var self = this;\n    var argType = arg[0];\n    var argValue = arg[1];\n    var argCode;\n\n    switch (argType) {\n      case 'STRING':\n      case 'NUMBER':\n      case 'BOOLEAN':\n      case 'NULL':\n        argCode = BlazeTools.toJSLiteral(argValue);\n        break;\n\n      case 'PATH':\n        argCode = self.codeGenPath(argValue);\n        break;\n\n      case 'EXPR':\n        // The format of EXPR is ['EXPR', { type: 'EXPR', path: [...], args: { ... } }]\n        argCode = self.codeGenMustache(argValue.path, argValue.args, 'dataMustache');\n        break;\n\n      default:\n        // can't get here\n        throw new Error(\"Unexpected arg type: \" + argType);\n    }\n\n    return argCode;\n  },\n  // Generates a call to `Spacebars.fooMustache` on evaluated arguments.\n  // The resulting code has no function literals and must be wrapped in\n  // one for fine-grained reactivity.\n  codeGenMustache: function (path, args, mustacheType) {\n    var self = this;\n    var nameCode = self.codeGenPath(path);\n    var argCode = self.codeGenMustacheArgs(args);\n    var mustache = mustacheType || 'mustache';\n    return 'Spacebars.' + mustache + '(' + nameCode + (argCode ? ', ' + argCode.join(', ') : '') + ')';\n  },\n  // returns: array of source strings, or null if no\n  // args at all.\n  codeGenMustacheArgs: function (tagArgs) {\n    var self = this;\n    var kwArgs = null; // source -> source\n\n    var args = null; // [source]\n    // tagArgs may be null\n\n    _.each(tagArgs, function (arg) {\n      var argCode = self.codeGenArgValue(arg);\n\n      if (arg.length > 2) {\n        // keyword argument (represented as [type, value, name])\n        kwArgs = kwArgs || {};\n        kwArgs[arg[2]] = argCode;\n      } else {\n        // positional argument\n        args = args || [];\n        args.push(argCode);\n      }\n    }); // put kwArgs in options dictionary at end of args\n\n\n    if (kwArgs) {\n      args = args || [];\n      args.push('Spacebars.kw(' + makeObjectLiteral(kwArgs) + ')');\n    }\n\n    return args;\n  },\n  codeGenBlock: function (content) {\n    return codeGen(content);\n  },\n  codeGenInclusionData: function (args) {\n    var self = this;\n\n    if (!args.length) {\n      // e.g. `{{#foo}}`\n      return null;\n    } else if (args[0].length === 3) {\n      // keyword arguments only, e.g. `{{> point x=1 y=2}}`\n      var dataProps = {};\n\n      _.each(args, function (arg) {\n        var argKey = arg[2];\n        dataProps[argKey] = 'Spacebars.call(' + self.codeGenArgValue(arg) + ')';\n      });\n\n      return makeObjectLiteral(dataProps);\n    } else if (args[0][0] !== 'PATH') {\n      // literal first argument, e.g. `{{> foo \"blah\"}}`\n      //\n      // tag validation has confirmed, in this case, that there is only\n      // one argument (`args.length === 1`)\n      return self.codeGenArgValue(args[0]);\n    } else if (args.length === 1) {\n      // one argument, must be a PATH\n      return 'Spacebars.call(' + self.codeGenPath(args[0][1]) + ')';\n    } else {\n      // Multiple positional arguments; treat them as a nested\n      // \"data mustache\"\n      return self.codeGenMustache(args[0][1], args.slice(1), 'dataMustache');\n    }\n  },\n  codeGenInclusionDataFunc: function (args) {\n    var self = this;\n    var dataCode = self.codeGenInclusionData(args);\n\n    if (dataCode) {\n      return 'function () { return ' + dataCode + '; }';\n    } else {\n      return null;\n    }\n  }\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"compiler.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/spacebars-compiler/compiler.js                                                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  parse: function () {\n    return parse;\n  },\n  compile: function () {\n    return compile;\n  },\n  TemplateTagReplacer: function () {\n    return TemplateTagReplacer;\n  },\n  codeGen: function () {\n    return codeGen;\n  },\n  beautify: function () {\n    return beautify;\n  }\n});\nvar Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 0);\nvar HTMLTools;\nmodule.link(\"meteor/html-tools\", {\n  HTMLTools: function (v) {\n    HTMLTools = v;\n  }\n}, 1);\nvar HTML;\nmodule.link(\"meteor/htmljs\", {\n  HTML: function (v) {\n    HTML = v;\n  }\n}, 2);\nvar BlazeTools;\nmodule.link(\"meteor/blaze-tools\", {\n  BlazeTools: function (v) {\n    BlazeTools = v;\n  }\n}, 3);\nvar CodeGen;\nmodule.link(\"./codegen\", {\n  CodeGen: function (v) {\n    CodeGen = v;\n  }\n}, 4);\nvar optimize;\nmodule.link(\"./optimizer\", {\n  optimize: function (v) {\n    optimize = v;\n  }\n}, 5);\nvar ReactComponentSiblingForbidder;\nmodule.link(\"./react\", {\n  ReactComponentSiblingForbidder: function (v) {\n    ReactComponentSiblingForbidder = v;\n  }\n}, 6);\nvar TemplateTag;\nmodule.link(\"./templatetag\", {\n  TemplateTag: function (v) {\n    TemplateTag = v;\n  }\n}, 7);\nvar removeWhitespace;\nmodule.link(\"./whitespace\", {\n  removeWhitespace: function (v) {\n    removeWhitespace = v;\n  }\n}, 8);\nvar UglifyJSMinify = null;\n\nif (Meteor.isServer) {\n  UglifyJSMinify = Npm.require('uglify-js').minify;\n}\n\nfunction parse(input) {\n  return HTMLTools.parseFragment(input, {\n    getTemplateTag: TemplateTag.parseCompleteTag\n  });\n}\n\nfunction compile(input, options) {\n  var tree = parse(input);\n  return codeGen(tree, options);\n}\n\nvar TemplateTagReplacer = HTML.TransformingVisitor.extend();\nTemplateTagReplacer.def({\n  visitObject: function (x) {\n    if (x instanceof HTMLTools.TemplateTag) {\n      // Make sure all TemplateTags in attributes have the right\n      // `.position` set on them.  This is a bit of a hack\n      // (we shouldn't be mutating that here), but it allows\n      // cleaner codegen of \"synthetic\" attributes like TEXTAREA's\n      // \"value\", where the template tags were originally not\n      // in an attribute.\n      if (this.inAttributeValue) x.position = HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE;\n      return this.codegen.codeGenTemplateTag(x);\n    }\n\n    return HTML.TransformingVisitor.prototype.visitObject.call(this, x);\n  },\n  visitAttributes: function (attrs) {\n    if (attrs instanceof HTMLTools.TemplateTag) return this.codegen.codeGenTemplateTag(attrs); // call super (e.g. for case where `attrs` is an array)\n\n    return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);\n  },\n  visitAttribute: function (name, value, tag) {\n    this.inAttributeValue = true;\n    var result = this.visit(value);\n    this.inAttributeValue = false;\n\n    if (result !== value) {\n      // some template tags must have been replaced, because otherwise\n      // we try to keep things `===` when transforming.  Wrap the code\n      // in a function as per the rules.  You can't have\n      // `{id: Blaze.View(...)}` as an attributes dict because the View\n      // would be rendered more than once; you need to wrap it in a function\n      // so that it's a different View each time.\n      return BlazeTools.EmitCode(this.codegen.codeGenBlock(result));\n    }\n\n    return result;\n  }\n});\n\nfunction codeGen(parseTree, options) {\n  // is this a template, rather than a block passed to\n  // a block helper, say\n  var isTemplate = options && options.isTemplate;\n  var isBody = options && options.isBody;\n  var whitespace = options && options.whitespace;\n  var sourceName = options && options.sourceName;\n  var tree = parseTree; // The flags `isTemplate` and `isBody` are kind of a hack.\n\n  if (isTemplate || isBody) {\n    if (typeof whitespace === 'string' && whitespace.toLowerCase() === 'strip') {\n      tree = removeWhitespace(tree);\n    } // optimizing fragments would require being smarter about whether we are\n    // in a TEXTAREA, say.\n\n\n    tree = optimize(tree);\n  } // throws an error if using `{{> React}}` with siblings\n\n\n  new ReactComponentSiblingForbidder({\n    sourceName: sourceName\n  }).visit(tree);\n  var codegen = new CodeGen();\n  tree = new TemplateTagReplacer({\n    codegen: codegen\n  }).visit(tree);\n  var code = '(function () { ';\n\n  if (isTemplate || isBody) {\n    code += 'var view = this; ';\n  }\n\n  code += 'return ';\n  code += BlazeTools.toJS(tree);\n  code += '; })';\n  code = beautify(code);\n  return code;\n}\n\nfunction beautify(code) {\n  if (!UglifyJSMinify) {\n    return code;\n  }\n\n  var result = UglifyJSMinify(code, {\n    fromString: true,\n    mangle: false,\n    compress: false,\n    output: {\n      beautify: true,\n      indent_level: 2,\n      width: 80\n    }\n  });\n  var output = result.code; // Uglify interprets our expression as a statement and may add a semicolon.\n  // Strip trailing semicolon.\n\n  output = output.replace(/;$/, '');\n  return output;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"optimizer.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/spacebars-compiler/optimizer.js                                                                            //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar _typeof;\n\nmodule.link(\"@babel/runtime/helpers/typeof\", {\n  default: function (v) {\n    _typeof = v;\n  }\n}, 0);\nmodule.export({\n  toRaw: function () {\n    return toRaw;\n  },\n  TreeTransformer: function () {\n    return TreeTransformer;\n  },\n  optimize: function () {\n    return optimize;\n  }\n});\nvar HTMLTools;\nmodule.link(\"meteor/html-tools\", {\n  HTMLTools: function (v) {\n    HTMLTools = v;\n  }\n}, 0);\nvar HTML;\nmodule.link(\"meteor/htmljs\", {\n  HTML: function (v) {\n    HTML = v;\n  }\n}, 1);\n\n// Optimize parts of an HTMLjs tree into raw HTML strings when they don't\n// contain template tags.\nvar constant = function (value) {\n  return function () {\n    return value;\n  };\n};\n\nvar OPTIMIZABLE = {\n  NONE: 0,\n  PARTS: 1,\n  FULL: 2\n}; // We can only turn content into an HTML string if it contains no template\n// tags and no \"tricky\" HTML tags.  If we can optimize the entire content\n// into a string, we return OPTIMIZABLE.FULL.  If the we are given an\n// unoptimizable node, we return OPTIMIZABLE.NONE.  If we are given a tree\n// that contains an unoptimizable node somewhere, we return OPTIMIZABLE.PARTS.\n//\n// For example, we always create SVG elements programmatically, since SVG\n// doesn't have innerHTML.  If we are given an SVG element, we return NONE.\n// However, if we are given a big tree that contains SVG somewhere, we\n// return PARTS so that the optimizer can descend into the tree and optimize\n// other parts of it.\n\nvar CanOptimizeVisitor = HTML.Visitor.extend();\nCanOptimizeVisitor.def({\n  visitNull: constant(OPTIMIZABLE.FULL),\n  visitPrimitive: constant(OPTIMIZABLE.FULL),\n  visitComment: constant(OPTIMIZABLE.FULL),\n  visitCharRef: constant(OPTIMIZABLE.FULL),\n  visitRaw: constant(OPTIMIZABLE.FULL),\n  visitObject: constant(OPTIMIZABLE.NONE),\n  visitFunction: constant(OPTIMIZABLE.NONE),\n  visitArray: function (x) {\n    for (var i = 0; i < x.length; i++) {\n      if (this.visit(x[i]) !== OPTIMIZABLE.FULL) return OPTIMIZABLE.PARTS;\n    }\n\n    return OPTIMIZABLE.FULL;\n  },\n  visitTag: function (tag) {\n    var tagName = tag.tagName;\n\n    if (tagName === 'textarea') {\n      // optimizing into a TEXTAREA's RCDATA would require being a little\n      // more clever.\n      return OPTIMIZABLE.NONE;\n    } else if (tagName === 'script') {\n      // script tags don't work when rendered from strings\n      return OPTIMIZABLE.NONE;\n    } else if (!(HTML.isKnownElement(tagName) && !HTML.isKnownSVGElement(tagName))) {\n      // foreign elements like SVG can't be stringified for innerHTML.\n      return OPTIMIZABLE.NONE;\n    } else if (tagName === 'table') {\n      // Avoid ever producing HTML containing `<table><tr>...`, because the\n      // browser will insert a TBODY.  If we just `createElement(\"table\")` and\n      // `createElement(\"tr\")`, on the other hand, no TBODY is necessary\n      // (assuming IE 8+).\n      return OPTIMIZABLE.PARTS;\n    } else if (tagName === 'tr') {\n      return OPTIMIZABLE.PARTS;\n    }\n\n    var children = tag.children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (this.visit(children[i]) !== OPTIMIZABLE.FULL) return OPTIMIZABLE.PARTS;\n    }\n\n    if (this.visitAttributes(tag.attrs) !== OPTIMIZABLE.FULL) return OPTIMIZABLE.PARTS;\n    return OPTIMIZABLE.FULL;\n  },\n  visitAttributes: function (attrs) {\n    if (attrs) {\n      var isArray = HTML.isArray(attrs);\n\n      for (var i = 0; i < (isArray ? attrs.length : 1); i++) {\n        var a = isArray ? attrs[i] : attrs;\n        if (_typeof(a) !== 'object' || a instanceof HTMLTools.TemplateTag) return OPTIMIZABLE.PARTS;\n\n        for (var k in meteorBabelHelpers.sanitizeForInObject(a)) {\n          if (this.visit(a[k]) !== OPTIMIZABLE.FULL) return OPTIMIZABLE.PARTS;\n        }\n      }\n    }\n\n    return OPTIMIZABLE.FULL;\n  }\n});\n\nvar getOptimizability = function (content) {\n  return new CanOptimizeVisitor().visit(content);\n};\n\nfunction toRaw(x) {\n  return HTML.Raw(HTML.toHTML(x));\n}\n\nvar TreeTransformer = HTML.TransformingVisitor.extend();\nTreeTransformer.def({\n  visitAttributes: function (attrs\n  /*, ...*/\n  ) {\n    // pass template tags through by default\n    if (attrs instanceof HTMLTools.TemplateTag) return attrs;\n    return HTML.TransformingVisitor.prototype.visitAttributes.apply(this, arguments);\n  }\n}); // Replace parts of the HTMLjs tree that have no template tags (or\n// tricky HTML tags) with HTML.Raw objects containing raw HTML.\n\nvar OptimizingVisitor = TreeTransformer.extend();\nOptimizingVisitor.def({\n  visitNull: toRaw,\n  visitPrimitive: toRaw,\n  visitComment: toRaw,\n  visitCharRef: toRaw,\n  visitArray: function (array) {\n    var optimizability = getOptimizability(array);\n\n    if (optimizability === OPTIMIZABLE.FULL) {\n      return toRaw(array);\n    } else if (optimizability === OPTIMIZABLE.PARTS) {\n      return TreeTransformer.prototype.visitArray.call(this, array);\n    } else {\n      return array;\n    }\n  },\n  visitTag: function (tag) {\n    var optimizability = getOptimizability(tag);\n\n    if (optimizability === OPTIMIZABLE.FULL) {\n      return toRaw(tag);\n    } else if (optimizability === OPTIMIZABLE.PARTS) {\n      return TreeTransformer.prototype.visitTag.call(this, tag);\n    } else {\n      return tag;\n    }\n  },\n  visitChildren: function (children) {\n    // don't optimize the children array into a Raw object!\n    return TreeTransformer.prototype.visitArray.call(this, children);\n  },\n  visitAttributes: function (attrs) {\n    return attrs;\n  }\n}); // Combine consecutive HTML.Raws.  Remove empty ones.\n\nvar RawCompactingVisitor = TreeTransformer.extend();\nRawCompactingVisitor.def({\n  visitArray: function (array) {\n    var result = [];\n\n    for (var i = 0; i < array.length; i++) {\n      var item = array[i];\n\n      if (item instanceof HTML.Raw && (!item.value || result.length && result[result.length - 1] instanceof HTML.Raw)) {\n        // two cases: item is an empty Raw, or previous item is\n        // a Raw as well.  In the latter case, replace the previous\n        // Raw with a longer one that includes the new Raw.\n        if (item.value) {\n          result[result.length - 1] = HTML.Raw(result[result.length - 1].value + item.value);\n        }\n      } else {\n        result.push(this.visit(item));\n      }\n    }\n\n    return result;\n  }\n}); // Replace pointless Raws like `HTMl.Raw('foo')` that contain no special\n// characters with simple strings.\n\nvar RawReplacingVisitor = TreeTransformer.extend();\nRawReplacingVisitor.def({\n  visitRaw: function (raw) {\n    var html = raw.value;\n\n    if (html.indexOf('&') < 0 && html.indexOf('<') < 0) {\n      return html;\n    } else {\n      return raw;\n    }\n  }\n});\n\nfunction optimize(tree) {\n  tree = new OptimizingVisitor().visit(tree);\n  tree = new RawCompactingVisitor().visit(tree);\n  tree = new RawReplacingVisitor().visit(tree);\n  return tree;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"react.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/spacebars-compiler/react.js                                                                                //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  ReactComponentSiblingForbidder: function () {\n    return ReactComponentSiblingForbidder;\n  }\n});\nvar HTMLTools;\nmodule.link(\"meteor/html-tools\", {\n  HTMLTools: function (v) {\n    HTMLTools = v;\n  }\n}, 0);\nvar HTML;\nmodule.link(\"meteor/htmljs\", {\n  HTML: function (v) {\n    HTML = v;\n  }\n}, 1);\nvar BlazeTools;\nmodule.link(\"meteor/blaze-tools\", {\n  BlazeTools: function (v) {\n    BlazeTools = v;\n  }\n}, 2);\nvar ReactComponentSiblingForbidder = HTML.Visitor.extend();\nReactComponentSiblingForbidder.def({\n  visitArray: function (array, parentTag) {\n    for (var i = 0; i < array.length; i++) {\n      this.visit(array[i], parentTag);\n    }\n  },\n  visitObject: function (obj, parentTag) {\n    if (obj.type === \"INCLUSION\" && obj.path.length === 1 && obj.path[0] === \"React\") {\n      if (!parentTag) {\n        throw new Error(\"{{> React}} must be used in a container element\" + (this.sourceName ? \" in \" + this.sourceName : \"\") + \". Learn more at https://github.com/meteor/meteor/wiki/React-components-must-be-the-only-thing-in-their-wrapper-element\");\n      }\n\n      var numSiblings = 0;\n\n      for (var i = 0; i < parentTag.children.length; i++) {\n        var child = parentTag.children[i];\n\n        if (child !== obj && !(typeof child === \"string\" && child.match(/^\\s*$/))) {\n          numSiblings++;\n        }\n      }\n\n      if (numSiblings > 0) {\n        throw new Error(\"{{> React}} must be used as the only child in a container element\" + (this.sourceName ? \" in \" + this.sourceName : \"\") + \". Learn more at https://github.com/meteor/meteor/wiki/React-components-must-be-the-only-thing-in-their-wrapper-element\");\n      }\n    }\n  },\n  visitTag: function (tag) {\n    this.visitArray(tag.children, tag\n    /*parentTag*/\n    );\n  }\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"templatetag.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/spacebars-compiler/templatetag.js                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  TemplateTag: function () {\n    return TemplateTag;\n  }\n});\nvar HTMLTools;\nmodule.link(\"meteor/html-tools\", {\n  HTMLTools: function (v) {\n    HTMLTools = v;\n  }\n}, 0);\nvar HTML;\nmodule.link(\"meteor/htmljs\", {\n  HTML: function (v) {\n    HTML = v;\n  }\n}, 1);\nvar BlazeTools;\nmodule.link(\"meteor/blaze-tools\", {\n  BlazeTools: function (v) {\n    BlazeTools = v;\n  }\n}, 2);\n// A TemplateTag is the result of parsing a single `{{...}}` tag.\n//\n// The `.type` of a TemplateTag is one of:\n//\n// - `\"DOUBLE\"` - `{{foo}}`\n// - `\"TRIPLE\"` - `{{{foo}}}`\n// - `\"EXPR\"` - `(foo)`\n// - `\"COMMENT\"` - `{{! foo}}`\n// - `\"BLOCKCOMMENT\" - `{{!-- foo--}}`\n// - `\"INCLUSION\"` - `{{> foo}}`\n// - `\"BLOCKOPEN\"` - `{{#foo}}`\n// - `\"BLOCKCLOSE\"` - `{{/foo}}`\n// - `\"ELSE\"` - `{{else}}`\n// - `\"ESCAPE\"` - `{{|`, `{{{|`, `{{{{|` and so on\n//\n// Besides `type`, the mandatory properties of a TemplateTag are:\n//\n// - `path` - An array of one or more strings.  The path of `{{foo.bar}}`\n//   is `[\"foo\", \"bar\"]`.  Applies to DOUBLE, TRIPLE, INCLUSION, BLOCKOPEN,\n//   BLOCKCLOSE, and ELSE.\n//\n// - `args` - An array of zero or more argument specs.  An argument spec\n//   is a two or three element array, consisting of a type, value, and\n//   optional keyword name.  For example, the `args` of `{{foo \"bar\" x=3}}`\n//   are `[[\"STRING\", \"bar\"], [\"NUMBER\", 3, \"x\"]]`.  Applies to DOUBLE,\n//   TRIPLE, INCLUSION, BLOCKOPEN, and ELSE.\n//\n// - `value` - A string of the comment's text. Applies to COMMENT and\n//   BLOCKCOMMENT.\n//\n// These additional are typically set during parsing:\n//\n// - `position` - The HTMLTools.TEMPLATE_TAG_POSITION specifying at what sort\n//   of site the TemplateTag was encountered (e.g. at element level or as\n//   part of an attribute value). Its absence implies\n//   TEMPLATE_TAG_POSITION.ELEMENT.\n//\n// - `content` and `elseContent` - When a BLOCKOPEN tag's contents are\n//   parsed, they are put here.  `elseContent` will only be present if\n//   an `{{else}}` was found.\nvar TEMPLATE_TAG_POSITION = HTMLTools.TEMPLATE_TAG_POSITION;\n\nfunction TemplateTag() {\n  HTMLTools.TemplateTag.apply(this, arguments);\n}\n\nTemplateTag.prototype = new HTMLTools.TemplateTag();\nTemplateTag.prototype.constructorName = 'SpacebarsCompiler.TemplateTag';\n\nvar makeStacheTagStartRegex = function (r) {\n  return new RegExp(r.source + /(?![{>!#/])/.source, r.ignoreCase ? 'i' : '');\n}; // \"starts\" regexes are used to see what type of template\n// tag the parser is looking at.  They must match a non-empty\n// result, but not the interesting part of the tag.\n\n\nvar starts = {\n  ESCAPE: /^\\{\\{(?=\\{*\\|)/,\n  ELSE: makeStacheTagStartRegex(/^\\{\\{\\s*else(\\s+(?!\\s)|(?=[}]))/i),\n  DOUBLE: makeStacheTagStartRegex(/^\\{\\{\\s*(?!\\s)/),\n  TRIPLE: makeStacheTagStartRegex(/^\\{\\{\\{\\s*(?!\\s)/),\n  BLOCKCOMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!--/),\n  COMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!/),\n  INCLUSION: makeStacheTagStartRegex(/^\\{\\{\\s*>\\s*(?!\\s)/),\n  BLOCKOPEN: makeStacheTagStartRegex(/^\\{\\{\\s*#\\s*(?!\\s)/),\n  BLOCKCLOSE: makeStacheTagStartRegex(/^\\{\\{\\s*\\/\\s*(?!\\s)/)\n};\nvar ends = {\n  DOUBLE: /^\\s*\\}\\}/,\n  TRIPLE: /^\\s*\\}\\}\\}/,\n  EXPR: /^\\s*\\)/\n};\nvar endsString = {\n  DOUBLE: '}}',\n  TRIPLE: '}}}',\n  EXPR: ')'\n}; // Parse a tag from the provided scanner or string.  If the input\n// doesn't start with `{{`, returns null.  Otherwise, either succeeds\n// and returns a SpacebarsCompiler.TemplateTag, or throws an error (using\n// `scanner.fatal` if a scanner is provided).\n\nTemplateTag.parse = function (scannerOrString) {\n  var scanner = scannerOrString;\n  if (typeof scanner === 'string') scanner = new HTMLTools.Scanner(scannerOrString);\n  if (!(scanner.peek() === '{' && scanner.rest().slice(0, 2) === '{{')) return null;\n\n  var run = function (regex) {\n    // regex is assumed to start with `^`\n    var result = regex.exec(scanner.rest());\n    if (!result) return null;\n    var ret = result[0];\n    scanner.pos += ret.length;\n    return ret;\n  };\n\n  var advance = function (amount) {\n    scanner.pos += amount;\n  };\n\n  var scanIdentifier = function (isFirstInPath) {\n    var id = BlazeTools.parseExtendedIdentifierName(scanner);\n\n    if (!id) {\n      expected('IDENTIFIER');\n    }\n\n    if (isFirstInPath && (id === 'null' || id === 'true' || id === 'false')) scanner.fatal(\"Can't use null, true, or false, as an identifier at start of path\");\n    return id;\n  };\n\n  var scanPath = function () {\n    var segments = []; // handle initial `.`, `..`, `./`, `../`, `../..`, `../../`, etc\n\n    var dots;\n\n    if (dots = run(/^[\\.\\/]+/)) {\n      var ancestorStr = '.'; // eg `../../..` maps to `....`\n\n      var endsWithSlash = /\\/$/.test(dots);\n      if (endsWithSlash) dots = dots.slice(0, -1);\n\n      _.each(dots.split('/'), function (dotClause, index) {\n        if (index === 0) {\n          if (dotClause !== '.' && dotClause !== '..') expected(\"`.`, `..`, `./` or `../`\");\n        } else {\n          if (dotClause !== '..') expected(\"`..` or `../`\");\n        }\n\n        if (dotClause === '..') ancestorStr += '.';\n      });\n\n      segments.push(ancestorStr);\n      if (!endsWithSlash) return segments;\n    }\n\n    while (true) {\n      // scan a path segment\n      if (run(/^\\[/)) {\n        var seg = run(/^[\\s\\S]*?\\]/);\n        if (!seg) error(\"Unterminated path segment\");\n        seg = seg.slice(0, -1);\n        if (!seg && !segments.length) error(\"Path can't start with empty string\");\n        segments.push(seg);\n      } else {\n        var id = scanIdentifier(!segments.length);\n\n        if (id === 'this') {\n          if (!segments.length) {\n            // initial `this`\n            segments.push('.');\n          } else {\n            error(\"Can only use `this` at the beginning of a path.\\nInstead of `foo.this` or `../this`, just write `foo` or `..`.\");\n          }\n        } else {\n          segments.push(id);\n        }\n      }\n\n      var sep = run(/^[\\.\\/]/);\n      if (!sep) break;\n    }\n\n    return segments;\n  }; // scan the keyword portion of a keyword argument\n  // (the \"foo\" portion in \"foo=bar\").\n  // Result is either the keyword matched, or null\n  // if we're not at a keyword argument position.\n\n\n  var scanArgKeyword = function () {\n    var match = /^([^\\{\\}\\(\\)\\>#=\\s\"'\\[\\]]+)\\s*=\\s*/.exec(scanner.rest());\n\n    if (match) {\n      scanner.pos += match[0].length;\n      return match[1];\n    } else {\n      return null;\n    }\n  }; // scan an argument; succeeds or errors.\n  // Result is an array of two or three items:\n  // type , value, and (indicating a keyword argument)\n  // keyword name.\n\n\n  var scanArg = function () {\n    var keyword = scanArgKeyword(); // null if not parsing a kwarg\n\n    var value = scanArgValue();\n    return keyword ? value.concat(keyword) : value;\n  }; // scan an argument value (for keyword or positional arguments);\n  // succeeds or errors.  Result is an array of type, value.\n\n\n  var scanArgValue = function () {\n    var startPos = scanner.pos;\n    var result;\n\n    if (result = BlazeTools.parseNumber(scanner)) {\n      return ['NUMBER', result.value];\n    } else if (result = BlazeTools.parseStringLiteral(scanner)) {\n      return ['STRING', result.value];\n    } else if (/^[\\.\\[]/.test(scanner.peek())) {\n      return ['PATH', scanPath()];\n    } else if (run(/^\\(/)) {\n      return ['EXPR', scanExpr('EXPR')];\n    } else if (result = BlazeTools.parseExtendedIdentifierName(scanner)) {\n      var id = result;\n\n      if (id === 'null') {\n        return ['NULL', null];\n      } else if (id === 'true' || id === 'false') {\n        return ['BOOLEAN', id === 'true'];\n      } else {\n        scanner.pos = startPos; // unconsume `id`\n\n        return ['PATH', scanPath()];\n      }\n    } else {\n      expected('identifier, number, string, boolean, null, or a sub expression enclosed in \"(\", \")\"');\n    }\n  };\n\n  var scanExpr = function (type) {\n    var endType = type;\n    if (type === 'INCLUSION' || type === 'BLOCKOPEN' || type === 'ELSE') endType = 'DOUBLE';\n    var tag = new TemplateTag();\n    tag.type = type;\n    tag.path = scanPath();\n    tag.args = [];\n    var foundKwArg = false;\n\n    while (true) {\n      run(/^\\s*/);\n      if (run(ends[endType])) break;else if (/^[})]/.test(scanner.peek())) {\n        expected('`' + endsString[endType] + '`');\n      }\n      var newArg = scanArg();\n\n      if (newArg.length === 3) {\n        foundKwArg = true;\n      } else {\n        if (foundKwArg) error(\"Can't have a non-keyword argument after a keyword argument\");\n      }\n\n      tag.args.push(newArg); // expect a whitespace or a closing ')' or '}'\n\n      if (run(/^(?=[\\s})])/) !== '') expected('space');\n    }\n\n    return tag;\n  };\n\n  var type;\n\n  var error = function (msg) {\n    scanner.fatal(msg);\n  };\n\n  var expected = function (what) {\n    error('Expected ' + what);\n  }; // must do ESCAPE first, immediately followed by ELSE\n  // order of others doesn't matter\n\n\n  if (run(starts.ESCAPE)) type = 'ESCAPE';else if (run(starts.ELSE)) type = 'ELSE';else if (run(starts.DOUBLE)) type = 'DOUBLE';else if (run(starts.TRIPLE)) type = 'TRIPLE';else if (run(starts.BLOCKCOMMENT)) type = 'BLOCKCOMMENT';else if (run(starts.COMMENT)) type = 'COMMENT';else if (run(starts.INCLUSION)) type = 'INCLUSION';else if (run(starts.BLOCKOPEN)) type = 'BLOCKOPEN';else if (run(starts.BLOCKCLOSE)) type = 'BLOCKCLOSE';else error('Unknown stache tag');\n  var tag = new TemplateTag();\n  tag.type = type;\n\n  if (type === 'BLOCKCOMMENT') {\n    var result = run(/^[\\s\\S]*?--\\s*?\\}\\}/);\n    if (!result) error(\"Unclosed block comment\");\n    tag.value = result.slice(0, result.lastIndexOf('--'));\n  } else if (type === 'COMMENT') {\n    var result = run(/^[\\s\\S]*?\\}\\}/);\n    if (!result) error(\"Unclosed comment\");\n    tag.value = result.slice(0, -2);\n  } else if (type === 'BLOCKCLOSE') {\n    tag.path = scanPath();\n    if (!run(ends.DOUBLE)) expected('`}}`');\n  } else if (type === 'ELSE') {\n    if (!run(ends.DOUBLE)) {\n      tag = scanExpr(type);\n    }\n  } else if (type === 'ESCAPE') {\n    var result = run(/^\\{*\\|/);\n    tag.value = '{{' + result.slice(0, -1);\n  } else {\n    // DOUBLE, TRIPLE, BLOCKOPEN, INCLUSION\n    tag = scanExpr(type);\n  }\n\n  return tag;\n}; // Returns a SpacebarsCompiler.TemplateTag parsed from `scanner`, leaving scanner\n// at its original position.\n//\n// An error will still be thrown if there is not a valid template tag at\n// the current position.\n\n\nTemplateTag.peek = function (scanner) {\n  var startPos = scanner.pos;\n  var result = TemplateTag.parse(scanner);\n  scanner.pos = startPos;\n  return result;\n}; // Like `TemplateTag.parse`, but in the case of blocks, parse the complete\n// `{{#foo}}...{{/foo}}` with `content` and possible `elseContent`, rather\n// than just the BLOCKOPEN tag.\n//\n// In addition:\n//\n// - Throws an error if `{{else}}` or `{{/foo}}` tag is encountered.\n//\n// - Returns `null` for a COMMENT.  (This case is distinguishable from\n//   parsing no tag by the fact that the scanner is advanced.)\n//\n// - Takes an HTMLTools.TEMPLATE_TAG_POSITION `position` and sets it as the\n//   TemplateTag's `.position` property.\n//\n// - Validates the tag's well-formedness and legality at in its position.\n\n\nTemplateTag.parseCompleteTag = function (scannerOrString, position) {\n  var scanner = scannerOrString;\n  if (typeof scanner === 'string') scanner = new HTMLTools.Scanner(scannerOrString);\n  var startPos = scanner.pos; // for error messages\n\n  var result = TemplateTag.parse(scannerOrString);\n  if (!result) return result;\n  if (result.type === 'BLOCKCOMMENT') return null;\n  if (result.type === 'COMMENT') return null;\n  if (result.type === 'ELSE') scanner.fatal(\"Unexpected {{else}}\");\n  if (result.type === 'BLOCKCLOSE') scanner.fatal(\"Unexpected closing template tag\");\n  position = position || TEMPLATE_TAG_POSITION.ELEMENT;\n  if (position !== TEMPLATE_TAG_POSITION.ELEMENT) result.position = position;\n\n  if (result.type === 'BLOCKOPEN') {\n    // parse block contents\n    // Construct a string version of `.path` for comparing start and\n    // end tags.  For example, `foo/[0]` was parsed into `[\"foo\", \"0\"]`\n    // and now becomes `foo,0`.  This form may also show up in error\n    // messages.\n    var blockName = result.path.join(',');\n    var textMode = null;\n\n    if (blockName === 'markdown' || position === TEMPLATE_TAG_POSITION.IN_RAWTEXT) {\n      textMode = HTML.TEXTMODE.STRING;\n    } else if (position === TEMPLATE_TAG_POSITION.IN_RCDATA || position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n      textMode = HTML.TEXTMODE.RCDATA;\n    }\n\n    var parserOptions = {\n      getTemplateTag: TemplateTag.parseCompleteTag,\n      shouldStop: isAtBlockCloseOrElse,\n      textMode: textMode\n    };\n    result.textMode = textMode;\n    result.content = HTMLTools.parseFragment(scanner, parserOptions);\n    if (scanner.rest().slice(0, 2) !== '{{') scanner.fatal(\"Expected {{else}} or block close for \" + blockName);\n    var lastPos = scanner.pos; // save for error messages\n\n    var tmplTag = TemplateTag.parse(scanner); // {{else}} or {{/foo}}\n\n    var lastElseContentTag = result;\n\n    while (tmplTag.type === 'ELSE') {\n      if (lastElseContentTag === null) {\n        scanner.fatal(\"Unexpected else after {{else}}\");\n      }\n\n      if (tmplTag.path) {\n        lastElseContentTag.elseContent = new TemplateTag();\n        lastElseContentTag.elseContent.type = 'BLOCKOPEN';\n        lastElseContentTag.elseContent.path = tmplTag.path;\n        lastElseContentTag.elseContent.args = tmplTag.args;\n        lastElseContentTag.elseContent.textMode = textMode;\n        lastElseContentTag.elseContent.content = HTMLTools.parseFragment(scanner, parserOptions);\n        lastElseContentTag = lastElseContentTag.elseContent;\n      } else {\n        // parse {{else}} and content up to close tag\n        lastElseContentTag.elseContent = HTMLTools.parseFragment(scanner, parserOptions);\n        lastElseContentTag = null;\n      }\n\n      if (scanner.rest().slice(0, 2) !== '{{') scanner.fatal(\"Expected block close for \" + blockName);\n      lastPos = scanner.pos;\n      tmplTag = TemplateTag.parse(scanner);\n    }\n\n    if (tmplTag.type === 'BLOCKCLOSE') {\n      var blockName2 = tmplTag.path.join(',');\n\n      if (blockName !== blockName2) {\n        scanner.pos = lastPos;\n        scanner.fatal('Expected tag to close ' + blockName + ', found ' + blockName2);\n      }\n    } else {\n      scanner.pos = lastPos;\n      scanner.fatal('Expected tag to close ' + blockName + ', found ' + tmplTag.type);\n    }\n  }\n\n  var finalPos = scanner.pos;\n  scanner.pos = startPos;\n  validateTag(result, scanner);\n  scanner.pos = finalPos;\n  return result;\n};\n\nvar isAtBlockCloseOrElse = function (scanner) {\n  // Detect `{{else}}` or `{{/foo}}`.\n  //\n  // We do as much work ourselves before deferring to `TemplateTag.peek`,\n  // for efficiency (we're called for every input token) and to be\n  // less obtrusive, because `TemplateTag.peek` will throw an error if it\n  // sees `{{` followed by a malformed tag.\n  var rest, type;\n  return scanner.peek() === '{' && (rest = scanner.rest()).slice(0, 2) === '{{' && /^\\{\\{\\s*(\\/|else\\b)/.test(rest) && (type = TemplateTag.peek(scanner).type) && (type === 'BLOCKCLOSE' || type === 'ELSE');\n}; // Validate that `templateTag` is correctly formed and legal for its\n// HTML position.  Use `scanner` to report errors. On success, does\n// nothing.\n\n\nvar validateTag = function (ttag, scanner) {\n  if (ttag.type === 'INCLUSION' || ttag.type === 'BLOCKOPEN') {\n    var args = ttag.args;\n\n    if (ttag.path[0] === 'each' && args[1] && args[1][0] === 'PATH' && args[1][1][0] === 'in') {// For slightly better error messages, we detect the each-in case\n      // here in order not to complain if the user writes `{{#each 3 in x}}`\n      // that \"3 is not a function\"\n    } else {\n      if (args.length > 1 && args[0].length === 2 && args[0][0] !== 'PATH') {\n        // we have a positional argument that is not a PATH followed by\n        // other arguments\n        scanner.fatal(\"First argument must be a function, to be called on \" + \"the rest of the arguments; found \" + args[0][0]);\n      }\n    }\n  }\n\n  var position = ttag.position || TEMPLATE_TAG_POSITION.ELEMENT;\n\n  if (position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n    if (ttag.type === 'DOUBLE' || ttag.type === 'ESCAPE') {\n      return;\n    } else if (ttag.type === 'BLOCKOPEN') {\n      var path = ttag.path;\n      var path0 = path[0];\n\n      if (!(path.length === 1 && (path0 === 'if' || path0 === 'unless' || path0 === 'with' || path0 === 'each'))) {\n        scanner.fatal(\"Custom block helpers are not allowed in an HTML attribute, only built-in ones like #each and #if\");\n      }\n    } else {\n      scanner.fatal(ttag.type + \" template tag is not allowed in an HTML attribute\");\n    }\n  } else if (position === TEMPLATE_TAG_POSITION.IN_START_TAG) {\n    if (!(ttag.type === 'DOUBLE')) {\n      scanner.fatal(\"Reactive HTML attributes must either have a constant name or consist of a single {{helper}} providing a dictionary of names and values.  A template tag of type \" + ttag.type + \" is not allowed here.\");\n    }\n\n    if (scanner.peek() === '=') {\n      scanner.fatal(\"Template tags are not allowed in attribute names, only in attribute values or in the form of a single {{helper}} that evaluates to a dictionary of name=value pairs.\");\n    }\n  }\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"whitespace.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/spacebars-compiler/whitespace.js                                                                           //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  removeWhitespace: function () {\n    return removeWhitespace;\n  }\n});\nvar HTML;\nmodule.link(\"meteor/htmljs\", {\n  HTML: function (v) {\n    HTML = v;\n  }\n}, 0);\nvar TreeTransformer, toRaw;\nmodule.link(\"./optimizer\", {\n  TreeTransformer: function (v) {\n    TreeTransformer = v;\n  },\n  toRaw: function (v) {\n    toRaw = v;\n  }\n}, 1);\n\nfunction compactRaw(array) {\n  var result = [];\n\n  for (var i = 0; i < array.length; i++) {\n    var item = array[i];\n\n    if (item instanceof HTML.Raw) {\n      if (!item.value) {\n        continue;\n      }\n\n      if (result.length && result[result.length - 1] instanceof HTML.Raw) {\n        result[result.length - 1] = HTML.Raw(result[result.length - 1].value + item.value);\n        continue;\n      }\n    }\n\n    result.push(item);\n  }\n\n  return result;\n}\n\nfunction replaceIfContainsNewline(match) {\n  if (match.indexOf('\\n') >= 0) {\n    return '';\n  }\n\n  return match;\n}\n\nfunction stripWhitespace(array) {\n  var result = [];\n\n  for (var i = 0; i < array.length; i++) {\n    var item = array[i];\n\n    if (item instanceof HTML.Raw) {\n      // remove nodes that contain only whitespace & a newline\n      if (item.value.indexOf('\\n') !== -1 && !/\\S/.test(item.value)) {\n        continue;\n      } // Trim any preceding whitespace, if it contains a newline\n\n\n      var newStr = item.value;\n      newStr = newStr.replace(/^\\s+/, replaceIfContainsNewline);\n      newStr = newStr.replace(/\\s+$/, replaceIfContainsNewline);\n      item.value = newStr;\n    }\n\n    result.push(item);\n  }\n\n  return result;\n}\n\nvar WhitespaceRemovingVisitor = TreeTransformer.extend();\nWhitespaceRemovingVisitor.def({\n  visitNull: toRaw,\n  visitPrimitive: toRaw,\n  visitCharRef: toRaw,\n  visitArray: function (array) {\n    // this.super(array)\n    var result = TreeTransformer.prototype.visitArray.call(this, array);\n    result = compactRaw(result);\n    result = stripWhitespace(result);\n    return result;\n  },\n  visitTag: function (tag) {\n    var tagName = tag.tagName; // TODO - List tags that we don't want to strip whitespace for.\n\n    if (tagName === 'textarea' || tagName === 'script' || tagName === 'pre' || !HTML.isKnownElement(tagName) || HTML.isKnownSVGElement(tagName)) {\n      return tag;\n    }\n\n    return TreeTransformer.prototype.visitTag.call(this, tag);\n  },\n  visitAttributes: function (attrs) {\n    return attrs;\n  }\n});\n\nfunction removeWhitespace(tree) {\n  tree = new WhitespaceRemovingVisitor().visit(tree);\n  return tree;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nvar exports = require(\"/node_modules/meteor/spacebars-compiler/preamble.js\");\n\n/* Exports */\nPackage._define(\"spacebars-compiler\", exports);\n\n})();\n","servePath":"/packages/spacebars-compiler.js","sourceMap":{"version":3,"sources":["packages/spacebars-compiler/preamble.js","packages/spacebars-compiler/codegen.js","packages/spacebars-compiler/compiler.js","packages/spacebars-compiler/optimizer.js","packages/spacebars-compiler/react.js","packages/spacebars-compiler/templatetag.js","packages/spacebars-compiler/whitespace.js"],"names":["module","export","SpacebarsCompiler","CodeGen","builtInBlockHelpers","isReservedName","link","v","optimize","parse","compile","codeGen","TemplateTagReplacer","beautify","TemplateTag","_builtInBlockHelpers","_TemplateTagReplacer","_beautify","HTMLTools","HTML","BlazeTools","builtInTemplateMacros","additionalReservedNames","name","hasOwnProperty","_","indexOf","makeObjectLiteral","obj","parts","k","push","toObjectLiteralKey","join","extend","prototype","codeGenTemplateTag","tag","self","position","TEMPLATE_TAG_POSITION","IN_START_TAG","EmitCode","codeGenMustache","path","args","type","code","IN_ATTRIBUTE","toJSLiteral","length","Error","dataCode","eachUsage","inArg","variableArg","replace","variable","codeGenInclusionData","slice","dataProps","each","arg","argKey","codeGenArgValue","codeGenInclusionDataFunc","contentBlock","codeGenBlock","content","elseContentBlock","elseContent","callArgs","compCode","codeGenPath","lookupTemplate","includeArgs","includeCode","value","opts","firstPathItem","lookupMethod","map","argType","argValue","argCode","mustacheType","nameCode","codeGenMustacheArgs","mustache","tagArgs","kwArgs","Meteor","ReactComponentSiblingForbidder","removeWhitespace","UglifyJSMinify","isServer","Npm","require","minify","input","parseFragment","getTemplateTag","parseCompleteTag","options","tree","TransformingVisitor","def","visitObject","x","inAttributeValue","codegen","call","visitAttributes","attrs","visitAttribute","result","visit","parseTree","isTemplate","isBody","whitespace","sourceName","toLowerCase","toJS","fromString","mangle","compress","output","indent_level","width","_typeof","default","toRaw","TreeTransformer","constant","OPTIMIZABLE","NONE","PARTS","FULL","CanOptimizeVisitor","Visitor","visitNull","visitPrimitive","visitComment","visitCharRef","visitRaw","visitFunction","visitArray","i","visitTag","tagName","isKnownElement","isKnownSVGElement","children","isArray","a","getOptimizability","Raw","toHTML","apply","arguments","OptimizingVisitor","array","optimizability","visitChildren","RawCompactingVisitor","item","RawReplacingVisitor","raw","html","parentTag","numSiblings","child","match","constructorName","makeStacheTagStartRegex","r","RegExp","source","ignoreCase","starts","ESCAPE","ELSE","DOUBLE","TRIPLE","BLOCKCOMMENT","COMMENT","INCLUSION","BLOCKOPEN","BLOCKCLOSE","ends","EXPR","endsString","scannerOrString","scanner","Scanner","peek","rest","run","regex","exec","ret","pos","advance","amount","scanIdentifier","isFirstInPath","id","parseExtendedIdentifierName","expected","fatal","scanPath","segments","dots","ancestorStr","endsWithSlash","test","split","dotClause","index","seg","error","sep","scanArgKeyword","scanArg","keyword","scanArgValue","concat","startPos","parseNumber","parseStringLiteral","scanExpr","endType","foundKwArg","newArg","msg","what","lastIndexOf","ELEMENT","blockName","textMode","IN_RAWTEXT","TEXTMODE","STRING","IN_RCDATA","RCDATA","parserOptions","shouldStop","isAtBlockCloseOrElse","lastPos","tmplTag","lastElseContentTag","blockName2","finalPos","validateTag","ttag","path0","compactRaw","replaceIfContainsNewline","stripWhitespace","newStr","WhitespaceRemovingVisitor"],"mappings":"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","file":"/packages/spacebars-compiler.js","sourcesContent":["import { CodeGen, builtInBlockHelpers, isReservedName } from './codegen';\nimport { optimize } from './optimizer';\nimport { parse, compile, codeGen, TemplateTagReplacer, beautify } from './compiler';\nimport { TemplateTag } from './templatetag';\n\nexport const SpacebarsCompiler = {\n  CodeGen,\n  _builtInBlockHelpers: builtInBlockHelpers,\n  isReservedName,\n  optimize,\n  parse,\n  compile,\n  codeGen,\n  _TemplateTagReplacer: TemplateTagReplacer,\n  _beautify: beautify,\n  TemplateTag,\n};\n","import { HTMLTools } from 'meteor/html-tools';\nimport { HTML } from 'meteor/htmljs';\nimport { BlazeTools } from 'meteor/blaze-tools';\nimport { codeGen } from './compiler';\n\n\n// ============================================================\n// Code-generation of template tags\n\n// The `CodeGen` class currently has no instance state, but in theory\n// it could be useful to track per-function state, like whether we\n// need to emit `var self = this` or not.\nexport function CodeGen() {}\n\nexport const builtInBlockHelpers = {\n  'if': 'Blaze.If',\n  'unless': 'Blaze.Unless',\n  'with': 'Spacebars.With',\n  'each': 'Blaze.Each',\n  'let': 'Blaze.Let'\n};\n\n\n// Mapping of \"macros\" which, when preceded by `Template.`, expand\n// to special code rather than following the lookup rules for dotted\n// symbols.\nvar builtInTemplateMacros = {\n  // `view` is a local variable defined in the generated render\n  // function for the template in which `Template.contentBlock` or\n  // `Template.elseBlock` is invoked.\n  'contentBlock': 'view.templateContentBlock',\n  'elseBlock': 'view.templateElseBlock',\n\n  // Confusingly, this makes `{{> Template.dynamic}}` an alias\n  // for `{{> __dynamic}}`, where \"__dynamic\" is the template that\n  // implements the dynamic template feature.\n  'dynamic': 'Template.__dynamic',\n\n  'subscriptionsReady': 'view.templateInstance().subscriptionsReady()'\n};\n\nvar additionalReservedNames = [\"body\", \"toString\", \"instance\",  \"constructor\",\n  \"toString\", \"toLocaleString\", \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\",\n  \"propertyIsEnumerable\", \"__defineGetter__\", \"__lookupGetter__\",\n  \"__defineSetter__\", \"__lookupSetter__\", \"__proto__\", \"dynamic\",\n  \"registerHelper\", \"currentData\", \"parentData\", \"_migrateTemplate\",\n  \"_applyHmrChanges\", \"__pendingReplacement\"\n];\n\n// A \"reserved name\" can't be used as a <template> name.  This\n// function is used by the template file scanner.\n//\n// Note that the runtime imposes additional restrictions, for example\n// banning the name \"body\" and names of built-in object properties\n// like \"toString\".\nexport function isReservedName(name) {\n  return builtInBlockHelpers.hasOwnProperty(name) ||\n    builtInTemplateMacros.hasOwnProperty(name) ||\n    _.indexOf(additionalReservedNames, name) > -1;\n}\n\nvar makeObjectLiteral = function (obj) {\n  var parts = [];\n  for (var k in obj)\n    parts.push(BlazeTools.toObjectLiteralKey(k) + ': ' + obj[k]);\n  return '{' + parts.join(', ') + '}';\n};\n\n_.extend(CodeGen.prototype, {\n  codeGenTemplateTag: function (tag) {\n    var self = this;\n    if (tag.position === HTMLTools.TEMPLATE_TAG_POSITION.IN_START_TAG) {\n      // Special dynamic attributes: `<div {{attrs}}>...`\n      // only `tag.type === 'DOUBLE'` allowed (by earlier validation)\n      return BlazeTools.EmitCode('function () { return ' +\n          self.codeGenMustache(tag.path, tag.args, 'attrMustache')\n          + '; }');\n    } else {\n      if (tag.type === 'DOUBLE' || tag.type === 'TRIPLE') {\n        var code = self.codeGenMustache(tag.path, tag.args);\n        if (tag.type === 'TRIPLE') {\n          code = 'Spacebars.makeRaw(' + code + ')';\n        }\n        if (tag.position !== HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n          // Reactive attributes are already wrapped in a function,\n          // and there's no fine-grained reactivity.\n          // Anywhere else, we need to create a View.\n          code = 'Blaze.View(' +\n            BlazeTools.toJSLiteral('lookup:' + tag.path.join('.')) + ', ' +\n            'function () { return ' + code + '; })';\n        }\n        return BlazeTools.EmitCode(code);\n      } else if (tag.type === 'INCLUSION' || tag.type === 'BLOCKOPEN') {\n        var path = tag.path;\n        var args = tag.args;\n\n        if (tag.type === 'BLOCKOPEN' &&\n            builtInBlockHelpers.hasOwnProperty(path[0])) {\n          // if, unless, with, each.\n          //\n          // If someone tries to do `{{> if}}`, we don't\n          // get here, but an error is thrown when we try to codegen the path.\n\n          // Note: If we caught these errors earlier, while scanning, we'd be able to\n          // provide nice line numbers.\n          if (path.length > 1)\n            throw new Error(\"Unexpected dotted path beginning with \" + path[0]);\n          if (! args.length)\n            throw new Error(\"#\" + path[0] + \" requires an argument\");\n\n          var dataCode = null;\n          // #each has a special treatment as it features two different forms:\n          // - {{#each people}}\n          // - {{#each person in people}}\n          if (path[0] === 'each' && args.length >= 2 && args[1][0] === 'PATH' &&\n              args[1][1].length && args[1][1][0] === 'in') {\n            // minimum conditions are met for each-in.  now validate this\n            // isn't some weird case.\n            var eachUsage = \"Use either {{#each items}} or \" +\n                  \"{{#each item in items}} form of #each.\";\n            var inArg = args[1];\n            if (! (args.length >= 3 && inArg[1].length === 1)) {\n              // we don't have at least 3 space-separated parts after #each, or\n              // inArg doesn't look like ['PATH',['in']]\n              throw new Error(\"Malformed #each. \" + eachUsage);\n            }\n            // split out the variable name and sequence arguments\n            var variableArg = args[0];\n            if (! (variableArg[0] === \"PATH\" && variableArg[1].length === 1 &&\n                   variableArg[1][0].replace(/\\./g, ''))) {\n              throw new Error(\"Bad variable name in #each\");\n            }\n            var variable = variableArg[1][0];\n            dataCode = 'function () { return { _sequence: ' +\n              self.codeGenInclusionData(args.slice(2)) +\n              ', _variable: ' + BlazeTools.toJSLiteral(variable) + ' }; }';\n          } else if (path[0] === 'let') {\n            var dataProps = {};\n            _.each(args, function (arg) {\n              if (arg.length !== 3) {\n                // not a keyword arg (x=y)\n                throw new Error(\"Incorrect form of #let\");\n              }\n              var argKey = arg[2];\n              dataProps[argKey] =\n                'function () { return Spacebars.call(' +\n                self.codeGenArgValue(arg) + '); }';\n            });\n            dataCode = makeObjectLiteral(dataProps);\n          }\n\n          if (! dataCode) {\n            // `args` must exist (tag.args.length > 0)\n            dataCode = self.codeGenInclusionDataFunc(args) || 'null';\n          }\n\n          // `content` must exist\n          var contentBlock = (('content' in tag) ?\n                              self.codeGenBlock(tag.content) : null);\n          // `elseContent` may not exist\n          var elseContentBlock = (('elseContent' in tag) ?\n                                  self.codeGenBlock(tag.elseContent) : null);\n\n          var callArgs = [dataCode, contentBlock];\n          if (elseContentBlock)\n            callArgs.push(elseContentBlock);\n\n          return BlazeTools.EmitCode(\n            builtInBlockHelpers[path[0]] + '(' + callArgs.join(', ') + ')');\n\n        } else {\n          var compCode = self.codeGenPath(path, {lookupTemplate: true});\n          if (path.length > 1) {\n            // capture reactivity\n            compCode = 'function () { return Spacebars.call(' + compCode +\n              '); }';\n          }\n\n          var dataCode = self.codeGenInclusionDataFunc(tag.args);\n          var content = (('content' in tag) ?\n                         self.codeGenBlock(tag.content) : null);\n          var elseContent = (('elseContent' in tag) ?\n                             self.codeGenBlock(tag.elseContent) : null);\n\n          var includeArgs = [compCode];\n          if (content) {\n            includeArgs.push(content);\n            if (elseContent)\n              includeArgs.push(elseContent);\n          }\n\n          var includeCode =\n                'Spacebars.include(' + includeArgs.join(', ') + ')';\n\n          // calling convention compat -- set the data context around the\n          // entire inclusion, so that if the name of the inclusion is\n          // a helper function, it gets the data context in `this`.\n          // This makes for a pretty confusing calling convention --\n          // In `{{#foo bar}}`, `foo` is evaluated in the context of `bar`\n          // -- but it's what we shipped for 0.8.0.  The rationale is that\n          // `{{#foo bar}}` is sugar for `{{#with bar}}{{#foo}}...`.\n          if (dataCode) {\n            includeCode =\n              'Blaze._TemplateWith(' + dataCode + ', function () { return ' +\n              includeCode + '; })';\n          }\n\n          // XXX BACK COMPAT - UI is the old name, Template is the new\n          if ((path[0] === 'UI' || path[0] === 'Template') &&\n              (path[1] === 'contentBlock' || path[1] === 'elseBlock')) {\n            // Call contentBlock and elseBlock in the appropriate scope\n            includeCode = 'Blaze._InOuterTemplateScope(view, function () { return '\n              + includeCode + '; })';\n          }\n\n          return BlazeTools.EmitCode(includeCode);\n        }\n      } else if (tag.type === 'ESCAPE') {\n        return tag.value;\n      } else {\n        // Can't get here; TemplateTag validation should catch any\n        // inappropriate tag types that might come out of the parser.\n        throw new Error(\"Unexpected template tag type: \" + tag.type);\n      }\n    }\n  },\n\n  // `path` is an array of at least one string.\n  //\n  // If `path.length > 1`, the generated code may be reactive\n  // (i.e. it may invalidate the current computation).\n  //\n  // No code is generated to call the result if it's a function.\n  //\n  // Options:\n  //\n  // - lookupTemplate {Boolean} If true, generated code also looks in\n  //   the list of templates. (After helpers, before data context).\n  //   Used when generating code for `{{> foo}}` or `{{#foo}}`. Only\n  //   used for non-dotted paths.\n  codeGenPath: function (path, opts) {\n    if (builtInBlockHelpers.hasOwnProperty(path[0]))\n      throw new Error(\"Can't use the built-in '\" + path[0] + \"' here\");\n    // Let `{{#if Template.contentBlock}}` check whether this template was\n    // invoked via inclusion or as a block helper, in addition to supporting\n    // `{{> Template.contentBlock}}`.\n    // XXX BACK COMPAT - UI is the old name, Template is the new\n    if (path.length >= 2 &&\n        (path[0] === 'UI' || path[0] === 'Template')\n        && builtInTemplateMacros.hasOwnProperty(path[1])) {\n      if (path.length > 2)\n        throw new Error(\"Unexpected dotted path beginning with \" +\n                        path[0] + '.' + path[1]);\n      return builtInTemplateMacros[path[1]];\n    }\n\n    var firstPathItem = BlazeTools.toJSLiteral(path[0]);\n    var lookupMethod = 'lookup';\n    if (opts && opts.lookupTemplate && path.length === 1)\n      lookupMethod = 'lookupTemplate';\n    var code = 'view.' + lookupMethod + '(' + firstPathItem + ')';\n\n    if (path.length > 1) {\n      code = 'Spacebars.dot(' + code + ', ' +\n        _.map(path.slice(1), BlazeTools.toJSLiteral).join(', ') + ')';\n    }\n\n    return code;\n  },\n\n  // Generates code for an `[argType, argValue]` argument spec,\n  // ignoring the third element (keyword argument name) if present.\n  //\n  // The resulting code may be reactive (in the case of a PATH of\n  // more than one element) and is not wrapped in a closure.\n  codeGenArgValue: function (arg) {\n    var self = this;\n\n    var argType = arg[0];\n    var argValue = arg[1];\n\n    var argCode;\n    switch (argType) {\n    case 'STRING':\n    case 'NUMBER':\n    case 'BOOLEAN':\n    case 'NULL':\n      argCode = BlazeTools.toJSLiteral(argValue);\n      break;\n    case 'PATH':\n      argCode = self.codeGenPath(argValue);\n      break;\n    case 'EXPR':\n      // The format of EXPR is ['EXPR', { type: 'EXPR', path: [...], args: { ... } }]\n      argCode = self.codeGenMustache(argValue.path, argValue.args, 'dataMustache');\n      break;\n    default:\n      // can't get here\n      throw new Error(\"Unexpected arg type: \" + argType);\n    }\n\n    return argCode;\n  },\n\n  // Generates a call to `Spacebars.fooMustache` on evaluated arguments.\n  // The resulting code has no function literals and must be wrapped in\n  // one for fine-grained reactivity.\n  codeGenMustache: function (path, args, mustacheType) {\n    var self = this;\n\n    var nameCode = self.codeGenPath(path);\n    var argCode = self.codeGenMustacheArgs(args);\n    var mustache = (mustacheType || 'mustache');\n\n    return 'Spacebars.' + mustache + '(' + nameCode +\n      (argCode ? ', ' + argCode.join(', ') : '') + ')';\n  },\n\n  // returns: array of source strings, or null if no\n  // args at all.\n  codeGenMustacheArgs: function (tagArgs) {\n    var self = this;\n\n    var kwArgs = null; // source -> source\n    var args = null; // [source]\n\n    // tagArgs may be null\n    _.each(tagArgs, function (arg) {\n      var argCode = self.codeGenArgValue(arg);\n\n      if (arg.length > 2) {\n        // keyword argument (represented as [type, value, name])\n        kwArgs = (kwArgs || {});\n        kwArgs[arg[2]] = argCode;\n      } else {\n        // positional argument\n        args = (args || []);\n        args.push(argCode);\n      }\n    });\n\n    // put kwArgs in options dictionary at end of args\n    if (kwArgs) {\n      args = (args || []);\n      args.push('Spacebars.kw(' + makeObjectLiteral(kwArgs) + ')');\n    }\n\n    return args;\n  },\n\n  codeGenBlock: function (content) {\n    return codeGen(content);\n  },\n\n  codeGenInclusionData: function (args) {\n    var self = this;\n\n    if (! args.length) {\n      // e.g. `{{#foo}}`\n      return null;\n    } else if (args[0].length === 3) {\n      // keyword arguments only, e.g. `{{> point x=1 y=2}}`\n      var dataProps = {};\n      _.each(args, function (arg) {\n        var argKey = arg[2];\n        dataProps[argKey] = 'Spacebars.call(' + self.codeGenArgValue(arg) + ')';\n      });\n      return makeObjectLiteral(dataProps);\n    } else if (args[0][0] !== 'PATH') {\n      // literal first argument, e.g. `{{> foo \"blah\"}}`\n      //\n      // tag validation has confirmed, in this case, that there is only\n      // one argument (`args.length === 1`)\n      return self.codeGenArgValue(args[0]);\n    } else if (args.length === 1) {\n      // one argument, must be a PATH\n      return 'Spacebars.call(' + self.codeGenPath(args[0][1]) + ')';\n    } else {\n      // Multiple positional arguments; treat them as a nested\n      // \"data mustache\"\n      return self.codeGenMustache(args[0][1], args.slice(1),\n                                  'dataMustache');\n    }\n\n  },\n\n  codeGenInclusionDataFunc: function (args) {\n    var self = this;\n    var dataCode = self.codeGenInclusionData(args);\n    if (dataCode) {\n      return 'function () { return ' + dataCode + '; }';\n    } else {\n      return null;\n    }\n  }\n\n});\n","import { Meteor } from 'meteor/meteor';\nimport { HTMLTools } from 'meteor/html-tools';\nimport { HTML } from 'meteor/htmljs';\nimport { BlazeTools } from 'meteor/blaze-tools';\nimport { CodeGen } from './codegen';\nimport { optimize } from './optimizer';\nimport { ReactComponentSiblingForbidder} from './react';\nimport { TemplateTag } from './templatetag';\nimport { removeWhitespace } from './whitespace';\n\nvar UglifyJSMinify = null;\nif (Meteor.isServer) {\n  UglifyJSMinify = Npm.require('uglify-js').minify;\n}\n\nexport function parse(input) {\n  return HTMLTools.parseFragment(\n    input,\n    { getTemplateTag: TemplateTag.parseCompleteTag });\n}\n\nexport function compile(input, options) {\n  var tree = parse(input);\n  return codeGen(tree, options);\n}\n\nexport const TemplateTagReplacer = HTML.TransformingVisitor.extend();\nTemplateTagReplacer.def({\n  visitObject: function (x) {\n    if (x instanceof HTMLTools.TemplateTag) {\n\n      // Make sure all TemplateTags in attributes have the right\n      // `.position` set on them.  This is a bit of a hack\n      // (we shouldn't be mutating that here), but it allows\n      // cleaner codegen of \"synthetic\" attributes like TEXTAREA's\n      // \"value\", where the template tags were originally not\n      // in an attribute.\n      if (this.inAttributeValue)\n        x.position = HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE;\n\n      return this.codegen.codeGenTemplateTag(x);\n    }\n\n    return HTML.TransformingVisitor.prototype.visitObject.call(this, x);\n  },\n  visitAttributes: function (attrs) {\n    if (attrs instanceof HTMLTools.TemplateTag)\n      return this.codegen.codeGenTemplateTag(attrs);\n\n    // call super (e.g. for case where `attrs` is an array)\n    return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);\n  },\n  visitAttribute: function (name, value, tag) {\n    this.inAttributeValue = true;\n    var result = this.visit(value);\n    this.inAttributeValue = false;\n\n    if (result !== value) {\n      // some template tags must have been replaced, because otherwise\n      // we try to keep things `===` when transforming.  Wrap the code\n      // in a function as per the rules.  You can't have\n      // `{id: Blaze.View(...)}` as an attributes dict because the View\n      // would be rendered more than once; you need to wrap it in a function\n      // so that it's a different View each time.\n      return BlazeTools.EmitCode(this.codegen.codeGenBlock(result));\n    }\n    return result;\n  }\n});\n\nexport function codeGen (parseTree, options) {\n  // is this a template, rather than a block passed to\n  // a block helper, say\n  var isTemplate = (options && options.isTemplate);\n  var isBody = (options && options.isBody);\n  var whitespace = (options && options.whitespace)\n  var sourceName = (options && options.sourceName);\n\n  var tree = parseTree;\n\n  // The flags `isTemplate` and `isBody` are kind of a hack.\n  if (isTemplate || isBody) {\n    if (typeof whitespace === 'string' && whitespace.toLowerCase() === 'strip') {\n      tree = removeWhitespace(tree);\n    }\n    // optimizing fragments would require being smarter about whether we are\n    // in a TEXTAREA, say.\n    tree = optimize(tree);\n  }\n\n  // throws an error if using `{{> React}}` with siblings\n  new ReactComponentSiblingForbidder({sourceName: sourceName})\n    .visit(tree);\n\n  var codegen = new CodeGen;\n  tree = (new TemplateTagReplacer(\n    {codegen: codegen})).visit(tree);\n\n  var code = '(function () { ';\n  if (isTemplate || isBody) {\n    code += 'var view = this; ';\n  }\n  code += 'return ';\n  code += BlazeTools.toJS(tree);\n  code += '; })';\n\n  code = beautify(code);\n\n  return code;\n}\n\nexport function beautify (code) {\n  if (!UglifyJSMinify) {\n    return code;\n  }\n\n  var result = UglifyJSMinify(code, {\n    fromString: true,\n    mangle: false,\n    compress: false,\n    output: {\n      beautify: true,\n      indent_level: 2,\n      width: 80\n    }\n  });\n\n  var output = result.code;\n  // Uglify interprets our expression as a statement and may add a semicolon.\n  // Strip trailing semicolon.\n  output = output.replace(/;$/, '');\n  return output;\n}\n","import { HTMLTools } from 'meteor/html-tools';\nimport { HTML } from 'meteor/htmljs';\n\n// Optimize parts of an HTMLjs tree into raw HTML strings when they don't\n// contain template tags.\n\nvar constant = function (value) {\n  return function () { return value; };\n};\n\nvar OPTIMIZABLE = {\n  NONE: 0,\n  PARTS: 1,\n  FULL: 2\n};\n\n// We can only turn content into an HTML string if it contains no template\n// tags and no \"tricky\" HTML tags.  If we can optimize the entire content\n// into a string, we return OPTIMIZABLE.FULL.  If the we are given an\n// unoptimizable node, we return OPTIMIZABLE.NONE.  If we are given a tree\n// that contains an unoptimizable node somewhere, we return OPTIMIZABLE.PARTS.\n//\n// For example, we always create SVG elements programmatically, since SVG\n// doesn't have innerHTML.  If we are given an SVG element, we return NONE.\n// However, if we are given a big tree that contains SVG somewhere, we\n// return PARTS so that the optimizer can descend into the tree and optimize\n// other parts of it.\nvar CanOptimizeVisitor = HTML.Visitor.extend();\nCanOptimizeVisitor.def({\n  visitNull: constant(OPTIMIZABLE.FULL),\n  visitPrimitive: constant(OPTIMIZABLE.FULL),\n  visitComment: constant(OPTIMIZABLE.FULL),\n  visitCharRef: constant(OPTIMIZABLE.FULL),\n  visitRaw: constant(OPTIMIZABLE.FULL),\n  visitObject: constant(OPTIMIZABLE.NONE),\n  visitFunction: constant(OPTIMIZABLE.NONE),\n  visitArray: function (x) {\n    for (var i = 0; i < x.length; i++)\n      if (this.visit(x[i]) !== OPTIMIZABLE.FULL)\n        return OPTIMIZABLE.PARTS;\n    return OPTIMIZABLE.FULL;\n  },\n  visitTag: function (tag) {\n    var tagName = tag.tagName;\n    if (tagName === 'textarea') {\n      // optimizing into a TEXTAREA's RCDATA would require being a little\n      // more clever.\n      return OPTIMIZABLE.NONE;\n    } else if (tagName === 'script') {\n      // script tags don't work when rendered from strings\n      return OPTIMIZABLE.NONE;\n    } else if (! (HTML.isKnownElement(tagName) &&\n                  ! HTML.isKnownSVGElement(tagName))) {\n      // foreign elements like SVG can't be stringified for innerHTML.\n      return OPTIMIZABLE.NONE;\n    } else if (tagName === 'table') {\n      // Avoid ever producing HTML containing `<table><tr>...`, because the\n      // browser will insert a TBODY.  If we just `createElement(\"table\")` and\n      // `createElement(\"tr\")`, on the other hand, no TBODY is necessary\n      // (assuming IE 8+).\n      return OPTIMIZABLE.PARTS;\n    } else if (tagName === 'tr'){\n      return OPTIMIZABLE.PARTS;\n    }\n\n    var children = tag.children;\n    for (var i = 0; i < children.length; i++)\n      if (this.visit(children[i]) !== OPTIMIZABLE.FULL)\n        return OPTIMIZABLE.PARTS;\n\n    if (this.visitAttributes(tag.attrs) !== OPTIMIZABLE.FULL)\n      return OPTIMIZABLE.PARTS;\n\n    return OPTIMIZABLE.FULL;\n  },\n  visitAttributes: function (attrs) {\n    if (attrs) {\n      var isArray = HTML.isArray(attrs);\n      for (var i = 0; i < (isArray ? attrs.length : 1); i++) {\n        var a = (isArray ? attrs[i] : attrs);\n        if ((typeof a !== 'object') || (a instanceof HTMLTools.TemplateTag))\n          return OPTIMIZABLE.PARTS;\n        for (var k in a)\n          if (this.visit(a[k]) !== OPTIMIZABLE.FULL)\n            return OPTIMIZABLE.PARTS;\n      }\n    }\n    return OPTIMIZABLE.FULL;\n  }\n});\n\nvar getOptimizability = function (content) {\n  return (new CanOptimizeVisitor).visit(content);\n};\n\nexport function toRaw(x) {\n  return HTML.Raw(HTML.toHTML(x));\n}\n\nexport const TreeTransformer = HTML.TransformingVisitor.extend();\nTreeTransformer.def({\n  visitAttributes: function (attrs/*, ...*/) {\n    // pass template tags through by default\n    if (attrs instanceof HTMLTools.TemplateTag)\n      return attrs;\n\n    return HTML.TransformingVisitor.prototype.visitAttributes.apply(\n      this, arguments);\n  }\n});\n\n// Replace parts of the HTMLjs tree that have no template tags (or\n// tricky HTML tags) with HTML.Raw objects containing raw HTML.\nvar OptimizingVisitor = TreeTransformer.extend();\nOptimizingVisitor.def({\n  visitNull: toRaw,\n  visitPrimitive: toRaw,\n  visitComment: toRaw,\n  visitCharRef: toRaw,\n  visitArray: function (array) {\n    var optimizability = getOptimizability(array);\n    if (optimizability === OPTIMIZABLE.FULL) {\n      return toRaw(array);\n    } else if (optimizability === OPTIMIZABLE.PARTS) {\n      return TreeTransformer.prototype.visitArray.call(this, array);\n    } else {\n      return array;\n    }\n  },\n  visitTag: function (tag) {\n    var optimizability = getOptimizability(tag);\n    if (optimizability === OPTIMIZABLE.FULL) {\n      return toRaw(tag);\n    } else if (optimizability === OPTIMIZABLE.PARTS) {\n      return TreeTransformer.prototype.visitTag.call(this, tag);\n    } else {\n      return tag;\n    }\n  },\n  visitChildren: function (children) {\n    // don't optimize the children array into a Raw object!\n    return TreeTransformer.prototype.visitArray.call(this, children);\n  },\n  visitAttributes: function (attrs) {\n    return attrs;\n  }\n});\n\n// Combine consecutive HTML.Raws.  Remove empty ones.\nvar RawCompactingVisitor = TreeTransformer.extend();\nRawCompactingVisitor.def({\n  visitArray: function (array) {\n    var result = [];\n    for (var i = 0; i < array.length; i++) {\n      var item = array[i];\n      if ((item instanceof HTML.Raw) &&\n          ((! item.value) ||\n           (result.length &&\n            (result[result.length - 1] instanceof HTML.Raw)))) {\n        // two cases: item is an empty Raw, or previous item is\n        // a Raw as well.  In the latter case, replace the previous\n        // Raw with a longer one that includes the new Raw.\n        if (item.value) {\n          result[result.length - 1] = HTML.Raw(\n            result[result.length - 1].value + item.value);\n        }\n      } else {\n        result.push(this.visit(item));\n      }\n    }\n    return result;\n  }\n});\n\n// Replace pointless Raws like `HTMl.Raw('foo')` that contain no special\n// characters with simple strings.\nvar RawReplacingVisitor = TreeTransformer.extend();\nRawReplacingVisitor.def({\n  visitRaw: function (raw) {\n    var html = raw.value;\n    if (html.indexOf('&') < 0 && html.indexOf('<') < 0) {\n      return html;\n    } else {\n      return raw;\n    }\n  }\n});\n\nexport function optimize (tree) {\n  tree = (new OptimizingVisitor).visit(tree);\n  tree = (new RawCompactingVisitor).visit(tree);\n  tree = (new RawReplacingVisitor).visit(tree);\n  return tree;\n}\n","import { HTMLTools } from 'meteor/html-tools';\nimport { HTML } from 'meteor/htmljs';\nimport { BlazeTools } from 'meteor/blaze-tools';\n\n// A visitor to ensure that React components included via the `{{>\n// React}}` template defined in the react-template-helper package are\n// the only child in their parent component. Otherwise `React.render`\n// would eliminate all of their sibling nodes.\n//\n// It's a little strange that this logic is in spacebars-compiler if\n// it's only relevant to a specific package but there's no way to have\n// a package hook into a build plugin.\nexport const ReactComponentSiblingForbidder = HTML.Visitor.extend();\nReactComponentSiblingForbidder.def({\n  visitArray: function (array, parentTag) {\n    for (var i = 0; i < array.length; i++) {\n      this.visit(array[i], parentTag);\n    }\n  },\n  visitObject: function (obj, parentTag) {\n    if (obj.type === \"INCLUSION\" && obj.path.length === 1 && obj.path[0] === \"React\") {\n      if (!parentTag) {\n        throw new Error(\n          \"{{> React}} must be used in a container element\"\n            + (this.sourceName ? (\" in \" + this.sourceName) : \"\")\n               + \". Learn more at https://github.com/meteor/meteor/wiki/React-components-must-be-the-only-thing-in-their-wrapper-element\");\n      }\n\n      var numSiblings = 0;\n      for (var i = 0; i < parentTag.children.length; i++) {\n        var child = parentTag.children[i];\n        if (child !== obj && !(typeof child === \"string\" && child.match(/^\\s*$/))) {\n          numSiblings++;\n        }\n      }\n\n      if (numSiblings > 0) {\n        throw new Error(\n          \"{{> React}} must be used as the only child in a container element\"\n            + (this.sourceName ? (\" in \" + this.sourceName) : \"\")\n               + \". Learn more at https://github.com/meteor/meteor/wiki/React-components-must-be-the-only-thing-in-their-wrapper-element\");\n      }\n    }\n  },\n  visitTag: function (tag) {\n    this.visitArray(tag.children, tag /*parentTag*/);\n  }\n});\n","import { HTMLTools } from 'meteor/html-tools';\nimport { HTML } from 'meteor/htmljs';\nimport { BlazeTools } from 'meteor/blaze-tools';\n\n// A TemplateTag is the result of parsing a single `{{...}}` tag.\n//\n// The `.type` of a TemplateTag is one of:\n//\n// - `\"DOUBLE\"` - `{{foo}}`\n// - `\"TRIPLE\"` - `{{{foo}}}`\n// - `\"EXPR\"` - `(foo)`\n// - `\"COMMENT\"` - `{{! foo}}`\n// - `\"BLOCKCOMMENT\" - `{{!-- foo--}}`\n// - `\"INCLUSION\"` - `{{> foo}}`\n// - `\"BLOCKOPEN\"` - `{{#foo}}`\n// - `\"BLOCKCLOSE\"` - `{{/foo}}`\n// - `\"ELSE\"` - `{{else}}`\n// - `\"ESCAPE\"` - `{{|`, `{{{|`, `{{{{|` and so on\n//\n// Besides `type`, the mandatory properties of a TemplateTag are:\n//\n// - `path` - An array of one or more strings.  The path of `{{foo.bar}}`\n//   is `[\"foo\", \"bar\"]`.  Applies to DOUBLE, TRIPLE, INCLUSION, BLOCKOPEN,\n//   BLOCKCLOSE, and ELSE.\n//\n// - `args` - An array of zero or more argument specs.  An argument spec\n//   is a two or three element array, consisting of a type, value, and\n//   optional keyword name.  For example, the `args` of `{{foo \"bar\" x=3}}`\n//   are `[[\"STRING\", \"bar\"], [\"NUMBER\", 3, \"x\"]]`.  Applies to DOUBLE,\n//   TRIPLE, INCLUSION, BLOCKOPEN, and ELSE.\n//\n// - `value` - A string of the comment's text. Applies to COMMENT and\n//   BLOCKCOMMENT.\n//\n// These additional are typically set during parsing:\n//\n// - `position` - The HTMLTools.TEMPLATE_TAG_POSITION specifying at what sort\n//   of site the TemplateTag was encountered (e.g. at element level or as\n//   part of an attribute value). Its absence implies\n//   TEMPLATE_TAG_POSITION.ELEMENT.\n//\n// - `content` and `elseContent` - When a BLOCKOPEN tag's contents are\n//   parsed, they are put here.  `elseContent` will only be present if\n//   an `{{else}}` was found.\n\nvar TEMPLATE_TAG_POSITION = HTMLTools.TEMPLATE_TAG_POSITION;\n\nexport function TemplateTag () {\n  HTMLTools.TemplateTag.apply(this, arguments);\n}\n\nTemplateTag.prototype = new HTMLTools.TemplateTag;\nTemplateTag.prototype.constructorName = 'SpacebarsCompiler.TemplateTag';\n\nvar makeStacheTagStartRegex = function (r) {\n  return new RegExp(r.source + /(?![{>!#/])/.source,\n                    r.ignoreCase ? 'i' : '');\n};\n\n// \"starts\" regexes are used to see what type of template\n// tag the parser is looking at.  They must match a non-empty\n// result, but not the interesting part of the tag.\nvar starts = {\n  ESCAPE: /^\\{\\{(?=\\{*\\|)/,\n  ELSE: makeStacheTagStartRegex(/^\\{\\{\\s*else(\\s+(?!\\s)|(?=[}]))/i),\n  DOUBLE: makeStacheTagStartRegex(/^\\{\\{\\s*(?!\\s)/),\n  TRIPLE: makeStacheTagStartRegex(/^\\{\\{\\{\\s*(?!\\s)/),\n  BLOCKCOMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!--/),\n  COMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!/),\n  INCLUSION: makeStacheTagStartRegex(/^\\{\\{\\s*>\\s*(?!\\s)/),\n  BLOCKOPEN: makeStacheTagStartRegex(/^\\{\\{\\s*#\\s*(?!\\s)/),\n  BLOCKCLOSE: makeStacheTagStartRegex(/^\\{\\{\\s*\\/\\s*(?!\\s)/)\n};\n\nvar ends = {\n  DOUBLE: /^\\s*\\}\\}/,\n  TRIPLE: /^\\s*\\}\\}\\}/,\n  EXPR: /^\\s*\\)/\n};\n\nvar endsString = {\n  DOUBLE: '}}',\n  TRIPLE: '}}}',\n  EXPR: ')'\n};\n\n// Parse a tag from the provided scanner or string.  If the input\n// doesn't start with `{{`, returns null.  Otherwise, either succeeds\n// and returns a SpacebarsCompiler.TemplateTag, or throws an error (using\n// `scanner.fatal` if a scanner is provided).\nTemplateTag.parse = function (scannerOrString) {\n  var scanner = scannerOrString;\n  if (typeof scanner === 'string')\n    scanner = new HTMLTools.Scanner(scannerOrString);\n\n  if (! (scanner.peek() === '{' &&\n         (scanner.rest()).slice(0, 2) === '{{'))\n    return null;\n\n  var run = function (regex) {\n    // regex is assumed to start with `^`\n    var result = regex.exec(scanner.rest());\n    if (! result)\n      return null;\n    var ret = result[0];\n    scanner.pos += ret.length;\n    return ret;\n  };\n\n  var advance = function (amount) {\n    scanner.pos += amount;\n  };\n\n  var scanIdentifier = function (isFirstInPath) {\n    var id = BlazeTools.parseExtendedIdentifierName(scanner);\n    if (! id) {\n      expected('IDENTIFIER');\n    }\n    if (isFirstInPath &&\n        (id === 'null' || id === 'true' || id === 'false'))\n      scanner.fatal(\"Can't use null, true, or false, as an identifier at start of path\");\n\n    return id;\n  };\n\n  var scanPath = function () {\n    var segments = [];\n\n    // handle initial `.`, `..`, `./`, `../`, `../..`, `../../`, etc\n    var dots;\n    if ((dots = run(/^[\\.\\/]+/))) {\n      var ancestorStr = '.'; // eg `../../..` maps to `....`\n      var endsWithSlash = /\\/$/.test(dots);\n\n      if (endsWithSlash)\n        dots = dots.slice(0, -1);\n\n      _.each(dots.split('/'), function(dotClause, index) {\n        if (index === 0) {\n          if (dotClause !== '.' && dotClause !== '..')\n            expected(\"`.`, `..`, `./` or `../`\");\n        } else {\n          if (dotClause !== '..')\n            expected(\"`..` or `../`\");\n        }\n\n        if (dotClause === '..')\n          ancestorStr += '.';\n      });\n\n      segments.push(ancestorStr);\n\n      if (!endsWithSlash)\n        return segments;\n    }\n\n    while (true) {\n      // scan a path segment\n\n      if (run(/^\\[/)) {\n        var seg = run(/^[\\s\\S]*?\\]/);\n        if (! seg)\n          error(\"Unterminated path segment\");\n        seg = seg.slice(0, -1);\n        if (! seg && ! segments.length)\n          error(\"Path can't start with empty string\");\n        segments.push(seg);\n      } else {\n        var id = scanIdentifier(! segments.length);\n        if (id === 'this') {\n          if (! segments.length) {\n            // initial `this`\n            segments.push('.');\n          } else {\n            error(\"Can only use `this` at the beginning of a path.\\nInstead of `foo.this` or `../this`, just write `foo` or `..`.\");\n          }\n        } else {\n          segments.push(id);\n        }\n      }\n\n      var sep = run(/^[\\.\\/]/);\n      if (! sep)\n        break;\n    }\n\n    return segments;\n  };\n\n  // scan the keyword portion of a keyword argument\n  // (the \"foo\" portion in \"foo=bar\").\n  // Result is either the keyword matched, or null\n  // if we're not at a keyword argument position.\n  var scanArgKeyword = function () {\n    var match = /^([^\\{\\}\\(\\)\\>#=\\s\"'\\[\\]]+)\\s*=\\s*/.exec(scanner.rest());\n    if (match) {\n      scanner.pos += match[0].length;\n      return match[1];\n    } else {\n      return null;\n    }\n  };\n\n  // scan an argument; succeeds or errors.\n  // Result is an array of two or three items:\n  // type , value, and (indicating a keyword argument)\n  // keyword name.\n  var scanArg = function () {\n    var keyword = scanArgKeyword(); // null if not parsing a kwarg\n    var value = scanArgValue();\n    return keyword ? value.concat(keyword) : value;\n  };\n\n  // scan an argument value (for keyword or positional arguments);\n  // succeeds or errors.  Result is an array of type, value.\n  var scanArgValue = function () {\n    var startPos = scanner.pos;\n    var result;\n    if ((result = BlazeTools.parseNumber(scanner))) {\n      return ['NUMBER', result.value];\n    } else if ((result = BlazeTools.parseStringLiteral(scanner))) {\n      return ['STRING', result.value];\n    } else if (/^[\\.\\[]/.test(scanner.peek())) {\n      return ['PATH', scanPath()];\n    } else if (run(/^\\(/)) {\n      return ['EXPR', scanExpr('EXPR')];\n    } else if ((result = BlazeTools.parseExtendedIdentifierName(scanner))) {\n      var id = result;\n      if (id === 'null') {\n        return ['NULL', null];\n      } else if (id === 'true' || id === 'false') {\n        return ['BOOLEAN', id === 'true'];\n      } else {\n        scanner.pos = startPos; // unconsume `id`\n        return ['PATH', scanPath()];\n      }\n    } else {\n      expected('identifier, number, string, boolean, null, or a sub expression enclosed in \"(\", \")\"');\n    }\n  };\n\n  var scanExpr = function (type) {\n    var endType = type;\n    if (type === 'INCLUSION' || type === 'BLOCKOPEN' || type === 'ELSE')\n      endType = 'DOUBLE';\n\n    var tag = new TemplateTag;\n    tag.type = type;\n    tag.path = scanPath();\n    tag.args = [];\n    var foundKwArg = false;\n    while (true) {\n      run(/^\\s*/);\n      if (run(ends[endType]))\n        break;\n      else if (/^[})]/.test(scanner.peek())) {\n        expected('`' + endsString[endType] + '`');\n      }\n      var newArg = scanArg();\n      if (newArg.length === 3) {\n        foundKwArg = true;\n      } else {\n        if (foundKwArg)\n          error(\"Can't have a non-keyword argument after a keyword argument\");\n      }\n      tag.args.push(newArg);\n\n      // expect a whitespace or a closing ')' or '}'\n      if (run(/^(?=[\\s})])/) !== '')\n        expected('space');\n    }\n\n    return tag;\n  };\n\n  var type;\n\n  var error = function (msg) {\n    scanner.fatal(msg);\n  };\n\n  var expected = function (what) {\n    error('Expected ' + what);\n  };\n\n  // must do ESCAPE first, immediately followed by ELSE\n  // order of others doesn't matter\n  if (run(starts.ESCAPE)) type = 'ESCAPE';\n  else if (run(starts.ELSE)) type = 'ELSE';\n  else if (run(starts.DOUBLE)) type = 'DOUBLE';\n  else if (run(starts.TRIPLE)) type = 'TRIPLE';\n  else if (run(starts.BLOCKCOMMENT)) type = 'BLOCKCOMMENT';\n  else if (run(starts.COMMENT)) type = 'COMMENT';\n  else if (run(starts.INCLUSION)) type = 'INCLUSION';\n  else if (run(starts.BLOCKOPEN)) type = 'BLOCKOPEN';\n  else if (run(starts.BLOCKCLOSE)) type = 'BLOCKCLOSE';\n  else\n    error('Unknown stache tag');\n\n  var tag = new TemplateTag;\n  tag.type = type;\n\n  if (type === 'BLOCKCOMMENT') {\n    var result = run(/^[\\s\\S]*?--\\s*?\\}\\}/);\n    if (! result)\n      error(\"Unclosed block comment\");\n    tag.value = result.slice(0, result.lastIndexOf('--'));\n  } else if (type === 'COMMENT') {\n    var result = run(/^[\\s\\S]*?\\}\\}/);\n    if (! result)\n      error(\"Unclosed comment\");\n    tag.value = result.slice(0, -2);\n  } else if (type === 'BLOCKCLOSE') {\n    tag.path = scanPath();\n    if (! run(ends.DOUBLE))\n      expected('`}}`');\n  } else if (type === 'ELSE') {\n    if (! run(ends.DOUBLE)) {\n      tag = scanExpr(type);\n    }\n  } else if (type === 'ESCAPE') {\n    var result = run(/^\\{*\\|/);\n    tag.value = '{{' + result.slice(0, -1);\n  } else {\n    // DOUBLE, TRIPLE, BLOCKOPEN, INCLUSION\n    tag = scanExpr(type);\n  }\n\n  return tag;\n};\n\n// Returns a SpacebarsCompiler.TemplateTag parsed from `scanner`, leaving scanner\n// at its original position.\n//\n// An error will still be thrown if there is not a valid template tag at\n// the current position.\nTemplateTag.peek = function (scanner) {\n  var startPos = scanner.pos;\n  var result = TemplateTag.parse(scanner);\n  scanner.pos = startPos;\n  return result;\n};\n\n// Like `TemplateTag.parse`, but in the case of blocks, parse the complete\n// `{{#foo}}...{{/foo}}` with `content` and possible `elseContent`, rather\n// than just the BLOCKOPEN tag.\n//\n// In addition:\n//\n// - Throws an error if `{{else}}` or `{{/foo}}` tag is encountered.\n//\n// - Returns `null` for a COMMENT.  (This case is distinguishable from\n//   parsing no tag by the fact that the scanner is advanced.)\n//\n// - Takes an HTMLTools.TEMPLATE_TAG_POSITION `position` and sets it as the\n//   TemplateTag's `.position` property.\n//\n// - Validates the tag's well-formedness and legality at in its position.\nTemplateTag.parseCompleteTag = function (scannerOrString, position) {\n  var scanner = scannerOrString;\n  if (typeof scanner === 'string')\n    scanner = new HTMLTools.Scanner(scannerOrString);\n\n  var startPos = scanner.pos; // for error messages\n  var result = TemplateTag.parse(scannerOrString);\n  if (! result)\n    return result;\n\n  if (result.type === 'BLOCKCOMMENT')\n    return null;\n\n  if (result.type === 'COMMENT')\n    return null;\n\n  if (result.type === 'ELSE')\n    scanner.fatal(\"Unexpected {{else}}\");\n\n  if (result.type === 'BLOCKCLOSE')\n    scanner.fatal(\"Unexpected closing template tag\");\n\n  position = (position || TEMPLATE_TAG_POSITION.ELEMENT);\n  if (position !== TEMPLATE_TAG_POSITION.ELEMENT)\n    result.position = position;\n\n  if (result.type === 'BLOCKOPEN') {\n    // parse block contents\n\n    // Construct a string version of `.path` for comparing start and\n    // end tags.  For example, `foo/[0]` was parsed into `[\"foo\", \"0\"]`\n    // and now becomes `foo,0`.  This form may also show up in error\n    // messages.\n    var blockName = result.path.join(',');\n\n    var textMode = null;\n      if (blockName === 'markdown' ||\n          position === TEMPLATE_TAG_POSITION.IN_RAWTEXT) {\n        textMode = HTML.TEXTMODE.STRING;\n      } else if (position === TEMPLATE_TAG_POSITION.IN_RCDATA ||\n                 position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n        textMode = HTML.TEXTMODE.RCDATA;\n      }\n      var parserOptions = {\n        getTemplateTag: TemplateTag.parseCompleteTag,\n        shouldStop: isAtBlockCloseOrElse,\n        textMode: textMode\n      };\n    result.textMode = textMode;\n    result.content = HTMLTools.parseFragment(scanner, parserOptions);\n\n    if (scanner.rest().slice(0, 2) !== '{{')\n      scanner.fatal(\"Expected {{else}} or block close for \" + blockName);\n\n    var lastPos = scanner.pos; // save for error messages\n    var tmplTag = TemplateTag.parse(scanner); // {{else}} or {{/foo}}\n\n    var lastElseContentTag = result;\n    while (tmplTag.type === 'ELSE') {\n      if (lastElseContentTag === null) {\n        scanner.fatal(\"Unexpected else after {{else}}\");\n      }\n\n      if (tmplTag.path) {\n        lastElseContentTag.elseContent = new TemplateTag;\n        lastElseContentTag.elseContent.type = 'BLOCKOPEN';\n        lastElseContentTag.elseContent.path = tmplTag.path;\n        lastElseContentTag.elseContent.args = tmplTag.args;\n        lastElseContentTag.elseContent.textMode = textMode;\n        lastElseContentTag.elseContent.content = HTMLTools.parseFragment(scanner, parserOptions);\n\n        lastElseContentTag = lastElseContentTag.elseContent;\n      }\n      else {\n        // parse {{else}} and content up to close tag\n        lastElseContentTag.elseContent = HTMLTools.parseFragment(scanner, parserOptions);\n\n        lastElseContentTag = null;\n      }\n\n      if (scanner.rest().slice(0, 2) !== '{{')\n        scanner.fatal(\"Expected block close for \" + blockName);\n\n      lastPos = scanner.pos;\n      tmplTag = TemplateTag.parse(scanner);\n    }\n\n    if (tmplTag.type === 'BLOCKCLOSE') {\n      var blockName2 = tmplTag.path.join(',');\n      if (blockName !== blockName2) {\n        scanner.pos = lastPos;\n        scanner.fatal('Expected tag to close ' + blockName + ', found ' +\n                      blockName2);\n      }\n    } else {\n      scanner.pos = lastPos;\n      scanner.fatal('Expected tag to close ' + blockName + ', found ' +\n                    tmplTag.type);\n    }\n  }\n\n  var finalPos = scanner.pos;\n  scanner.pos = startPos;\n  validateTag(result, scanner);\n  scanner.pos = finalPos;\n\n  return result;\n};\n\nvar isAtBlockCloseOrElse = function (scanner) {\n  // Detect `{{else}}` or `{{/foo}}`.\n  //\n  // We do as much work ourselves before deferring to `TemplateTag.peek`,\n  // for efficiency (we're called for every input token) and to be\n  // less obtrusive, because `TemplateTag.peek` will throw an error if it\n  // sees `{{` followed by a malformed tag.\n  var rest, type;\n  return (scanner.peek() === '{' &&\n          (rest = scanner.rest()).slice(0, 2) === '{{' &&\n          /^\\{\\{\\s*(\\/|else\\b)/.test(rest) &&\n          (type = TemplateTag.peek(scanner).type) &&\n          (type === 'BLOCKCLOSE' || type === 'ELSE'));\n};\n\n// Validate that `templateTag` is correctly formed and legal for its\n// HTML position.  Use `scanner` to report errors. On success, does\n// nothing.\nvar validateTag = function (ttag, scanner) {\n\n  if (ttag.type === 'INCLUSION' || ttag.type === 'BLOCKOPEN') {\n    var args = ttag.args;\n    if (ttag.path[0] === 'each' && args[1] && args[1][0] === 'PATH' &&\n        args[1][1][0] === 'in') {\n      // For slightly better error messages, we detect the each-in case\n      // here in order not to complain if the user writes `{{#each 3 in x}}`\n      // that \"3 is not a function\"\n    } else {\n      if (args.length > 1 && args[0].length === 2 && args[0][0] !== 'PATH') {\n        // we have a positional argument that is not a PATH followed by\n        // other arguments\n        scanner.fatal(\"First argument must be a function, to be called on \" +\n                      \"the rest of the arguments; found \" + args[0][0]);\n      }\n    }\n  }\n\n  var position = ttag.position || TEMPLATE_TAG_POSITION.ELEMENT;\n  if (position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n    if (ttag.type === 'DOUBLE' || ttag.type === 'ESCAPE') {\n      return;\n    } else if (ttag.type === 'BLOCKOPEN') {\n      var path = ttag.path;\n      var path0 = path[0];\n      if (! (path.length === 1 && (path0 === 'if' ||\n                                   path0 === 'unless' ||\n                                   path0 === 'with' ||\n                                   path0 === 'each'))) {\n        scanner.fatal(\"Custom block helpers are not allowed in an HTML attribute, only built-in ones like #each and #if\");\n      }\n    } else {\n      scanner.fatal(ttag.type + \" template tag is not allowed in an HTML attribute\");\n    }\n  } else if (position === TEMPLATE_TAG_POSITION.IN_START_TAG) {\n    if (! (ttag.type === 'DOUBLE')) {\n      scanner.fatal(\"Reactive HTML attributes must either have a constant name or consist of a single {{helper}} providing a dictionary of names and values.  A template tag of type \" + ttag.type + \" is not allowed here.\");\n    }\n    if (scanner.peek() === '=') {\n      scanner.fatal(\"Template tags are not allowed in attribute names, only in attribute values or in the form of a single {{helper}} that evaluates to a dictionary of name=value pairs.\");\n    }\n  }\n\n};\n","import { HTML } from 'meteor/htmljs';\nimport { TreeTransformer, toRaw } from './optimizer';\n\nfunction compactRaw(array){\n  var result = [];\n  for (var i = 0; i < array.length; i++) {\n    var item = array[i];\n    if (item instanceof HTML.Raw) {\n      if (!item.value) {\n        continue;\n      }\n      if (result.length &&\n          (result[result.length - 1] instanceof HTML.Raw)){\n        result[result.length - 1] = HTML.Raw(\n          result[result.length - 1].value + item.value);\n        continue\n      }\n    }\n    result.push(item);\n  }\n  return result;\n}\n\nfunction replaceIfContainsNewline(match) {\n  if (match.indexOf('\\n') >= 0) {\n    return ''\n  }\n  return match;\n}\n\nfunction stripWhitespace(array){\n  var result = [];\n  for (var i = 0; i < array.length; i++) {\n    var item = array[i];\n    if (item instanceof HTML.Raw) {\n      // remove nodes that contain only whitespace & a newline\n      if (item.value.indexOf('\\n') !== -1 && !/\\S/.test(item.value)) {\n        continue;\n      }\n      // Trim any preceding whitespace, if it contains a newline\n      var newStr = item.value;\n      newStr = newStr.replace(/^\\s+/, replaceIfContainsNewline);\n      newStr = newStr.replace(/\\s+$/, replaceIfContainsNewline);\n      item.value = newStr;\n    }\n    result.push(item)\n  }\n  return result;\n}\n\nvar WhitespaceRemovingVisitor = TreeTransformer.extend();\nWhitespaceRemovingVisitor.def({\n  visitNull: toRaw,\n  visitPrimitive: toRaw,\n  visitCharRef: toRaw,\n  visitArray: function(array){\n    // this.super(array)\n    var result = TreeTransformer.prototype.visitArray.call(this, array);\n    result = compactRaw(result);\n    result = stripWhitespace(result);\n    return result;\n  },\n  visitTag: function (tag) {\n    var tagName = tag.tagName;\n    // TODO - List tags that we don't want to strip whitespace for.\n    if (tagName === 'textarea' || tagName === 'script' || tagName === 'pre'\n      || !HTML.isKnownElement(tagName) || HTML.isKnownSVGElement(tagName)) {\n      return tag;\n    }\n    return TreeTransformer.prototype.visitTag.call(this, tag)\n  },\n  visitAttributes: function (attrs) {\n    return attrs;\n  }\n});\n\n\nexport function removeWhitespace(tree) {\n  tree = (new WhitespaceRemovingVisitor).visit(tree);\n  return tree;\n}\n"]}}]