[{"type":"js","data":"/* Imports for global scope */\n\nMongoInternals = Package.mongo.MongoInternals;\nMongo = Package.mongo.Mongo;\nTracker = Package.tracker.Tracker;\nDeps = Package.tracker.Deps;\nLog = Package.logging.Log;\nRandom = Package.random.Random;\nEJSON = Package.ejson.EJSON;\nSpacebars = Package.spacebars.Spacebars;\ncheck = Package.check.check;\nMatch = Package.check.Match;\nECMAScript = Package.ecmascript.ECMAScript;\nSortable = Package['rubaxa:sortable'].Sortable;\ns = Package['underscorestring:underscore.string'].s;\nTemplate = Package['meteorhacks:ssr'].Template;\nSSR = Package['meteorhacks:ssr'].SSR;\n_ = Package.underscore._;\nSpacebarsCompiler = Package['spacebars-compiler'].SpacebarsCompiler;\nMeteor = Package.meteor.Meteor;\nglobal = Package.meteor.global;\nmeteorEnv = Package.meteor.meteorEnv;\nWebApp = Package.webapp.WebApp;\nWebAppInternals = Package.webapp.WebAppInternals;\nmain = Package.webapp.main;\nDDP = Package['ddp-client'].DDP;\nDDPServer = Package['ddp-server'].DDPServer;\nLaunchScreen = Package['launch-screen'].LaunchScreen;\nBlaze = Package.ui.Blaze;\nUI = Package.ui.UI;\nHandlebars = Package.ui.Handlebars;\nmeteorInstall = Package.modules.meteorInstall;\nPromise = Package.promise.Promise;\nAsync = Package['meteorhacks:async'].Async;\nAutoupdate = Package.autoupdate.Autoupdate;\nHTML = Package.htmljs.HTML;\n\n","servePath":"/global-imports.js"},{"type":"js","data":"var require = meteorInstall({\"lib\":{\"external\":{\"convnet\":{\"1.1.0\":{\"convnet.js\":function module(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/external/convnet/1.1.0/convnet.js                                                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar convnetjs = convnetjs || {\n  REVISION: 'ALPHA'\n};\n\n(function (global) {\n  \"use strict\"; // Random number utilities\n\n  var return_v = false;\n  var v_val = 0.0;\n\n  var gaussRandom = function () {\n    if (return_v) {\n      return_v = false;\n      return v_val;\n    }\n\n    var u = 2 * Math.random() - 1;\n    var v = 2 * Math.random() - 1;\n    var r = u * u + v * v;\n    if (r == 0 || r > 1) return gaussRandom();\n    var c = Math.sqrt(-2 * Math.log(r) / r);\n    v_val = v * c; // cache this\n\n    return_v = true;\n    return u * c;\n  };\n\n  var randf = function (a, b) {\n    return Math.random() * (b - a) + a;\n  };\n\n  var randi = function (a, b) {\n    return Math.floor(Math.random() * (b - a) + a);\n  };\n\n  var randn = function (mu, std) {\n    return mu + gaussRandom() * std;\n  }; // Array utilities\n\n\n  var zeros = function (n) {\n    if (typeof n === 'undefined' || isNaN(n)) {\n      return [];\n    }\n\n    if (typeof ArrayBuffer === 'undefined') {\n      // lacking browser support\n      var arr = new Array(n);\n\n      for (var i = 0; i < n; i++) {\n        arr[i] = 0;\n      }\n\n      return arr;\n    } else {\n      return new Float64Array(n);\n    }\n  };\n\n  var arrContains = function (arr, elt) {\n    for (var i = 0, n = arr.length; i < n; i++) {\n      if (arr[i] === elt) return true;\n    }\n\n    return false;\n  };\n\n  var arrUnique = function (arr) {\n    var b = [];\n\n    for (var i = 0, n = arr.length; i < n; i++) {\n      if (!arrContains(b, arr[i])) {\n        b.push(arr[i]);\n      }\n    }\n\n    return b;\n  }; // return max and min of a given non-empty array.\n\n\n  var maxmin = function (w) {\n    if (w.length === 0) {\n      return {};\n    } // ... ;s\n\n\n    var maxv = w[0];\n    var minv = w[0];\n    var maxi = 0;\n    var mini = 0;\n    var n = w.length;\n\n    for (var i = 1; i < n; i++) {\n      if (w[i] > maxv) {\n        maxv = w[i];\n        maxi = i;\n      }\n\n      if (w[i] < minv) {\n        minv = w[i];\n        mini = i;\n      }\n    }\n\n    return {\n      maxi: maxi,\n      maxv: maxv,\n      mini: mini,\n      minv: minv,\n      dv: maxv - minv\n    };\n  }; // create random permutation of numbers, in range [0...n-1]\n\n\n  var randperm = function (n) {\n    var i = n,\n        j = 0,\n        temp;\n    var array = [];\n\n    for (var q = 0; q < n; q++) array[q] = q;\n\n    while (i--) {\n      j = Math.floor(Math.random() * (i + 1));\n      temp = array[i];\n      array[i] = array[j];\n      array[j] = temp;\n    }\n\n    return array;\n  }; // sample from list lst according to probabilities in list probs\n  // the two lists are of same size, and probs adds up to 1\n\n\n  var weightedSample = function (lst, probs) {\n    var p = randf(0, 1.0);\n    var cumprob = 0.0;\n\n    for (var k = 0, n = lst.length; k < n; k++) {\n      cumprob += probs[k];\n\n      if (p < cumprob) {\n        return lst[k];\n      }\n    }\n  }; // syntactic sugar function for getting default parameter values\n\n\n  var getopt = function (opt, field_name, default_value) {\n    return typeof opt[field_name] !== 'undefined' ? opt[field_name] : default_value;\n  };\n\n  global.randf = randf;\n  global.randi = randi;\n  global.randn = randn;\n  global.zeros = zeros;\n  global.maxmin = maxmin;\n  global.randperm = randperm;\n  global.weightedSample = weightedSample;\n  global.arrUnique = arrUnique;\n  global.arrContains = arrContains;\n  global.getopt = getopt;\n})(convnetjs);\n\n(function (global) {\n  \"use strict\"; // Vol is the basic building block of all data in a net.\n  // it is essentially just a 3D volume of numbers, with a\n  // width (sx), height (sy), and depth (depth).\n  // it is used to hold data for all filters, all volumes,\n  // all weights, and also stores all gradients w.r.t. \n  // the data. c is optionally a value to initialize the volume\n  // with. If c is missing, fills the Vol with random numbers.\n\n  var Vol = function (sx, sy, depth, c) {\n    // this is how you check if a variable is an array. Oh, Javascript :)\n    if (Object.prototype.toString.call(sx) === '[object Array]') {\n      // we were given a list in sx, assume 1D volume and fill it up\n      this.sx = 1;\n      this.sy = 1;\n      this.depth = sx.length; // we have to do the following copy because we want to use\n      // fast typed arrays, not an ordinary javascript array\n\n      this.w = global.zeros(this.depth);\n      this.dw = global.zeros(this.depth);\n\n      for (var i = 0; i < this.depth; i++) {\n        this.w[i] = sx[i];\n      }\n    } else {\n      // we were given dimensions of the vol\n      this.sx = sx;\n      this.sy = sy;\n      this.depth = depth;\n      var n = sx * sy * depth;\n      this.w = global.zeros(n);\n      this.dw = global.zeros(n);\n\n      if (typeof c === 'undefined') {\n        // weight normalization is done to equalize the output\n        // variance of every neuron, otherwise neurons with a lot\n        // of incoming connections have outputs of larger variance\n        var scale = Math.sqrt(1.0 / (sx * sy * depth));\n\n        for (var i = 0; i < n; i++) {\n          this.w[i] = global.randn(0.0, scale);\n        }\n      } else {\n        for (var i = 0; i < n; i++) {\n          this.w[i] = c;\n        }\n      }\n    }\n  };\n\n  Vol.prototype = {\n    get: function (x, y, d) {\n      var ix = (this.sx * y + x) * this.depth + d;\n      return this.w[ix];\n    },\n    set: function (x, y, d, v) {\n      var ix = (this.sx * y + x) * this.depth + d;\n      this.w[ix] = v;\n    },\n    add: function (x, y, d, v) {\n      var ix = (this.sx * y + x) * this.depth + d;\n      this.w[ix] += v;\n    },\n    get_grad: function (x, y, d) {\n      var ix = (this.sx * y + x) * this.depth + d;\n      return this.dw[ix];\n    },\n    set_grad: function (x, y, d, v) {\n      var ix = (this.sx * y + x) * this.depth + d;\n      this.dw[ix] = v;\n    },\n    add_grad: function (x, y, d, v) {\n      var ix = (this.sx * y + x) * this.depth + d;\n      this.dw[ix] += v;\n    },\n    cloneAndZero: function () {\n      return new Vol(this.sx, this.sy, this.depth, 0.0);\n    },\n    clone: function () {\n      var V = new Vol(this.sx, this.sy, this.depth, 0.0);\n      var n = this.w.length;\n\n      for (var i = 0; i < n; i++) {\n        V.w[i] = this.w[i];\n      }\n\n      return V;\n    },\n    addFrom: function (V) {\n      for (var k = 0; k < this.w.length; k++) {\n        this.w[k] += V.w[k];\n      }\n    },\n    addFromScaled: function (V, a) {\n      for (var k = 0; k < this.w.length; k++) {\n        this.w[k] += a * V.w[k];\n      }\n    },\n    setConst: function (a) {\n      for (var k = 0; k < this.w.length; k++) {\n        this.w[k] = a;\n      }\n    },\n    toJSON: function () {\n      // todo: we may want to only save d most significant digits to save space\n      var json = {};\n      json.sx = this.sx;\n      json.sy = this.sy;\n      json.depth = this.depth;\n      json.w = this.w;\n      return json; // we wont back up gradients to save space\n    },\n    fromJSON: function (json) {\n      this.sx = json.sx;\n      this.sy = json.sy;\n      this.depth = json.depth;\n      var n = this.sx * this.sy * this.depth;\n      this.w = global.zeros(n);\n      this.dw = global.zeros(n); // copy over the elements.\n\n      for (var i = 0; i < n; i++) {\n        this.w[i] = json.w[i];\n      }\n    }\n  };\n  global.Vol = Vol;\n})(convnetjs);\n\n(function (global) {\n  \"use strict\";\n\n  var Vol = global.Vol; // convenience\n  // Volume utilities\n  // intended for use with data augmentation\n  // crop is the size of output\n  // dx,dy are offset wrt incoming volume, of the shift\n  // fliplr is boolean on whether we also want to flip left<->right\n\n  var augment = function (V, crop, dx, dy, fliplr) {\n    // note assumes square outputs of size crop x crop\n    if (typeof fliplr === 'undefined') var fliplr = false;\n    if (typeof dx === 'undefined') var dx = global.randi(0, V.sx - crop);\n    if (typeof dy === 'undefined') var dy = global.randi(0, V.sy - crop); // randomly sample a crop in the input volume\n\n    var W;\n\n    if (crop !== V.sx || dx !== 0 || dy !== 0) {\n      W = new Vol(crop, crop, V.depth, 0.0);\n\n      for (var x = 0; x < crop; x++) {\n        for (var y = 0; y < crop; y++) {\n          if (x + dx < 0 || x + dx >= V.sx || y + dy < 0 || y + dy >= V.sy) continue; // oob\n\n          for (var d = 0; d < V.depth; d++) {\n            W.set(x, y, d, V.get(x + dx, y + dy, d)); // copy data over\n          }\n        }\n      }\n    } else {\n      W = V;\n    }\n\n    if (fliplr) {\n      // flip volume horziontally\n      var W2 = W.cloneAndZero();\n\n      for (var x = 0; x < W.sx; x++) {\n        for (var y = 0; y < W.sy; y++) {\n          for (var d = 0; d < W.depth; d++) {\n            W2.set(x, y, d, W.get(W.sx - x - 1, y, d)); // copy data over\n          }\n        }\n      }\n\n      W = W2; //swap\n    }\n\n    return W;\n  }; // img is a DOM element that contains a loaded image\n  // returns a Vol of size (W, H, 4). 4 is for RGBA\n\n\n  var img_to_vol = function (img, convert_grayscale) {\n    if (typeof convert_grayscale === 'undefined') var convert_grayscale = false;\n    var canvas = document.createElement('canvas');\n    canvas.width = img.width;\n    canvas.height = img.height;\n    var ctx = canvas.getContext(\"2d\"); // due to a Firefox bug\n\n    try {\n      ctx.drawImage(img, 0, 0);\n    } catch (e) {\n      if (e.name === \"NS_ERROR_NOT_AVAILABLE\") {\n        // sometimes happens, lets just abort\n        return false;\n      } else {\n        throw e;\n      }\n    }\n\n    try {\n      var img_data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    } catch (e) {\n      if (e.name === 'IndexSizeError') {\n        return false; // not sure what causes this sometimes but okay abort\n      } else {\n        throw e;\n      }\n    } // prepare the input: get pixels and normalize them\n\n\n    var p = img_data.data;\n    var W = img.width;\n    var H = img.height;\n    var pv = [];\n\n    for (var i = 0; i < p.length; i++) {\n      pv.push(p[i] / 255.0 - 0.5); // normalize image pixels to [-0.5, 0.5]\n    }\n\n    var x = new Vol(W, H, 4, 0.0); //input volume (image)\n\n    x.w = pv;\n\n    if (convert_grayscale) {\n      // flatten into depth=1 array\n      var x1 = new Vol(W, H, 1, 0.0);\n\n      for (var i = 0; i < W; i++) {\n        for (var j = 0; j < H; j++) {\n          x1.set(i, j, 0, x.get(i, j, 0));\n        }\n      }\n\n      x = x1;\n    }\n\n    return x;\n  };\n\n  global.augment = augment;\n  global.img_to_vol = img_to_vol;\n})(convnetjs);\n\n(function (global) {\n  \"use strict\";\n\n  var Vol = global.Vol; // convenience\n  // This file contains all layers that do dot products with input,\n  // but usually in a different connectivity pattern and weight sharing\n  // schemes: \n  // - FullyConn is fully connected dot products \n  // - ConvLayer does convolutions (so weight sharing spatially)\n  // putting them together in one file because they are very similar\n\n  var ConvLayer = function (opt) {\n    var opt = opt || {}; // required\n\n    this.out_depth = opt.filters;\n    this.sx = opt.sx; // filter size. Should be odd if possible, it's cleaner.\n\n    this.in_depth = opt.in_depth;\n    this.in_sx = opt.in_sx;\n    this.in_sy = opt.in_sy; // optional\n\n    this.sy = typeof opt.sy !== 'undefined' ? opt.sy : this.sx;\n    this.stride = typeof opt.stride !== 'undefined' ? opt.stride : 1; // stride at which we apply filters to input volume\n\n    this.pad = typeof opt.pad !== 'undefined' ? opt.pad : 0; // amount of 0 padding to add around borders of input volume\n\n    this.l1_decay_mul = typeof opt.l1_decay_mul !== 'undefined' ? opt.l1_decay_mul : 0.0;\n    this.l2_decay_mul = typeof opt.l2_decay_mul !== 'undefined' ? opt.l2_decay_mul : 1.0; // computed\n    // note we are doing floor, so if the strided convolution of the filter doesnt fit into the input\n    // volume exactly, the output volume will be trimmed and not contain the (incomplete) computed\n    // final application.\n\n    this.out_sx = Math.floor((this.in_sx + this.pad * 2 - this.sx) / this.stride + 1);\n    this.out_sy = Math.floor((this.in_sy + this.pad * 2 - this.sy) / this.stride + 1);\n    this.layer_type = 'conv'; // initializations\n\n    var bias = typeof opt.bias_pref !== 'undefined' ? opt.bias_pref : 0.0;\n    this.filters = [];\n\n    for (var i = 0; i < this.out_depth; i++) {\n      this.filters.push(new Vol(this.sx, this.sy, this.in_depth));\n    }\n\n    this.biases = new Vol(1, 1, this.out_depth, bias);\n  };\n\n  ConvLayer.prototype = {\n    forward: function (V, is_training) {\n      // optimized code by @mdda that achieves 2x speedup over previous version\n      this.in_act = V;\n      var A = new Vol(this.out_sx | 0, this.out_sy | 0, this.out_depth | 0, 0.0);\n      var V_sx = V.sx | 0;\n      var V_sy = V.sy | 0;\n      var xy_stride = this.stride | 0;\n\n      for (var d = 0; d < this.out_depth; d++) {\n        var f = this.filters[d];\n        var x = -this.pad | 0;\n        var y = -this.pad | 0;\n\n        for (var ay = 0; ay < this.out_sy; y += xy_stride, ay++) {\n          // xy_stride\n          x = -this.pad | 0;\n\n          for (var ax = 0; ax < this.out_sx; x += xy_stride, ax++) {\n            // xy_stride\n            // convolve centered at this particular location\n            var a = 0.0;\n\n            for (var fy = 0; fy < f.sy; fy++) {\n              var oy = y + fy; // coordinates in the original input array coordinates\n\n              for (var fx = 0; fx < f.sx; fx++) {\n                var ox = x + fx;\n\n                if (oy >= 0 && oy < V_sy && ox >= 0 && ox < V_sx) {\n                  for (var fd = 0; fd < f.depth; fd++) {\n                    // avoid function call overhead (x2) for efficiency, compromise modularity :(\n                    a += f.w[(f.sx * fy + fx) * f.depth + fd] * V.w[(V_sx * oy + ox) * V.depth + fd];\n                  }\n                }\n              }\n            }\n\n            a += this.biases.w[d];\n            A.set(ax, ay, d, a);\n          }\n        }\n      }\n\n      this.out_act = A;\n      return this.out_act;\n    },\n    backward: function () {\n      var V = this.in_act;\n      V.dw = global.zeros(V.w.length); // zero out gradient wrt bottom data, we're about to fill it\n\n      var V_sx = V.sx | 0;\n      var V_sy = V.sy | 0;\n      var xy_stride = this.stride | 0;\n\n      for (var d = 0; d < this.out_depth; d++) {\n        var f = this.filters[d];\n        var x = -this.pad | 0;\n        var y = -this.pad | 0;\n\n        for (var ay = 0; ay < this.out_sy; y += xy_stride, ay++) {\n          // xy_stride\n          x = -this.pad | 0;\n\n          for (var ax = 0; ax < this.out_sx; x += xy_stride, ax++) {\n            // xy_stride\n            // convolve centered at this particular location\n            var chain_grad = this.out_act.get_grad(ax, ay, d); // gradient from above, from chain rule\n\n            for (var fy = 0; fy < f.sy; fy++) {\n              var oy = y + fy; // coordinates in the original input array coordinates\n\n              for (var fx = 0; fx < f.sx; fx++) {\n                var ox = x + fx;\n\n                if (oy >= 0 && oy < V_sy && ox >= 0 && ox < V_sx) {\n                  for (var fd = 0; fd < f.depth; fd++) {\n                    // avoid function call overhead (x2) for efficiency, compromise modularity :(\n                    var ix1 = (V_sx * oy + ox) * V.depth + fd;\n                    var ix2 = (f.sx * fy + fx) * f.depth + fd;\n                    f.dw[ix2] += V.w[ix1] * chain_grad;\n                    V.dw[ix1] += f.w[ix2] * chain_grad;\n                  }\n                }\n              }\n            }\n\n            this.biases.dw[d] += chain_grad;\n          }\n        }\n      }\n    },\n    getParamsAndGrads: function () {\n      var response = [];\n\n      for (var i = 0; i < this.out_depth; i++) {\n        response.push({\n          params: this.filters[i].w,\n          grads: this.filters[i].dw,\n          l2_decay_mul: this.l2_decay_mul,\n          l1_decay_mul: this.l1_decay_mul\n        });\n      }\n\n      response.push({\n        params: this.biases.w,\n        grads: this.biases.dw,\n        l1_decay_mul: 0.0,\n        l2_decay_mul: 0.0\n      });\n      return response;\n    },\n    toJSON: function () {\n      var json = {};\n      json.sx = this.sx; // filter size in x, y dims\n\n      json.sy = this.sy;\n      json.stride = this.stride;\n      json.in_depth = this.in_depth;\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      json.l1_decay_mul = this.l1_decay_mul;\n      json.l2_decay_mul = this.l2_decay_mul;\n      json.pad = this.pad;\n      json.filters = [];\n\n      for (var i = 0; i < this.filters.length; i++) {\n        json.filters.push(this.filters[i].toJSON());\n      }\n\n      json.biases = this.biases.toJSON();\n      return json;\n    },\n    fromJSON: function (json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n      this.sx = json.sx; // filter size in x, y dims\n\n      this.sy = json.sy;\n      this.stride = json.stride;\n      this.in_depth = json.in_depth; // depth of input volume\n\n      this.filters = [];\n      this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;\n      this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;\n      this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;\n\n      for (var i = 0; i < json.filters.length; i++) {\n        var v = new Vol(0, 0, 0, 0);\n        v.fromJSON(json.filters[i]);\n        this.filters.push(v);\n      }\n\n      this.biases = new Vol(0, 0, 0, 0);\n      this.biases.fromJSON(json.biases);\n    }\n  };\n\n  var FullyConnLayer = function (opt) {\n    var opt = opt || {}; // required\n    // ok fine we will allow 'filters' as the word as well\n\n    this.out_depth = typeof opt.num_neurons !== 'undefined' ? opt.num_neurons : opt.filters; // optional \n\n    this.l1_decay_mul = typeof opt.l1_decay_mul !== 'undefined' ? opt.l1_decay_mul : 0.0;\n    this.l2_decay_mul = typeof opt.l2_decay_mul !== 'undefined' ? opt.l2_decay_mul : 1.0; // computed\n\n    this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;\n    this.out_sx = 1;\n    this.out_sy = 1;\n    this.layer_type = 'fc'; // initializations\n\n    var bias = typeof opt.bias_pref !== 'undefined' ? opt.bias_pref : 0.0;\n    this.filters = [];\n\n    for (var i = 0; i < this.out_depth; i++) {\n      this.filters.push(new Vol(1, 1, this.num_inputs));\n    }\n\n    this.biases = new Vol(1, 1, this.out_depth, bias);\n  };\n\n  FullyConnLayer.prototype = {\n    forward: function (V, is_training) {\n      this.in_act = V;\n      var A = new Vol(1, 1, this.out_depth, 0.0);\n      var Vw = V.w;\n\n      for (var i = 0; i < this.out_depth; i++) {\n        var a = 0.0;\n        var wi = this.filters[i].w;\n\n        for (var d = 0; d < this.num_inputs; d++) {\n          a += Vw[d] * wi[d]; // for efficiency use Vols directly for now\n        }\n\n        a += this.biases.w[i];\n        A.w[i] = a;\n      }\n\n      this.out_act = A;\n      return this.out_act;\n    },\n    backward: function () {\n      var V = this.in_act;\n      V.dw = global.zeros(V.w.length); // zero out the gradient in input Vol\n      // compute gradient wrt weights and data\n\n      for (var i = 0; i < this.out_depth; i++) {\n        var tfi = this.filters[i];\n        var chain_grad = this.out_act.dw[i];\n\n        for (var d = 0; d < this.num_inputs; d++) {\n          V.dw[d] += tfi.w[d] * chain_grad; // grad wrt input data\n\n          tfi.dw[d] += V.w[d] * chain_grad; // grad wrt params\n        }\n\n        this.biases.dw[i] += chain_grad;\n      }\n    },\n    getParamsAndGrads: function () {\n      var response = [];\n\n      for (var i = 0; i < this.out_depth; i++) {\n        response.push({\n          params: this.filters[i].w,\n          grads: this.filters[i].dw,\n          l1_decay_mul: this.l1_decay_mul,\n          l2_decay_mul: this.l2_decay_mul\n        });\n      }\n\n      response.push({\n        params: this.biases.w,\n        grads: this.biases.dw,\n        l1_decay_mul: 0.0,\n        l2_decay_mul: 0.0\n      });\n      return response;\n    },\n    toJSON: function () {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      json.num_inputs = this.num_inputs;\n      json.l1_decay_mul = this.l1_decay_mul;\n      json.l2_decay_mul = this.l2_decay_mul;\n      json.filters = [];\n\n      for (var i = 0; i < this.filters.length; i++) {\n        json.filters.push(this.filters[i].toJSON());\n      }\n\n      json.biases = this.biases.toJSON();\n      return json;\n    },\n    fromJSON: function (json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n      this.num_inputs = json.num_inputs;\n      this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;\n      this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;\n      this.filters = [];\n\n      for (var i = 0; i < json.filters.length; i++) {\n        var v = new Vol(0, 0, 0, 0);\n        v.fromJSON(json.filters[i]);\n        this.filters.push(v);\n      }\n\n      this.biases = new Vol(0, 0, 0, 0);\n      this.biases.fromJSON(json.biases);\n    }\n  };\n  global.ConvLayer = ConvLayer;\n  global.FullyConnLayer = FullyConnLayer;\n})(convnetjs);\n\n(function (global) {\n  \"use strict\";\n\n  var Vol = global.Vol; // convenience\n\n  var PoolLayer = function (opt) {\n    var opt = opt || {}; // required\n\n    this.sx = opt.sx; // filter size\n\n    this.in_depth = opt.in_depth;\n    this.in_sx = opt.in_sx;\n    this.in_sy = opt.in_sy; // optional\n\n    this.sy = typeof opt.sy !== 'undefined' ? opt.sy : this.sx;\n    this.stride = typeof opt.stride !== 'undefined' ? opt.stride : 2;\n    this.pad = typeof opt.pad !== 'undefined' ? opt.pad : 0; // amount of 0 padding to add around borders of input volume\n    // computed\n\n    this.out_depth = this.in_depth;\n    this.out_sx = Math.floor((this.in_sx + this.pad * 2 - this.sx) / this.stride + 1);\n    this.out_sy = Math.floor((this.in_sy + this.pad * 2 - this.sy) / this.stride + 1);\n    this.layer_type = 'pool'; // store switches for x,y coordinates for where the max comes from, for each output neuron\n\n    this.switchx = global.zeros(this.out_sx * this.out_sy * this.out_depth);\n    this.switchy = global.zeros(this.out_sx * this.out_sy * this.out_depth);\n  };\n\n  PoolLayer.prototype = {\n    forward: function (V, is_training) {\n      this.in_act = V;\n      var A = new Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);\n      var n = 0; // a counter for switches\n\n      for (var d = 0; d < this.out_depth; d++) {\n        var x = -this.pad;\n        var y = -this.pad;\n\n        for (var ax = 0; ax < this.out_sx; x += this.stride, ax++) {\n          y = -this.pad;\n\n          for (var ay = 0; ay < this.out_sy; y += this.stride, ay++) {\n            // convolve centered at this particular location\n            var a = -99999; // hopefully small enough ;\\\n\n            var winx = -1,\n                winy = -1;\n\n            for (var fx = 0; fx < this.sx; fx++) {\n              for (var fy = 0; fy < this.sy; fy++) {\n                var oy = y + fy;\n                var ox = x + fx;\n\n                if (oy >= 0 && oy < V.sy && ox >= 0 && ox < V.sx) {\n                  var v = V.get(ox, oy, d); // perform max pooling and store pointers to where\n                  // the max came from. This will speed up backprop \n                  // and can help make nice visualizations in future\n\n                  if (v > a) {\n                    a = v;\n                    winx = ox;\n                    winy = oy;\n                  }\n                }\n              }\n            }\n\n            this.switchx[n] = winx;\n            this.switchy[n] = winy;\n            n++;\n            A.set(ax, ay, d, a);\n          }\n        }\n      }\n\n      this.out_act = A;\n      return this.out_act;\n    },\n    backward: function () {\n      // pooling layers have no parameters, so simply compute \n      // gradient wrt data here\n      var V = this.in_act;\n      V.dw = global.zeros(V.w.length); // zero out gradient wrt data\n\n      var A = this.out_act; // computed in forward pass \n\n      var n = 0;\n\n      for (var d = 0; d < this.out_depth; d++) {\n        var x = -this.pad;\n        var y = -this.pad;\n\n        for (var ax = 0; ax < this.out_sx; x += this.stride, ax++) {\n          y = -this.pad;\n\n          for (var ay = 0; ay < this.out_sy; y += this.stride, ay++) {\n            var chain_grad = this.out_act.get_grad(ax, ay, d);\n            V.add_grad(this.switchx[n], this.switchy[n], d, chain_grad);\n            n++;\n          }\n        }\n      }\n    },\n    getParamsAndGrads: function () {\n      return [];\n    },\n    toJSON: function () {\n      var json = {};\n      json.sx = this.sx;\n      json.sy = this.sy;\n      json.stride = this.stride;\n      json.in_depth = this.in_depth;\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      json.pad = this.pad;\n      return json;\n    },\n    fromJSON: function (json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n      this.sx = json.sx;\n      this.sy = json.sy;\n      this.stride = json.stride;\n      this.in_depth = json.in_depth;\n      this.pad = typeof json.pad !== 'undefined' ? json.pad : 0; // backwards compatibility\n\n      this.switchx = global.zeros(this.out_sx * this.out_sy * this.out_depth); // need to re-init these appropriately\n\n      this.switchy = global.zeros(this.out_sx * this.out_sy * this.out_depth);\n    }\n  };\n  global.PoolLayer = PoolLayer;\n})(convnetjs);\n\n(function (global) {\n  \"use strict\";\n\n  var Vol = global.Vol; // convenience\n\n  var InputLayer = function (opt) {\n    var opt = opt || {}; // this is a bit silly but lets allow people to specify either ins or outs\n\n    this.out_sx = typeof opt.out_sx !== 'undefined' ? opt.out_sx : opt.in_sx;\n    this.out_sy = typeof opt.out_sy !== 'undefined' ? opt.out_sy : opt.in_sy;\n    this.out_depth = typeof opt.out_depth !== 'undefined' ? opt.out_depth : opt.in_depth;\n    this.layer_type = 'input';\n  };\n\n  InputLayer.prototype = {\n    forward: function (V, is_training) {\n      this.in_act = V;\n      this.out_act = V;\n      return this.out_act; // dummy identity function for now\n    },\n    backward: function () {},\n    getParamsAndGrads: function () {\n      return [];\n    },\n    toJSON: function () {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      return json;\n    },\n    fromJSON: function (json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n    }\n  };\n  global.InputLayer = InputLayer;\n})(convnetjs);\n\n(function (global) {\n  \"use strict\";\n\n  var Vol = global.Vol; // convenience\n  // Layers that implement a loss. Currently these are the layers that \n  // can initiate a backward() pass. In future we probably want a more \n  // flexible system that can accomodate multiple losses to do multi-task\n  // learning, and stuff like that. But for now, one of the layers in this\n  // file must be the final layer in a Net.\n  // This is a classifier, with N discrete classes from 0 to N-1\n  // it gets a stream of N incoming numbers and computes the softmax\n  // function (exponentiate and normalize to sum to 1 as probabilities should)\n\n  var SoftmaxLayer = function (opt) {\n    var opt = opt || {}; // computed\n\n    this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;\n    this.out_depth = this.num_inputs;\n    this.out_sx = 1;\n    this.out_sy = 1;\n    this.layer_type = 'softmax';\n  };\n\n  SoftmaxLayer.prototype = {\n    forward: function (V, is_training) {\n      this.in_act = V;\n      var A = new Vol(1, 1, this.out_depth, 0.0); // compute max activation\n\n      var as = V.w;\n      var amax = V.w[0];\n\n      for (var i = 1; i < this.out_depth; i++) {\n        if (as[i] > amax) amax = as[i];\n      } // compute exponentials (carefully to not blow up)\n\n\n      var es = global.zeros(this.out_depth);\n      var esum = 0.0;\n\n      for (var i = 0; i < this.out_depth; i++) {\n        var e = Math.exp(as[i] - amax);\n        esum += e;\n        es[i] = e;\n      } // normalize and output to sum to one\n\n\n      for (var i = 0; i < this.out_depth; i++) {\n        es[i] /= esum;\n        A.w[i] = es[i];\n      }\n\n      this.es = es; // save these for backprop\n\n      this.out_act = A;\n      return this.out_act;\n    },\n    backward: function (y) {\n      // compute and accumulate gradient wrt weights and bias of this layer\n      var x = this.in_act;\n      x.dw = global.zeros(x.w.length); // zero out the gradient of input Vol\n\n      for (var i = 0; i < this.out_depth; i++) {\n        var indicator = i === y ? 1.0 : 0.0;\n        var mul = -(indicator - this.es[i]);\n        x.dw[i] = mul;\n      } // loss is the class negative log likelihood\n\n\n      return -Math.log(this.es[y]);\n    },\n    getParamsAndGrads: function () {\n      return [];\n    },\n    toJSON: function () {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      json.num_inputs = this.num_inputs;\n      return json;\n    },\n    fromJSON: function (json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n      this.num_inputs = json.num_inputs;\n    }\n  }; // implements an L2 regression cost layer,\n  // so penalizes \\sum_i(||x_i - y_i||^2), where x is its input\n  // and y is the user-provided array of \"correct\" values.\n\n  var RegressionLayer = function (opt) {\n    var opt = opt || {}; // computed\n\n    this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;\n    this.out_depth = this.num_inputs;\n    this.out_sx = 1;\n    this.out_sy = 1;\n    this.layer_type = 'regression';\n  };\n\n  RegressionLayer.prototype = {\n    forward: function (V, is_training) {\n      this.in_act = V;\n      this.out_act = V;\n      return V; // identity function\n    },\n    // y is a list here of size num_inputs\n    backward: function (y) {\n      // compute and accumulate gradient wrt weights and bias of this layer\n      var x = this.in_act;\n      x.dw = global.zeros(x.w.length); // zero out the gradient of input Vol\n\n      var loss = 0.0;\n\n      if (y instanceof Array || y instanceof Float64Array) {\n        for (var i = 0; i < this.out_depth; i++) {\n          var dy = x.w[i] - y[i];\n          x.dw[i] = dy;\n          loss += 2 * dy * dy;\n        }\n      } else {\n        // assume it is a struct with entries .dim and .val\n        // and we pass gradient only along dimension dim to be equal to val\n        var i = y.dim;\n        var yi = y.val;\n        var dy = x.w[i] - yi;\n        x.dw[i] = dy;\n        loss += 2 * dy * dy;\n      }\n\n      return loss;\n    },\n    getParamsAndGrads: function () {\n      return [];\n    },\n    toJSON: function () {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      json.num_inputs = this.num_inputs;\n      return json;\n    },\n    fromJSON: function (json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n      this.num_inputs = json.num_inputs;\n    }\n  };\n\n  var SVMLayer = function (opt) {\n    var opt = opt || {}; // computed\n\n    this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;\n    this.out_depth = this.num_inputs;\n    this.out_sx = 1;\n    this.out_sy = 1;\n    this.layer_type = 'svm';\n  };\n\n  SVMLayer.prototype = {\n    forward: function (V, is_training) {\n      this.in_act = V;\n      this.out_act = V; // nothing to do, output raw scores\n\n      return V;\n    },\n    backward: function (y) {\n      // compute and accumulate gradient wrt weights and bias of this layer\n      var x = this.in_act;\n      x.dw = global.zeros(x.w.length); // zero out the gradient of input Vol\n\n      var yscore = x.w[y]; // score of ground truth\n\n      var margin = 1.0;\n      var loss = 0.0;\n\n      for (var i = 0; i < this.out_depth; i++) {\n        if (-yscore + x.w[i] + margin > 0) {\n          // violating example, apply loss\n          // I love hinge loss, by the way. Truly.\n          // Seriously, compare this SVM code with Softmax forward AND backprop code above\n          // it's clear which one is superior, not only in code, simplicity\n          // and beauty, but also in practice.\n          x.dw[i] += 1;\n          x.dw[y] -= 1;\n          loss += -yscore + x.w[i] + margin;\n        }\n      }\n\n      return loss;\n    },\n    getParamsAndGrads: function () {\n      return [];\n    },\n    toJSON: function () {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      json.num_inputs = this.num_inputs;\n      return json;\n    },\n    fromJSON: function (json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n      this.num_inputs = json.num_inputs;\n    }\n  };\n  global.RegressionLayer = RegressionLayer;\n  global.SoftmaxLayer = SoftmaxLayer;\n  global.SVMLayer = SVMLayer;\n})(convnetjs);\n\n(function (global) {\n  \"use strict\";\n\n  var Vol = global.Vol; // convenience\n  // Implements ReLU nonlinearity elementwise\n  // x -> max(0, x)\n  // the output is in [0, inf)\n\n  var ReluLayer = function (opt) {\n    var opt = opt || {}; // computed\n\n    this.out_sx = opt.in_sx;\n    this.out_sy = opt.in_sy;\n    this.out_depth = opt.in_depth;\n    this.layer_type = 'relu';\n  };\n\n  ReluLayer.prototype = {\n    forward: function (V, is_training) {\n      this.in_act = V;\n      var V2 = V.clone();\n      var N = V.w.length;\n      var V2w = V2.w;\n\n      for (var i = 0; i < N; i++) {\n        if (V2w[i] < 0) V2w[i] = 0; // threshold at 0\n      }\n\n      this.out_act = V2;\n      return this.out_act;\n    },\n    backward: function () {\n      var V = this.in_act; // we need to set dw of this\n\n      var V2 = this.out_act;\n      var N = V.w.length;\n      V.dw = global.zeros(N); // zero out gradient wrt data\n\n      for (var i = 0; i < N; i++) {\n        if (V2.w[i] <= 0) V.dw[i] = 0; // threshold\n        else V.dw[i] = V2.dw[i];\n      }\n    },\n    getParamsAndGrads: function () {\n      return [];\n    },\n    toJSON: function () {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      return json;\n    },\n    fromJSON: function (json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n    }\n  }; // Implements Sigmoid nnonlinearity elementwise\n  // x -> 1/(1+e^(-x))\n  // so the output is between 0 and 1.\n\n  var SigmoidLayer = function (opt) {\n    var opt = opt || {}; // computed\n\n    this.out_sx = opt.in_sx;\n    this.out_sy = opt.in_sy;\n    this.out_depth = opt.in_depth;\n    this.layer_type = 'sigmoid';\n  };\n\n  SigmoidLayer.prototype = {\n    forward: function (V, is_training) {\n      this.in_act = V;\n      var V2 = V.cloneAndZero();\n      var N = V.w.length;\n      var V2w = V2.w;\n      var Vw = V.w;\n\n      for (var i = 0; i < N; i++) {\n        V2w[i] = 1.0 / (1.0 + Math.exp(-Vw[i]));\n      }\n\n      this.out_act = V2;\n      return this.out_act;\n    },\n    backward: function () {\n      var V = this.in_act; // we need to set dw of this\n\n      var V2 = this.out_act;\n      var N = V.w.length;\n      V.dw = global.zeros(N); // zero out gradient wrt data\n\n      for (var i = 0; i < N; i++) {\n        var v2wi = V2.w[i];\n        V.dw[i] = v2wi * (1.0 - v2wi) * V2.dw[i];\n      }\n    },\n    getParamsAndGrads: function () {\n      return [];\n    },\n    toJSON: function () {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      return json;\n    },\n    fromJSON: function (json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n    }\n  }; // Implements Maxout nnonlinearity that computes\n  // x -> max(x)\n  // where x is a vector of size group_size. Ideally of course,\n  // the input size should be exactly divisible by group_size\n\n  var MaxoutLayer = function (opt) {\n    var opt = opt || {}; // required\n\n    this.group_size = typeof opt.group_size !== 'undefined' ? opt.group_size : 2; // computed\n\n    this.out_sx = opt.in_sx;\n    this.out_sy = opt.in_sy;\n    this.out_depth = Math.floor(opt.in_depth / this.group_size);\n    this.layer_type = 'maxout';\n    this.switches = global.zeros(this.out_sx * this.out_sy * this.out_depth); // useful for backprop\n  };\n\n  MaxoutLayer.prototype = {\n    forward: function (V, is_training) {\n      this.in_act = V;\n      var N = this.out_depth;\n      var V2 = new Vol(this.out_sx, this.out_sy, this.out_depth, 0.0); // optimization branch. If we're operating on 1D arrays we dont have\n      // to worry about keeping track of x,y,d coordinates inside\n      // input volumes. In convnets we do :(\n\n      if (this.out_sx === 1 && this.out_sy === 1) {\n        for (var i = 0; i < N; i++) {\n          var ix = i * this.group_size; // base index offset\n\n          var a = V.w[ix];\n          var ai = 0;\n\n          for (var j = 1; j < this.group_size; j++) {\n            var a2 = V.w[ix + j];\n\n            if (a2 > a) {\n              a = a2;\n              ai = j;\n            }\n          }\n\n          V2.w[i] = a;\n          this.switches[i] = ix + ai;\n        }\n      } else {\n        var n = 0; // counter for switches\n\n        for (var x = 0; x < V.sx; x++) {\n          for (var y = 0; y < V.sy; y++) {\n            for (var i = 0; i < N; i++) {\n              var ix = i * this.group_size;\n              var a = V.get(x, y, ix);\n              var ai = 0;\n\n              for (var j = 1; j < this.group_size; j++) {\n                var a2 = V.get(x, y, ix + j);\n\n                if (a2 > a) {\n                  a = a2;\n                  ai = j;\n                }\n              }\n\n              V2.set(x, y, i, a);\n              this.switches[n] = ix + ai;\n              n++;\n            }\n          }\n        }\n      }\n\n      this.out_act = V2;\n      return this.out_act;\n    },\n    backward: function () {\n      var V = this.in_act; // we need to set dw of this\n\n      var V2 = this.out_act;\n      var N = this.out_depth;\n      V.dw = global.zeros(V.w.length); // zero out gradient wrt data\n      // pass the gradient through the appropriate switch\n\n      if (this.out_sx === 1 && this.out_sy === 1) {\n        for (var i = 0; i < N; i++) {\n          var chain_grad = V2.dw[i];\n          V.dw[this.switches[i]] = chain_grad;\n        }\n      } else {\n        // bleh okay, lets do this the hard way\n        var n = 0; // counter for switches\n\n        for (var x = 0; x < V2.sx; x++) {\n          for (var y = 0; y < V2.sy; y++) {\n            for (var i = 0; i < N; i++) {\n              var chain_grad = V2.get_grad(x, y, i);\n              V.set_grad(x, y, this.switches[n], chain_grad);\n              n++;\n            }\n          }\n        }\n      }\n    },\n    getParamsAndGrads: function () {\n      return [];\n    },\n    toJSON: function () {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      json.group_size = this.group_size;\n      return json;\n    },\n    fromJSON: function (json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n      this.group_size = json.group_size;\n      this.switches = global.zeros(this.group_size);\n    }\n  }; // a helper function, since tanh is not yet part of ECMAScript. Will be in v6.\n\n  function tanh(x) {\n    var y = Math.exp(2 * x);\n    return (y - 1) / (y + 1);\n  } // Implements Tanh nnonlinearity elementwise\n  // x -> tanh(x) \n  // so the output is between -1 and 1.\n\n\n  var TanhLayer = function (opt) {\n    var opt = opt || {}; // computed\n\n    this.out_sx = opt.in_sx;\n    this.out_sy = opt.in_sy;\n    this.out_depth = opt.in_depth;\n    this.layer_type = 'tanh';\n  };\n\n  TanhLayer.prototype = {\n    forward: function (V, is_training) {\n      this.in_act = V;\n      var V2 = V.cloneAndZero();\n      var N = V.w.length;\n\n      for (var i = 0; i < N; i++) {\n        V2.w[i] = tanh(V.w[i]);\n      }\n\n      this.out_act = V2;\n      return this.out_act;\n    },\n    backward: function () {\n      var V = this.in_act; // we need to set dw of this\n\n      var V2 = this.out_act;\n      var N = V.w.length;\n      V.dw = global.zeros(N); // zero out gradient wrt data\n\n      for (var i = 0; i < N; i++) {\n        var v2wi = V2.w[i];\n        V.dw[i] = (1.0 - v2wi * v2wi) * V2.dw[i];\n      }\n    },\n    getParamsAndGrads: function () {\n      return [];\n    },\n    toJSON: function () {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      return json;\n    },\n    fromJSON: function (json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n    }\n  };\n  global.TanhLayer = TanhLayer;\n  global.MaxoutLayer = MaxoutLayer;\n  global.ReluLayer = ReluLayer;\n  global.SigmoidLayer = SigmoidLayer;\n})(convnetjs);\n\n(function (global) {\n  \"use strict\";\n\n  var Vol = global.Vol; // convenience\n  // An inefficient dropout layer\n  // Note this is not most efficient implementation since the layer before\n  // computed all these activations and now we're just going to drop them :(\n  // same goes for backward pass. Also, if we wanted to be efficient at test time\n  // we could equivalently be clever and upscale during train and copy pointers during test\n  // todo: make more efficient.\n\n  var DropoutLayer = function (opt) {\n    var opt = opt || {}; // computed\n\n    this.out_sx = opt.in_sx;\n    this.out_sy = opt.in_sy;\n    this.out_depth = opt.in_depth;\n    this.layer_type = 'dropout';\n    this.drop_prob = typeof opt.drop_prob !== 'undefined' ? opt.drop_prob : 0.5;\n    this.dropped = global.zeros(this.out_sx * this.out_sy * this.out_depth);\n  };\n\n  DropoutLayer.prototype = {\n    forward: function (V, is_training) {\n      this.in_act = V;\n\n      if (typeof is_training === 'undefined') {\n        is_training = false;\n      } // default is prediction mode\n\n\n      var V2 = V.clone();\n      var N = V.w.length;\n\n      if (is_training) {\n        // do dropout\n        for (var i = 0; i < N; i++) {\n          if (Math.random() < this.drop_prob) {\n            V2.w[i] = 0;\n            this.dropped[i] = true;\n          } // drop!\n          else {\n            this.dropped[i] = false;\n          }\n        }\n      } else {\n        // scale the activations during prediction\n        for (var i = 0; i < N; i++) {\n          V2.w[i] *= this.drop_prob;\n        }\n      }\n\n      this.out_act = V2;\n      return this.out_act; // dummy identity function for now\n    },\n    backward: function () {\n      var V = this.in_act; // we need to set dw of this\n\n      var chain_grad = this.out_act;\n      var N = V.w.length;\n      V.dw = global.zeros(N); // zero out gradient wrt data\n\n      for (var i = 0; i < N; i++) {\n        if (!this.dropped[i]) {\n          V.dw[i] = chain_grad.dw[i]; // copy over the gradient\n        }\n      }\n    },\n    getParamsAndGrads: function () {\n      return [];\n    },\n    toJSON: function () {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      json.drop_prob = this.drop_prob;\n      return json;\n    },\n    fromJSON: function (json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n      this.drop_prob = json.drop_prob;\n    }\n  };\n  global.DropoutLayer = DropoutLayer;\n})(convnetjs);\n\n(function (global) {\n  \"use strict\";\n\n  var Vol = global.Vol; // convenience\n  // a bit experimental layer for now. I think it works but I'm not 100%\n  // the gradient check is a bit funky. I'll look into this a bit later.\n  // Local Response Normalization in window, along depths of volumes\n\n  var LocalResponseNormalizationLayer = function (opt) {\n    var opt = opt || {}; // required\n\n    this.k = opt.k;\n    this.n = opt.n;\n    this.alpha = opt.alpha;\n    this.beta = opt.beta; // computed\n\n    this.out_sx = opt.in_sx;\n    this.out_sy = opt.in_sy;\n    this.out_depth = opt.in_depth;\n    this.layer_type = 'lrn'; // checks\n\n    if (this.n % 2 === 0) {\n      console.log('WARNING n should be odd for LRN layer');\n    }\n  };\n\n  LocalResponseNormalizationLayer.prototype = {\n    forward: function (V, is_training) {\n      this.in_act = V;\n      var A = V.cloneAndZero();\n      this.S_cache_ = V.cloneAndZero();\n      var n2 = Math.floor(this.n / 2);\n\n      for (var x = 0; x < V.sx; x++) {\n        for (var y = 0; y < V.sy; y++) {\n          for (var i = 0; i < V.depth; i++) {\n            var ai = V.get(x, y, i); // normalize in a window of size n\n\n            var den = 0.0;\n\n            for (var j = Math.max(0, i - n2); j <= Math.min(i + n2, V.depth - 1); j++) {\n              var aa = V.get(x, y, j);\n              den += aa * aa;\n            }\n\n            den *= this.alpha / this.n;\n            den += this.k;\n            this.S_cache_.set(x, y, i, den); // will be useful for backprop\n\n            den = Math.pow(den, this.beta);\n            A.set(x, y, i, ai / den);\n          }\n        }\n      }\n\n      this.out_act = A;\n      return this.out_act; // dummy identity function for now\n    },\n    backward: function () {\n      // evaluate gradient wrt data\n      var V = this.in_act; // we need to set dw of this\n\n      V.dw = global.zeros(V.w.length); // zero out gradient wrt data\n\n      var A = this.out_act; // computed in forward pass \n\n      var n2 = Math.floor(this.n / 2);\n\n      for (var x = 0; x < V.sx; x++) {\n        for (var y = 0; y < V.sy; y++) {\n          for (var i = 0; i < V.depth; i++) {\n            var chain_grad = this.out_act.get_grad(x, y, i);\n            var S = this.S_cache_.get(x, y, i);\n            var SB = Math.pow(S, this.beta);\n            var SB2 = SB * SB; // normalize in a window of size n\n\n            for (var j = Math.max(0, i - n2); j <= Math.min(i + n2, V.depth - 1); j++) {\n              var aj = V.get(x, y, j);\n              var g = -aj * this.beta * Math.pow(S, this.beta - 1) * this.alpha / this.n * 2 * aj;\n              if (j === i) g += SB;\n              g /= SB2;\n              g *= chain_grad;\n              V.add_grad(x, y, j, g);\n            }\n          }\n        }\n      }\n    },\n    getParamsAndGrads: function () {\n      return [];\n    },\n    toJSON: function () {\n      var json = {};\n      json.k = this.k;\n      json.n = this.n;\n      json.alpha = this.alpha; // normalize by size\n\n      json.beta = this.beta;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.out_depth = this.out_depth;\n      json.layer_type = this.layer_type;\n      return json;\n    },\n    fromJSON: function (json) {\n      this.k = json.k;\n      this.n = json.n;\n      this.alpha = json.alpha; // normalize by size\n\n      this.beta = json.beta;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.out_depth = json.out_depth;\n      this.layer_type = json.layer_type;\n    }\n  };\n  global.LocalResponseNormalizationLayer = LocalResponseNormalizationLayer;\n})(convnetjs);\n\n(function (global) {\n  \"use strict\";\n\n  var Vol = global.Vol; // convenience\n  // Net manages a set of layers\n  // For now constraints: Simple linear order of layers, first layer input last layer a cost layer\n\n  var Net = function (options) {\n    this.layers = [];\n  };\n\n  Net.prototype = {\n    // takes a list of layer definitions and creates the network layer objects\n    makeLayers: function (defs) {\n      // few checks for now\n      if (defs.length < 2) {\n        console.log('ERROR! For now at least have input and softmax layers.');\n      }\n\n      if (defs[0].type !== 'input') {\n        console.log('ERROR! For now first layer should be input.');\n      } // desugar syntactic for adding activations and dropouts\n\n\n      var desugar = function () {\n        var new_defs = [];\n\n        for (var i = 0; i < defs.length; i++) {\n          var def = defs[i];\n\n          if (def.type === 'softmax' || def.type === 'svm') {\n            // add an fc layer here, there is no reason the user should\n            // have to worry about this and we almost always want to\n            new_defs.push({\n              type: 'fc',\n              num_neurons: def.num_classes\n            });\n          }\n\n          if (def.type === 'regression') {\n            // add an fc layer here, there is no reason the user should\n            // have to worry about this and we almost always want to\n            new_defs.push({\n              type: 'fc',\n              num_neurons: def.num_neurons\n            });\n          }\n\n          if ((def.type === 'fc' || def.type === 'conv') && typeof def.bias_pref === 'undefined') {\n            def.bias_pref = 0.0;\n\n            if (typeof def.activation !== 'undefined' && def.activation === 'relu') {\n              def.bias_pref = 0.1; // relus like a bit of positive bias to get gradients early\n              // otherwise it's technically possible that a relu unit will never turn on (by chance)\n              // and will never get any gradient and never contribute any computation. Dead relu.\n            }\n          }\n\n          if (typeof def.tensor !== 'undefined') {\n            // apply quadratic transform so that the upcoming multiply will include\n            // quadratic terms, equivalent to doing a tensor product\n            if (def.tensor) {\n              new_defs.push({\n                type: 'quadtransform'\n              });\n            }\n          }\n\n          new_defs.push(def);\n\n          if (typeof def.activation !== 'undefined') {\n            if (def.activation === 'relu') {\n              new_defs.push({\n                type: 'relu'\n              });\n            } else if (def.activation === 'sigmoid') {\n              new_defs.push({\n                type: 'sigmoid'\n              });\n            } else if (def.activation === 'tanh') {\n              new_defs.push({\n                type: 'tanh'\n              });\n            } else if (def.activation === 'maxout') {\n              // create maxout activation, and pass along group size, if provided\n              var gs = def.group_size !== 'undefined' ? def.group_size : 2;\n              new_defs.push({\n                type: 'maxout',\n                group_size: gs\n              });\n            } else {\n              console.log('ERROR unsupported activation ' + def.activation);\n            }\n          }\n\n          if (typeof def.drop_prob !== 'undefined' && def.type !== 'dropout') {\n            new_defs.push({\n              type: 'dropout',\n              drop_prob: def.drop_prob\n            });\n          }\n        }\n\n        return new_defs;\n      };\n\n      defs = desugar(defs); // create the layers\n\n      this.layers = [];\n\n      for (var i = 0; i < defs.length; i++) {\n        var def = defs[i];\n\n        if (i > 0) {\n          var prev = this.layers[i - 1];\n          def.in_sx = prev.out_sx;\n          def.in_sy = prev.out_sy;\n          def.in_depth = prev.out_depth;\n        }\n\n        switch (def.type) {\n          case 'fc':\n            this.layers.push(new global.FullyConnLayer(def));\n            break;\n\n          case 'lrn':\n            this.layers.push(new global.LocalResponseNormalizationLayer(def));\n            break;\n\n          case 'dropout':\n            this.layers.push(new global.DropoutLayer(def));\n            break;\n\n          case 'input':\n            this.layers.push(new global.InputLayer(def));\n            break;\n\n          case 'softmax':\n            this.layers.push(new global.SoftmaxLayer(def));\n            break;\n\n          case 'regression':\n            this.layers.push(new global.RegressionLayer(def));\n            break;\n\n          case 'conv':\n            this.layers.push(new global.ConvLayer(def));\n            break;\n\n          case 'pool':\n            this.layers.push(new global.PoolLayer(def));\n            break;\n\n          case 'relu':\n            this.layers.push(new global.ReluLayer(def));\n            break;\n\n          case 'sigmoid':\n            this.layers.push(new global.SigmoidLayer(def));\n            break;\n\n          case 'tanh':\n            this.layers.push(new global.TanhLayer(def));\n            break;\n\n          case 'maxout':\n            this.layers.push(new global.MaxoutLayer(def));\n            break;\n\n          case 'quadtransform':\n            this.layers.push(new global.QuadTransformLayer(def));\n            break;\n\n          case 'svm':\n            this.layers.push(new global.SVMLayer(def));\n            break;\n\n          default:\n            console.log('ERROR: UNRECOGNIZED LAYER TYPE!');\n        }\n      }\n    },\n    // forward prop the network. A trainer will pass in is_training = true\n    forward: function (V, is_training) {\n      if (typeof is_training === 'undefined') is_training = false;\n      var act = this.layers[0].forward(V, is_training);\n\n      for (var i = 1; i < this.layers.length; i++) {\n        act = this.layers[i].forward(act, is_training);\n      }\n\n      return act;\n    },\n    getCostLoss: function (V, y) {\n      this.forward(V, false);\n      var N = this.layers.length;\n      var loss = this.layers[N - 1].backward(y);\n      return loss;\n    },\n    // backprop: compute gradients wrt all parameters\n    backward: function (y) {\n      var N = this.layers.length;\n      var loss = this.layers[N - 1].backward(y); // last layer assumed softmax\n\n      for (var i = N - 2; i >= 0; i--) {\n        // first layer assumed input\n        this.layers[i].backward();\n      }\n\n      return loss;\n    },\n    getParamsAndGrads: function () {\n      // accumulate parameters and gradients for the entire network\n      var response = [];\n\n      for (var i = 0; i < this.layers.length; i++) {\n        var layer_reponse = this.layers[i].getParamsAndGrads();\n\n        for (var j = 0; j < layer_reponse.length; j++) {\n          response.push(layer_reponse[j]);\n        }\n      }\n\n      return response;\n    },\n    getPrediction: function () {\n      var S = this.layers[this.layers.length - 1]; // softmax layer\n\n      var p = S.out_act.w;\n      var maxv = p[0];\n      var maxi = 0;\n\n      for (var i = 1; i < p.length; i++) {\n        if (p[i] > maxv) {\n          maxv = p[i];\n          maxi = i;\n        }\n      }\n\n      return maxi;\n    },\n    toJSON: function () {\n      var json = {};\n      json.layers = [];\n\n      for (var i = 0; i < this.layers.length; i++) {\n        json.layers.push(this.layers[i].toJSON());\n      }\n\n      return json;\n    },\n    fromJSON: function (json) {\n      this.layers = [];\n\n      for (var i = 0; i < json.layers.length; i++) {\n        var Lj = json.layers[i];\n        var t = Lj.layer_type;\n        var L;\n\n        if (t === 'input') {\n          L = new global.InputLayer();\n        }\n\n        if (t === 'relu') {\n          L = new global.ReluLayer();\n        }\n\n        if (t === 'sigmoid') {\n          L = new global.SigmoidLayer();\n        }\n\n        if (t === 'tanh') {\n          L = new global.TanhLayer();\n        }\n\n        if (t === 'dropout') {\n          L = new global.DropoutLayer();\n        }\n\n        if (t === 'conv') {\n          L = new global.ConvLayer();\n        }\n\n        if (t === 'pool') {\n          L = new global.PoolLayer();\n        }\n\n        if (t === 'lrn') {\n          L = new global.LocalResponseNormalizationLayer();\n        }\n\n        if (t === 'softmax') {\n          L = new global.SoftmaxLayer();\n        }\n\n        if (t === 'regression') {\n          L = new global.RegressionLayer();\n        }\n\n        if (t === 'fc') {\n          L = new global.FullyConnLayer();\n        }\n\n        if (t === 'maxout') {\n          L = new global.MaxoutLayer();\n        }\n\n        if (t === 'quadtransform') {\n          L = new global.QuadTransformLayer();\n        }\n\n        if (t === 'svm') {\n          L = new global.SVMLayer();\n        }\n\n        L.fromJSON(Lj);\n        this.layers.push(L);\n      }\n    }\n  };\n  global.Net = Net;\n})(convnetjs);\n\n(function (global) {\n  \"use strict\";\n\n  var Vol = global.Vol; // convenience\n\n  var Trainer = function (net, options) {\n    this.net = net;\n    var options = options || {};\n    this.learning_rate = typeof options.learning_rate !== 'undefined' ? options.learning_rate : 0.01;\n    this.l1_decay = typeof options.l1_decay !== 'undefined' ? options.l1_decay : 0.0;\n    this.l2_decay = typeof options.l2_decay !== 'undefined' ? options.l2_decay : 0.0;\n    this.batch_size = typeof options.batch_size !== 'undefined' ? options.batch_size : 1;\n    this.method = typeof options.method !== 'undefined' ? options.method : 'sgd'; // sgd/adagrad/adadelta/windowgrad\n\n    this.momentum = typeof options.momentum !== 'undefined' ? options.momentum : 0.9;\n    this.ro = typeof options.ro !== 'undefined' ? options.ro : 0.95; // used in adadelta\n\n    this.eps = typeof options.eps !== 'undefined' ? options.eps : 1e-6; // used in adadelta\n\n    this.k = 0; // iteration counter\n\n    this.gsum = []; // last iteration gradients (used for momentum calculations)\n\n    this.xsum = []; // used in adadelta\n  };\n\n  Trainer.prototype = {\n    train: function (x, y) {\n      var start = new Date().getTime();\n      this.net.forward(x, true); // also set the flag that lets the net know we're just training\n\n      var end = new Date().getTime();\n      var fwd_time = end - start;\n      var start = new Date().getTime();\n      var cost_loss = this.net.backward(y);\n      var l2_decay_loss = 0.0;\n      var l1_decay_loss = 0.0;\n      var end = new Date().getTime();\n      var bwd_time = end - start;\n      this.k++;\n\n      if (this.k % this.batch_size === 0) {\n        var pglist = this.net.getParamsAndGrads(); // initialize lists for accumulators. Will only be done once on first iteration\n\n        if (this.gsum.length === 0 && (this.method !== 'sgd' || this.momentum > 0.0)) {\n          // only vanilla sgd doesnt need either lists\n          // momentum needs gsum\n          // adagrad needs gsum\n          // adadelta needs gsum and xsum\n          for (var i = 0; i < pglist.length; i++) {\n            this.gsum.push(global.zeros(pglist[i].params.length));\n\n            if (this.method === 'adadelta') {\n              this.xsum.push(global.zeros(pglist[i].params.length));\n            } else {\n              this.xsum.push([]); // conserve memory\n            }\n          }\n        } // perform an update for all sets of weights\n\n\n        for (var i = 0; i < pglist.length; i++) {\n          var pg = pglist[i]; // param, gradient, other options in future (custom learning rate etc)\n\n          var p = pg.params;\n          var g = pg.grads; // learning rate for some parameters.\n\n          var l2_decay_mul = typeof pg.l2_decay_mul !== 'undefined' ? pg.l2_decay_mul : 1.0;\n          var l1_decay_mul = typeof pg.l1_decay_mul !== 'undefined' ? pg.l1_decay_mul : 1.0;\n          var l2_decay = this.l2_decay * l2_decay_mul;\n          var l1_decay = this.l1_decay * l1_decay_mul;\n          var plen = p.length;\n\n          for (var j = 0; j < plen; j++) {\n            l2_decay_loss += l2_decay * p[j] * p[j] / 2; // accumulate weight decay loss\n\n            l1_decay_loss += l1_decay * Math.abs(p[j]);\n            var l1grad = l1_decay * (p[j] > 0 ? 1 : -1);\n            var l2grad = l2_decay * p[j];\n            var gij = (l2grad + l1grad + g[j]) / this.batch_size; // raw batch gradient\n\n            var gsumi = this.gsum[i];\n            var xsumi = this.xsum[i];\n\n            if (this.method === 'adagrad') {\n              // adagrad update\n              gsumi[j] = gsumi[j] + gij * gij;\n              var dx = -this.learning_rate / Math.sqrt(gsumi[j] + this.eps) * gij;\n              p[j] += dx;\n            } else if (this.method === 'windowgrad') {\n              // this is adagrad but with a moving window weighted average\n              // so the gradient is not accumulated over the entire history of the run. \n              // it's also referred to as Idea #1 in Zeiler paper on Adadelta. Seems reasonable to me!\n              gsumi[j] = this.ro * gsumi[j] + (1 - this.ro) * gij * gij;\n              var dx = -this.learning_rate / Math.sqrt(gsumi[j] + this.eps) * gij; // eps added for better conditioning\n\n              p[j] += dx;\n            } else if (this.method === 'adadelta') {\n              // assume adadelta if not sgd or adagrad\n              gsumi[j] = this.ro * gsumi[j] + (1 - this.ro) * gij * gij;\n              var dx = -Math.sqrt((xsumi[j] + this.eps) / (gsumi[j] + this.eps)) * gij;\n              xsumi[j] = this.ro * xsumi[j] + (1 - this.ro) * dx * dx; // yes, xsum lags behind gsum by 1.\n\n              p[j] += dx;\n            } else {\n              // assume SGD\n              if (this.momentum > 0.0) {\n                // momentum update\n                var dx = this.momentum * gsumi[j] - this.learning_rate * gij; // step\n\n                gsumi[j] = dx; // back this up for next iteration of momentum\n\n                p[j] += dx; // apply corrected gradient\n              } else {\n                // vanilla sgd\n                p[j] += -this.learning_rate * gij;\n              }\n            }\n\n            g[j] = 0.0; // zero out gradient so that we can begin accumulating anew\n          }\n        }\n      } // appending softmax_loss for backwards compatibility, but from now on we will always use cost_loss\n      // in future, TODO: have to completely redo the way loss is done around the network as currently \n      // loss is a bit of a hack. Ideally, user should specify arbitrary number of loss functions on any layer\n      // and it should all be computed correctly and automatically. \n\n\n      return {\n        fwd_time: fwd_time,\n        bwd_time: bwd_time,\n        l2_decay_loss: l2_decay_loss,\n        l1_decay_loss: l1_decay_loss,\n        cost_loss: cost_loss,\n        softmax_loss: cost_loss,\n        loss: cost_loss + l1_decay_loss + l2_decay_loss\n      };\n    }\n  };\n  global.Trainer = Trainer;\n  global.SGDTrainer = Trainer; // backwards compatibility\n})(convnetjs);\n\n(function (global) {\n  \"use strict\"; // used utilities, make explicit local references\n\n  var randf = global.randf;\n  var randi = global.randi;\n  var Net = global.Net;\n  var Trainer = global.Trainer;\n  var maxmin = global.maxmin;\n  var randperm = global.randperm;\n  var weightedSample = global.weightedSample;\n  var getopt = global.getopt;\n  var arrUnique = global.arrUnique;\n  /*\n  A MagicNet takes data: a list of convnetjs.Vol(), and labels\n  which for now are assumed to be class indeces 0..K. MagicNet then:\n  - creates data folds for cross-validation\n  - samples candidate networks\n  - evaluates candidate networks on all data folds\n  - produces predictions by model-averaging the best networks\n  */\n\n  var MagicNet = function (data, labels, opt) {\n    var opt = opt || {};\n\n    if (typeof data === 'undefined') {\n      data = [];\n    }\n\n    if (typeof labels === 'undefined') {\n      labels = [];\n    } // required inputs\n\n\n    this.data = data; // store these pointers to data\n\n    this.labels = labels; // optional inputs\n\n    this.train_ratio = getopt(opt, 'train_ratio', 0.7);\n    this.num_folds = getopt(opt, 'num_folds', 10);\n    this.num_candidates = getopt(opt, 'num_candidates', 50); // we evaluate several in parallel\n    // how many epochs of data to train every network? for every fold?\n    // higher values mean higher accuracy in final results, but more expensive\n\n    this.num_epochs = getopt(opt, 'num_epochs', 50); // number of best models to average during prediction. Usually higher = better\n\n    this.ensemble_size = getopt(opt, 'ensemble_size', 10); // candidate parameters\n\n    this.batch_size_min = getopt(opt, 'batch_size_min', 10);\n    this.batch_size_max = getopt(opt, 'batch_size_max', 300);\n    this.l2_decay_min = getopt(opt, 'l2_decay_min', -4);\n    this.l2_decay_max = getopt(opt, 'l2_decay_max', 2);\n    this.learning_rate_min = getopt(opt, 'learning_rate_min', -4);\n    this.learning_rate_max = getopt(opt, 'learning_rate_max', 0);\n    this.momentum_min = getopt(opt, 'momentum_min', 0.9);\n    this.momentum_max = getopt(opt, 'momentum_max', 0.9);\n    this.neurons_min = getopt(opt, 'neurons_min', 5);\n    this.neurons_max = getopt(opt, 'neurons_max', 30); // computed\n\n    this.folds = []; // data fold indices, gets filled by sampleFolds()\n\n    this.candidates = []; // candidate networks that are being currently evaluated\n\n    this.evaluated_candidates = []; // history of all candidates that were fully evaluated on all folds\n\n    this.unique_labels = arrUnique(labels);\n    this.iter = 0; // iteration counter, goes from 0 -> num_epochs * num_training_data\n\n    this.foldix = 0; // index of active fold\n    // callbacks\n\n    this.finish_fold_callback = null;\n    this.finish_batch_callback = null; // initializations\n\n    if (this.data.length > 0) {\n      this.sampleFolds();\n      this.sampleCandidates();\n    }\n  };\n\n  MagicNet.prototype = {\n    // sets this.folds to a sampling of this.num_folds folds\n    sampleFolds: function () {\n      var N = this.data.length;\n      var num_train = Math.floor(this.train_ratio * N);\n      this.folds = []; // flush folds, if any\n\n      for (var i = 0; i < this.num_folds; i++) {\n        var p = randperm(N);\n        this.folds.push({\n          train_ix: p.slice(0, num_train),\n          test_ix: p.slice(num_train, N)\n        });\n      }\n    },\n    // returns a random candidate network\n    sampleCandidate: function () {\n      var input_depth = this.data[0].w.length;\n      var num_classes = this.unique_labels.length; // sample network topology and hyperparameters\n\n      var layer_defs = [];\n      layer_defs.push({\n        type: 'input',\n        out_sx: 1,\n        out_sy: 1,\n        out_depth: input_depth\n      });\n      var nl = weightedSample([0, 1, 2, 3], [0.2, 0.3, 0.3, 0.2]); // prefer nets with 1,2 hidden layers\n\n      for (var q = 0; q < nl; q++) {\n        var ni = randi(this.neurons_min, this.neurons_max);\n        var act = ['tanh', 'maxout', 'relu'][randi(0, 3)];\n\n        if (randf(0, 1) < 0.5) {\n          var dp = Math.random();\n          layer_defs.push({\n            type: 'fc',\n            num_neurons: ni,\n            activation: act,\n            drop_prob: dp\n          });\n        } else {\n          layer_defs.push({\n            type: 'fc',\n            num_neurons: ni,\n            activation: act\n          });\n        }\n      }\n\n      layer_defs.push({\n        type: 'softmax',\n        num_classes: num_classes\n      });\n      var net = new Net();\n      net.makeLayers(layer_defs); // sample training hyperparameters\n\n      var bs = randi(this.batch_size_min, this.batch_size_max); // batch size\n\n      var l2 = Math.pow(10, randf(this.l2_decay_min, this.l2_decay_max)); // l2 weight decay\n\n      var lr = Math.pow(10, randf(this.learning_rate_min, this.learning_rate_max)); // learning rate\n\n      var mom = randf(this.momentum_min, this.momentum_max); // momentum. Lets just use 0.9, works okay usually ;p\n\n      var tp = randf(0, 1); // trainer type\n\n      var trainer_def;\n\n      if (tp < 0.33) {\n        trainer_def = {\n          method: 'adadelta',\n          batch_size: bs,\n          l2_decay: l2\n        };\n      } else if (tp < 0.66) {\n        trainer_def = {\n          method: 'adagrad',\n          learning_rate: lr,\n          batch_size: bs,\n          l2_decay: l2\n        };\n      } else {\n        trainer_def = {\n          method: 'sgd',\n          learning_rate: lr,\n          momentum: mom,\n          batch_size: bs,\n          l2_decay: l2\n        };\n      }\n\n      var trainer = new Trainer(net, trainer_def);\n      var cand = {};\n      cand.acc = [];\n      cand.accv = 0; // this will maintained as sum(acc) for convenience\n\n      cand.layer_defs = layer_defs;\n      cand.trainer_def = trainer_def;\n      cand.net = net;\n      cand.trainer = trainer;\n      return cand;\n    },\n    // sets this.candidates with this.num_candidates candidate nets\n    sampleCandidates: function () {\n      this.candidates = []; // flush, if any\n\n      for (var i = 0; i < this.num_candidates; i++) {\n        var cand = this.sampleCandidate();\n        this.candidates.push(cand);\n      }\n    },\n    step: function () {\n      // run an example through current candidate\n      this.iter++; // step all candidates on a random data point\n\n      var fold = this.folds[this.foldix]; // active fold\n\n      var dataix = fold.train_ix[randi(0, fold.train_ix.length)];\n\n      for (var k = 0; k < this.candidates.length; k++) {\n        var x = this.data[dataix];\n        var l = this.labels[dataix];\n        this.candidates[k].trainer.train(x, l);\n      } // process consequences: sample new folds, or candidates\n\n\n      var lastiter = this.num_epochs * fold.train_ix.length;\n\n      if (this.iter >= lastiter) {\n        // finished evaluation of this fold. Get final validation\n        // accuracies, record them, and go on to next fold.\n        var val_acc = this.evalValErrors();\n\n        for (var k = 0; k < this.candidates.length; k++) {\n          var c = this.candidates[k];\n          c.acc.push(val_acc[k]);\n          c.accv += val_acc[k];\n        }\n\n        this.iter = 0; // reset step number\n\n        this.foldix++; // increment fold\n\n        if (this.finish_fold_callback !== null) {\n          this.finish_fold_callback();\n        }\n\n        if (this.foldix >= this.folds.length) {\n          // we finished all folds as well! Record these candidates\n          // and sample new ones to evaluate.\n          for (var k = 0; k < this.candidates.length; k++) {\n            this.evaluated_candidates.push(this.candidates[k]);\n          } // sort evaluated candidates according to accuracy achieved\n\n\n          this.evaluated_candidates.sort(function (a, b) {\n            return a.accv / a.acc.length > b.accv / b.acc.length ? -1 : 1;\n          }); // and clip only to the top few ones (lets place limit at 3*ensemble_size)\n          // otherwise there are concerns with keeping these all in memory \n          // if MagicNet is being evaluated for a very long time\n\n          if (this.evaluated_candidates.length > 3 * this.ensemble_size) {\n            this.evaluated_candidates = this.evaluated_candidates.slice(0, 3 * this.ensemble_size);\n          }\n\n          if (this.finish_batch_callback !== null) {\n            this.finish_batch_callback();\n          }\n\n          this.sampleCandidates(); // begin with new candidates\n\n          this.foldix = 0; // reset this\n        } else {\n          // we will go on to another fold. reset all candidates nets\n          for (var k = 0; k < this.candidates.length; k++) {\n            var c = this.candidates[k];\n            var net = new Net();\n            net.makeLayers(c.layer_defs);\n            var trainer = new Trainer(net, c.trainer_def);\n            c.net = net;\n            c.trainer = trainer;\n          }\n        }\n      }\n    },\n    evalValErrors: function () {\n      // evaluate candidates on validation data and return performance of current networks\n      // as simple list\n      var vals = [];\n      var fold = this.folds[this.foldix]; // active fold\n\n      for (var k = 0; k < this.candidates.length; k++) {\n        var net = this.candidates[k].net;\n        var v = 0.0;\n\n        for (var q = 0; q < fold.test_ix.length; q++) {\n          var x = this.data[fold.test_ix[q]];\n          var l = this.labels[fold.test_ix[q]];\n          net.forward(x);\n          var yhat = net.getPrediction();\n          v += yhat === l ? 1.0 : 0.0; // 0 1 loss\n        }\n\n        v /= fold.test_ix.length; // normalize\n\n        vals.push(v);\n      }\n\n      return vals;\n    },\n    // returns prediction scores for given test data point, as Vol\n    // uses an averaged prediction from the best ensemble_size models\n    // x is a Vol.\n    predict_soft: function (data) {\n      // forward prop the best networks\n      // and accumulate probabilities at last layer into a an output Vol\n      var nv = Math.min(this.ensemble_size, this.evaluated_candidates.length);\n\n      if (nv === 0) {\n        return new convnetjs.Vol(0, 0, 0);\n      } // not sure what to do here? we're not ready yet\n\n\n      var xout, n;\n\n      for (var j = 0; j < nv; j++) {\n        var net = this.evaluated_candidates[j].net;\n        var x = net.forward(data);\n\n        if (j === 0) {\n          xout = x;\n          n = x.w.length;\n        } else {\n          // add it on\n          for (var d = 0; d < n; d++) {\n            xout.w[d] += x.w[d];\n          }\n        }\n      } // produce average\n\n\n      for (var d = 0; d < n; d++) {\n        xout.w[d] /= n;\n      }\n\n      return xout;\n    },\n    predict: function (data) {\n      var xout = this.predict_soft(data);\n\n      if (xout.w.length !== 0) {\n        var stats = maxmin(xout.w);\n        var predicted_label = stats.maxi;\n      } else {\n        var predicted_label = -1; // error out\n      }\n\n      return predicted_label;\n    },\n    toJSON: function () {\n      // dump the top ensemble_size networks as a list\n      var nv = Math.min(this.ensemble_size, this.evaluated_candidates.length);\n      var json = {};\n      json.nets = [];\n\n      for (var i = 0; i < nv; i++) {\n        json.nets.push(this.evaluated_candidates[i].net.toJSON());\n      }\n\n      return json;\n    },\n    fromJSON: function (json) {\n      this.ensemble_size = json.nets.length;\n      this.evaluated_candidates = [];\n\n      for (var i = 0; i < this.ensemble_size; i++) {\n        var net = new Net();\n        net.fromJSON(json.nets[i]);\n        var dummy_candidate = {};\n        dummy_candidate.net = net;\n        this.evaluated_candidates.push(dummy_candidate);\n      }\n    },\n    // callback functions\n    // called when a fold is finished, while evaluating a batch\n    onFinishFold: function (f) {\n      this.finish_fold_callback = f;\n    },\n    // called when a batch of candidates has finished evaluating\n    onFinishBatch: function (f) {\n      this.finish_batch_callback = f;\n    }\n  };\n  global.MagicNet = MagicNet;\n})(convnetjs);\n\nthis.convnetjs = convnetjs;\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},\"simplify\":{\"1.2.2\":{\"simplify.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/external/simplify/1.2.2/simplify.js                                                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!function (module1) {\n  /*\n   (c) 2013, Vladimir Agafonkin\n   Simplify.js, a high-performance JS polyline simplification library\n   mourner.github.io/simplify-js\n  */\n  this.simplify = function () {\n    'use strict'; // to suit your point format, run search/replace for '.x' and '.y';\n    // for 3D version, see 3d branch (configurability would draw significant performance overhead)\n    // square distance between 2 points\n\n    function getSqDist(p1, p2) {\n      var dx = p1.x - p2.x,\n          dy = p1.y - p2.y;\n      return dx * dx + dy * dy;\n    } // square distance from a point to a segment\n\n\n    function getSqSegDist(p, p1, p2) {\n      var x = p1.x,\n          y = p1.y,\n          dx = p2.x - x,\n          dy = p2.y - y;\n\n      if (dx !== 0 || dy !== 0) {\n        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n          x = p2.x;\n          y = p2.y;\n        } else if (t > 0) {\n          x += dx * t;\n          y += dy * t;\n        }\n      }\n\n      dx = p.x - x;\n      dy = p.y - y;\n      return dx * dx + dy * dy;\n    } // rest of the code doesn't care about point format\n    // basic distance-based simplification\n\n\n    function simplifyRadialDist(points, sqTolerance) {\n      var prevPoint = points[0],\n          newPoints = [prevPoint],\n          point;\n\n      for (var i = 1, len = points.length; i < len; i++) {\n        point = points[i];\n\n        if (getSqDist(point, prevPoint) > sqTolerance) {\n          newPoints.push(point);\n          prevPoint = point;\n        }\n      }\n\n      if (prevPoint !== point) newPoints.push(point);\n      return newPoints;\n    }\n\n    function simplifyDPStep(points, first, last, sqTolerance, simplified) {\n      var maxSqDist = sqTolerance,\n          index;\n\n      for (var i = first + 1; i < last; i++) {\n        var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n        if (sqDist > maxSqDist) {\n          index = i;\n          maxSqDist = sqDist;\n        }\n      }\n\n      if (maxSqDist > sqTolerance) {\n        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n        simplified.push(points[index]);\n        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n      }\n    } // simplification using Ramer-Douglas-Peucker algorithm\n\n\n    function simplifyDouglasPeucker(points, sqTolerance) {\n      var last = points.length - 1;\n      var simplified = [points[0]];\n      simplifyDPStep(points, 0, last, sqTolerance, simplified);\n      simplified.push(points[last]);\n      return simplified;\n    } // both algorithms combined for awesome performance\n\n\n    function simplify(points, tolerance, highestQuality) {\n      if (points.length <= 2) return points;\n      var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n      points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n      points = simplifyDouglasPeucker(points, sqTolerance);\n      return points;\n    } // export as AMD module / Node module / browser or worker variable\n\n\n    if (typeof define === 'function' && define.amd) define(function () {\n      return simplify;\n    });else if (typeof module !== 'undefined') module.exports = simplify;else return simplify;\n  }();\n}.call(this, module);\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},\"voronoi\":{\"0.98\":{\"rhill-voronoi-core.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/external/voronoi/0.98/rhill-voronoi-core.js                                                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!function (module1) {\n  /*!\n  Copyright (C) 2010-2013 Raymond Hill: https://github.com/gorhill/Javascript-Voronoi\n  MIT License: See https://github.com/gorhill/Javascript-Voronoi/LICENSE.md\n  */\n\n  /*\n  Author: Raymond Hill (rhill@raymondhill.net)\n  Contributor: Jesse Morgan (morgajel@gmail.com)\n  File: rhill-voronoi-core.js\n  Version: 0.98\n  Date: January 21, 2013\n  Description: This is my personal Javascript implementation of\n  Steven Fortune's algorithm to compute Voronoi diagrams.\n  \n  License: See https://github.com/gorhill/Javascript-Voronoi/LICENSE.md\n  Credits: See https://github.com/gorhill/Javascript-Voronoi/CREDITS.md\n  History: See https://github.com/gorhill/Javascript-Voronoi/CHANGELOG.md\n  \n  ## Usage:\n  \n    var sites = [{x:300,y:300}, {x:100,y:100}, {x:200,y:500}, {x:250,y:450}, {x:600,y:150}];\n    // xl, xr means x left, x right\n    // yt, yb means y top, y bottom\n    var bbox = {xl:0, xr:800, yt:0, yb:600};\n    var voronoi = new Voronoi();\n    // pass an object which exhibits xl, xr, yt, yb properties. The bounding\n    // box will be used to connect unbound edges, and to close open cells\n    result = voronoi.compute(sites, bbox);\n    // render, further analyze, etc.\n  \n  Return value:\n    An object with the following properties:\n  \n    result.vertices = an array of unordered, unique Voronoi.Vertex objects making\n      up the Voronoi diagram.\n    result.edges = an array of unordered, unique Voronoi.Edge objects making up\n      the Voronoi diagram.\n    result.cells = an array of Voronoi.Cell object making up the Voronoi diagram.\n      A Cell object might have an empty array of halfedges, meaning no Voronoi\n      cell could be computed for a particular cell.\n    result.execTime = the time it took to compute the Voronoi diagram, in\n      milliseconds.\n  \n  Voronoi.Vertex object:\n    x: The x position of the vertex.\n    y: The y position of the vertex.\n  \n  Voronoi.Edge object:\n    lSite: the Voronoi site object at the left of this Voronoi.Edge object.\n    rSite: the Voronoi site object at the right of this Voronoi.Edge object (can\n      be null).\n    va: an object with an 'x' and a 'y' property defining the start point\n      (relative to the Voronoi site on the left) of this Voronoi.Edge object.\n    vb: an object with an 'x' and a 'y' property defining the end point\n      (relative to Voronoi site on the left) of this Voronoi.Edge object.\n  \n    For edges which are used to close open cells (using the supplied bounding\n    box), the rSite property will be null.\n  \n  Voronoi.Cell object:\n    site: the Voronoi site object associated with the Voronoi cell.\n    halfedges: an array of Voronoi.Halfedge objects, ordered counterclockwise,\n      defining the polygon for this Voronoi cell.\n  \n  Voronoi.Halfedge object:\n    site: the Voronoi site object owning this Voronoi.Halfedge object.\n    edge: a reference to the unique Voronoi.Edge object underlying this\n      Voronoi.Halfedge object.\n    getStartpoint(): a method returning an object with an 'x' and a 'y' property\n      for the start point of this halfedge. Keep in mind halfedges are always\n      countercockwise.\n    getEndpoint(): a method returning an object with an 'x' and a 'y' property\n      for the end point of this halfedge. Keep in mind halfedges are always\n      countercockwise.\n  \n  TODO: Identify opportunities for performance improvement.\n  \n  TODO: Let the user close the Voronoi cells, do not do it automatically. Not only let\n        him close the cells, but also allow him to close more than once using a different\n        bounding box for the same Voronoi diagram.\n  */\n\n  /*global Math */\n  // ---------------------------------------------------------------------------\n  function Voronoi() {\n    this.vertices = null;\n    this.edges = null;\n    this.cells = null;\n    this.toRecycle = null;\n    this.beachsectionJunkyard = [];\n    this.circleEventJunkyard = [];\n    this.vertexJunkyard = [];\n    this.edgeJunkyard = [];\n    this.cellJunkyard = [];\n  } // ---------------------------------------------------------------------------\n\n\n  Voronoi.prototype.reset = function () {\n    if (!this.beachline) {\n      this.beachline = new this.RBTree();\n    } // Move leftover beachsections to the beachsection junkyard.\n\n\n    if (this.beachline.root) {\n      var beachsection = this.beachline.getFirst(this.beachline.root);\n\n      while (beachsection) {\n        this.beachsectionJunkyard.push(beachsection); // mark for reuse\n\n        beachsection = beachsection.rbNext;\n      }\n    }\n\n    this.beachline.root = null;\n\n    if (!this.circleEvents) {\n      this.circleEvents = new this.RBTree();\n    }\n\n    this.circleEvents.root = this.firstCircleEvent = null;\n    this.vertices = [];\n    this.edges = [];\n    this.cells = [];\n  };\n\n  Voronoi.prototype.sqrt = Math.sqrt;\n  Voronoi.prototype.abs = Math.abs;\n  Voronoi.prototype.ε = Voronoi.ε = 1e-9;\n  Voronoi.prototype.invε = Voronoi.invε = 1.0 / Voronoi.ε;\n\n  Voronoi.prototype.equalWithEpsilon = function (a, b) {\n    return this.abs(a - b) < 1e-9;\n  };\n\n  Voronoi.prototype.greaterThanWithEpsilon = function (a, b) {\n    return a - b > 1e-9;\n  };\n\n  Voronoi.prototype.greaterThanOrEqualWithEpsilon = function (a, b) {\n    return b - a < 1e-9;\n  };\n\n  Voronoi.prototype.lessThanWithEpsilon = function (a, b) {\n    return b - a > 1e-9;\n  };\n\n  Voronoi.prototype.lessThanOrEqualWithEpsilon = function (a, b) {\n    return a - b < 1e-9;\n  }; // ---------------------------------------------------------------------------\n  // Red-Black tree code (based on C version of \"rbtree\" by Franck Bui-Huu\n  // https://github.com/fbuihuu/libtree/blob/master/rb.c\n\n\n  Voronoi.prototype.RBTree = function () {\n    this.root = null;\n  };\n\n  Voronoi.prototype.RBTree.prototype.rbInsertSuccessor = function (node, successor) {\n    var parent;\n\n    if (node) {\n      // >>> rhill 2011-05-27: Performance: cache previous/next nodes\n      successor.rbPrevious = node;\n      successor.rbNext = node.rbNext;\n\n      if (node.rbNext) {\n        node.rbNext.rbPrevious = successor;\n      }\n\n      node.rbNext = successor; // <<<\n\n      if (node.rbRight) {\n        // in-place expansion of node.rbRight.getFirst();\n        node = node.rbRight;\n\n        while (node.rbLeft) {\n          node = node.rbLeft;\n        }\n\n        node.rbLeft = successor;\n      } else {\n        node.rbRight = successor;\n      }\n\n      parent = node;\n    } // rhill 2011-06-07: if node is null, successor must be inserted\n    // to the left-most part of the tree\n    else if (this.root) {\n      node = this.getFirst(this.root); // >>> Performance: cache previous/next nodes\n\n      successor.rbPrevious = null;\n      successor.rbNext = node;\n      node.rbPrevious = successor; // <<<\n\n      node.rbLeft = successor;\n      parent = node;\n    } else {\n      // >>> Performance: cache previous/next nodes\n      successor.rbPrevious = successor.rbNext = null; // <<<\n\n      this.root = successor;\n      parent = null;\n    }\n\n    successor.rbLeft = successor.rbRight = null;\n    successor.rbParent = parent;\n    successor.rbRed = true; // Fixup the modified tree by recoloring nodes and performing\n    // rotations (2 at most) hence the red-black tree properties are\n    // preserved.\n\n    var grandpa, uncle;\n    node = successor;\n\n    while (parent && parent.rbRed) {\n      grandpa = parent.rbParent;\n\n      if (parent === grandpa.rbLeft) {\n        uncle = grandpa.rbRight;\n\n        if (uncle && uncle.rbRed) {\n          parent.rbRed = uncle.rbRed = false;\n          grandpa.rbRed = true;\n          node = grandpa;\n        } else {\n          if (node === parent.rbRight) {\n            this.rbRotateLeft(parent);\n            node = parent;\n            parent = node.rbParent;\n          }\n\n          parent.rbRed = false;\n          grandpa.rbRed = true;\n          this.rbRotateRight(grandpa);\n        }\n      } else {\n        uncle = grandpa.rbLeft;\n\n        if (uncle && uncle.rbRed) {\n          parent.rbRed = uncle.rbRed = false;\n          grandpa.rbRed = true;\n          node = grandpa;\n        } else {\n          if (node === parent.rbLeft) {\n            this.rbRotateRight(parent);\n            node = parent;\n            parent = node.rbParent;\n          }\n\n          parent.rbRed = false;\n          grandpa.rbRed = true;\n          this.rbRotateLeft(grandpa);\n        }\n      }\n\n      parent = node.rbParent;\n    }\n\n    this.root.rbRed = false;\n  };\n\n  Voronoi.prototype.RBTree.prototype.rbRemoveNode = function (node) {\n    // >>> rhill 2011-05-27: Performance: cache previous/next nodes\n    if (node.rbNext) {\n      node.rbNext.rbPrevious = node.rbPrevious;\n    }\n\n    if (node.rbPrevious) {\n      node.rbPrevious.rbNext = node.rbNext;\n    }\n\n    node.rbNext = node.rbPrevious = null; // <<<\n\n    var parent = node.rbParent,\n        left = node.rbLeft,\n        right = node.rbRight,\n        next;\n\n    if (!left) {\n      next = right;\n    } else if (!right) {\n      next = left;\n    } else {\n      next = this.getFirst(right);\n    }\n\n    if (parent) {\n      if (parent.rbLeft === node) {\n        parent.rbLeft = next;\n      } else {\n        parent.rbRight = next;\n      }\n    } else {\n      this.root = next;\n    } // enforce red-black rules\n\n\n    var isRed;\n\n    if (left && right) {\n      isRed = next.rbRed;\n      next.rbRed = node.rbRed;\n      next.rbLeft = left;\n      left.rbParent = next;\n\n      if (next !== right) {\n        parent = next.rbParent;\n        next.rbParent = node.rbParent;\n        node = next.rbRight;\n        parent.rbLeft = node;\n        next.rbRight = right;\n        right.rbParent = next;\n      } else {\n        next.rbParent = parent;\n        parent = next;\n        node = next.rbRight;\n      }\n    } else {\n      isRed = node.rbRed;\n      node = next;\n    } // 'node' is now the sole successor's child and 'parent' its\n    // new parent (since the successor can have been moved)\n\n\n    if (node) {\n      node.rbParent = parent;\n    } // the 'easy' cases\n\n\n    if (isRed) {\n      return;\n    }\n\n    if (node && node.rbRed) {\n      node.rbRed = false;\n      return;\n    } // the other cases\n\n\n    var sibling;\n\n    do {\n      if (node === this.root) {\n        break;\n      }\n\n      if (node === parent.rbLeft) {\n        sibling = parent.rbRight;\n\n        if (sibling.rbRed) {\n          sibling.rbRed = false;\n          parent.rbRed = true;\n          this.rbRotateLeft(parent);\n          sibling = parent.rbRight;\n        }\n\n        if (sibling.rbLeft && sibling.rbLeft.rbRed || sibling.rbRight && sibling.rbRight.rbRed) {\n          if (!sibling.rbRight || !sibling.rbRight.rbRed) {\n            sibling.rbLeft.rbRed = false;\n            sibling.rbRed = true;\n            this.rbRotateRight(sibling);\n            sibling = parent.rbRight;\n          }\n\n          sibling.rbRed = parent.rbRed;\n          parent.rbRed = sibling.rbRight.rbRed = false;\n          this.rbRotateLeft(parent);\n          node = this.root;\n          break;\n        }\n      } else {\n        sibling = parent.rbLeft;\n\n        if (sibling.rbRed) {\n          sibling.rbRed = false;\n          parent.rbRed = true;\n          this.rbRotateRight(parent);\n          sibling = parent.rbLeft;\n        }\n\n        if (sibling.rbLeft && sibling.rbLeft.rbRed || sibling.rbRight && sibling.rbRight.rbRed) {\n          if (!sibling.rbLeft || !sibling.rbLeft.rbRed) {\n            sibling.rbRight.rbRed = false;\n            sibling.rbRed = true;\n            this.rbRotateLeft(sibling);\n            sibling = parent.rbLeft;\n          }\n\n          sibling.rbRed = parent.rbRed;\n          parent.rbRed = sibling.rbLeft.rbRed = false;\n          this.rbRotateRight(parent);\n          node = this.root;\n          break;\n        }\n      }\n\n      sibling.rbRed = true;\n      node = parent;\n      parent = parent.rbParent;\n    } while (!node.rbRed);\n\n    if (node) {\n      node.rbRed = false;\n    }\n  };\n\n  Voronoi.prototype.RBTree.prototype.rbRotateLeft = function (node) {\n    var p = node,\n        q = node.rbRight,\n        // can't be null\n    parent = p.rbParent;\n\n    if (parent) {\n      if (parent.rbLeft === p) {\n        parent.rbLeft = q;\n      } else {\n        parent.rbRight = q;\n      }\n    } else {\n      this.root = q;\n    }\n\n    q.rbParent = parent;\n    p.rbParent = q;\n    p.rbRight = q.rbLeft;\n\n    if (p.rbRight) {\n      p.rbRight.rbParent = p;\n    }\n\n    q.rbLeft = p;\n  };\n\n  Voronoi.prototype.RBTree.prototype.rbRotateRight = function (node) {\n    var p = node,\n        q = node.rbLeft,\n        // can't be null\n    parent = p.rbParent;\n\n    if (parent) {\n      if (parent.rbLeft === p) {\n        parent.rbLeft = q;\n      } else {\n        parent.rbRight = q;\n      }\n    } else {\n      this.root = q;\n    }\n\n    q.rbParent = parent;\n    p.rbParent = q;\n    p.rbLeft = q.rbRight;\n\n    if (p.rbLeft) {\n      p.rbLeft.rbParent = p;\n    }\n\n    q.rbRight = p;\n  };\n\n  Voronoi.prototype.RBTree.prototype.getFirst = function (node) {\n    while (node.rbLeft) {\n      node = node.rbLeft;\n    }\n\n    return node;\n  };\n\n  Voronoi.prototype.RBTree.prototype.getLast = function (node) {\n    while (node.rbRight) {\n      node = node.rbRight;\n    }\n\n    return node;\n  }; // ---------------------------------------------------------------------------\n  // Diagram methods\n\n\n  Voronoi.prototype.Diagram = function (site) {\n    this.site = site;\n  }; // ---------------------------------------------------------------------------\n  // Cell methods\n\n\n  Voronoi.prototype.Cell = function (site) {\n    this.site = site;\n    this.halfedges = [];\n    this.closeMe = false;\n  };\n\n  Voronoi.prototype.Cell.prototype.init = function (site) {\n    this.site = site;\n    this.halfedges = [];\n    this.closeMe = false;\n    return this;\n  };\n\n  Voronoi.prototype.createCell = function (site) {\n    var cell = this.cellJunkyard.pop();\n\n    if (cell) {\n      return cell.init(site);\n    }\n\n    return new this.Cell(site);\n  };\n\n  Voronoi.prototype.Cell.prototype.prepareHalfedges = function () {\n    var halfedges = this.halfedges,\n        iHalfedge = halfedges.length,\n        edge; // get rid of unused halfedges\n    // rhill 2011-05-27: Keep it simple, no point here in trying\n    // to be fancy: dangling edges are a typically a minority.\n\n    while (iHalfedge--) {\n      edge = halfedges[iHalfedge].edge;\n\n      if (!edge.vb || !edge.va) {\n        halfedges.splice(iHalfedge, 1);\n      }\n    } // rhill 2011-05-26: I tried to use a binary search at insertion\n    // time to keep the array sorted on-the-fly (in Cell.addHalfedge()).\n    // There was no real benefits in doing so, performance on\n    // Firefox 3.6 was improved marginally, while performance on\n    // Opera 11 was penalized marginally.\n\n\n    halfedges.sort(function (a, b) {\n      return b.angle - a.angle;\n    });\n    return halfedges.length;\n  }; // Return a list of the neighbor Ids\n\n\n  Voronoi.prototype.Cell.prototype.getNeighborIds = function () {\n    var neighbors = [],\n        iHalfedge = this.halfedges.length,\n        edge;\n\n    while (iHalfedge--) {\n      edge = this.halfedges[iHalfedge].edge;\n\n      if (edge.lSite !== null && edge.lSite.voronoiId != this.site.voronoiId) {\n        neighbors.push(edge.lSite.voronoiId);\n      } else if (edge.rSite !== null && edge.rSite.voronoiId != this.site.voronoiId) {\n        neighbors.push(edge.rSite.voronoiId);\n      }\n    }\n\n    return neighbors;\n  }; // Compute bounding box\n  //\n\n\n  Voronoi.prototype.Cell.prototype.getBbox = function () {\n    var halfedges = this.halfedges,\n        iHalfedge = halfedges.length,\n        xmin = Infinity,\n        ymin = Infinity,\n        xmax = -Infinity,\n        ymax = -Infinity,\n        v,\n        vx,\n        vy;\n\n    while (iHalfedge--) {\n      v = halfedges[iHalfedge].getStartpoint();\n      vx = v.x;\n      vy = v.y;\n\n      if (vx < xmin) {\n        xmin = vx;\n      }\n\n      if (vy < ymin) {\n        ymin = vy;\n      }\n\n      if (vx > xmax) {\n        xmax = vx;\n      }\n\n      if (vy > ymax) {\n        ymax = vy;\n      } // we dont need to take into account end point,\n      // since each end point matches a start point\n\n    }\n\n    return {\n      x: xmin,\n      y: ymin,\n      width: xmax - xmin,\n      height: ymax - ymin\n    };\n  }; // Return whether a point is inside, on, or outside the cell:\n  //   -1: point is outside the perimeter of the cell\n  //    0: point is on the perimeter of the cell\n  //    1: point is inside the perimeter of the cell\n  //\n\n\n  Voronoi.prototype.Cell.prototype.pointIntersection = function (x, y) {\n    // Check if point in polygon. Since all polygons of a Voronoi\n    // diagram are convex, then:\n    // http://paulbourke.net/geometry/polygonmesh/\n    // Solution 3 (2D):\n    //   \"If the polygon is convex then one can consider the polygon\n    //   \"as a 'path' from the first vertex. A point is on the interior\n    //   \"of this polygons if it is always on the same side of all the\n    //   \"line segments making up the path. ...\n    //   \"(y - y0) (x1 - x0) - (x - x0) (y1 - y0)\n    //   \"if it is less than 0 then P is to the right of the line segment,\n    //   \"if greater than 0 it is to the left, if equal to 0 then it lies\n    //   \"on the line segment\"\n    var halfedges = this.halfedges,\n        iHalfedge = halfedges.length,\n        halfedge,\n        p0,\n        p1,\n        r;\n\n    while (iHalfedge--) {\n      halfedge = halfedges[iHalfedge];\n      p0 = halfedge.getStartpoint();\n      p1 = halfedge.getEndpoint();\n      r = (y - p0.y) * (p1.x - p0.x) - (x - p0.x) * (p1.y - p0.y);\n\n      if (!r) {\n        return 0;\n      }\n\n      if (r > 0) {\n        return -1;\n      }\n    }\n\n    return 1;\n  }; // ---------------------------------------------------------------------------\n  // Edge methods\n  //\n\n\n  Voronoi.prototype.Vertex = function (x, y) {\n    this.x = x;\n    this.y = y;\n  };\n\n  Voronoi.prototype.Edge = function (lSite, rSite) {\n    this.lSite = lSite;\n    this.rSite = rSite;\n    this.va = this.vb = null;\n  };\n\n  Voronoi.prototype.Halfedge = function (edge, lSite, rSite) {\n    this.site = lSite;\n    this.edge = edge; // 'angle' is a value to be used for properly sorting the\n    // halfsegments counterclockwise. By convention, we will\n    // use the angle of the line defined by the 'site to the left'\n    // to the 'site to the right'.\n    // However, border edges have no 'site to the right': thus we\n    // use the angle of line perpendicular to the halfsegment (the\n    // edge should have both end points defined in such case.)\n\n    if (rSite) {\n      this.angle = Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x);\n    } else {\n      var va = edge.va,\n          vb = edge.vb; // rhill 2011-05-31: used to call getStartpoint()/getEndpoint(),\n      // but for performance purpose, these are expanded in place here.\n\n      this.angle = edge.lSite === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);\n    }\n  };\n\n  Voronoi.prototype.createHalfedge = function (edge, lSite, rSite) {\n    return new this.Halfedge(edge, lSite, rSite);\n  };\n\n  Voronoi.prototype.Halfedge.prototype.getStartpoint = function () {\n    return this.edge.lSite === this.site ? this.edge.va : this.edge.vb;\n  };\n\n  Voronoi.prototype.Halfedge.prototype.getEndpoint = function () {\n    return this.edge.lSite === this.site ? this.edge.vb : this.edge.va;\n  }; // this create and add a vertex to the internal collection\n\n\n  Voronoi.prototype.createVertex = function (x, y) {\n    var v = this.vertexJunkyard.pop();\n\n    if (!v) {\n      v = new this.Vertex(x, y);\n    } else {\n      v.x = x;\n      v.y = y;\n    }\n\n    this.vertices.push(v);\n    return v;\n  }; // this create and add an edge to internal collection, and also create\n  // two halfedges which are added to each site's counterclockwise array\n  // of halfedges.\n\n\n  Voronoi.prototype.createEdge = function (lSite, rSite, va, vb) {\n    var edge = this.edgeJunkyard.pop();\n\n    if (!edge) {\n      edge = new this.Edge(lSite, rSite);\n    } else {\n      edge.lSite = lSite;\n      edge.rSite = rSite;\n      edge.va = edge.vb = null;\n    }\n\n    this.edges.push(edge);\n\n    if (va) {\n      this.setEdgeStartpoint(edge, lSite, rSite, va);\n    }\n\n    if (vb) {\n      this.setEdgeEndpoint(edge, lSite, rSite, vb);\n    }\n\n    this.cells[lSite.voronoiId].halfedges.push(this.createHalfedge(edge, lSite, rSite));\n    this.cells[rSite.voronoiId].halfedges.push(this.createHalfedge(edge, rSite, lSite));\n    return edge;\n  };\n\n  Voronoi.prototype.createBorderEdge = function (lSite, va, vb) {\n    var edge = this.edgeJunkyard.pop();\n\n    if (!edge) {\n      edge = new this.Edge(lSite, null);\n    } else {\n      edge.lSite = lSite;\n      edge.rSite = null;\n    }\n\n    edge.va = va;\n    edge.vb = vb;\n    this.edges.push(edge);\n    return edge;\n  };\n\n  Voronoi.prototype.setEdgeStartpoint = function (edge, lSite, rSite, vertex) {\n    if (!edge.va && !edge.vb) {\n      edge.va = vertex;\n      edge.lSite = lSite;\n      edge.rSite = rSite;\n    } else if (edge.lSite === rSite) {\n      edge.vb = vertex;\n    } else {\n      edge.va = vertex;\n    }\n  };\n\n  Voronoi.prototype.setEdgeEndpoint = function (edge, lSite, rSite, vertex) {\n    this.setEdgeStartpoint(edge, rSite, lSite, vertex);\n  }; // ---------------------------------------------------------------------------\n  // Beachline methods\n  // rhill 2011-06-07: For some reasons, performance suffers significantly\n  // when instanciating a literal object instead of an empty ctor\n\n\n  Voronoi.prototype.Beachsection = function () {}; // rhill 2011-06-02: A lot of Beachsection instanciations\n  // occur during the computation of the Voronoi diagram,\n  // somewhere between the number of sites and twice the\n  // number of sites, while the number of Beachsections on the\n  // beachline at any given time is comparatively low. For this\n  // reason, we reuse already created Beachsections, in order\n  // to avoid new memory allocation. This resulted in a measurable\n  // performance gain.\n\n\n  Voronoi.prototype.createBeachsection = function (site) {\n    var beachsection = this.beachsectionJunkyard.pop();\n\n    if (!beachsection) {\n      beachsection = new this.Beachsection();\n    }\n\n    beachsection.site = site;\n    return beachsection;\n  }; // calculate the left break point of a particular beach section,\n  // given a particular sweep line\n\n\n  Voronoi.prototype.leftBreakPoint = function (arc, directrix) {\n    // http://en.wikipedia.org/wiki/Parabola\n    // http://en.wikipedia.org/wiki/Quadratic_equation\n    // h1 = x1,\n    // k1 = (y1+directrix)/2,\n    // h2 = x2,\n    // k2 = (y2+directrix)/2,\n    // p1 = k1-directrix,\n    // a1 = 1/(4*p1),\n    // b1 = -h1/(2*p1),\n    // c1 = h1*h1/(4*p1)+k1,\n    // p2 = k2-directrix,\n    // a2 = 1/(4*p2),\n    // b2 = -h2/(2*p2),\n    // c2 = h2*h2/(4*p2)+k2,\n    // x = (-(b2-b1) + Math.sqrt((b2-b1)*(b2-b1) - 4*(a2-a1)*(c2-c1))) / (2*(a2-a1))\n    // When x1 become the x-origin:\n    // h1 = 0,\n    // k1 = (y1+directrix)/2,\n    // h2 = x2-x1,\n    // k2 = (y2+directrix)/2,\n    // p1 = k1-directrix,\n    // a1 = 1/(4*p1),\n    // b1 = 0,\n    // c1 = k1,\n    // p2 = k2-directrix,\n    // a2 = 1/(4*p2),\n    // b2 = -h2/(2*p2),\n    // c2 = h2*h2/(4*p2)+k2,\n    // x = (-b2 + Math.sqrt(b2*b2 - 4*(a2-a1)*(c2-k1))) / (2*(a2-a1)) + x1\n    // change code below at your own risk: care has been taken to\n    // reduce errors due to computers' finite arithmetic precision.\n    // Maybe can still be improved, will see if any more of this\n    // kind of errors pop up again.\n    var site = arc.site,\n        rfocx = site.x,\n        rfocy = site.y,\n        pby2 = rfocy - directrix; // parabola in degenerate case where focus is on directrix\n\n    if (!pby2) {\n      return rfocx;\n    }\n\n    var lArc = arc.rbPrevious;\n\n    if (!lArc) {\n      return -Infinity;\n    }\n\n    site = lArc.site;\n    var lfocx = site.x,\n        lfocy = site.y,\n        plby2 = lfocy - directrix; // parabola in degenerate case where focus is on directrix\n\n    if (!plby2) {\n      return lfocx;\n    }\n\n    var hl = lfocx - rfocx,\n        aby2 = 1 / pby2 - 1 / plby2,\n        b = hl / plby2;\n\n    if (aby2) {\n      return (-b + this.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n    } // both parabolas have same distance to directrix, thus break point is midway\n\n\n    return (rfocx + lfocx) / 2;\n  }; // calculate the right break point of a particular beach section,\n  // given a particular directrix\n\n\n  Voronoi.prototype.rightBreakPoint = function (arc, directrix) {\n    var rArc = arc.rbNext;\n\n    if (rArc) {\n      return this.leftBreakPoint(rArc, directrix);\n    }\n\n    var site = arc.site;\n    return site.y === directrix ? site.x : Infinity;\n  };\n\n  Voronoi.prototype.detachBeachsection = function (beachsection) {\n    this.detachCircleEvent(beachsection); // detach potentially attached circle event\n\n    this.beachline.rbRemoveNode(beachsection); // remove from RB-tree\n\n    this.beachsectionJunkyard.push(beachsection); // mark for reuse\n  };\n\n  Voronoi.prototype.removeBeachsection = function (beachsection) {\n    var circle = beachsection.circleEvent,\n        x = circle.x,\n        y = circle.ycenter,\n        vertex = this.createVertex(x, y),\n        previous = beachsection.rbPrevious,\n        next = beachsection.rbNext,\n        disappearingTransitions = [beachsection],\n        abs_fn = Math.abs; // remove collapsed beachsection from beachline\n\n    this.detachBeachsection(beachsection); // there could be more than one empty arc at the deletion point, this\n    // happens when more than two edges are linked by the same vertex,\n    // so we will collect all those edges by looking up both sides of\n    // the deletion point.\n    // by the way, there is *always* a predecessor/successor to any collapsed\n    // beach section, it's just impossible to have a collapsing first/last\n    // beach sections on the beachline, since they obviously are unconstrained\n    // on their left/right side.\n    // look left\n\n    var lArc = previous;\n\n    while (lArc.circleEvent && abs_fn(x - lArc.circleEvent.x) < 1e-9 && abs_fn(y - lArc.circleEvent.ycenter) < 1e-9) {\n      previous = lArc.rbPrevious;\n      disappearingTransitions.unshift(lArc);\n      this.detachBeachsection(lArc); // mark for reuse\n\n      lArc = previous;\n    } // even though it is not disappearing, I will also add the beach section\n    // immediately to the left of the left-most collapsed beach section, for\n    // convenience, since we need to refer to it later as this beach section\n    // is the 'left' site of an edge for which a start point is set.\n\n\n    disappearingTransitions.unshift(lArc);\n    this.detachCircleEvent(lArc); // look right\n\n    var rArc = next;\n\n    while (rArc.circleEvent && abs_fn(x - rArc.circleEvent.x) < 1e-9 && abs_fn(y - rArc.circleEvent.ycenter) < 1e-9) {\n      next = rArc.rbNext;\n      disappearingTransitions.push(rArc);\n      this.detachBeachsection(rArc); // mark for reuse\n\n      rArc = next;\n    } // we also have to add the beach section immediately to the right of the\n    // right-most collapsed beach section, since there is also a disappearing\n    // transition representing an edge's start point on its left.\n\n\n    disappearingTransitions.push(rArc);\n    this.detachCircleEvent(rArc); // walk through all the disappearing transitions between beach sections and\n    // set the start point of their (implied) edge.\n\n    var nArcs = disappearingTransitions.length,\n        iArc;\n\n    for (iArc = 1; iArc < nArcs; iArc++) {\n      rArc = disappearingTransitions[iArc];\n      lArc = disappearingTransitions[iArc - 1];\n      this.setEdgeStartpoint(rArc.edge, lArc.site, rArc.site, vertex);\n    } // create a new edge as we have now a new transition between\n    // two beach sections which were previously not adjacent.\n    // since this edge appears as a new vertex is defined, the vertex\n    // actually define an end point of the edge (relative to the site\n    // on the left)\n\n\n    lArc = disappearingTransitions[0];\n    rArc = disappearingTransitions[nArcs - 1];\n    rArc.edge = this.createEdge(lArc.site, rArc.site, undefined, vertex); // create circle events if any for beach sections left in the beachline\n    // adjacent to collapsed sections\n\n    this.attachCircleEvent(lArc);\n    this.attachCircleEvent(rArc);\n  };\n\n  Voronoi.prototype.addBeachsection = function (site) {\n    var x = site.x,\n        directrix = site.y; // find the left and right beach sections which will surround the newly\n    // created beach section.\n    // rhill 2011-06-01: This loop is one of the most often executed,\n    // hence we expand in-place the comparison-against-epsilon calls.\n\n    var lArc,\n        rArc,\n        dxl,\n        dxr,\n        node = this.beachline.root;\n\n    while (node) {\n      dxl = this.leftBreakPoint(node, directrix) - x; // x lessThanWithEpsilon xl => falls somewhere before the left edge of the beachsection\n\n      if (dxl > 1e-9) {\n        // this case should never happen\n        // if (!node.rbLeft) {\n        //    rArc = node.rbLeft;\n        //    break;\n        //    }\n        node = node.rbLeft;\n      } else {\n        dxr = x - this.rightBreakPoint(node, directrix); // x greaterThanWithEpsilon xr => falls somewhere after the right edge of the beachsection\n\n        if (dxr > 1e-9) {\n          if (!node.rbRight) {\n            lArc = node;\n            break;\n          }\n\n          node = node.rbRight;\n        } else {\n          // x equalWithEpsilon xl => falls exactly on the left edge of the beachsection\n          if (dxl > -1e-9) {\n            lArc = node.rbPrevious;\n            rArc = node;\n          } // x equalWithEpsilon xr => falls exactly on the right edge of the beachsection\n          else if (dxr > -1e-9) {\n            lArc = node;\n            rArc = node.rbNext;\n          } // falls exactly somewhere in the middle of the beachsection\n          else {\n            lArc = rArc = node;\n          }\n\n          break;\n        }\n      }\n    } // at this point, keep in mind that lArc and/or rArc could be\n    // undefined or null.\n    // create a new beach section object for the site and add it to RB-tree\n\n\n    var newArc = this.createBeachsection(site);\n    this.beachline.rbInsertSuccessor(lArc, newArc); // cases:\n    //\n    // [null,null]\n    // least likely case: new beach section is the first beach section on the\n    // beachline.\n    // This case means:\n    //   no new transition appears\n    //   no collapsing beach section\n    //   new beachsection become root of the RB-tree\n\n    if (!lArc && !rArc) {\n      return;\n    } // [lArc,rArc] where lArc == rArc\n    // most likely case: new beach section split an existing beach\n    // section.\n    // This case means:\n    //   one new transition appears\n    //   the left and right beach section might be collapsing as a result\n    //   two new nodes added to the RB-tree\n\n\n    if (lArc === rArc) {\n      // invalidate circle event of split beach section\n      this.detachCircleEvent(lArc); // split the beach section into two separate beach sections\n\n      rArc = this.createBeachsection(lArc.site);\n      this.beachline.rbInsertSuccessor(newArc, rArc); // since we have a new transition between two beach sections,\n      // a new edge is born\n\n      newArc.edge = rArc.edge = this.createEdge(lArc.site, newArc.site); // check whether the left and right beach sections are collapsing\n      // and if so create circle events, to be notified when the point of\n      // collapse is reached.\n\n      this.attachCircleEvent(lArc);\n      this.attachCircleEvent(rArc);\n      return;\n    } // [lArc,null]\n    // even less likely case: new beach section is the *last* beach section\n    // on the beachline -- this can happen *only* if *all* the previous beach\n    // sections currently on the beachline share the same y value as\n    // the new beach section.\n    // This case means:\n    //   one new transition appears\n    //   no collapsing beach section as a result\n    //   new beach section become right-most node of the RB-tree\n\n\n    if (lArc && !rArc) {\n      newArc.edge = this.createEdge(lArc.site, newArc.site);\n      return;\n    } // [null,rArc]\n    // impossible case: because sites are strictly processed from top to bottom,\n    // and left to right, which guarantees that there will always be a beach section\n    // on the left -- except of course when there are no beach section at all on\n    // the beach line, which case was handled above.\n    // rhill 2011-06-02: No point testing in non-debug version\n    //if (!lArc && rArc) {\n    //    throw \"Voronoi.addBeachsection(): What is this I don't even\";\n    //    }\n    // [lArc,rArc] where lArc != rArc\n    // somewhat less likely case: new beach section falls *exactly* in between two\n    // existing beach sections\n    // This case means:\n    //   one transition disappears\n    //   two new transitions appear\n    //   the left and right beach section might be collapsing as a result\n    //   only one new node added to the RB-tree\n\n\n    if (lArc !== rArc) {\n      // invalidate circle events of left and right sites\n      this.detachCircleEvent(lArc);\n      this.detachCircleEvent(rArc); // an existing transition disappears, meaning a vertex is defined at\n      // the disappearance point.\n      // since the disappearance is caused by the new beachsection, the\n      // vertex is at the center of the circumscribed circle of the left,\n      // new and right beachsections.\n      // http://mathforum.org/library/drmath/view/55002.html\n      // Except that I bring the origin at A to simplify\n      // calculation\n\n      var lSite = lArc.site,\n          ax = lSite.x,\n          ay = lSite.y,\n          bx = site.x - ax,\n          by = site.y - ay,\n          rSite = rArc.site,\n          cx = rSite.x - ax,\n          cy = rSite.y - ay,\n          d = 2 * (bx * cy - by * cx),\n          hb = bx * bx + by * by,\n          hc = cx * cx + cy * cy,\n          vertex = this.createVertex((cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay); // one transition disappear\n\n      this.setEdgeStartpoint(rArc.edge, lSite, rSite, vertex); // two new transitions appear at the new vertex location\n\n      newArc.edge = this.createEdge(lSite, site, undefined, vertex);\n      rArc.edge = this.createEdge(site, rSite, undefined, vertex); // check whether the left and right beach sections are collapsing\n      // and if so create circle events, to handle the point of collapse.\n\n      this.attachCircleEvent(lArc);\n      this.attachCircleEvent(rArc);\n      return;\n    }\n  }; // ---------------------------------------------------------------------------\n  // Circle event methods\n  // rhill 2011-06-07: For some reasons, performance suffers significantly\n  // when instanciating a literal object instead of an empty ctor\n\n\n  Voronoi.prototype.CircleEvent = function () {\n    // rhill 2013-10-12: it helps to state exactly what we are at ctor time.\n    this.arc = null;\n    this.rbLeft = null;\n    this.rbNext = null;\n    this.rbParent = null;\n    this.rbPrevious = null;\n    this.rbRed = false;\n    this.rbRight = null;\n    this.site = null;\n    this.x = this.y = this.ycenter = 0;\n  };\n\n  Voronoi.prototype.attachCircleEvent = function (arc) {\n    var lArc = arc.rbPrevious,\n        rArc = arc.rbNext;\n\n    if (!lArc || !rArc) {\n      return;\n    } // does that ever happen?\n\n\n    var lSite = lArc.site,\n        cSite = arc.site,\n        rSite = rArc.site; // If site of left beachsection is same as site of\n    // right beachsection, there can't be convergence\n\n    if (lSite === rSite) {\n      return;\n    } // Find the circumscribed circle for the three sites associated\n    // with the beachsection triplet.\n    // rhill 2011-05-26: It is more efficient to calculate in-place\n    // rather than getting the resulting circumscribed circle from an\n    // object returned by calling Voronoi.circumcircle()\n    // http://mathforum.org/library/drmath/view/55002.html\n    // Except that I bring the origin at cSite to simplify calculations.\n    // The bottom-most part of the circumcircle is our Fortune 'circle\n    // event', and its center is a vertex potentially part of the final\n    // Voronoi diagram.\n\n\n    var bx = cSite.x,\n        by = cSite.y,\n        ax = lSite.x - bx,\n        ay = lSite.y - by,\n        cx = rSite.x - bx,\n        cy = rSite.y - by; // If points l->c->r are clockwise, then center beach section does not\n    // collapse, hence it can't end up as a vertex (we reuse 'd' here, which\n    // sign is reverse of the orientation, hence we reverse the test.\n    // http://en.wikipedia.org/wiki/Curve_orientation#Orientation_of_a_simple_polygon\n    // rhill 2011-05-21: Nasty finite precision error which caused circumcircle() to\n    // return infinites: 1e-12 seems to fix the problem.\n\n    var d = 2 * (ax * cy - ay * cx);\n\n    if (d >= -2e-12) {\n      return;\n    }\n\n    var ha = ax * ax + ay * ay,\n        hc = cx * cx + cy * cy,\n        x = (cy * ha - ay * hc) / d,\n        y = (ax * hc - cx * ha) / d,\n        ycenter = y + by; // Important: ybottom should always be under or at sweep, so no need\n    // to waste CPU cycles by checking\n    // recycle circle event object if possible\n\n    var circleEvent = this.circleEventJunkyard.pop();\n\n    if (!circleEvent) {\n      circleEvent = new this.CircleEvent();\n    }\n\n    circleEvent.arc = arc;\n    circleEvent.site = cSite;\n    circleEvent.x = x + bx;\n    circleEvent.y = ycenter + this.sqrt(x * x + y * y); // y bottom\n\n    circleEvent.ycenter = ycenter;\n    arc.circleEvent = circleEvent; // find insertion point in RB-tree: circle events are ordered from\n    // smallest to largest\n\n    var predecessor = null,\n        node = this.circleEvents.root;\n\n    while (node) {\n      if (circleEvent.y < node.y || circleEvent.y === node.y && circleEvent.x <= node.x) {\n        if (node.rbLeft) {\n          node = node.rbLeft;\n        } else {\n          predecessor = node.rbPrevious;\n          break;\n        }\n      } else {\n        if (node.rbRight) {\n          node = node.rbRight;\n        } else {\n          predecessor = node;\n          break;\n        }\n      }\n    }\n\n    this.circleEvents.rbInsertSuccessor(predecessor, circleEvent);\n\n    if (!predecessor) {\n      this.firstCircleEvent = circleEvent;\n    }\n  };\n\n  Voronoi.prototype.detachCircleEvent = function (arc) {\n    var circleEvent = arc.circleEvent;\n\n    if (circleEvent) {\n      if (!circleEvent.rbPrevious) {\n        this.firstCircleEvent = circleEvent.rbNext;\n      }\n\n      this.circleEvents.rbRemoveNode(circleEvent); // remove from RB-tree\n\n      this.circleEventJunkyard.push(circleEvent);\n      arc.circleEvent = null;\n    }\n  }; // ---------------------------------------------------------------------------\n  // Diagram completion methods\n  // connect dangling edges (not if a cursory test tells us\n  // it is not going to be visible.\n  // return value:\n  //   false: the dangling endpoint couldn't be connected\n  //   true: the dangling endpoint could be connected\n\n\n  Voronoi.prototype.connectEdge = function (edge, bbox) {\n    // skip if end point already connected\n    var vb = edge.vb;\n\n    if (!!vb) {\n      return true;\n    } // make local copy for performance purpose\n\n\n    var va = edge.va,\n        xl = bbox.xl,\n        xr = bbox.xr,\n        yt = bbox.yt,\n        yb = bbox.yb,\n        lSite = edge.lSite,\n        rSite = edge.rSite,\n        lx = lSite.x,\n        ly = lSite.y,\n        rx = rSite.x,\n        ry = rSite.y,\n        fx = (lx + rx) / 2,\n        fy = (ly + ry) / 2,\n        fm,\n        fb; // if we reach here, this means cells which use this edge will need\n    // to be closed, whether because the edge was removed, or because it\n    // was connected to the bounding box.\n\n    this.cells[lSite.voronoiId].closeMe = true;\n    this.cells[rSite.voronoiId].closeMe = true; // get the line equation of the bisector if line is not vertical\n\n    if (ry !== ly) {\n      fm = (lx - rx) / (ry - ly);\n      fb = fy - fm * fx;\n    } // remember, direction of line (relative to left site):\n    // upward: left.x < right.x\n    // downward: left.x > right.x\n    // horizontal: left.x == right.x\n    // upward: left.x < right.x\n    // rightward: left.y < right.y\n    // leftward: left.y > right.y\n    // vertical: left.y == right.y\n    // depending on the direction, find the best side of the\n    // bounding box to use to determine a reasonable start point\n    // rhill 2013-12-02:\n    // While at it, since we have the values which define the line,\n    // clip the end of va if it is outside the bbox.\n    // https://github.com/gorhill/Javascript-Voronoi/issues/15\n    // TODO: Do all the clipping here rather than rely on Liang-Barsky\n    // which does not do well sometimes due to loss of arithmetic\n    // precision. The code here doesn't degrade if one of the vertex is\n    // at a huge distance.\n    // special case: vertical line\n\n\n    if (fm === undefined) {\n      // doesn't intersect with viewport\n      if (fx < xl || fx >= xr) {\n        return false;\n      } // downward\n\n\n      if (lx > rx) {\n        if (!va || va.y < yt) {\n          va = this.createVertex(fx, yt);\n        } else if (va.y >= yb) {\n          return false;\n        }\n\n        vb = this.createVertex(fx, yb);\n      } // upward\n      else {\n        if (!va || va.y > yb) {\n          va = this.createVertex(fx, yb);\n        } else if (va.y < yt) {\n          return false;\n        }\n\n        vb = this.createVertex(fx, yt);\n      }\n    } // closer to vertical than horizontal, connect start point to the\n    // top or bottom side of the bounding box\n    else if (fm < -1 || fm > 1) {\n      // downward\n      if (lx > rx) {\n        if (!va || va.y < yt) {\n          va = this.createVertex((yt - fb) / fm, yt);\n        } else if (va.y >= yb) {\n          return false;\n        }\n\n        vb = this.createVertex((yb - fb) / fm, yb);\n      } // upward\n      else {\n        if (!va || va.y > yb) {\n          va = this.createVertex((yb - fb) / fm, yb);\n        } else if (va.y < yt) {\n          return false;\n        }\n\n        vb = this.createVertex((yt - fb) / fm, yt);\n      }\n    } // closer to horizontal than vertical, connect start point to the\n    // left or right side of the bounding box\n    else {\n      // rightward\n      if (ly < ry) {\n        if (!va || va.x < xl) {\n          va = this.createVertex(xl, fm * xl + fb);\n        } else if (va.x >= xr) {\n          return false;\n        }\n\n        vb = this.createVertex(xr, fm * xr + fb);\n      } // leftward\n      else {\n        if (!va || va.x > xr) {\n          va = this.createVertex(xr, fm * xr + fb);\n        } else if (va.x < xl) {\n          return false;\n        }\n\n        vb = this.createVertex(xl, fm * xl + fb);\n      }\n    }\n\n    edge.va = va;\n    edge.vb = vb;\n    return true;\n  }; // line-clipping code taken from:\n  //   Liang-Barsky function by Daniel White\n  //   http://www.skytopia.com/project/articles/compsci/clipping.html\n  // Thanks!\n  // A bit modified to minimize code paths\n\n\n  Voronoi.prototype.clipEdge = function (edge, bbox) {\n    var ax = edge.va.x,\n        ay = edge.va.y,\n        bx = edge.vb.x,\n        by = edge.vb.y,\n        t0 = 0,\n        t1 = 1,\n        dx = bx - ax,\n        dy = by - ay; // left\n\n    var q = ax - bbox.xl;\n\n    if (dx === 0 && q < 0) {\n      return false;\n    }\n\n    var r = -q / dx;\n\n    if (dx < 0) {\n      if (r < t0) {\n        return false;\n      }\n\n      if (r < t1) {\n        t1 = r;\n      }\n    } else if (dx > 0) {\n      if (r > t1) {\n        return false;\n      }\n\n      if (r > t0) {\n        t0 = r;\n      }\n    } // right\n\n\n    q = bbox.xr - ax;\n\n    if (dx === 0 && q < 0) {\n      return false;\n    }\n\n    r = q / dx;\n\n    if (dx < 0) {\n      if (r > t1) {\n        return false;\n      }\n\n      if (r > t0) {\n        t0 = r;\n      }\n    } else if (dx > 0) {\n      if (r < t0) {\n        return false;\n      }\n\n      if (r < t1) {\n        t1 = r;\n      }\n    } // top\n\n\n    q = ay - bbox.yt;\n\n    if (dy === 0 && q < 0) {\n      return false;\n    }\n\n    r = -q / dy;\n\n    if (dy < 0) {\n      if (r < t0) {\n        return false;\n      }\n\n      if (r < t1) {\n        t1 = r;\n      }\n    } else if (dy > 0) {\n      if (r > t1) {\n        return false;\n      }\n\n      if (r > t0) {\n        t0 = r;\n      }\n    } // bottom        \n\n\n    q = bbox.yb - ay;\n\n    if (dy === 0 && q < 0) {\n      return false;\n    }\n\n    r = q / dy;\n\n    if (dy < 0) {\n      if (r > t1) {\n        return false;\n      }\n\n      if (r > t0) {\n        t0 = r;\n      }\n    } else if (dy > 0) {\n      if (r < t0) {\n        return false;\n      }\n\n      if (r < t1) {\n        t1 = r;\n      }\n    } // if we reach this point, Voronoi edge is within bbox\n    // if t0 > 0, va needs to change\n    // rhill 2011-06-03: we need to create a new vertex rather\n    // than modifying the existing one, since the existing\n    // one is likely shared with at least another edge\n\n\n    if (t0 > 0) {\n      edge.va = this.createVertex(ax + t0 * dx, ay + t0 * dy);\n    } // if t1 < 1, vb needs to change\n    // rhill 2011-06-03: we need to create a new vertex rather\n    // than modifying the existing one, since the existing\n    // one is likely shared with at least another edge\n\n\n    if (t1 < 1) {\n      edge.vb = this.createVertex(ax + t1 * dx, ay + t1 * dy);\n    } // va and/or vb were clipped, thus we will need to close\n    // cells which use this edge.\n\n\n    if (t0 > 0 || t1 < 1) {\n      this.cells[edge.lSite.voronoiId].closeMe = true;\n      this.cells[edge.rSite.voronoiId].closeMe = true;\n    }\n\n    return true;\n  }; // Connect/cut edges at bounding box\n\n\n  Voronoi.prototype.clipEdges = function (bbox) {\n    // connect all dangling edges to bounding box\n    // or get rid of them if it can't be done\n    var edges = this.edges,\n        iEdge = edges.length,\n        edge,\n        abs_fn = Math.abs; // iterate backward so we can splice safely\n\n    while (iEdge--) {\n      edge = edges[iEdge]; // edge is removed if:\n      //   it is wholly outside the bounding box\n      //   it is looking more like a point than a line\n\n      if (!this.connectEdge(edge, bbox) || !this.clipEdge(edge, bbox) || abs_fn(edge.va.x - edge.vb.x) < 1e-9 && abs_fn(edge.va.y - edge.vb.y) < 1e-9) {\n        edge.va = edge.vb = null;\n        edges.splice(iEdge, 1);\n      }\n    }\n  }; // Close the cells.\n  // The cells are bound by the supplied bounding box.\n  // Each cell refers to its associated site, and a list\n  // of halfedges ordered counterclockwise.\n\n\n  Voronoi.prototype.closeCells = function (bbox) {\n    var xl = bbox.xl,\n        xr = bbox.xr,\n        yt = bbox.yt,\n        yb = bbox.yb,\n        cells = this.cells,\n        iCell = cells.length,\n        cell,\n        iLeft,\n        halfedges,\n        nHalfedges,\n        edge,\n        va,\n        vb,\n        vz,\n        lastBorderSegment,\n        abs_fn = Math.abs;\n\n    while (iCell--) {\n      cell = cells[iCell]; // prune, order halfedges counterclockwise, then add missing ones\n      // required to close cells\n\n      if (!cell.prepareHalfedges()) {\n        continue;\n      }\n\n      if (!cell.closeMe) {\n        continue;\n      } // find first 'unclosed' point.\n      // an 'unclosed' point will be the end point of a halfedge which\n      // does not match the start point of the following halfedge\n\n\n      halfedges = cell.halfedges;\n      nHalfedges = halfedges.length; // special case: only one site, in which case, the viewport is the cell\n      // ...\n      // all other cases\n\n      iLeft = 0;\n\n      while (iLeft < nHalfedges) {\n        va = halfedges[iLeft].getEndpoint();\n        vz = halfedges[(iLeft + 1) % nHalfedges].getStartpoint(); // if end point is not equal to start point, we need to add the missing\n        // halfedge(s) up to vz\n\n        if (abs_fn(va.x - vz.x) >= 1e-9 || abs_fn(va.y - vz.y) >= 1e-9) {\n          // rhill 2013-12-02:\n          // \"Holes\" in the halfedges are not necessarily always adjacent.\n          // https://github.com/gorhill/Javascript-Voronoi/issues/16\n          // find entry point:\n          switch (true) {\n            // walk downward along left side\n            case this.equalWithEpsilon(va.x, xl) && this.lessThanWithEpsilon(va.y, yb):\n              lastBorderSegment = this.equalWithEpsilon(vz.x, xl);\n              vb = this.createVertex(xl, lastBorderSegment ? vz.y : yb);\n              edge = this.createBorderEdge(cell.site, va, vb);\n              iLeft++;\n              halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));\n              nHalfedges++;\n\n              if (lastBorderSegment) {\n                break;\n              }\n\n              va = vb;\n            // fall through\n            // walk rightward along bottom side\n\n            case this.equalWithEpsilon(va.y, yb) && this.lessThanWithEpsilon(va.x, xr):\n              lastBorderSegment = this.equalWithEpsilon(vz.y, yb);\n              vb = this.createVertex(lastBorderSegment ? vz.x : xr, yb);\n              edge = this.createBorderEdge(cell.site, va, vb);\n              iLeft++;\n              halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));\n              nHalfedges++;\n\n              if (lastBorderSegment) {\n                break;\n              }\n\n              va = vb;\n            // fall through\n            // walk upward along right side\n\n            case this.equalWithEpsilon(va.x, xr) && this.greaterThanWithEpsilon(va.y, yt):\n              lastBorderSegment = this.equalWithEpsilon(vz.x, xr);\n              vb = this.createVertex(xr, lastBorderSegment ? vz.y : yt);\n              edge = this.createBorderEdge(cell.site, va, vb);\n              iLeft++;\n              halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));\n              nHalfedges++;\n\n              if (lastBorderSegment) {\n                break;\n              }\n\n              va = vb;\n            // fall through\n            // walk leftward along top side\n\n            case this.equalWithEpsilon(va.y, yt) && this.greaterThanWithEpsilon(va.x, xl):\n              lastBorderSegment = this.equalWithEpsilon(vz.y, yt);\n              vb = this.createVertex(lastBorderSegment ? vz.x : xl, yt);\n              edge = this.createBorderEdge(cell.site, va, vb);\n              iLeft++;\n              halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));\n              nHalfedges++;\n\n              if (lastBorderSegment) {\n                break;\n              }\n\n              va = vb; // fall through\n              // walk downward along left side\n\n              lastBorderSegment = this.equalWithEpsilon(vz.x, xl);\n              vb = this.createVertex(xl, lastBorderSegment ? vz.y : yb);\n              edge = this.createBorderEdge(cell.site, va, vb);\n              iLeft++;\n              halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));\n              nHalfedges++;\n\n              if (lastBorderSegment) {\n                break;\n              }\n\n              va = vb; // fall through\n              // walk rightward along bottom side\n\n              lastBorderSegment = this.equalWithEpsilon(vz.y, yb);\n              vb = this.createVertex(lastBorderSegment ? vz.x : xr, yb);\n              edge = this.createBorderEdge(cell.site, va, vb);\n              iLeft++;\n              halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));\n              nHalfedges++;\n\n              if (lastBorderSegment) {\n                break;\n              }\n\n              va = vb; // fall through\n              // walk upward along right side\n\n              lastBorderSegment = this.equalWithEpsilon(vz.x, xr);\n              vb = this.createVertex(xr, lastBorderSegment ? vz.y : yt);\n              edge = this.createBorderEdge(cell.site, va, vb);\n              iLeft++;\n              halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));\n              nHalfedges++;\n\n              if (lastBorderSegment) {\n                break;\n              }\n\n            // fall through\n\n            default:\n              throw \"Voronoi.closeCells() > this makes no sense!\";\n          }\n        }\n\n        iLeft++;\n      }\n\n      cell.closeMe = false;\n    }\n  }; // ---------------------------------------------------------------------------\n  // Debugging helper\n\n  /*\n  Voronoi.prototype.dumpBeachline = function(y) {\n      console.log('Voronoi.dumpBeachline(%f) > Beachsections, from left to right:', y);\n      if ( !this.beachline ) {\n          console.log('  None');\n          }\n      else {\n          var bs = this.beachline.getFirst(this.beachline.root);\n          while ( bs ) {\n              console.log('  site %d: xl: %f, xr: %f', bs.site.voronoiId, this.leftBreakPoint(bs, y), this.rightBreakPoint(bs, y));\n              bs = bs.rbNext;\n              }\n          }\n      };\n  */\n  // ---------------------------------------------------------------------------\n  // Helper: Quantize sites\n  // rhill 2013-10-12:\n  // This is to solve https://github.com/gorhill/Javascript-Voronoi/issues/15\n  // Since not all users will end up using the kind of coord values which would\n  // cause the issue to arise, I chose to let the user decide whether or not\n  // he should sanitize his coord values through this helper. This way, for\n  // those users who uses coord values which are known to be fine, no overhead is\n  // added.\n\n\n  Voronoi.prototype.quantizeSites = function (sites) {\n    var ε = this.ε,\n        n = sites.length,\n        site;\n\n    while (n--) {\n      site = sites[n];\n      site.x = Math.floor(site.x / ε) * ε;\n      site.y = Math.floor(site.y / ε) * ε;\n    }\n  }; // ---------------------------------------------------------------------------\n  // Helper: Recycle diagram: all vertex, edge and cell objects are\n  // \"surrendered\" to the Voronoi object for reuse.\n  // TODO: rhill-voronoi-core v2: more performance to be gained\n  // when I change the semantic of what is returned.\n\n\n  Voronoi.prototype.recycle = function (diagram) {\n    if (diagram) {\n      if (diagram instanceof this.Diagram) {\n        this.toRecycle = diagram;\n      } else {\n        throw 'Voronoi.recycleDiagram() > Need a Diagram object.';\n      }\n    }\n  }; // ---------------------------------------------------------------------------\n  // Top-level Fortune loop\n  // rhill 2011-05-19:\n  //   Voronoi sites are kept client-side now, to allow\n  //   user to freely modify content. At compute time,\n  //   *references* to sites are copied locally.\n\n\n  Voronoi.prototype.compute = function (sites, bbox) {\n    // to measure execution time\n    var startTime = new Date(); // init internal state\n\n    this.reset(); // any diagram data available for recycling?\n    // I do that here so that this is included in execution time\n\n    if (this.toRecycle) {\n      this.vertexJunkyard = this.vertexJunkyard.concat(this.toRecycle.vertices);\n      this.edgeJunkyard = this.edgeJunkyard.concat(this.toRecycle.edges);\n      this.cellJunkyard = this.cellJunkyard.concat(this.toRecycle.cells);\n      this.toRecycle = null;\n    } // Initialize site event queue\n\n\n    var siteEvents = sites.slice(0);\n    siteEvents.sort(function (a, b) {\n      var r = b.y - a.y;\n\n      if (r) {\n        return r;\n      }\n\n      return b.x - a.x;\n    }); // process queue\n\n    var site = siteEvents.pop(),\n        siteid = 0,\n        xsitex,\n        // to avoid duplicate sites\n    xsitey,\n        cells = this.cells,\n        circle; // main loop\n\n    for (;;) {\n      // we need to figure whether we handle a site or circle event\n      // for this we find out if there is a site event and it is\n      // 'earlier' than the circle event\n      circle = this.firstCircleEvent; // add beach section\n\n      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {\n        // only if site is not a duplicate\n        if (site.x !== xsitex || site.y !== xsitey) {\n          // first create cell for new site\n          cells[siteid] = this.createCell(site);\n          site.voronoiId = siteid++; // then create a beachsection for that site\n\n          this.addBeachsection(site); // remember last site coords to detect duplicate\n\n          xsitey = site.y;\n          xsitex = site.x;\n        }\n\n        site = siteEvents.pop();\n      } // remove beach section\n      else if (circle) {\n        this.removeBeachsection(circle.arc);\n      } // all done, quit\n      else {\n        break;\n      }\n    } // wrapping-up:\n    //   connect dangling edges to bounding box\n    //   cut edges as per bounding box\n    //   discard edges completely outside bounding box\n    //   discard edges which are point-like\n\n\n    this.clipEdges(bbox); //   add missing edges in order to close opened cells\n\n    this.closeCells(bbox); // to measure execution time\n\n    var stopTime = new Date(); // prepare return values\n\n    var diagram = new this.Diagram();\n    diagram.cells = this.cells;\n    diagram.edges = this.edges;\n    diagram.vertices = this.vertices;\n    diagram.execTime = stopTime.getTime() - startTime.getTime(); // clean up\n\n    this.reset();\n    return diagram;\n  };\n  /******************************************************************************/\n\n\n  if (typeof module !== 'undefined') {\n    module.exports = Voronoi;\n  }\n\n  this.Voronoi = Voronoi;\n}.call(this, module);\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}},\"stroke_caps\":{\"fixStrokes.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/stroke_caps/fixStrokes.js                                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!function (module1) {\n  const {\n    distToPath,\n    getCosSimAroundPoint,\n    getLinesIntersectPoint,\n    getOutlinePoints,\n    extendPointOnLine,\n    estimateTanPoints,\n    roundPathPoints,\n    ptEq,\n    dist\n  } = require('./utils');\n\n  CLIP_THRESH = 2;\n  LOWER_COS_SIM_THRESH = 0.89;\n  UPPER_COS_SIM_THRESH = 0.97; // A bridge is a place in the pathstring where 2 strokes intersect. It can either be 1 stroke clipping\n  // another, or it can be strokes passing through each other. In the pathstring from makemeahanzi, any\n  // L # # in the pathstring is a\n\n  class Bridge {\n    constructor(points, pointString, stroke) {\n      this.points = points;\n      this.pointString = pointString;\n      this.stroke = stroke;\n      this.estTanPoints = estimateTanPoints(stroke.outline, points);\n    }\n\n    getClips() {\n      // this clip point is super tiny, it's probably just a glitch, skip it\n      if (dist(this.points[0], this.points[1]) < 3.1) return [];\n      const cosSim0 = getCosSimAroundPoint(this.points[0], this.stroke.outline);\n      const cosSim1 = getCosSimAroundPoint(this.points[1], this.stroke.outline); // If the angle around the bridge points looks flat, it's probably an intersection.\n\n      if (Math.min(cosSim0, cosSim1) > LOWER_COS_SIM_THRESH && Math.max(cosSim0, cosSim1) > UPPER_COS_SIM_THRESH) {\n        return [];\n      }\n\n      return this.stroke.character.strokes.filter(stroke => {\n        if (stroke === this.stroke) return false;\n        const dist0 = distToPath(this.points[0], stroke.outline);\n        const dist1 = distToPath(this.points[1], stroke.outline);\n        return dist0 <= CLIP_THRESH && dist1 <= CLIP_THRESH;\n      }).map(clippingStroke => new Clip(this, clippingStroke));\n    }\n\n  }\n\n  class Clip {\n    constructor(bridge, clippingStroke) {\n      this.points = bridge.points;\n      this.estTanPoints = bridge.estTanPoints;\n      this.pointString = bridge.pointString;\n      this.clippedBy = [clippingStroke];\n      this.isDouble = false;\n    }\n\n    canMerge(otherClip) {\n      return ptEq(this.points[1], otherClip.points[0]);\n    }\n\n    mergeIntoDouble(otherClip) {\n      this.isDouble = true;\n      this.clippedBy = this.clippedBy.concat(otherClip.clippedBy);\n      this.middlePoint = otherClip.points[0];\n      this.points[1] = otherClip.points[1];\n      this.estTanPoints[1] = otherClip.estTanPoints[1];\n      this.pointString += otherClip.pointString.replace(/.*L/, ' L');\n    }\n\n    getNewStrokeTip() {\n      const maxControlPoint = getLinesIntersectPoint(this.estTanPoints[0], this.points[0], this.estTanPoints[1], this.points[1]);\n      const maxDistControl0 = dist(maxControlPoint, this.points[0]);\n      const maxDistControl1 = dist(maxControlPoint, this.points[1]);\n      let distControl0 = Math.min(maxDistControl0, 30);\n      let distControl1 = Math.min(maxDistControl1, 30); // if the 2 lines are parallel, there will be no intersection point. Just use 30 in that case.\n\n      if (isNaN(distControl0)) distControl0 = 30;\n      if (isNaN(distControl1)) distControl1 = 30;\n\n      if (this.isDouble) {\n        const midDist0 = dist(this.middlePoint, this.points[0]);\n        const midDist1 = dist(this.middlePoint, this.points[1]);\n        distControl0 = Math.max(midDist0 * 1.4, distControl0);\n        distControl1 = Math.max(midDist1 * 1.4, distControl1);\n      }\n\n      const controlPoint0 = extendPointOnLine(this.estTanPoints[0], this.points[0], distControl0);\n      const controlPoint1 = extendPointOnLine(this.estTanPoints[1], this.points[1], distControl1);\n\n      const pString = point => \"\".concat(Math.round(point.x), \" \").concat(Math.round(point.y));\n\n      return \"\".concat(pString(this.points[0]), \" C \").concat(pString(controlPoint0), \" \").concat(pString(controlPoint1), \" \").concat(pString(this.points[1]));\n    }\n\n  }\n\n  class Stroke {\n    constructor(pathString, character, strokeNum) {\n      this.pathString = pathString;\n      this.outline = getOutlinePoints(pathString);\n      this.character = character;\n      this.strokeNum = strokeNum;\n    }\n\n    getBridges() {\n      const pointStringParts = this.pathString.match(/-?\\d+(?:\\.\\d+)? -?\\d+(?:\\.\\d+)? L/ig);\n      if (!pointStringParts) return [];\n      return pointStringParts.map(pointStringPart => {\n        const fullPointStringRegex = new RegExp(\"\".concat(pointStringPart, \" -?\\\\d+(?:\\\\.\\\\d+)? -?\\\\d+(?:\\\\.\\\\d+)?\"));\n        const pointString = this.pathString.match(fullPointStringRegex)[0];\n        const parts = pointString.split(/\\sL?\\s?/).map(num => parseFloat(num));\n        const points = [{\n          x: parts[0],\n          y: parts[1]\n        }, {\n          x: parts[2],\n          y: parts[3]\n        }];\n        return new Bridge(points, pointString, this);\n      });\n    }\n\n    fixPathString() {\n      const bridges = this.getBridges();\n      let clips = [];\n      bridges.forEach(bridge => {\n        bridge.getClips().forEach(clip => {\n          const lastClip = clips[clips.length - 1];\n\n          if (lastClip && lastClip.canMerge(clip)) {\n            lastClip.mergeIntoDouble(clip);\n          } else {\n            clips.push(clip);\n          }\n        });\n      });\n      let modifiedPathString = this.pathString;\n      clips.forEach(clip => {\n        const newTip = clip.getNewStrokeTip();\n        modifiedPathString = roundPathPoints(modifiedPathString.replace(clip.pointString, newTip));\n      });\n      return {\n        isModified: clips.length > 0,\n        isDoubleClipped: !!clips.find(clip => clip.isDouble),\n        pathString: modifiedPathString,\n        strokeNum: this.strokeNum\n      };\n    }\n\n  }\n\n  class Character {\n    constructor(pathStrings) {\n      this.strokes = pathStrings.map((path, i) => new Stroke(path, this, i));\n    }\n\n  }\n\n  const fixStrokesWithDetails = strokePathStrings => {\n    const character = new Character(strokePathStrings);\n    const fixedStrokesInfo = character.strokes.map(stroke => stroke.fixPathString());\n    return {\n      modified: !!fixedStrokesInfo.find(summary => summary.isModified),\n      hasDoubleClippedStroke: !!fixedStrokesInfo.find(summary => summary.isDoubleClipped),\n      modifiedStrokes: fixedStrokesInfo.filter(summary => summary.isModified).map(summary => summary.strokeNum),\n      strokes: fixedStrokesInfo.map(summary => summary.pathString)\n    };\n  };\n\n  const fixStrokesOnce = strokes => {\n    const corrected = fixStrokesWithDetails(strokes);\n    return corrected.modified ? corrected.strokes : strokes;\n  };\n\n  const fixStrokes = strokes => fixStrokesOnce(fixStrokesOnce(strokes));\n\n  module.exports = {\n    fixStrokes\n  };\n}.call(this, module);\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"utils.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/stroke_caps/utils.js                                                                                            //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!function (module1) {\n  const svgPathUtils = require('point-at-length');\n\n  const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n\n  const norm = vect => dist(vect, {\n    x: 0,\n    y: 0\n  });\n\n  const subtract = (p1, p2) => ({\n    x: p1.x - p2.x,\n    y: p1.y - p2.y\n  });\n\n  const ptEq = (p1, p2) => p1.x === p2.x && p1.y === p2.y;\n\n  const getOutlinePoints = function (pathString) {\n    let count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    const path = svgPathUtils(pathString);\n    const delta = path.length() / count;\n    const outline = [];\n\n    for (let i = 0; i < count; i += 1) {\n      const svgPoint = path.at(i * delta);\n      outline.push({\n        x: svgPoint[0],\n        y: svgPoint[1]\n      });\n    }\n\n    return outline;\n  }; // get the intersection point of 2 lines defined by 2 points each\n  // from https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\n\n\n  const getLinesIntersectPoint = (l1p1, l1p2, l2p1, l2p2) => {\n    const x1 = l1p1.x;\n    const x2 = l1p2.x;\n    const x3 = l2p1.x;\n    const x4 = l2p2.x;\n    const y1 = l1p1.y;\n    const y2 = l1p2.y;\n    const y3 = l2p1.y;\n    const y4 = l2p2.y;\n    const xNumerator = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);\n    const yNumerator = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);\n    const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    return {\n      x: xNumerator / denominator,\n      y: yNumerator / denominator\n    };\n  };\n\n  const getPointIndex = (point, pathOutline) => {\n    const dists = pathOutline.map(outlinePoint => dist(point, outlinePoint));\n    const min = Math.min(...dists);\n    return dists.indexOf(min);\n  };\n\n  const getIndexAtDelta = (index, delta, pathOutline) => {\n    return (pathOutline.length + index + delta) % pathOutline.length;\n  };\n\n  const getCosSimAroundPoint = (point, pathOutline) => {\n    // if this is 1, the point is on a flat line.\n    const pointIndex = getPointIndex(point, pathOutline);\n    const preIndex = getIndexAtDelta(pointIndex, -3, pathOutline);\n    const postIndex = getIndexAtDelta(pointIndex, 3, pathOutline);\n    const vect1 = subtract(pathOutline[pointIndex], pathOutline[preIndex]);\n    const vect2 = subtract(pathOutline[postIndex], pathOutline[pointIndex]);\n    return (vect1.x * vect2.x + vect1.y * vect2.y) / (norm(vect1) * norm(vect2));\n  }; // return a new point, p3, which is on the same line as p1 and p2, but distance away\n  // from p2. p1, p2, p3 will always lie on the line in that order\n\n\n  const extendPointOnLine = (p1, p2, distance) => {\n    const vect = subtract(p2, p1);\n    const mag = distance / norm(vect);\n    return {\n      x: p2.x + mag * vect.x,\n      y: p2.y + mag * vect.y\n    };\n  };\n\n  const distToPath = (point, pathOutline) => {\n    const dists = pathOutline.map(outlinePoint => dist(point, outlinePoint));\n    return Math.min(...dists);\n  };\n\n  const roundPathPoints = pathString => {\n    const floats = pathString.match(/\\d+\\.\\d+/ig);\n    if (!floats) return pathString;\n    let fixedPathString = pathString;\n    floats.forEach(float => {\n      fixedPathString = fixedPathString.replace(float, Math.round(parseFloat(float)));\n    });\n    return fixedPathString;\n  };\n\n  const estimateTanPoints = (pathOutline, clipPoints) => {\n    const cpIndex0 = getPointIndex(clipPoints[0], pathOutline);\n    const cpIndex1 = getPointIndex(clipPoints[1], pathOutline);\n    return [pathOutline[getIndexAtDelta(cpIndex0, -15, pathOutline)], pathOutline[getIndexAtDelta(cpIndex1, 15, pathOutline)]];\n  };\n\n  module.exports = {\n    distToPath,\n    getCosSimAroundPoint,\n    getOutlinePoints,\n    getLinesIntersectPoint,\n    extendPointOnLine,\n    estimateTanPoints,\n    dist,\n    ptEq,\n    roundPathPoints\n  };\n}.call(this, module);\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"animation.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/animation.js                                                                                                    //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  getAnimationData: () => getAnimationData\n});\nconst kIdPrefix = 'make-me-a-hanzi';\nconst kWidth = 128;\n\nconst distance2 = (point1, point2) => {\n  const diff = [point1[0] - point2[0], point1[1] - point2[1]];\n  return diff[0] * diff[0] + diff[1] * diff[1];\n};\n\nconst getMedianLength = median => {\n  let result = 0;\n\n  for (let i = 0; i < median.length - 1; i++) {\n    result += Math.sqrt(distance2(median[i], median[i + 1]));\n  }\n\n  return result;\n};\n\nconst getMedianPath = median => {\n  const result = [];\n\n  for (let point of median) {\n    result.push(result.length === 0 ? 'M' : 'L');\n    result.push('' + point[0]);\n    result.push('' + point[1]);\n  }\n\n  return result.join(' ');\n};\n\nconst getAnimationData = (strokes, medians, options) => {\n  options = options || {};\n  const delay = 1024 * (options.delay || 0.3);\n  const speed = 1024 * (options.speed || 0.02);\n  const lengths = medians.map(x => getMedianLength(x) + kWidth).map(Math.round);\n  const paths = medians.map(getMedianPath);\n  const animations = [];\n  let total_duration = 0;\n\n  for (let i = 0; i < strokes.length; i++) {\n    const offset = lengths[i] + kWidth;\n    const duration = (delay + offset) / speed / 60;\n    const fraction = Math.round(100 * offset / (delay + offset));\n    animations.push({\n      animation_id: \"\".concat(kIdPrefix, \"-animation-\").concat(i),\n      clip_id: \"\".concat(kIdPrefix, \"-clip-\").concat(i),\n      d: paths[i],\n      delay: \"\".concat(total_duration, \"s\"),\n      duration: \"\".concat(duration, \"s\"),\n      fraction: \"\".concat(fraction, \"%\"),\n      keyframes: \"keyframes\".concat(i),\n      length: lengths[i],\n      offset: offset,\n      spacing: 2 * lengths[i],\n      stroke: strokes[i],\n      width: kWidth\n    });\n    total_duration += duration;\n  }\n\n  return {\n    animations: animations,\n    strokes: strokes\n  };\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"base.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/base.js                                                                                                         //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!function (module1) {\n  module1.export({\n    assert: () => assert,\n    getPWD: () => getPWD,\n    maybeRequire: () => maybeRequire,\n    Angle: () => Angle,\n    Point: () => Point\n  });\n\n  // Prints the message and throws an error if the conditionis false.\n  const assert = (condition, message) => {\n    if (!condition) {\n      console.error(message);\n      throw new Error();\n    }\n  };\n\n  const isNumber = x => Number.isFinite(x) && !Number.isNaN(x);\n\n  const maybeRequire = module => Meteor.isServer ? Npm.require(module) : null;\n\n  let getPWD = null;\n\n  if (Meteor.isServer) {\n    Meteor.npmRequire('es6-shim');\n\n    const path = Npm.require('path');\n\n    module1.runSetters(getPWD = () => {\n      // TODO(skishore): The next line makes assumptions about the Meteor build\n      // directory's structure. We should replace it with a Meteor-provided API.\n      return process.env && process.env.PWD ? process.env.PWD : path.join(process.cwd(), '../../../..');\n    }, [\"getPWD\"]);\n  } // Returns a list of the unique values in the given array, ordered by their\n  // first appearance in the array.\n\n\n  Array.prototype.unique = function () {\n    const result = [];\n    const seen = {};\n    this.map(x => {\n      if (!seen[x]) {\n        result.push(x);\n        seen[x] = true;\n      }\n    });\n    return result;\n  }; // Given a string and a dict mapping characters to other characters, return a\n  // string with that mapping applied to each of its characters.\n\n\n  String.prototype.applyMapping = function (mapping) {\n    let result = '';\n\n    for (let i = 0; i < this.length; i++) {\n      result += mapping[this[i]] ? mapping[this[i]] : this[i];\n    }\n\n    return result;\n  }; // Helper methods for use with angles, which are floats in [-pi, pi).\n\n\n  const Angle = {\n    subtract: (angle1, angle2) => {\n      var result = angle1 - angle2;\n\n      if (result < -Math.PI) {\n        result += 2 * Math.PI;\n      }\n\n      if (result >= Math.PI) {\n        result -= 2 * Math.PI;\n      }\n\n      return result;\n    },\n    penalty: diff => diff * diff\n  }; // Helper methods for use with \"points\", which are pairs of integers.\n\n  const Point = {\n    add: (point1, point2) => [point1[0] + point2[0], point1[1] + point2[1]],\n    angle: point => Math.atan2(point[1], point[0]),\n    clone: point => [point[0], point[1]],\n\n    distance2(point1, point2) {\n      var diff = Point.subtract(point1, point2);\n      return Math.pow(diff[0], 2) + Math.pow(diff[1], 2);\n    },\n\n    dot: (point1, point2) => point1[0] * point2[0] + point1[1] * point2[1],\n    equal: (point1, point2) => point1[0] === point2[0] && point1[1] === point2[1],\n    key: point => point.join(','),\n    midpoint: (point1, point2) => {\n      return [(point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2];\n    },\n    subtract: (point1, point2) => [point1[0] - point2[0], point1[1] - point2[1]],\n    valid: point => isNumber(point[0]) && isNumber(point[1])\n  };\n}.call(this, module);\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"cjklib.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/cjklib.js                                                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  cjklib: () => cjklib\n});\nlet assert, getPWD, maybeRequire;\nmodule.link(\"/lib/base\", {\n  assert(v) {\n    assert = v;\n  },\n\n  getPWD(v) {\n    getPWD = v;\n  },\n\n  maybeRequire(v) {\n    maybeRequire = v;\n  }\n\n}, 0);\nconst fs = maybeRequire('fs');\nconst path = maybeRequire('path');\nconst CHARACTER_FIELDS = ['character', 'decomposition', 'definition', 'frequency', 'kangxi_index', 'pinyin', 'simplified', 'strokes', 'traditional'];\nconst cjklib = {\n  characters: {},\n  gb2312: {},\n  promise: undefined,\n  radicals: {\n    primary_radical: {},\n    index_to_radical_map: {},\n    radical_to_index_map: {},\n    radical_to_character_map: {}\n  },\n\n  getCharacterData(character) {\n    const result = {};\n    CHARACTER_FIELDS.map(field => result[field] = cjklib.characters[field][character]);\n    result.character = character;\n    result.traditional = result.traditional || [];\n    return result;\n  }\n\n};\nCHARACTER_FIELDS.map(field => cjklib.characters[field] = {}); // Input: String contents of a cjklib data file.\n// Output: a list of rows, each of which is a list of String columns.\n\nconst getCJKLibRows = data => {\n  const lines = data.split('\\n');\n  return lines.filter(line => line.length > 0 && line[0] !== '#').map(line => line.split(',').map(entry => entry.replace(/[\"']/g, '')));\n}; // Input: String contents of a TSV data file.\n// Output: a list of rows, each of which is a list of String columns.\n\n\nconst getFrequencyRows = data => {\n  const lines = data.split('\\n');\n  return lines.filter(line => line.length > 0 && line[0] !== '#').map(line => line.split('\\t'));\n}; // Input: String contents of a Unihan data file.\n// Output: a list of rows, each of which is a list of String columns.\n\n\nconst getUnihanRows = data => {\n  const lines = data.split('\\n');\n  return lines.filter(line => line.length > 0 && line[0] !== '#').map(line => line.split('\\t'));\n}; // Input: a String of the form 'U+<hex>' representing a Unicode codepoint.\n// Output: the character at that codepoint\n\n\nconst parseUnicodeStr = str => String.fromCodePoint(parseInt(str.substr(2), 16)); // Input: the path to a Unihan data file, starting from the public directory.\n// Output: Promise that resolves to the String contents of that file.\n\n\nconst readFile = filename => new Promise((resolve, reject) => {\n  if (Meteor.isServer) {\n    const filepath = path.join(getPWD(), 'public', filename);\n    fs.readFile(filepath, 'utf8', (error, data) => {\n      if (error) throw error;\n      resolve(data);\n    });\n  } else {\n    $.get(filename, (data, code) => {\n      if (code !== 'success') throw new Error(code);\n      resolve(data);\n    });\n  }\n}); // Promises that fill data from specific tables.\n// Output: Promise that fills result with a mapping character -> decomposition.\n// The decompositions are formatted using Ideographic Description Sequence\n// symbols - see the Unicode standard for more details.\n\n\nconst fillDecompositions = (decompositions, glyphs, result) => {\n  return Promise.all([decompositions, glyphs]).then(_ref => {\n    let [rows, glyphs] = _ref;\n    rows.filter(row => parseInt(row[2], 10) === (glyphs[row[0]] || 0)).map(row => result[row[0]] = row[1]);\n  });\n}; // Output: Promise that fills result with a mapping character -> Pinyin.\n\n\nconst fillDefinitions = (readings, result) => {\n  return readings.then(rows => {\n    rows.filter(row => row[1] === 'kDefinition').map(row => result[parseUnicodeStr(row[0])] = row[2]);\n  });\n}; // Output: Promise that fills result with a mapping character -> frequency rank.\n\n\nconst fillFrequencies = (readings, result) => {\n  return readings.then(rows => {\n    rows.map(row => result[row[1]] = parseInt(row[0], 10));\n  });\n}; // Output: Promise that fills result with a mapping character -> Kangxi radical-\n// stroke count, which is a pair of integers [radical, extra_strokes].\n\n\nconst fillKangxiIndex = (readings, result) => {\n  return readings.then(rows => {\n    const getIndex = adotb => adotb.split('.').map(x => parseInt(x, 10));\n\n    rows.filter(row => row[1] === 'kRSKangXi').map(row => result[parseUnicodeStr(row[0])] = getIndex(row[2]));\n  });\n}; // Output: Promise that fills result with a mapping character -> Pinyin.\n\n\nconst fillPinyin = (readings, result) => {\n  return readings.then(rows => {\n    rows.filter(row => row[1] === 'kMandarin').map(row => result[parseUnicodeStr(row[0])] = row[2]);\n  });\n}; // Output: Promise that fills result with a mapping character -> stroke count.\n\n\nconst fillStrokeCounts = (dictionary_like_data, result) => {\n  return dictionary_like_data.then(rows => {\n    rows.filter(row => row[1] === 'kTotalStrokes').map(row => result[parseUnicodeStr(row[0])] = parseInt(row[2], 10));\n  });\n}; // Output: Promise that fills multiple dictionaries in the result:\n//   - index_to_radical_map: Map from index -> list of radicals at that index\n//   - radical_to_index_map: Map from radical -> index of that radical\n//   - primary_radical: Map from index -> primary radical at that index\n\n\nconst fillRadicalData = (locale, radicals, result) => {\n  return radicals.then(rows => {\n    rows.map(row => {\n      if (!result.index_to_radical_map.hasOwnProperty(row[0])) {\n        result.index_to_radical_map[row[0]] = [];\n      }\n\n      result.index_to_radical_map[row[0]].push(row[1]);\n      result.radical_to_index_map[row[1]] = row[0];\n\n      if (row[2] === 'R' && row[3].indexOf(locale) >= 0) {\n        result.primary_radical[row[0]] = row[1];\n      }\n    });\n  });\n}; // Output: Promise that fills result with a map from Unicode radical-codeblock\n// character -> equivalent Unicode CJK-codeblock (hopefully, GB2312) character.\n// There may be Unicode radical characters without a CJK equivalent.\n\n\nconst fillRadicalToCharacterMap = (locale, radical_equivalent_characters, result) => {\n  return radical_equivalent_characters.then(rows => {\n    rows.filter(row => row[2].indexOf(locale) >= 0).map(row => result[row[0]] = row[1]);\n  });\n}; // Output: Promise that fills the two maps with pointers from a given character\n// to its simplified and traditional variants.\n\n\nconst fillVariants = (simplified, traditional, variants) => {\n  return variants.then(rows => {\n    rows.map(row => {\n      if (row[1] !== 'kSimplifiedVariant' && row[1] !== 'kTraditionalVariant' || row[0] === row[2] || row[0] === 'U+2B5B8') {\n        // Unicode introduced an extra character U+2B5B8 matching U+613F.\n        return;\n      }\n\n      let source = parseUnicodeStr(row[0]);\n      let target = parseUnicodeStr(row[2]);\n      const split = row[2].split(' '); // A number of characters have multiple simplified variants. Of these,\n      // we should only use one of them, usually the first, but in three cases,\n      // the second.\n\n      if (split.length === 2 && ['U+937E', 'U+949F', 'U+9918'].indexOf(row[0]) >= 0) {\n        target = parseUnicodeStr(split[1]);\n      }\n\n      if (source === target) {\n        return;\n      } else if (row[1] === 'kTraditionalVariant') {\n        const swap = target;\n        target = source;\n        source = swap;\n      } // The mapping from traditional characters to simplified characters is\n      // many to one, so we can only assert that simplified[source] is unique.\n\n\n      assert(!simplified[source] || simplified[source] === target);\n      simplified[source] = target;\n      traditional[target] = _.unique((traditional[target] || []).concat([source]));\n    });\n  });\n}; // Given the data from the GB2312 data file, fills the GB2312 result map.\n\n\nconst fillGB2312 = (data, result) => {\n  Array.from(data).map(character => {\n    if (character === '\\n') return;\n    assert(character.length === 1);\n    const codepoint = character.codePointAt(0);\n    assert(0x4e00 <= codepoint && codepoint <= 0x9fff);\n    result[character] = true;\n  });\n  assert(Object.keys(result).length === 6763);\n}; // Given the rows of the locale-character map from the cjklib data, returns a\n// mapping from characters to the appropriate glyph in that locale.\n\n\nconst parseLocaleGlyphMap = (locale, rows) => {\n  const result = {};\n  rows.filter(row => row[2].indexOf(locale) >= 0).map(row => result[row[0]] = parseInt(row[1], 10));\n  return result;\n}; // Methods used for final post-processing of the loaded datasets.\n\n\nconst cleanupCJKLibData = () => {\n  const characters = cjklib.characters;\n  const radicals = cjklib.radicals;\n\n  const convert_astral_characters = x => x.length === 1 ? x : '？';\n\n  const radical_to_character = x => radicals.radical_to_character_map[x] || x;\n\n  Object.keys(characters.decomposition).map(character => {\n    // Convert any 'astral characters' - that is, characters outside the Basic\n    // Multilingual Plane - to wide question marks and replace radicals with an\n    // equivalent character with that character.\n    const decomposition = characters.decomposition[character];\n    characters.decomposition[character] = Array.from(decomposition).map(convert_astral_characters).map(radical_to_character).join('');\n  });\n\n  for (let i = 1; i <= 214; i++) {\n    // All primary radicals should have an equivalent character form.\n    const primary = radicals.primary_radical[i];\n    assert(radicals.radical_to_character_map.hasOwnProperty(primary));\n    radicals.primary_radical[i] = radicals.radical_to_character_map[primary];\n    radicals.index_to_radical_map[i] = radicals.index_to_radical_map[i].map(radical_to_character).unique();\n  }\n\n  Object.keys(radicals.radical_to_index_map).map(radical => {\n    const character = radical_to_character(radical);\n\n    if (character !== radical) {\n      radicals.radical_to_index_map[character] = radicals.radical_to_index_map[radical];\n      delete radicals.radical_to_index_map[radical];\n    }\n  });\n  delete radicals.radical_to_character_map;\n};\n\nMeteor.startup(() => {\n  // cjklib database data.\n  const locale = 'C';\n  const decomposition = readFile('cjklib/characterdecomposition.csv').then(getCJKLibRows);\n  const glyphs = readFile('cjklib/localecharacterglyph.csv').then(getCJKLibRows).then(parseLocaleGlyphMap.bind(null, locale));\n  const radicals = readFile('cjklib/kangxiradical.csv').then(getCJKLibRows);\n  const radical_equivalent_characters = readFile('cjklib/radicalequivalentcharacter.csv').then(getCJKLibRows);\n  const radical_isolated_characters = readFile('cjklib/kangxiradicalisolatedcharacter.csv').then(getCJKLibRows); // Jun Da's character frequency data, used only for prioritization.\n\n  const frequencies = readFile('junda/character_frequency.tsv').then(getFrequencyRows); // Unihan database data.\n\n  const dictionary_like_data = readFile('unihan/Unihan_DictionaryLikeData.txt').then(getUnihanRows);\n  const radical_stroke_counts = readFile('unihan/Unihan_RadicalStrokeCounts.txt').then(getUnihanRows);\n  const readings = readFile('unihan/Unihan_Readings.txt').then(getUnihanRows);\n  const variants = readFile('unihan/Unihan_Variants.txt').then(getUnihanRows);\n  cjklib.promise = Promise.all([// Per-character data.\n  fillDecompositions(decomposition, glyphs, cjklib.characters.decomposition), fillDefinitions(readings, cjklib.characters.definition), fillFrequencies(frequencies, cjklib.characters.frequency), fillKangxiIndex(radical_stroke_counts, cjklib.characters.kangxi_index), fillPinyin(readings, cjklib.characters.pinyin), fillStrokeCounts(dictionary_like_data, cjklib.characters.strokes), // Per-radical data.\n  fillRadicalData(locale, radicals, cjklib.radicals), fillRadicalData(locale, radical_isolated_characters, cjklib.radicals), fillRadicalToCharacterMap(locale, radical_equivalent_characters, cjklib.radicals.radical_to_character_map), fillVariants(cjklib.characters.simplified, cjklib.characters.traditional, variants), // Extract the list of characters in the GB2312 character set.\n  readFile('gb2312').then(data => fillGB2312(data, cjklib.gb2312))]).then(cleanupCJKLibData);\n  cjklib.promise.catch(console.error.bind(console));\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"classifier.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/classifier.js                                                                                                   //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nlet NEURAL_NET_TRAINED_FOR_STROKE_EXTRACTION;\nmodule.link(\"/lib/net\", {\n  NEURAL_NET_TRAINED_FOR_STROKE_EXTRACTION(v) {\n    NEURAL_NET_TRAINED_FOR_STROKE_EXTRACTION = v;\n  }\n\n}, 0);\nlet stroke_extractor;\nmodule.link(\"/lib/stroke_extractor\", {\n  stroke_extractor(v) {\n    stroke_extractor = v;\n  }\n\n}, 1);\nMeteor.startup(() => {\n  const input = new convnetjs.Vol(1, 1, 8\n  /* feature vector dimensions */\n  );\n  const net = new convnetjs.Net();\n  net.fromJSON(NEURAL_NET_TRAINED_FOR_STROKE_EXTRACTION);\n  const weight = 0.8;\n\n  const trainedClassifier = features => {\n    input.w = features;\n    const softmax = net.forward(input).w;\n    return softmax[1] - softmax[0];\n  };\n\n  stroke_extractor.combinedClassifier = features => {\n    return stroke_extractor.handTunedClassifier(features) + weight * trainedClassifier(features);\n  };\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"decomposition_util.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/decomposition_util.js                                                                                           //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  decomposition_util: () => decomposition_util\n});\nlet assert;\nmodule.link(\"/lib/base\", {\n  assert(v) {\n    assert = v;\n  }\n\n}, 0);\nconst decomposition_util = {};\ndecomposition_util.ids_data = {\n  '⿰': {\n    label: 'Left-to-right',\n    arity: 2\n  },\n  '⿱': {\n    label: 'Top-to-bottom',\n    arity: 2\n  },\n  '⿴': {\n    label: 'Surround',\n    arity: 2\n  },\n  '⿵': {\n    label: 'Surround-from-above',\n    arity: 2\n  },\n  '⿶': {\n    label: 'Surround-from-below',\n    arity: 2\n  },\n  '⿷': {\n    label: 'Surround-from-left',\n    arity: 2\n  },\n  '⿸': {\n    label: 'Surround-from-upper-left',\n    arity: 2\n  },\n  '⿹': {\n    label: 'Surround-from-upper-right',\n    arity: 2\n  },\n  '⿺': {\n    label: 'Surround-from-lower-left',\n    arity: 2\n  },\n  '⿻': {\n    label: 'Overlaid',\n    arity: 2\n  },\n  '⿳': {\n    label: 'Top-to-middle-to-bottom',\n    arity: 3\n  },\n  '⿲': {\n    label: 'Left-to-middle-to-right',\n    arity: 3\n  }\n};\ndecomposition_util.ideograph_description_characters = Object.keys(decomposition_util.ids_data);\nconst UNKNOWN_COMPONENT = '？';\n\nconst augmentTreeWithPathData = (tree, path) => {\n  tree.path = path;\n  const children = (tree.children || []).length;\n\n  for (let i = 0; i < children; i++) {\n    augmentTreeWithPathData(tree.children[i], path.concat([i]));\n  }\n\n  return tree;\n};\n\nconst parseSubtree = (decomposition, index) => {\n  assert(index[0] < decomposition.length, \"Not enough characters in \".concat(decomposition, \".\"));\n  const current = decomposition[index[0]];\n  index[0] += 1;\n\n  if (decomposition_util.ids_data.hasOwnProperty(current)) {\n    const result = {\n      type: 'compound',\n      value: current,\n      children: []\n    };\n\n    for (let i = 0; i < decomposition_util.ids_data[current].arity; i++) {\n      result.children.push(parseSubtree(decomposition, index));\n    }\n\n    return result;\n  } else if (current === UNKNOWN_COMPONENT) {\n    return {\n      type: 'character',\n      value: '?'\n    };\n  } // Characters may be followed by a [x] annotation that records which variant\n  // of the character to use at that position. We ignore these annotations.\n\n\n  if (decomposition[index[0]] === '[') {\n    assert('0123456789'.indexOf(decomposition[index[0] + 1]) >= 0);\n    assert(decomposition[index[0] + 2] === ']');\n    index[0] += 3;\n  }\n\n  return {\n    type: 'character',\n    value: current\n  };\n};\n\nconst serializeSubtree = (subtree, result) => {\n  result[0] += subtree.value === '?' ? UNKNOWN_COMPONENT : subtree.value;\n  const children = subtree.children ? subtree.children.length : 0;\n\n  for (let i = 0; i < children; i++) {\n    serializeSubtree(subtree.children[i], result);\n  }\n};\n\ndecomposition_util.collectComponents = (tree, result) => {\n  result = result || [];\n\n  if (tree.type === 'character' && tree.value !== '?') {\n    result.push(tree.value);\n  }\n\n  for (let child of tree.children || []) {\n    decomposition_util.collectComponents(child, result);\n  }\n\n  return result;\n};\n\ndecomposition_util.convertDecompositionToTree = decomposition => {\n  const index = [0];\n  decomposition = decomposition || UNKNOWN_COMPONENT;\n  const result = parseSubtree(decomposition, index);\n  assert(index[0] === decomposition.length, \"Too many characters in \".concat(decomposition, \".\"));\n  return augmentTreeWithPathData(result, []);\n};\n\ndecomposition_util.convertTreeToDecomposition = tree => {\n  const result = [''];\n  serializeSubtree(tree, result);\n  return result[0];\n};\n\ndecomposition_util.getSubtree = (tree, path) => {\n  let subtree = tree;\n\n  for (let index of path) {\n    assert(0 <= index && index < subtree.children.length);\n    subtree = subtree.children[index];\n  }\n\n  return subtree;\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"glyphs.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/glyphs.js                                                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  Glyphs: () => Glyphs,\n  Progress: () => Progress\n});\nlet assert;\nmodule.link(\"/lib/base\", {\n  assert(v) {\n    assert = v;\n  }\n\n}, 0);\nlet cjklib;\nmodule.link(\"/lib/cjklib\", {\n  cjklib(v) {\n    cjklib = v;\n  }\n\n}, 1);\n\nconst defaultGlyph = character => {\n  if (!character) return;\n  assert(character.length === 1);\n  const data = cjklib.getCharacterData(character);\n  const result = {\n    character: character,\n    codepoint: character.codePointAt(0),\n    metadata: {\n      frequency: data.frequency,\n      kangxi_index: data.kangxi_index\n    },\n    stages: {},\n    simplified: data.simplified,\n    traditional: data.traditional\n  };\n\n  if (data.simplified) {\n    const glyph = Glyphs.get(data.simplified);\n    const base = cjklib.getCharacterData(data.simplified);\n\n    if (glyph.stages.verified) {\n      const metadata = glyph.metadata;\n      result.metadata.definition = metadata.definition || base.definition;\n      result.metadata.pinyin = metadata.pinyin || base.pinyin;\n    }\n  }\n\n  return result;\n};\n\nconst Glyphs = new Mongo.Collection('glyphs');\nconst Progress = new Mongo.Collection('progress');\n\nGlyphs.clearDependencies = character => {\n  const stack = [character];\n  const visited = {};\n  visited[character] = true;\n\n  while (stack.length > 0) {\n    const current = stack.pop();\n    const dependencies = Glyphs.find({\n      'stages.analysis.decomposition': {\n        $regex: \".*\".concat(current, \".*\")\n      },\n      'stages.order': {\n        $ne: null\n      }\n    }, {\n      character: 1\n    }).fetch();\n    dependencies.map(x => x.character).filter(x => !visited[x]).map(x => {\n      stack.push(x);\n      visited[x] = true;\n    });\n  }\n\n  delete visited[character];\n  Glyphs.update({\n    character: {\n      $in: Object.keys(visited)\n    }\n  }, {\n    $set: {\n      'stages.order': null,\n      'stages.verified': null\n    }\n  }, {\n    multi: true\n  });\n};\n\nGlyphs.get = character => Glyphs.findOne({\n  character: character\n}) || defaultGlyph(character);\n\nGlyphs.getAll = characters => Glyphs.find({\n  character: {\n    $in: characters\n  }\n});\n\nGlyphs.getNext = (glyph, clause) => {\n  clause = clause || {};\n  const codepoint = glyph ? glyph.codepoint : undefined;\n\n  const condition = _.extend({\n    codepoint: {\n      $gt: codepoint\n    }\n  }, clause);\n\n  const next = Glyphs.findOne(condition, {\n    sort: {\n      codepoint: 1\n    }\n  });\n  return next ? next : Glyphs.findOne(clause, {\n    sort: {\n      codepoint: 1\n    }\n  });\n};\n\nGlyphs.getNextUnverified = glyph => {\n  return Glyphs.getNext(glyph, {\n    'stages.verified': null\n  });\n};\n\nGlyphs.getNextVerified = glyph => {\n  return Glyphs.getNext(glyph, {\n    'stages.verified': {\n      $ne: null\n    }\n  });\n};\n\nGlyphs.getPrevious = (glyph, clause) => {\n  clause = clause || {};\n  const codepoint = glyph ? glyph.codepoint : undefined;\n\n  const condition = _.extend({\n    codepoint: {\n      $lt: codepoint\n    }\n  }, clause);\n\n  const previous = Glyphs.findOne(condition, {\n    sort: {\n      codepoint: -1\n    }\n  });\n  return previous ? previous : Glyphs.findOne(clause, {\n    sort: {\n      codepoint: -1\n    }\n  });\n};\n\nGlyphs.getPreviousUnverified = glyph => {\n  return Glyphs.getPrevious(glyph, {\n    'stages.verified': null\n  });\n};\n\nGlyphs.getPreviousVerified = glyph => {\n  return Glyphs.getPrevious(glyph, {\n    'stages.verified': {\n      $ne: null\n    }\n  });\n};\n\nGlyphs.loadAll = characters => {\n  for (let character of characters) {\n    const glyph = Glyphs.get(character);\n\n    if (!glyph.stages.verified) {\n      Glyphs.upsert({\n        character: glyph.character\n      }, glyph);\n    }\n  }\n\n  Progress.refresh();\n};\n\nGlyphs.save = glyph => {\n  check(glyph.character, String);\n  assert(glyph.character.length === 1);\n  const current = Glyphs.get(glyph.character);\n\n  if (current && current.stages.verified && !glyph.stages.verified) {\n    Glyphs.clearDependencies(glyph.character);\n  }\n\n  Glyphs.syncDefinitionAndPinyin(glyph);\n\n  if (glyph.stages.path && !glyph.stages.path.sentinel) {\n    Glyphs.upsert({\n      character: glyph.character\n    }, glyph);\n  } else {\n    Glyphs.remove({\n      character: glyph.character\n    });\n  }\n\n  Progress.refresh();\n};\n\nGlyphs.syncDefinitionAndPinyin = glyph => {\n  const data = cjklib.getCharacterData(glyph.character);\n  const base = cjklib.getCharacterData(data.simplified || glyph.character);\n  const targets = [base.character].concat(base.traditional);\n\n  if (targets.length === 1 || '干么着复'.indexOf(targets[0]) >= 0) {\n    return;\n  }\n\n  const definition = glyph.metadata.definition || data.definition;\n  const pinyin = glyph.metadata.pinyin || data.pinyin;\n  Glyphs.update({\n    character: {\n      $in: targets\n    }\n  }, {\n    $set: {\n      'metadata.definition': definition,\n      'metadata.pinyin': pinyin\n    }\n  }, {\n    multi: true\n  });\n};\n\nProgress.refresh = () => {\n  const total = Glyphs.find().count();\n  const complete = Glyphs.find({\n    'stages.verified': {\n      $ne: null\n    }\n  }).count();\n  Progress.upsert({}, {\n    total: total,\n    complete: complete,\n    backup: false\n  });\n};\n\nif (Meteor.isServer) {\n  // Construct indices on the Glyphs table.\n  Glyphs._ensureIndex({\n    character: 1\n  }, {\n    unique: true\n  });\n\n  Glyphs._ensureIndex({\n    codepoint: 1\n  }, {\n    unique: true\n  });\n\n  Glyphs._ensureIndex({\n    'stages.verified': 1\n  }); // Refresh the Progress counter.\n\n\n  Progress.refresh(); // Register the methods above so they are available to the client.\n\n  const methods = {};\n  const method_names = ['get', 'getNext', 'getNextUnverified', 'getNextVerified', 'getPrevious', 'getPreviousUnverified', 'getPreviousVerified', 'save'];\n  method_names.map(name => methods[\"\".concat(name, \"Glyph\")] = Glyphs[name]);\n  methods.loadAllGlyphs = Glyphs.loadAll;\n\n  methods.saveGlyphs = glyphs => glyphs.map(Glyphs.save);\n\n  Meteor.methods(methods); // Publish accessors that will get all glyphs in a list and get the progress.\n\n  Meteor.publish('getAllGlyphs', Glyphs.getAll);\n  Meteor.publish('getProgress', Progress.find.bind(Progress));\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"hungarian.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/hungarian.js                                                                                                    //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  Hungarian: () => Hungarian\n});\n\n// This algorithm was pulled from another one of my projects. -skishore\n//   https://github.com/skishore/tesseract/blob/master/coffee/hungarian.coffee\nvar bind = function (fn, me) {\n  return function () {\n    return fn.apply(me, arguments);\n  };\n};\n\nconst Hungarian = function () {\n  function Hungarian(cost_matrix) {\n    var i, j, last_matched, len, ref, ref1, results, row, x, y;\n    this.cost_matrix = cost_matrix;\n    this.get_final_score = bind(this.get_final_score, this);\n    this.update_labels = bind(this.update_labels, this);\n    this.find_root_and_slacks = bind(this.find_root_and_slacks, this);\n    this.augment = bind(this.augment, this);\n    this.match = bind(this.match, this);\n    this.cost = bind(this.cost, this);\n    this.find_greedy_solution = bind(this.find_greedy_solution, this);\n    this.reduce_cost_matrix = bind(this.reduce_cost_matrix, this);\n    this.n = this.cost_matrix.length;\n    ref = this.cost_matrix;\n\n    for (i = 0, len = ref.length; i < len; i++) {\n      row = ref[i];\n\n      if (row.length !== this.n) {\n        throw new Error(\"Malforrmed cost_matrix: \" + this.cost_matrix);\n      }\n    }\n\n    this.range = function () {\n      results = [];\n\n      for (var j = 0, ref1 = this.n; 0 <= ref1 ? j < ref1 : j > ref1; 0 <= ref1 ? j++ : j--) {\n        results.push(j);\n      }\n\n      return results;\n    }.apply(this);\n\n    this.matched = 0;\n\n    this.x_label = function () {\n      var k, len1, ref2, results1;\n      ref2 = this.range;\n      results1 = [];\n\n      for (k = 0, len1 = ref2.length; k < len1; k++) {\n        x = ref2[k];\n        results1.push(0);\n      }\n\n      return results1;\n    }.call(this);\n\n    this.y_label = function () {\n      var k, len1, ref2, results1;\n      ref2 = this.range;\n      results1 = [];\n\n      for (k = 0, len1 = ref2.length; k < len1; k++) {\n        y = ref2[k];\n        results1.push(0);\n      }\n\n      return results1;\n    }.call(this);\n\n    this.x_match = function () {\n      var k, len1, ref2, results1;\n      ref2 = this.range;\n      results1 = [];\n\n      for (k = 0, len1 = ref2.length; k < len1; k++) {\n        x = ref2[k];\n        results1.push(-1);\n      }\n\n      return results1;\n    }.call(this);\n\n    this.y_match = function () {\n      var k, len1, ref2, results1;\n      ref2 = this.range;\n      results1 = [];\n\n      for (k = 0, len1 = ref2.length; k < len1; k++) {\n        y = ref2[k];\n        results1.push(-1);\n      }\n\n      return results1;\n    }.call(this);\n\n    this.reduce_cost_matrix();\n    this.find_greedy_solution();\n\n    while (this.matched < this.n) {\n      last_matched = this.matched;\n      this.augment();\n\n      if (this.matched <= last_matched) {\n        throw new Error(\"Augmentation round did not increase matched!\");\n      }\n    }\n  }\n\n  Hungarian.prototype.reduce_cost_matrix = function () {\n    var i, j, k, l, len, len1, len2, len3, max_cost, ref, ref1, ref2, ref3, row, x, y;\n\n    this.cost_matrix = function () {\n      var i, len, ref, results;\n      ref = this.cost_matrix;\n      results = [];\n\n      for (i = 0, len = ref.length; i < len; i++) {\n        row = ref[i];\n        results.push(row.slice());\n      }\n\n      return results;\n    }.call(this);\n\n    ref = this.range;\n\n    for (i = 0, len = ref.length; i < len; i++) {\n      x = ref[i];\n      max_cost = Math.max.apply(0, function () {\n        var j, len1, ref1, results;\n        ref1 = this.range;\n        results = [];\n\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          y = ref1[j];\n          results.push(this.cost_matrix[x][y]);\n        }\n\n        return results;\n      }.call(this));\n      ref1 = this.range;\n\n      for (j = 0, len1 = ref1.length; j < len1; j++) {\n        y = ref1[j];\n        this.cost_matrix[x][y] -= max_cost;\n      }\n\n      this.x_label[x] = 0;\n    }\n\n    ref2 = this.range;\n\n    for (k = 0, len2 = ref2.length; k < len2; k++) {\n      y = ref2[k];\n      max_cost = Math.max.apply(0, function () {\n        var l, len3, ref3, results;\n        ref3 = this.range;\n        results = [];\n\n        for (l = 0, len3 = ref3.length; l < len3; l++) {\n          x = ref3[l];\n          results.push(this.cost_matrix[x][y]);\n        }\n\n        return results;\n      }.call(this));\n      ref3 = this.range;\n\n      for (l = 0, len3 = ref3.length; l < len3; l++) {\n        x = ref3[l];\n        this.cost_matrix[x][y] -= max_cost;\n      }\n\n      this.y_label[y] = 0;\n    }\n  };\n\n  Hungarian.prototype.find_greedy_solution = function () {\n    var i, len, ref, results, x, y;\n    ref = this.range;\n    results = [];\n\n    for (i = 0, len = ref.length; i < len; i++) {\n      x = ref[i];\n      results.push(function () {\n        var j, len1, ref1, results1;\n        ref1 = this.range;\n        results1 = [];\n\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          y = ref1[j];\n\n          if (this.x_match[x] === -1 && this.y_match[y] === -1 && this.cost(x, y) === 0) {\n            this.match(x, y);\n            results1.push(this.matched += 1);\n          } else {\n            results1.push(void 0);\n          }\n        }\n\n        return results1;\n      }.call(this));\n    }\n\n    return results;\n  };\n\n  Hungarian.prototype.cost = function (x, y) {\n    return this.cost_matrix[x][y] - this.x_label[x] - this.y_label[y];\n  };\n\n  Hungarian.prototype.match = function (x, y) {\n    this.x_match[x] = y;\n    return this.y_match[y] = x;\n  };\n\n  Hungarian.prototype.augment = function () {\n    var cur_x, cur_y, delta, delta_x, delta_y, i, j, len, len1, new_slack, next_y, ref, ref1, ref2, root, slack, slack_x, x, x_in_tree, y, y_parent;\n\n    x_in_tree = function () {\n      var i, len, ref, results;\n      ref = this.range;\n      results = [];\n\n      for (i = 0, len = ref.length; i < len; i++) {\n        x = ref[i];\n        results.push(false);\n      }\n\n      return results;\n    }.call(this);\n\n    y_parent = function () {\n      var i, len, ref, results;\n      ref = this.range;\n      results = [];\n\n      for (i = 0, len = ref.length; i < len; i++) {\n        y = ref[i];\n        results.push(-1);\n      }\n\n      return results;\n    }.call(this);\n\n    ref = this.find_root_and_slacks(), root = ref[0], slack = ref[1], slack_x = ref[2];\n    x_in_tree[root] = true;\n\n    while (true) {\n      delta = Infinity;\n      ref1 = this.range;\n\n      for (i = 0, len = ref1.length; i < len; i++) {\n        y = ref1[i];\n\n        if (y_parent[y] < 0 && slack[y] < delta) {\n          delta = slack[y];\n          delta_x = slack_x[y];\n          delta_y = y;\n        }\n      }\n\n      this.update_labels(delta, x_in_tree, y_parent, slack);\n      y_parent[delta_y] = delta_x;\n\n      if (this.y_match[delta_y] < 0) {\n        cur_y = delta_y;\n\n        while (cur_y >= 0) {\n          cur_x = y_parent[cur_y];\n          next_y = this.x_match[cur_x];\n          this.match(cur_x, cur_y);\n          cur_y = next_y;\n        }\n\n        this.matched += 1;\n        return;\n      }\n\n      x = this.y_match[delta_y];\n      x_in_tree[x] = true;\n      ref2 = this.range;\n\n      for (j = 0, len1 = ref2.length; j < len1; j++) {\n        y = ref2[j];\n\n        if (y_parent[y] < 0) {\n          new_slack = -this.cost(x, y);\n\n          if (slack[y] > new_slack) {\n            slack[y] = new_slack;\n            slack_x[y] = x;\n          }\n        }\n      }\n    }\n  };\n\n  Hungarian.prototype.find_root_and_slacks = function () {\n    var i, len, ref, x, y;\n    ref = this.range;\n\n    for (i = 0, len = ref.length; i < len; i++) {\n      x = ref[i];\n\n      if (this.x_match[x] < 0) {\n        return [x, function () {\n          var j, len1, ref1, results;\n          ref1 = this.range;\n          results = [];\n\n          for (j = 0, len1 = ref1.length; j < len1; j++) {\n            y = ref1[j];\n            results.push(-this.cost(x, y));\n          }\n\n          return results;\n        }.call(this), function () {\n          var j, len1, ref1, results;\n          ref1 = this.range;\n          results = [];\n\n          for (j = 0, len1 = ref1.length; j < len1; j++) {\n            y = ref1[j];\n            results.push(x);\n          }\n\n          return results;\n        }.call(this)];\n      }\n    }\n  };\n\n  Hungarian.prototype.update_labels = function (delta, x_in_tree, y_parent, slack) {\n    var i, j, len, len1, ref, ref1, results, x, y;\n    ref = this.range;\n\n    for (i = 0, len = ref.length; i < len; i++) {\n      x = ref[i];\n\n      if (x_in_tree[x]) {\n        this.x_label[x] -= delta;\n      }\n    }\n\n    ref1 = this.range;\n    results = [];\n\n    for (j = 0, len1 = ref1.length; j < len1; j++) {\n      y = ref1[j];\n\n      if (y_parent[y] < 0) {\n        results.push(slack[y] -= delta);\n      } else {\n        results.push(this.y_label[y] += delta);\n      }\n    }\n\n    return results;\n  };\n\n  Hungarian.prototype.get_final_score = function (original_matrix) {\n    var x;\n    return Util.sum(function () {\n      var i, len, ref, results;\n      ref = this.range;\n      results = [];\n\n      for (i = 0, len = ref.length; i < len; i++) {\n        x = ref[i];\n        results.push(original_matrix[x][this.x_match[x]]);\n      }\n\n      return results;\n    }.call(this));\n  };\n\n  return Hungarian;\n}();\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"median_util.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/median_util.js                                                                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  median_util: () => median_util\n});\nlet simplify;\nmodule.link(\"/lib/external/simplify/1.2.2/simplify\", {\n  default(v) {\n    simplify = v;\n  }\n\n}, 0);\nlet assert, Point;\nmodule.link(\"/lib/base\", {\n  assert(v) {\n    assert = v;\n  },\n\n  Point(v) {\n    Point = v;\n  }\n\n}, 1);\nlet svg;\nmodule.link(\"/lib/svg\", {\n  svg(v) {\n    svg = v;\n  }\n\n}, 2);\nconst size = 1024;\nconst rise = 900;\nconst num_to_match = 8;\nlet voronoi = undefined;\n\nconst filterMedian = (median, n) => {\n  const distances = _.range(median.length - 1).map(i => Math.sqrt(Point.distance2(median[i], median[i + 1])));\n\n  let total = 0;\n  distances.map(x => total += x);\n  const result = [];\n  let index = 0;\n  let position = median[0];\n  let total_so_far = 0;\n\n  for (let i of _.range(n - 1)) {\n    const target = i * total / (n - 1);\n\n    while (total_so_far < target) {\n      const step = Math.sqrt(Point.distance2(position, median[index + 1]));\n\n      if (total_so_far + step < target) {\n        index += 1;\n        position = median[index];\n        total_so_far += step;\n      } else {\n        const t = (target - total_so_far) / step;\n        position = [(1 - t) * position[0] + t * median[index + 1][0], (1 - t) * position[1] + t * median[index + 1][1]];\n        total_so_far = target;\n      }\n    }\n\n    result.push(Point.clone(position));\n  }\n\n  result.push(median[median.length - 1]);\n  return result;\n};\n\nconst findLongestShortestPath = (adjacency, vertices, node) => {\n  const path = findPathFromFurthestNode(adjacency, vertices, node);\n  return findPathFromFurthestNode(adjacency, vertices, path[0]);\n};\n\nconst findPathFromFurthestNode = (adjacency, vertices, node, visited) => {\n  visited = visited || {};\n  visited[node] = true;\n  let result = [];\n  result.distance = 0;\n\n  for (let neighbor of adjacency[node] || []) {\n    if (!visited[neighbor]) {\n      const candidate = findPathFromFurthestNode(adjacency, vertices, neighbor, visited);\n      candidate.distance += Math.sqrt(Point.distance2(vertices[node], vertices[neighbor]));\n\n      if (candidate.distance > result.distance) {\n        result = candidate;\n      }\n    }\n  }\n\n  result.push(node);\n  return result;\n};\n\nconst findStrokeMedian = stroke => {\n  const paths = svg.convertSVGPathToPaths(stroke);\n  assert(paths.length === 1, \"Got stroke with multiple loops: \".concat(stroke));\n  let polygon = undefined;\n  let diagram = undefined;\n\n  for (let approximation of [16, 64]) {\n    polygon = svg.getPolygonApproximation(paths[0], approximation);\n    voronoi = voronoi || new Voronoi();\n    const sites = polygon.map(point => ({\n      x: point[0],\n      y: point[1]\n    }));\n    const bounding_box = {\n      xl: -size,\n      xr: size,\n      yt: -size,\n      yb: size\n    };\n\n    try {\n      diagram = voronoi.compute(sites, bounding_box);\n      break;\n    } catch (error) {\n      console.error(\"WARNING: Voronoi computation failed at \".concat(approximation, \".\"));\n    }\n  }\n\n  assert(diagram, 'Voronoi computation failed completely!');\n  diagram.vertices.map((x, i) => {\n    x.include = svg.polygonContainsPoint(polygon, [x.x, x.y]);\n    x.index = i;\n  });\n  const vertices = diagram.vertices.map(x => [x.x, x.y].map(Math.round));\n  const edges = diagram.edges.map(x => [x.va.index, x.vb.index]).filter(x => diagram.vertices[x[0]].include && diagram.vertices[x[1]].include);\n  voronoi.recycle(diagram);\n  assert(edges.length > 0);\n  const adjacency = {};\n\n  for (let edge of edges) {\n    adjacency[edge[0]] = adjacency[edge[0]] || [];\n    adjacency[edge[0]].push(edge[1]);\n    adjacency[edge[1]] = adjacency[edge[1]] || [];\n    adjacency[edge[1]].push(edge[0]);\n  }\n\n  const root = edges[0][0];\n  const path = findLongestShortestPath(adjacency, vertices, root);\n  const points = path.map(i => vertices[i]);\n  const tolerance = 4;\n  const simple = simplify(points.map(x => ({\n    x: x[0],\n    y: x[1]\n  })), tolerance);\n  return simple.map(x => [x.x, x.y]);\n};\n\nconst normalizeForMatch = median => {\n  return filterMedian(median, num_to_match).map(x => [x[0] / size, (rise - x[1]) / size]);\n};\n\nconst median_util = {\n  findStrokeMedian: findStrokeMedian,\n  normalizeForMatch: normalizeForMatch\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"net.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/net.js                                                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  NEURAL_NET_TRAINED_FOR_STROKE_EXTRACTION: () => NEURAL_NET_TRAINED_FOR_STROKE_EXTRACTION\n});\nconst NEURAL_NET_TRAINED_FOR_STROKE_EXTRACTION = {\n  \"layers\": [{\n    \"out_depth\": 8,\n    \"out_sx\": 1,\n    \"out_sy\": 1,\n    \"layer_type\": \"input\"\n  }, {\n    \"out_depth\": 8,\n    \"out_sx\": 1,\n    \"out_sy\": 1,\n    \"layer_type\": \"fc\",\n    \"num_inputs\": 8,\n    \"l1_decay_mul\": 0,\n    \"l2_decay_mul\": 1,\n    \"filters\": [{\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": -0.3044261605666167,\n        \"1\": -0.14834922423083324,\n        \"2\": 0.20219401661574177,\n        \"3\": 0.5503522616459873,\n        \"4\": 0.45502127328350234,\n        \"5\": 0.2625745186594936,\n        \"6\": 0.012889731022695689,\n        \"7\": -0.2675923800252626,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 183,\n          \"1\": 140,\n          \"2\": 235,\n          \"3\": 220,\n          \"4\": 183,\n          \"5\": 123,\n          \"6\": 211,\n          \"7\": 191,\n          \"8\": 214,\n          \"9\": 172,\n          \"10\": 58,\n          \"11\": 125,\n          \"12\": 27,\n          \"13\": 253,\n          \"14\": 194,\n          \"15\": 191,\n          \"16\": 244,\n          \"17\": 222,\n          \"18\": 103,\n          \"19\": 88,\n          \"20\": 126,\n          \"21\": 225,\n          \"22\": 201,\n          \"23\": 63,\n          \"24\": 164,\n          \"25\": 146,\n          \"26\": 161,\n          \"27\": 88,\n          \"28\": 124,\n          \"29\": 156,\n          \"30\": 225,\n          \"31\": 63,\n          \"32\": 183,\n          \"33\": 41,\n          \"34\": 239,\n          \"35\": 139,\n          \"36\": 17,\n          \"37\": 31,\n          \"38\": 221,\n          \"39\": 63,\n          \"40\": 43,\n          \"41\": 243,\n          \"42\": 153,\n          \"43\": 90,\n          \"44\": 5,\n          \"45\": 206,\n          \"46\": 208,\n          \"47\": 63,\n          \"48\": 29,\n          \"49\": 223,\n          \"50\": 146,\n          \"51\": 105,\n          \"52\": 238,\n          \"53\": 101,\n          \"54\": 138,\n          \"55\": 63,\n          \"56\": 243,\n          \"57\": 129,\n          \"58\": 55,\n          \"59\": 202,\n          \"60\": 59,\n          \"61\": 32,\n          \"62\": 209,\n          \"63\": 191,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }, {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": -0.5596639882456166,\n        \"1\": -0.2794084096442046,\n        \"2\": -0.1125698422524117,\n        \"3\": -0.08850676702777903,\n        \"4\": 0.06317601682543969,\n        \"5\": -0.18247248453514878,\n        \"6\": 0.2940108272454184,\n        \"7\": 0.9861821092760742,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 121,\n          \"1\": 113,\n          \"2\": 200,\n          \"3\": 115,\n          \"4\": 196,\n          \"5\": 232,\n          \"6\": 225,\n          \"7\": 191,\n          \"8\": 251,\n          \"9\": 140,\n          \"10\": 105,\n          \"11\": 207,\n          \"12\": 211,\n          \"13\": 225,\n          \"14\": 209,\n          \"15\": 191,\n          \"16\": 206,\n          \"17\": 111,\n          \"18\": 253,\n          \"19\": 142,\n          \"20\": 96,\n          \"21\": 209,\n          \"22\": 188,\n          \"23\": 191,\n          \"24\": 143,\n          \"25\": 231,\n          \"26\": 219,\n          \"27\": 37,\n          \"28\": 97,\n          \"29\": 168,\n          \"30\": 182,\n          \"31\": 191,\n          \"32\": 166,\n          \"33\": 36,\n          \"34\": 40,\n          \"35\": 174,\n          \"36\": 77,\n          \"37\": 44,\n          \"38\": 176,\n          \"39\": 63,\n          \"40\": 69,\n          \"41\": 201,\n          \"42\": 191,\n          \"43\": 36,\n          \"44\": 66,\n          \"45\": 91,\n          \"46\": 199,\n          \"47\": 191,\n          \"48\": 54,\n          \"49\": 24,\n          \"50\": 236,\n          \"51\": 201,\n          \"52\": 18,\n          \"53\": 209,\n          \"54\": 210,\n          \"55\": 63,\n          \"56\": 147,\n          \"57\": 182,\n          \"58\": 103,\n          \"59\": 200,\n          \"60\": 205,\n          \"61\": 142,\n          \"62\": 239,\n          \"63\": 63,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }, {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": -0.4293240703659736,\n        \"1\": 0.48799666353430715,\n        \"2\": -0.011221411170891243,\n        \"3\": 0.016759551491042825,\n        \"4\": -0.10178241490300455,\n        \"5\": -0.05938636975897821,\n        \"6\": -0.7140555216543757,\n        \"7\": -0.13033896328056724,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 157,\n          \"1\": 224,\n          \"2\": 102,\n          \"3\": 170,\n          \"4\": 11,\n          \"5\": 122,\n          \"6\": 219,\n          \"7\": 191,\n          \"8\": 60,\n          \"9\": 247,\n          \"10\": 155,\n          \"11\": 91,\n          \"12\": 86,\n          \"13\": 59,\n          \"14\": 223,\n          \"15\": 63,\n          \"16\": 118,\n          \"17\": 154,\n          \"18\": 243,\n          \"19\": 79,\n          \"20\": 64,\n          \"21\": 251,\n          \"22\": 134,\n          \"23\": 191,\n          \"24\": 71,\n          \"25\": 217,\n          \"26\": 50,\n          \"27\": 118,\n          \"28\": 106,\n          \"29\": 41,\n          \"30\": 145,\n          \"31\": 63,\n          \"32\": 136,\n          \"33\": 249,\n          \"34\": 80,\n          \"35\": 143,\n          \"36\": 105,\n          \"37\": 14,\n          \"38\": 186,\n          \"39\": 191,\n          \"40\": 152,\n          \"41\": 205,\n          \"42\": 226,\n          \"43\": 231,\n          \"44\": 227,\n          \"45\": 103,\n          \"46\": 174,\n          \"47\": 191,\n          \"48\": 151,\n          \"49\": 20,\n          \"50\": 33,\n          \"51\": 247,\n          \"52\": 138,\n          \"53\": 217,\n          \"54\": 230,\n          \"55\": 191,\n          \"56\": 91,\n          \"57\": 160,\n          \"58\": 87,\n          \"59\": 120,\n          \"60\": 242,\n          \"61\": 174,\n          \"62\": 192,\n          \"63\": 191,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }, {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": 0.004132243204399921,\n        \"1\": 0.31644328046013015,\n        \"2\": -0.4246219644532225,\n        \"3\": 0.021888719524958525,\n        \"4\": -0.5736499683744954,\n        \"5\": -0.1285778687631867,\n        \"6\": -0.17633637428199953,\n        \"7\": -0.09184800562849475,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 192,\n          \"1\": 147,\n          \"2\": 192,\n          \"3\": 150,\n          \"4\": 248,\n          \"5\": 236,\n          \"6\": 112,\n          \"7\": 63,\n          \"8\": 174,\n          \"9\": 95,\n          \"10\": 39,\n          \"11\": 81,\n          \"12\": 155,\n          \"13\": 64,\n          \"14\": 212,\n          \"15\": 63,\n          \"16\": 243,\n          \"17\": 89,\n          \"18\": 159,\n          \"19\": 154,\n          \"20\": 1,\n          \"21\": 45,\n          \"22\": 219,\n          \"23\": 191,\n          \"24\": 33,\n          \"25\": 71,\n          \"26\": 11,\n          \"27\": 26,\n          \"28\": 255,\n          \"29\": 105,\n          \"30\": 150,\n          \"31\": 63,\n          \"32\": 245,\n          \"33\": 162,\n          \"34\": 176,\n          \"35\": 45,\n          \"36\": 87,\n          \"37\": 91,\n          \"38\": 226,\n          \"39\": 191,\n          \"40\": 225,\n          \"41\": 227,\n          \"42\": 169,\n          \"43\": 86,\n          \"44\": 61,\n          \"45\": 117,\n          \"46\": 192,\n          \"47\": 191,\n          \"48\": 171,\n          \"49\": 117,\n          \"50\": 81,\n          \"51\": 184,\n          \"52\": 48,\n          \"53\": 146,\n          \"54\": 198,\n          \"55\": 191,\n          \"56\": 195,\n          \"57\": 144,\n          \"58\": 96,\n          \"59\": 212,\n          \"60\": 89,\n          \"61\": 131,\n          \"62\": 183,\n          \"63\": 191,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }, {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": 0.09461892805990832,\n        \"1\": -0.6329745552844204,\n        \"2\": -0.7923676394624737,\n        \"3\": -0.08606445900172546,\n        \"4\": 0.11603124920286288,\n        \"5\": 0.029252054814320392,\n        \"6\": -0.03747907757038657,\n        \"7\": -0.6005289047981558,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 238,\n          \"1\": 145,\n          \"2\": 153,\n          \"3\": 49,\n          \"4\": 242,\n          \"5\": 56,\n          \"6\": 184,\n          \"7\": 63,\n          \"8\": 2,\n          \"9\": 178,\n          \"10\": 196,\n          \"11\": 218,\n          \"12\": 83,\n          \"13\": 65,\n          \"14\": 228,\n          \"15\": 191,\n          \"16\": 40,\n          \"17\": 205,\n          \"18\": 60,\n          \"19\": 97,\n          \"20\": 19,\n          \"21\": 91,\n          \"22\": 233,\n          \"23\": 191,\n          \"24\": 226,\n          \"25\": 165,\n          \"26\": 194,\n          \"27\": 4,\n          \"28\": 82,\n          \"29\": 8,\n          \"30\": 182,\n          \"31\": 191,\n          \"32\": 39,\n          \"33\": 236,\n          \"34\": 163,\n          \"35\": 84,\n          \"36\": 57,\n          \"37\": 180,\n          \"38\": 189,\n          \"39\": 63,\n          \"40\": 169,\n          \"41\": 190,\n          \"42\": 18,\n          \"43\": 43,\n          \"44\": 64,\n          \"45\": 244,\n          \"46\": 157,\n          \"47\": 63,\n          \"48\": 220,\n          \"49\": 234,\n          \"50\": 229,\n          \"51\": 40,\n          \"52\": 117,\n          \"53\": 48,\n          \"54\": 163,\n          \"55\": 191,\n          \"56\": 21,\n          \"57\": 37,\n          \"58\": 205,\n          \"59\": 100,\n          \"60\": 136,\n          \"61\": 55,\n          \"62\": 227,\n          \"63\": 191,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }, {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": 0.42277438855180405,\n        \"1\": 1.4138688143060145,\n        \"2\": -0.3778547415032166,\n        \"3\": -0.012023049493322651,\n        \"4\": 0.11825224526479829,\n        \"5\": -0.4434819918251306,\n        \"6\": -0.6772974432572635,\n        \"7\": -0.14741163123927092,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 56,\n          \"1\": 166,\n          \"2\": 26,\n          \"3\": 79,\n          \"4\": 188,\n          \"5\": 14,\n          \"6\": 219,\n          \"7\": 63,\n          \"8\": 68,\n          \"9\": 117,\n          \"10\": 228,\n          \"11\": 231,\n          \"12\": 52,\n          \"13\": 159,\n          \"14\": 246,\n          \"15\": 63,\n          \"16\": 53,\n          \"17\": 69,\n          \"18\": 89,\n          \"19\": 167,\n          \"20\": 197,\n          \"21\": 46,\n          \"22\": 216,\n          \"23\": 191,\n          \"24\": 118,\n          \"25\": 224,\n          \"26\": 249,\n          \"27\": 98,\n          \"28\": 138,\n          \"29\": 159,\n          \"30\": 136,\n          \"31\": 191,\n          \"32\": 225,\n          \"33\": 67,\n          \"34\": 23,\n          \"35\": 118,\n          \"36\": 199,\n          \"37\": 69,\n          \"38\": 190,\n          \"39\": 63,\n          \"40\": 126,\n          \"41\": 63,\n          \"42\": 208,\n          \"43\": 74,\n          \"44\": 2,\n          \"45\": 98,\n          \"46\": 220,\n          \"47\": 191,\n          \"48\": 35,\n          \"49\": 138,\n          \"50\": 14,\n          \"51\": 176,\n          \"52\": 107,\n          \"53\": 172,\n          \"54\": 229,\n          \"55\": 191,\n          \"56\": 204,\n          \"57\": 128,\n          \"58\": 156,\n          \"59\": 99,\n          \"60\": 98,\n          \"61\": 222,\n          \"62\": 194,\n          \"63\": 191,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }, {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": 1.1993670420146874,\n        \"1\": 0.3223431096192715,\n        \"2\": -0.36861400047798204,\n        \"3\": -0.08038294233717612,\n        \"4\": 0.2711210775205418,\n        \"5\": 0.42879169827918595,\n        \"6\": 0.6376085656983045,\n        \"7\": 0.03756028253259824,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 72,\n          \"1\": 167,\n          \"2\": 213,\n          \"3\": 126,\n          \"4\": 155,\n          \"5\": 48,\n          \"6\": 243,\n          \"7\": 63,\n          \"8\": 56,\n          \"9\": 247,\n          \"10\": 121,\n          \"11\": 254,\n          \"12\": 68,\n          \"13\": 161,\n          \"14\": 212,\n          \"15\": 63,\n          \"16\": 111,\n          \"17\": 164,\n          \"18\": 57,\n          \"19\": 45,\n          \"20\": 95,\n          \"21\": 151,\n          \"22\": 215,\n          \"23\": 191,\n          \"24\": 167,\n          \"25\": 146,\n          \"26\": 126,\n          \"27\": 252,\n          \"28\": 249,\n          \"29\": 147,\n          \"30\": 180,\n          \"31\": 191,\n          \"32\": 158,\n          \"33\": 63,\n          \"34\": 77,\n          \"35\": 56,\n          \"36\": 12,\n          \"37\": 90,\n          \"38\": 209,\n          \"39\": 63,\n          \"40\": 32,\n          \"41\": 242,\n          \"42\": 57,\n          \"43\": 188,\n          \"44\": 82,\n          \"45\": 113,\n          \"46\": 219,\n          \"47\": 63,\n          \"48\": 161,\n          \"49\": 91,\n          \"50\": 42,\n          \"51\": 20,\n          \"52\": 74,\n          \"53\": 103,\n          \"54\": 228,\n          \"55\": 63,\n          \"56\": 127,\n          \"57\": 73,\n          \"58\": 54,\n          \"59\": 242,\n          \"60\": 25,\n          \"61\": 59,\n          \"62\": 163,\n          \"63\": 63,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }, {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": 0.13967402583430144,\n        \"1\": -0.11357850366802424,\n        \"2\": -0.5746610827627967,\n        \"3\": -0.5717582875884522,\n        \"4\": -0.1898576928922138,\n        \"5\": -0.18657398702306335,\n        \"6\": 0.7165884005339106,\n        \"7\": -0.6224249593531741,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 200,\n          \"1\": 140,\n          \"2\": 135,\n          \"3\": 166,\n          \"4\": 214,\n          \"5\": 224,\n          \"6\": 193,\n          \"7\": 63,\n          \"8\": 72,\n          \"9\": 100,\n          \"10\": 200,\n          \"11\": 22,\n          \"12\": 123,\n          \"13\": 19,\n          \"14\": 189,\n          \"15\": 191,\n          \"16\": 82,\n          \"17\": 1,\n          \"18\": 152,\n          \"19\": 163,\n          \"20\": 159,\n          \"21\": 99,\n          \"22\": 226,\n          \"23\": 191,\n          \"24\": 132,\n          \"25\": 25,\n          \"26\": 77,\n          \"27\": 9,\n          \"28\": 216,\n          \"29\": 75,\n          \"30\": 226,\n          \"31\": 191,\n          \"32\": 97,\n          \"33\": 219,\n          \"34\": 238,\n          \"35\": 194,\n          \"36\": 65,\n          \"37\": 77,\n          \"38\": 200,\n          \"39\": 191,\n          \"40\": 127,\n          \"41\": 49,\n          \"42\": 70,\n          \"43\": 10,\n          \"44\": 168,\n          \"45\": 225,\n          \"46\": 199,\n          \"47\": 191,\n          \"48\": 23,\n          \"49\": 142,\n          \"50\": 31,\n          \"51\": 204,\n          \"52\": 74,\n          \"53\": 238,\n          \"54\": 230,\n          \"55\": 63,\n          \"56\": 54,\n          \"57\": 90,\n          \"58\": 148,\n          \"59\": 191,\n          \"60\": 231,\n          \"61\": 234,\n          \"62\": 227,\n          \"63\": 191,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }],\n    \"biases\": {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": 0.2562049254190115,\n        \"1\": -0.5455393081802729,\n        \"2\": 0.10903726980643962,\n        \"3\": -0.16355954769541572,\n        \"4\": 0.08992117884673975,\n        \"5\": 0.5185622512844232,\n        \"6\": -0.46073562437071663,\n        \"7\": 0.38509647559811017,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 232,\n          \"1\": 235,\n          \"2\": 239,\n          \"3\": 87,\n          \"4\": 169,\n          \"5\": 101,\n          \"6\": 208,\n          \"7\": 63,\n          \"8\": 182,\n          \"9\": 34,\n          \"10\": 234,\n          \"11\": 217,\n          \"12\": 14,\n          \"13\": 117,\n          \"14\": 225,\n          \"15\": 191,\n          \"16\": 27,\n          \"17\": 33,\n          \"18\": 221,\n          \"19\": 211,\n          \"20\": 221,\n          \"21\": 233,\n          \"22\": 187,\n          \"23\": 63,\n          \"24\": 73,\n          \"25\": 114,\n          \"26\": 38,\n          \"27\": 238,\n          \"28\": 132,\n          \"29\": 239,\n          \"30\": 196,\n          \"31\": 191,\n          \"32\": 206,\n          \"33\": 80,\n          \"34\": 93,\n          \"35\": 10,\n          \"36\": 19,\n          \"37\": 5,\n          \"38\": 183,\n          \"39\": 63,\n          \"40\": 140,\n          \"41\": 157,\n          \"42\": 198,\n          \"43\": 220,\n          \"44\": 15,\n          \"45\": 152,\n          \"46\": 224,\n          \"47\": 63,\n          \"48\": 65,\n          \"49\": 143,\n          \"50\": 177,\n          \"51\": 69,\n          \"52\": 177,\n          \"53\": 124,\n          \"54\": 221,\n          \"55\": 191,\n          \"56\": 113,\n          \"57\": 235,\n          \"58\": 31,\n          \"59\": 176,\n          \"60\": 107,\n          \"61\": 165,\n          \"62\": 216,\n          \"63\": 63,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }\n  }, {\n    \"out_depth\": 8,\n    \"out_sx\": 1,\n    \"out_sy\": 1,\n    \"layer_type\": \"tanh\"\n  }, {\n    \"out_depth\": 8,\n    \"out_sx\": 1,\n    \"out_sy\": 1,\n    \"layer_type\": \"fc\",\n    \"num_inputs\": 8,\n    \"l1_decay_mul\": 0,\n    \"l2_decay_mul\": 1,\n    \"filters\": [{\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": -0.38832824611419614,\n        \"1\": 0.5331207710690121,\n        \"2\": -0.16958013252471874,\n        \"3\": -0.03763800230330026,\n        \"4\": -0.30277152771651167,\n        \"5\": -0.03899235791753754,\n        \"6\": 0.4840579241426027,\n        \"7\": -0.5416342032769544,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 208,\n          \"1\": 26,\n          \"2\": 75,\n          \"3\": 183,\n          \"4\": 94,\n          \"5\": 218,\n          \"6\": 216,\n          \"7\": 191,\n          \"8\": 37,\n          \"9\": 233,\n          \"10\": 145,\n          \"11\": 74,\n          \"12\": 83,\n          \"13\": 15,\n          \"14\": 225,\n          \"15\": 63,\n          \"16\": 149,\n          \"17\": 92,\n          \"18\": 159,\n          \"19\": 65,\n          \"20\": 205,\n          \"21\": 180,\n          \"22\": 197,\n          \"23\": 191,\n          \"24\": 29,\n          \"25\": 122,\n          \"26\": 245,\n          \"27\": 201,\n          \"28\": 73,\n          \"29\": 69,\n          \"30\": 163,\n          \"31\": 191,\n          \"32\": 183,\n          \"33\": 243,\n          \"34\": 108,\n          \"35\": 212,\n          \"36\": 155,\n          \"37\": 96,\n          \"38\": 211,\n          \"39\": 191,\n          \"40\": 226,\n          \"41\": 120,\n          \"42\": 25,\n          \"43\": 108,\n          \"44\": 206,\n          \"45\": 246,\n          \"46\": 163,\n          \"47\": 191,\n          \"48\": 229,\n          \"49\": 249,\n          \"50\": 99,\n          \"51\": 22,\n          \"52\": 206,\n          \"53\": 250,\n          \"54\": 222,\n          \"55\": 63,\n          \"56\": 111,\n          \"57\": 6,\n          \"58\": 175,\n          \"59\": 64,\n          \"60\": 17,\n          \"61\": 85,\n          \"62\": 225,\n          \"63\": 191,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }, {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": -0.11439407632270632,\n        \"1\": -1.2819890886327963,\n        \"2\": 0.14634106395136273,\n        \"3\": 0.14304395032875164,\n        \"4\": 0.2297327647600765,\n        \"5\": 0.4348725634157742,\n        \"6\": -0.26416425812412686,\n        \"7\": 0.058453811796899485,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 196,\n          \"1\": 130,\n          \"2\": 169,\n          \"3\": 32,\n          \"4\": 238,\n          \"5\": 72,\n          \"6\": 189,\n          \"7\": 191,\n          \"8\": 119,\n          \"9\": 27,\n          \"10\": 152,\n          \"11\": 253,\n          \"12\": 6,\n          \"13\": 131,\n          \"14\": 244,\n          \"15\": 191,\n          \"16\": 57,\n          \"17\": 209,\n          \"18\": 221,\n          \"19\": 209,\n          \"20\": 77,\n          \"21\": 187,\n          \"22\": 194,\n          \"23\": 63,\n          \"24\": 205,\n          \"25\": 188,\n          \"26\": 70,\n          \"27\": 160,\n          \"28\": 67,\n          \"29\": 79,\n          \"30\": 194,\n          \"31\": 63,\n          \"32\": 147,\n          \"33\": 106,\n          \"34\": 187,\n          \"35\": 27,\n          \"36\": 226,\n          \"37\": 103,\n          \"38\": 205,\n          \"39\": 63,\n          \"40\": 148,\n          \"41\": 25,\n          \"42\": 115,\n          \"43\": 187,\n          \"44\": 243,\n          \"45\": 212,\n          \"46\": 219,\n          \"47\": 63,\n          \"48\": 21,\n          \"49\": 147,\n          \"50\": 90,\n          \"51\": 52,\n          \"52\": 17,\n          \"53\": 232,\n          \"54\": 208,\n          \"55\": 191,\n          \"56\": 180,\n          \"57\": 10,\n          \"58\": 253,\n          \"59\": 115,\n          \"60\": 168,\n          \"61\": 237,\n          \"62\": 173,\n          \"63\": 63,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }, {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": -0.1406881916489247,\n        \"1\": 0.9405578660965507,\n        \"2\": 0.004901858025518234,\n        \"3\": -0.2326645372062353,\n        \"4\": -0.21448421502002576,\n        \"5\": -1.0893898213683164,\n        \"6\": -0.3778283066766321,\n        \"7\": -0.37747385299064595,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 178,\n          \"1\": 98,\n          \"2\": 8,\n          \"3\": 23,\n          \"4\": 18,\n          \"5\": 2,\n          \"6\": 194,\n          \"7\": 191,\n          \"8\": 221,\n          \"9\": 42,\n          \"10\": 92,\n          \"11\": 207,\n          \"12\": 12,\n          \"13\": 25,\n          \"14\": 238,\n          \"15\": 63,\n          \"16\": 254,\n          \"17\": 58,\n          \"18\": 140,\n          \"19\": 126,\n          \"20\": 248,\n          \"21\": 19,\n          \"22\": 116,\n          \"23\": 63,\n          \"24\": 82,\n          \"25\": 176,\n          \"26\": 30,\n          \"27\": 153,\n          \"28\": 243,\n          \"29\": 199,\n          \"30\": 205,\n          \"31\": 191,\n          \"32\": 139,\n          \"33\": 118,\n          \"34\": 130,\n          \"35\": 0,\n          \"36\": 56,\n          \"37\": 116,\n          \"38\": 203,\n          \"39\": 191,\n          \"40\": 137,\n          \"41\": 244,\n          \"42\": 117,\n          \"43\": 5,\n          \"44\": 36,\n          \"45\": 110,\n          \"46\": 241,\n          \"47\": 191,\n          \"48\": 231,\n          \"49\": 119,\n          \"50\": 43,\n          \"51\": 199,\n          \"52\": 86,\n          \"53\": 46,\n          \"54\": 216,\n          \"55\": 191,\n          \"56\": 234,\n          \"57\": 39,\n          \"58\": 108,\n          \"59\": 23,\n          \"60\": 136,\n          \"61\": 40,\n          \"62\": 216,\n          \"63\": 191,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }, {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": 0.3710384010689571,\n        \"1\": -0.6190881680177,\n        \"2\": 0.41162941225861827,\n        \"3\": -0.543618129725223,\n        \"4\": 0.6163330090258718,\n        \"5\": 0.7949110806898168,\n        \"6\": -0.7884090007104152,\n        \"7\": 0.38478012561877223,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 239,\n          \"1\": 174,\n          \"2\": 137,\n          \"3\": 217,\n          \"4\": 23,\n          \"5\": 191,\n          \"6\": 215,\n          \"7\": 63,\n          \"8\": 25,\n          \"9\": 64,\n          \"10\": 95,\n          \"11\": 253,\n          \"12\": 145,\n          \"13\": 207,\n          \"14\": 227,\n          \"15\": 191,\n          \"16\": 230,\n          \"17\": 60,\n          \"18\": 238,\n          \"19\": 227,\n          \"20\": 34,\n          \"21\": 88,\n          \"22\": 218,\n          \"23\": 63,\n          \"24\": 49,\n          \"25\": 215,\n          \"26\": 21,\n          \"27\": 217,\n          \"28\": 81,\n          \"29\": 101,\n          \"30\": 225,\n          \"31\": 191,\n          \"32\": 186,\n          \"33\": 195,\n          \"34\": 166,\n          \"35\": 0,\n          \"36\": 0,\n          \"37\": 185,\n          \"38\": 227,\n          \"39\": 63,\n          \"40\": 18,\n          \"41\": 78,\n          \"42\": 217,\n          \"43\": 92,\n          \"44\": 233,\n          \"45\": 111,\n          \"46\": 233,\n          \"47\": 63,\n          \"48\": 118,\n          \"49\": 139,\n          \"50\": 61,\n          \"51\": 131,\n          \"52\": 165,\n          \"53\": 58,\n          \"54\": 233,\n          \"55\": 191,\n          \"56\": 205,\n          \"57\": 188,\n          \"58\": 235,\n          \"59\": 209,\n          \"60\": 60,\n          \"61\": 160,\n          \"62\": 216,\n          \"63\": 63,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }, {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": 0.2740006754893999,\n        \"1\": -0.8544168596508195,\n        \"2\": 0.07387149782516346,\n        \"3\": -0.18854684467760982,\n        \"4\": 0.5306163852118577,\n        \"5\": 0.5217519355682549,\n        \"6\": -0.16672917486486497,\n        \"7\": 0.23335567893271977,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 182,\n          \"1\": 196,\n          \"2\": 19,\n          \"3\": 33,\n          \"4\": 58,\n          \"5\": 137,\n          \"6\": 209,\n          \"7\": 63,\n          \"8\": 200,\n          \"9\": 61,\n          \"10\": 171,\n          \"11\": 6,\n          \"12\": 98,\n          \"13\": 87,\n          \"14\": 235,\n          \"15\": 191,\n          \"16\": 41,\n          \"17\": 255,\n          \"18\": 67,\n          \"19\": 19,\n          \"20\": 62,\n          \"21\": 233,\n          \"22\": 178,\n          \"23\": 63,\n          \"24\": 243,\n          \"25\": 192,\n          \"26\": 211,\n          \"27\": 145,\n          \"28\": 77,\n          \"29\": 34,\n          \"30\": 200,\n          \"31\": 191,\n          \"32\": 4,\n          \"33\": 157,\n          \"34\": 166,\n          \"35\": 54,\n          \"36\": 207,\n          \"37\": 250,\n          \"38\": 224,\n          \"39\": 63,\n          \"40\": 200,\n          \"41\": 125,\n          \"42\": 124,\n          \"43\": 29,\n          \"44\": 49,\n          \"45\": 178,\n          \"46\": 224,\n          \"47\": 63,\n          \"48\": 97,\n          \"49\": 181,\n          \"50\": 170,\n          \"51\": 176,\n          \"52\": 97,\n          \"53\": 87,\n          \"54\": 197,\n          \"55\": 191,\n          \"56\": 79,\n          \"57\": 11,\n          \"58\": 173,\n          \"59\": 80,\n          \"60\": 153,\n          \"61\": 222,\n          \"62\": 205,\n          \"63\": 63,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }, {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": -0.1906626781357325,\n        \"1\": 0.4709381707241033,\n        \"2\": 0.24160919622692853,\n        \"3\": 0.6311757769867091,\n        \"4\": -0.3203913931138507,\n        \"5\": -0.5879387228046364,\n        \"6\": 0.39346084678734317,\n        \"7\": -0.3561015790308374,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 78,\n          \"1\": 147,\n          \"2\": 148,\n          \"3\": 119,\n          \"4\": 162,\n          \"5\": 103,\n          \"6\": 200,\n          \"7\": 191,\n          \"8\": 123,\n          \"9\": 173,\n          \"10\": 108,\n          \"11\": 218,\n          \"12\": 217,\n          \"13\": 35,\n          \"14\": 222,\n          \"15\": 63,\n          \"16\": 131,\n          \"17\": 143,\n          \"18\": 26,\n          \"19\": 214,\n          \"20\": 12,\n          \"21\": 237,\n          \"22\": 206,\n          \"23\": 63,\n          \"24\": 5,\n          \"25\": 238,\n          \"26\": 5,\n          \"27\": 139,\n          \"28\": 151,\n          \"29\": 50,\n          \"30\": 228,\n          \"31\": 63,\n          \"32\": 240,\n          \"33\": 1,\n          \"34\": 214,\n          \"35\": 230,\n          \"36\": 74,\n          \"37\": 129,\n          \"38\": 212,\n          \"39\": 191,\n          \"40\": 252,\n          \"41\": 238,\n          \"42\": 79,\n          \"43\": 222,\n          \"44\": 100,\n          \"45\": 208,\n          \"46\": 226,\n          \"47\": 191,\n          \"48\": 154,\n          \"49\": 81,\n          \"50\": 77,\n          \"51\": 103,\n          \"52\": 118,\n          \"53\": 46,\n          \"54\": 217,\n          \"55\": 63,\n          \"56\": 50,\n          \"57\": 115,\n          \"58\": 255,\n          \"59\": 70,\n          \"60\": 94,\n          \"61\": 202,\n          \"62\": 214,\n          \"63\": 191,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }, {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": -0.052332119821916476,\n        \"1\": 0.5000167096781711,\n        \"2\": 0.26266568911062693,\n        \"3\": 0.26506535297601835,\n        \"4\": -0.25463287277049923,\n        \"5\": 0.08282611179305391,\n        \"6\": 0.9396179911813585,\n        \"7\": -0.5542899781400487,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 102,\n          \"1\": 186,\n          \"2\": 84,\n          \"3\": 142,\n          \"4\": 70,\n          \"5\": 203,\n          \"6\": 170,\n          \"7\": 191,\n          \"8\": 66,\n          \"9\": 174,\n          \"10\": 240,\n          \"11\": 10,\n          \"12\": 35,\n          \"13\": 0,\n          \"14\": 224,\n          \"15\": 63,\n          \"16\": 136,\n          \"17\": 187,\n          \"18\": 32,\n          \"19\": 192,\n          \"20\": 131,\n          \"21\": 207,\n          \"22\": 208,\n          \"23\": 63,\n          \"24\": 165,\n          \"25\": 107,\n          \"26\": 149,\n          \"27\": 171,\n          \"28\": 212,\n          \"29\": 246,\n          \"30\": 208,\n          \"31\": 63,\n          \"32\": 237,\n          \"33\": 74,\n          \"34\": 66,\n          \"35\": 173,\n          \"36\": 231,\n          \"37\": 75,\n          \"38\": 208,\n          \"39\": 191,\n          \"40\": 10,\n          \"41\": 240,\n          \"42\": 103,\n          \"43\": 145,\n          \"44\": 23,\n          \"45\": 52,\n          \"46\": 181,\n          \"47\": 63,\n          \"48\": 200,\n          \"49\": 109,\n          \"50\": 219,\n          \"51\": 191,\n          \"52\": 89,\n          \"53\": 17,\n          \"54\": 238,\n          \"55\": 63,\n          \"56\": 7,\n          \"57\": 150,\n          \"58\": 19,\n          \"59\": 86,\n          \"60\": 190,\n          \"61\": 188,\n          \"62\": 225,\n          \"63\": 191,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }, {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": 0.5183573300646674,\n        \"1\": -0.8084279309930922,\n        \"2\": 0.17564116878772115,\n        \"3\": -0.4120839198806116,\n        \"4\": 0.5760434856452349,\n        \"5\": 0.35578634913953205,\n        \"6\": -0.3705548599822078,\n        \"7\": 0.44300177295886806,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 195,\n          \"1\": 160,\n          \"2\": 136,\n          \"3\": 28,\n          \"4\": 98,\n          \"5\": 150,\n          \"6\": 224,\n          \"7\": 63,\n          \"8\": 142,\n          \"9\": 57,\n          \"10\": 153,\n          \"11\": 64,\n          \"12\": 164,\n          \"13\": 222,\n          \"14\": 233,\n          \"15\": 191,\n          \"16\": 27,\n          \"17\": 34,\n          \"18\": 227,\n          \"19\": 233,\n          \"20\": 104,\n          \"21\": 123,\n          \"22\": 198,\n          \"23\": 63,\n          \"24\": 191,\n          \"25\": 15,\n          \"26\": 198,\n          \"27\": 59,\n          \"28\": 149,\n          \"29\": 95,\n          \"30\": 218,\n          \"31\": 191,\n          \"32\": 179,\n          \"33\": 113,\n          \"34\": 125,\n          \"35\": 191,\n          \"36\": 242,\n          \"37\": 110,\n          \"38\": 226,\n          \"39\": 63,\n          \"40\": 199,\n          \"41\": 184,\n          \"42\": 122,\n          \"43\": 27,\n          \"44\": 52,\n          \"45\": 197,\n          \"46\": 214,\n          \"47\": 63,\n          \"48\": 21,\n          \"49\": 214,\n          \"50\": 63,\n          \"51\": 187,\n          \"52\": 43,\n          \"53\": 183,\n          \"54\": 215,\n          \"55\": 191,\n          \"56\": 45,\n          \"57\": 106,\n          \"58\": 187,\n          \"59\": 27,\n          \"60\": 36,\n          \"61\": 90,\n          \"62\": 220,\n          \"63\": 63,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }],\n    \"biases\": {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": 0.013187463476726313,\n        \"1\": -0.007630520124428615,\n        \"2\": -0.27144190488489406,\n        \"3\": -0.30429595726968894,\n        \"4\": -0.05004981783245224,\n        \"5\": 0.07003641753819947,\n        \"6\": -0.09093686693747323,\n        \"7\": 0.05757614475366814,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 83,\n          \"1\": 65,\n          \"2\": 204,\n          \"3\": 98,\n          \"4\": 7,\n          \"5\": 2,\n          \"6\": 139,\n          \"7\": 63,\n          \"8\": 200,\n          \"9\": 155,\n          \"10\": 44,\n          \"11\": 38,\n          \"12\": 46,\n          \"13\": 65,\n          \"14\": 127,\n          \"15\": 191,\n          \"16\": 234,\n          \"17\": 166,\n          \"18\": 15,\n          \"19\": 222,\n          \"20\": 77,\n          \"21\": 95,\n          \"22\": 209,\n          \"23\": 191,\n          \"24\": 30,\n          \"25\": 208,\n          \"26\": 49,\n          \"27\": 192,\n          \"28\": 149,\n          \"29\": 121,\n          \"30\": 211,\n          \"31\": 191,\n          \"32\": 36,\n          \"33\": 180,\n          \"34\": 133,\n          \"35\": 53,\n          \"36\": 33,\n          \"37\": 160,\n          \"38\": 169,\n          \"39\": 191,\n          \"40\": 122,\n          \"41\": 6,\n          \"42\": 219,\n          \"43\": 26,\n          \"44\": 232,\n          \"45\": 237,\n          \"46\": 177,\n          \"47\": 63,\n          \"48\": 77,\n          \"49\": 69,\n          \"50\": 127,\n          \"51\": 117,\n          \"52\": 163,\n          \"53\": 71,\n          \"54\": 183,\n          \"55\": 191,\n          \"56\": 50,\n          \"57\": 88,\n          \"58\": 126,\n          \"59\": 213,\n          \"60\": 158,\n          \"61\": 122,\n          \"62\": 173,\n          \"63\": 63,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }\n  }, {\n    \"out_depth\": 8,\n    \"out_sx\": 1,\n    \"out_sy\": 1,\n    \"layer_type\": \"tanh\"\n  }, {\n    \"out_depth\": 2,\n    \"out_sx\": 1,\n    \"out_sy\": 1,\n    \"layer_type\": \"fc\",\n    \"num_inputs\": 8,\n    \"l1_decay_mul\": 0,\n    \"l2_decay_mul\": 1,\n    \"filters\": [{\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": 1.0172730016739508,\n        \"1\": -0.13221137581570833,\n        \"2\": 0.9395466221657038,\n        \"3\": -1.6251860610880569,\n        \"4\": -1.2388309137808013,\n        \"5\": 0.8533890654636394,\n        \"6\": 0.7649152131278658,\n        \"7\": -1.7907313802649556,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 167,\n          \"1\": 177,\n          \"2\": 20,\n          \"3\": 14,\n          \"4\": 192,\n          \"5\": 70,\n          \"6\": 240,\n          \"7\": 63,\n          \"8\": 37,\n          \"9\": 209,\n          \"10\": 164,\n          \"11\": 103,\n          \"12\": 77,\n          \"13\": 236,\n          \"14\": 192,\n          \"15\": 191,\n          \"16\": 96,\n          \"17\": 155,\n          \"18\": 232,\n          \"19\": 19,\n          \"20\": 196,\n          \"21\": 16,\n          \"22\": 238,\n          \"23\": 63,\n          \"24\": 185,\n          \"25\": 156,\n          \"26\": 100,\n          \"27\": 25,\n          \"28\": 195,\n          \"29\": 0,\n          \"30\": 250,\n          \"31\": 191,\n          \"32\": 188,\n          \"33\": 101,\n          \"34\": 63,\n          \"35\": 93,\n          \"36\": 64,\n          \"37\": 210,\n          \"38\": 243,\n          \"39\": 191,\n          \"40\": 76,\n          \"41\": 197,\n          \"42\": 221,\n          \"43\": 149,\n          \"44\": 246,\n          \"45\": 78,\n          \"46\": 235,\n          \"47\": 63,\n          \"48\": 16,\n          \"49\": 27,\n          \"50\": 19,\n          \"51\": 120,\n          \"52\": 47,\n          \"53\": 122,\n          \"54\": 232,\n          \"55\": 63,\n          \"56\": 244,\n          \"57\": 138,\n          \"58\": 162,\n          \"59\": 242,\n          \"60\": 213,\n          \"61\": 166,\n          \"62\": 252,\n          \"63\": 191,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }, {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 8,\n      \"w\": {\n        \"0\": -1.252270530582403,\n        \"1\": 0.7285270999976606,\n        \"2\": 0.023798576828390303,\n        \"3\": 1.064484519454345,\n        \"4\": 0.246286754788085,\n        \"5\": -1.2474340354253382,\n        \"6\": -0.3051491951725839,\n        \"7\": 1.4177785201450572,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 43,\n          \"1\": 137,\n          \"2\": 233,\n          \"3\": 210,\n          \"4\": 76,\n          \"5\": 9,\n          \"6\": 244,\n          \"7\": 191,\n          \"8\": 105,\n          \"9\": 171,\n          \"10\": 151,\n          \"11\": 16,\n          \"12\": 24,\n          \"13\": 80,\n          \"14\": 231,\n          \"15\": 63,\n          \"16\": 172,\n          \"17\": 87,\n          \"18\": 173,\n          \"19\": 116,\n          \"20\": 167,\n          \"21\": 94,\n          \"22\": 152,\n          \"23\": 63,\n          \"24\": 154,\n          \"25\": 121,\n          \"26\": 98,\n          \"27\": 235,\n          \"28\": 32,\n          \"29\": 8,\n          \"30\": 241,\n          \"31\": 63,\n          \"32\": 163,\n          \"33\": 91,\n          \"34\": 160,\n          \"35\": 10,\n          \"36\": 83,\n          \"37\": 134,\n          \"38\": 207,\n          \"39\": 63,\n          \"40\": 43,\n          \"41\": 27,\n          \"42\": 33,\n          \"43\": 100,\n          \"44\": 125,\n          \"45\": 245,\n          \"46\": 243,\n          \"47\": 191,\n          \"48\": 158,\n          \"49\": 175,\n          \"50\": 106,\n          \"51\": 125,\n          \"52\": 144,\n          \"53\": 135,\n          \"54\": 211,\n          \"55\": 191,\n          \"56\": 165,\n          \"57\": 232,\n          \"58\": 143,\n          \"59\": 135,\n          \"60\": 56,\n          \"61\": 175,\n          \"62\": 246,\n          \"63\": 63,\n          \"byteLength\": 64\n        },\n        \"length\": 8,\n        \"byteOffset\": 0,\n        \"byteLength\": 64\n      }\n    }],\n    \"biases\": {\n      \"sx\": 1,\n      \"sy\": 1,\n      \"depth\": 2,\n      \"w\": {\n        \"0\": -0.008745691297802017,\n        \"1\": 0.00874569129780175,\n        \"BYTES_PER_ELEMENT\": 8,\n        \"buffer\": {\n          \"0\": 71,\n          \"1\": 251,\n          \"2\": 214,\n          \"3\": 208,\n          \"4\": 66,\n          \"5\": 233,\n          \"6\": 129,\n          \"7\": 191,\n          \"8\": 173,\n          \"9\": 250,\n          \"10\": 214,\n          \"11\": 208,\n          \"12\": 66,\n          \"13\": 233,\n          \"14\": 129,\n          \"15\": 63,\n          \"byteLength\": 16\n        },\n        \"length\": 2,\n        \"byteOffset\": 0,\n        \"byteLength\": 16\n      }\n    }\n  }, {\n    \"out_depth\": 2,\n    \"out_sx\": 1,\n    \"out_sy\": 1,\n    \"layer_type\": \"softmax\",\n    \"num_inputs\": 2\n  }]\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"pinyin_util.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/pinyin_util.js                                                                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  pinyin_util: () => pinyin_util\n});\nlet assert;\nmodule.link(\"/lib/base\", {\n  assert(v) {\n    assert = v;\n  }\n\n}, 0);\nconst vowel_to_tone = {\n  0: \"aeiouü\",\n  1: \"āēīōūǖ\",\n  2: \"áéíóúǘ\",\n  3: \"ǎěǐǒǔǚ\",\n  4: \"àèìòùǜ\"\n};\n\nconst tokenSet = tokens => {\n  const result = {};\n  tokens.split(' ').map(x => result[x] = true);\n  return result;\n};\n\nconst consonants = tokenSet('b p m f d t n l g k h j q x zh ch sh r z c s y w');\nconst vowels = tokenSet('a ai an ang ao e ei en eng er i ia ian iang iao ie ' + 'in ing io iong iu o ong ou u ua uai uan uang ue ui ' + 'un uo v van vn');\nconst two_syllables = tokenSet('ia ian iang iao ie io iong iu ua uai uan ' + 'uang ue ui uo van');\nconst pinyin_util = {};\n\npinyin_util.dropTones = (pinyin, append_number) => {\n  for (let i = 0; i < pinyin.length; i++) {\n    for (let option = 1; option <= 4; option++) {\n      const index = vowel_to_tone[option].indexOf(pinyin[i]);\n\n      if (index >= 0) {\n        const toneless = 'aeiouv'[index];\n        pinyin = pinyin.substr(0, i) + toneless + pinyin.substr(i + 1);\n\n        if (append_number) {\n          return \"\".concat(pinyin).concat(option);\n        }\n      }\n    }\n  }\n\n  return pinyin;\n};\n\npinyin_util.numberedPinyinToTonePinyin = numbered => {\n  assert(numbered && numbered === numbered.toLowerCase());\n  let tone = 0;\n\n  if ('01234'.indexOf(numbered[numbered.length - 1]) >= 0) {\n    tone = parseInt(numbered[numbered.length - 1], 10);\n    numbered = numbered.substr(0, numbered.length - 1);\n  }\n\n  for (let i = 0; i < numbered.length; i++) {\n    for (let option = 1; option <= 4; option++) {\n      const index = vowel_to_tone[option].indexOf(numbered[i]);\n\n      if (index >= 0) {\n        tone = option;\n        const toneless = 'aeiouv'[index];\n        numbered = numbered.substr(0, i) + toneless + numbered.substr(i + 1);\n      }\n    }\n  }\n\n  let consonant = '';\n\n  for (let i = 1; i < numbered.length; i++) {\n    const candidate = numbered.substr(0, i);\n\n    if (consonants[candidate]) {\n      consonant = candidate;\n    } else {\n      break;\n    }\n  }\n\n  let vowel = numbered.substr(consonant.length);\n  assert((!consonant || consonants[consonant]) && vowels[vowel]);\n\n  if (two_syllables[vowel]) {\n    const index = 'aeiouv'.indexOf(vowel[1]);\n    vowel = vowel[0] + vowel_to_tone[tone][index] + vowel.substr(2);\n  } else {\n    const index = 'aeiouv'.indexOf(vowel[0]);\n    assert(index >= 0);\n    vowel = vowel_to_tone[tone][index] + vowel.substr(1);\n  }\n\n  return consonant + vowel.replace('v', 'ü');\n};\n\npinyin_util.tonePinyinToNumberedPinyin = tone => {\n  return pinyin_util.dropTones(tone, true\n  /* append_number */\n  );\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"stroke_extractor.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/stroke_extractor.js                                                                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  stroke_extractor: () => stroke_extractor\n});\nlet assert, Angle, Point;\nmodule.link(\"/lib/base\", {\n  assert(v) {\n    assert = v;\n  },\n\n  Angle(v) {\n    Angle = v;\n  },\n\n  Point(v) {\n    Point = v;\n  }\n\n}, 0);\nlet Hungarian;\nmodule.link(\"/lib/hungarian\", {\n  Hungarian(v) {\n    Hungarian = v;\n  }\n\n}, 1);\nlet svg;\nmodule.link(\"/lib/svg\", {\n  svg(v) {\n    svg = v;\n  }\n\n}, 2);\nconst MAX_BRIDGE_DISTANCE = 64;\nconst MIN_CORNER_ANGLE = 0.1 * Math.PI;\nconst MIN_CORNER_TANGENT_DISTANCE = 4;\nconst REVERSAL_PENALTY = 0.5; // Errors out if the bridges are invalid in some gross way.\n\nconst checkBridge = bridge => {\n  assert(Point.valid(bridge[0]) && Point.valid(bridge[1]));\n  assert(!Point.equal(bridge[0], bridge[1]));\n}; // Returns the list of bridges on the path with the given endpoints. We strip\n// nearly all of the metadata out of this list to make it easy to hand-correct.\n// The list that we return is simply a list of pairs of points.\n\n\nconst getBridges = (endpoints, classifier) => {\n  const result = [];\n  const corners = endpoints.filter(x => x.corner);\n  const matching = matchCorners(corners, classifier);\n\n  for (let i = 0; i < corners.length; i++) {\n    const j = matching[i];\n\n    if (j <= i && matching[j] === i) {\n      continue;\n    }\n\n    result.push([Point.clone(corners[i].point), Point.clone(corners[j].point)]);\n  }\n\n  result.map(checkBridge);\n  return result;\n}; // Returns a list of angle and distance features between two corners.\n\n\nconst getFeatures = (ins, out) => {\n  const diff = Point.subtract(out.point, ins.point);\n  const trivial = Point.equal(diff, [0, 0]);\n  const angle = Math.atan2(diff[1], diff[0]);\n  const distance = Math.sqrt(Point.distance2(out.point, ins.point));\n  return [Angle.subtract(angle, ins.angles[0]), Angle.subtract(out.angles[1], angle), Angle.subtract(ins.angles[1], angle), Angle.subtract(angle, out.angles[0]), Angle.subtract(ins.angles[1], ins.angles[0]), Angle.subtract(out.angles[1], out.angles[0]), trivial ? 1 : 0, distance / MAX_BRIDGE_DISTANCE];\n}; // A hand-tuned classifier that uses the features above to return a score for\n// connecting two corners by a bridge. This classifier throws out most data.\n\n\nconst handTunedClassifier = features => {\n  if (features[6] > 0) {\n    return -Angle.penalty(features[4]);\n  }\n\n  let angle_penalty = Angle.penalty(features[0]) + Angle.penalty(features[1]);\n  const distance_penalty = features[7];\n\n  if (features[0] > 0 && features[1] > 0 && features[2] + features[3] < -0.5 * Math.PI) {\n    angle_penalty = angle_penalty / 16;\n  }\n\n  return -(angle_penalty + distance_penalty);\n}; // Takes a list of corners and returns a bipartite matching between them.\n// If matching[i] === j, then corners[i] is matched with corners[j] - that is,\n// we should construct a bridge from corners[i].point to corners[j].point.\n\n\nconst matchCorners = (corners, classifier) => {\n  const matrix = [];\n\n  for (let i = 0; i < corners.length; i++) {\n    matrix.push([]);\n\n    for (let j = 0; j < corners.length; j++) {\n      matrix[i].push(scoreCorners(corners[i], corners[j], classifier));\n    }\n  }\n\n  for (let i = 0; i < corners.length; i++) {\n    for (let j = 0; j < corners.length; j++) {\n      const reversed_score = matrix[j][i] - REVERSAL_PENALTY;\n\n      if (reversed_score > matrix[i][j]) {\n        matrix[i][j] = reversed_score;\n      }\n    }\n  }\n\n  return new Hungarian(matrix).x_match;\n}; // Takes two corners and returns the score assigned to constructing a bridge\n// from one corner to the other. The score is directed: the bridge from ins to\n// out may be weighted higher than from out to ins.\n\n\nconst scoreCorners = (ins, out, classifier) => {\n  return classifier(getFeatures(ins, out));\n}; // Stores angle and distance metadata around an SVG path segment's start point.\n// This endpoint may be a 'corner', which is true if the path bends sharply in\n// the negative (clockwise) direction at that point.\n\n\nfunction Endpoint(paths, index) {\n  this.index = index;\n  const path = paths[index[0]];\n  const n = path.length;\n  this.indices = [[index[0], (index[1] + n - 1) % n], index];\n  this.segments = [path[(index[1] + n - 1) % n], path[index[1]]];\n  this.point = this.segments[0].end;\n  assert(Point.valid(this.point), this.point);\n  assert(Point.equal(this.point, this.segments[1].start), path);\n  this.tangents = [Point.subtract(this.segments[0].end, this.segments[0].start), Point.subtract(this.segments[1].end, this.segments[1].start)];\n  const threshold = Math.pow(MIN_CORNER_TANGENT_DISTANCE, 2);\n\n  if (this.segments[0].control !== undefined && Point.distance2(this.point, this.segments[0].control) > threshold) {\n    this.tangents[0] = Point.subtract(this.point, this.segments[0].control);\n  }\n\n  if (this.segments[1].control !== undefined && Point.distance2(this.point, this.segments[1].control) > threshold) {\n    this.tangents[1] = Point.subtract(this.segments[1].control, this.point);\n  }\n\n  this.angles = this.tangents.map(Point.angle);\n  const diff = Angle.subtract(this.angles[1], this.angles[0]);\n  this.corner = diff < -MIN_CORNER_ANGLE;\n  return this;\n} // Code for the stroke extraction step follows.\n\n\nconst addEdgeToAdjacency = (edge, adjacency) => {\n  assert(edge.length === 2);\n  adjacency[edge[0]] = adjacency[edge[0]] || [];\n\n  if (adjacency[edge[0]].indexOf(edge[1]) < 0) {\n    adjacency[edge[0]].push(edge[1]);\n  }\n};\n\nconst extractStroke = (paths, endpoint_map, bridge_adjacency, log, extracted_indices, start, attempt_one) => {\n  const result = [];\n  const visited = {};\n  let current = start; // A list of line segments that were added to the path but that were not\n  // part of the original stroke data. None of these should intersect.\n\n  const line_segments = [];\n  let self_intersecting = false;\n\n  const advance = index => [index[0], (index[1] + 1) % paths[index[0]].length];\n\n  const angle = (index1, index2) => {\n    const diff = Point.subtract(endpoint_map[Point.key(index2)].point, endpoint_map[Point.key(index1)].point);\n    assert(diff[0] !== 0 || diff[1] !== 0);\n    const angle = Math.atan2(diff[1], diff[0]);\n    return Angle.subtract(angle, endpoint.angles[0]);\n  };\n\n  const getIntersection = (segment1, segment2) => {\n    const diff1 = Point.subtract(segment1[1], segment1[0]);\n    const diff2 = Point.subtract(segment2[1], segment2[0]);\n    const cross = diff1[0] * diff2[1] - diff1[1] * diff2[0];\n\n    if (cross === 0) {\n      return undefined;\n    }\n\n    const v = Point.subtract(segment1[0], segment2[0]);\n    const s = (diff1[0] * v[1] - diff1[1] * v[0]) / cross;\n    const t = (diff2[0] * v[1] - diff2[1] * v[0]) / cross;\n\n    if (0 < s && s < 1 && 0 < t && t < 1) {\n      return [segment1[0][0] + t * diff1[0], segment1[0][1] + t * diff1[1]];\n    }\n\n    return undefined;\n  };\n\n  const indexToPoint = index => endpoint_map[Point.key(index)].point;\n\n  const pushLineSegments = points => {\n    const old_lines = line_segments.length;\n\n    for (let i = 0; i < points.length - 1; i++) {\n      line_segments.push([points[i], points[i + 1]]);\n      result.push({\n        start: Point.clone(points[i]),\n        end: Point.clone(points[i + 1]),\n        control: undefined\n      });\n    } // Log an error if this stroke is self-intersecting.\n\n\n    if (!self_intersecting) {\n      for (let i = 0; i < old_lines; i++) {\n        for (let j = old_lines; j < line_segments.length; j++) {\n          if (getIntersection(line_segments[i], line_segments[j])) {\n            self_intersecting = true;\n            return;\n          }\n        }\n      }\n    }\n  }; // Here there be dragons!\n  // TODO(skishore): Document the point of the geometry in this function.\n\n\n  const selectBridge = (endpoint, options) => {\n    if (options.length === 1 && extracted_indices[Point.key(options[0])]) {\n      // Handle star-shaped strokes where one stroke ends at the intersection\n      // of the bridges used by two other strokes.\n      const indices1 = [endpoint.index, options[0]];\n      const segment1 = indices1.map(indexToPoint);\n\n      for (let key in bridge_adjacency) {\n        if (Point.equal(endpoint_map[key].index, indices1[0])) {\n          continue;\n        }\n\n        for (let i = 0; i < bridge_adjacency[key].length; i++) {\n          if (Point.equal(bridge_adjacency[key][i], segment1[0])) {\n            continue;\n          } // Compute the other bridge segment and check if it intersects.\n\n\n          const indices2 = [endpoint_map[key].index, bridge_adjacency[key][i]];\n          const segment2 = indices2.map(indexToPoint);\n\n          if (Point.equal(indices2[0], indices1[1]) && !extracted_indices[Point.key(indices2[1])]) {\n            pushLineSegments([segment1[0], segment1[1], segment2[1]]);\n            return indices2[1];\n          } else if (Point.equal(indices2[1], indices1[1]) && !extracted_indices[Point.key(indices2[0])]) {\n            pushLineSegments([segment1[0], segment1[1], segment2[0]]);\n            return indices2[0];\n          }\n\n          const intersection = getIntersection(segment1, segment2);\n\n          if (intersection !== undefined) {\n            const angle1 = angle(indices1[0], indices1[1]);\n            const angle2 = angle(indices2[0], indices2[1]);\n\n            if (Angle.subtract(angle2, angle1) < 0) {\n              indices2.reverse();\n              segment2.reverse();\n            }\n\n            pushLineSegments([segment1[0], intersection, segment2[1]]);\n            return indices2[1];\n          }\n        }\n      }\n    } else {\n      // Handle segments where the correct path is to follow a dead-end bridge,\n      // even if there is another bridge that is more aligned with the stroke.\n      for (let i = 0; i < options.length; i++) {\n        const key = Point.key(options[i]);\n\n        if (!extracted_indices[key]) {\n          return options[i];\n        }\n      }\n    }\n\n    return options[0];\n  };\n\n  while (true) {\n    // Add the current path segment to the path.\n    result.push(paths[current[0]][current[1]]);\n    visited[Point.key(current)] = true;\n    current = advance(current); // If there are bridges at the start of the next path segment, follow the\n    // one that makes the largest angle with the current path. The ordering\n    // criterion enforce that we try to cross aligned bridges.\n\n    const key = Point.key(current);\n\n    if (bridge_adjacency.hasOwnProperty(key)) {\n      var endpoint = endpoint_map[key];\n      const options = bridge_adjacency[key].sort((a, b) => angle(endpoint.index, a) - angle(endpoint.index, b)); // HACK(skishore): The call to selectBridge may update the result.\n      // When a stroke is formed by computing a bridge intersection, then the\n      // two bridge fragments are added in selectBridge.\n\n      const result_length = result.length;\n      const next = attempt_one ? options[0] : selectBridge(endpoint, options);\n\n      if (result.length === result_length) {\n        pushLineSegments([endpoint.point, endpoint_map[Point.key(next)].point]);\n      }\n\n      current = next;\n    } // Check if we have either closed the loop or hit an extracted segment.\n\n\n    const new_key = Point.key(current);\n\n    if (Point.equal(current, start)) {\n      if (self_intersecting) {\n        log.push({\n          cls: 'error',\n          message: 'Extracted a self-intersecting stroke.'\n        });\n      }\n\n      let num_segments_on_path = 0;\n\n      for (let index in visited) {\n        extracted_indices[index] = true;\n        num_segments_on_path += 1;\n      } // Single-segment strokes may be due to graphical artifacts in the font.\n      // We drop them to remove these artifacts.\n\n\n      if (num_segments_on_path === 1) {\n        log.push({\n          cls: 'success',\n          message: 'Dropping single-segment stroke.'\n        });\n        return undefined;\n      }\n\n      return result;\n    } else if (extracted_indices[new_key] || visited[new_key]) {\n      return undefined;\n    }\n  }\n};\n\nconst extractStrokes = (paths, endpoints, bridges, log) => {\n  // Build up the necessary hash tables and adjacency lists needed to run the\n  // stroke extraction loop.\n  const endpoint_map = {};\n  const endpoint_position_map = {};\n\n  for (let endpoint of endpoints) {\n    endpoint_map[Point.key(endpoint.index)] = endpoint;\n    endpoint_position_map[Point.key(endpoint.point)] = endpoint;\n  }\n\n  bridges.map(checkBridge);\n  const bridge_adjacency = {};\n\n  for (let bridge of bridges) {\n    const keys = bridge.map(Point.key);\n    assert(endpoint_position_map.hasOwnProperty(keys[0]));\n    assert(endpoint_position_map.hasOwnProperty(keys[1]));\n    const xs = keys.map(x => endpoint_position_map[x].index);\n    addEdgeToAdjacency([Point.key(xs[0]), xs[1]], bridge_adjacency);\n    addEdgeToAdjacency([Point.key(xs[1]), xs[0]], bridge_adjacency);\n  } // Actually extract strokes. Any given path segment index should appear on\n  // exactly one stroke; if it is not on a stroke, we log a warning.\n\n\n  const extracted_indices = {};\n  const strokes = [];\n\n  for (let attempt = 0; attempt < 3; attempt++) {\n    let missed = false;\n\n    for (var i = 0; i < paths.length; i++) {\n      for (var j = 0; j < paths[i].length; j++) {\n        const index = [i, j];\n\n        if (extracted_indices[Point.key(index)]) {\n          continue;\n        }\n\n        const attempt_one = attempt === 0;\n        const stroke = extractStroke(paths, endpoint_map, bridge_adjacency, log, extracted_indices, index, attempt_one);\n\n        if (stroke === undefined) {\n          missed = true;\n          continue;\n        }\n\n        strokes.push(stroke);\n      }\n    }\n\n    if (!missed) {\n      return strokes;\n    }\n  }\n\n  log.push({\n    cls: 'error',\n    message: 'Stroke extraction missed some path segments.'\n  });\n  return strokes;\n}; // Exports go below this fold.\n\n\nconst stroke_extractor = {};\n\nstroke_extractor.getBridges = (path, classifier) => {\n  const paths = svg.convertSVGPathToPaths(path);\n  const endpoints = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    for (let j = 0; j < paths[i].length; j++) {\n      endpoints.push(new Endpoint(paths, [i, j]));\n    }\n  }\n\n  classifier = classifier || stroke_extractor.combinedClassifier;\n  const bridges = getBridges(endpoints, classifier);\n  return {\n    endpoints: endpoints,\n    bridges: bridges\n  };\n};\n\nstroke_extractor.getStrokes = (path, bridges) => {\n  const paths = svg.convertSVGPathToPaths(path);\n  const endpoints = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    for (let j = 0; j < paths[i].length; j++) {\n      endpoints.push(new Endpoint(paths, [i, j]));\n    }\n  }\n\n  const log = [];\n  const stroke_paths = extractStrokes(paths, endpoints, bridges, log);\n  const strokes = stroke_paths.map(x => svg.convertPathsToSVGPath([x]));\n  return {\n    log: log,\n    strokes: strokes\n  };\n};\n\nstroke_extractor.handTunedClassifier = handTunedClassifier;\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"svg.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// lib/svg.js                                                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  svg: () => svg\n});\nlet assert, Point;\nmodule.link(\"/lib/base\", {\n  assert(v) {\n    assert = v;\n  },\n\n  Point(v) {\n    Point = v;\n  }\n\n}, 0);\nconst svg = {}; // A normal-form SVG path string is a data string with the following properties:\n//   - Every command in the path is in ['L', 'M', 'Q', 'Z'].\n//   - Adjacent tokens in the path are separated by exactly one space.\n//   - There is exactly one 'Z', and it is the last command.\n//\n// A segment is a section of a path, represented as an object that has a start,\n// an end, and possibly a control, all of which are valid Points (that is, pairs\n// of Numbers).\n//\n// A path is a list of segments which is non-empty and closed - that is, the end\n// of the last segment on the path is the start of the first.\n// Returns twice the area contained in the polygon. The result is positive iff\n// the polygon winds in the counter-clockwise direction.\n\nconst get2xArea = polygon => {\n  let area = 0;\n\n  for (var i = 0; i < polygon.length; i++) {\n    const p1 = polygon[i];\n    const p2 = polygon[(i + 1) % polygon.length];\n    area += (p2[0] + p1[0]) * (p2[1] - p1[1]);\n  }\n\n  return area;\n}; // Takes a list of paths and orients them so that exterior contours are oriented\n// counter-clockwise and interior contours clockwise.\n\n\nconst orientPaths = (paths, approximation_error) => {\n  const polygons = paths.map(svg.getPolygonApproximation);\n\n  for (var i = 0; i < paths.length; i++) {\n    const path = paths[i];\n    let contains = 0;\n\n    for (let j = 0; j < paths.length; j++) {\n      if (j === i) {\n        continue;\n      } else if (svg.polygonContainsPoint(polygons[j], path[0].start)) {\n        contains += 1;\n      }\n    }\n\n    const area = get2xArea(polygons[i]); // The path is an external path iff it is contained in an even number of\n    // other paths. It is counter-clockwise iff its area is positive. The path\n    // should be reversed if (CCW && internal) || (CW && external).\n\n    const should_reverse = area > 0 !== (contains % 2 === 0);\n\n    if (should_reverse) {\n      for (let segment of path) {\n        [segment.start, segment.end] = [segment.end, segment.start];\n      }\n\n      path.reverse();\n    }\n  }\n\n  return paths;\n}; // Takes a normal-form SVG path string and converts it to a list of paths.\n\n\nconst splitPath = path => {\n  assert(path.length > 0);\n  assert(path[0] === 'M', \"Path did not start with M: \".concat(path));\n  assert(path[path.length - 1] === 'Z', \"Path did not end with Z: \".concat(path));\n  const terms = path.split(' ');\n  const result = [];\n  let start = undefined;\n  let current = undefined;\n\n  for (let i = 0; i < terms.length; i++) {\n    const command = terms[i];\n    assert(command.length > 0, \"Path includes empty command: \".concat(path));\n    assert('LMQZ'.indexOf(command) >= 0, command);\n\n    if (command === 'M' || command === 'Z') {\n      if (current !== undefined) {\n        assert(Point.equal(current, start), \"Path has open contour: \".concat(path));\n        assert(result[result.length - 1].length > 0, \"Path has empty contour: \".concat(path));\n\n        if (command === 'Z') {\n          assert(i === terms.length - 1, \"Path ended early: \".concat(path));\n          return result;\n        }\n      }\n\n      result.push([]);\n      assert(i < terms.length - 2, \"Missing point on path: \".concat(path));\n      start = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n      assert(Point.valid(start));\n      i += 2;\n      current = Point.clone(start);\n      continue;\n    }\n\n    let control = undefined;\n\n    if (command === 'Q') {\n      assert(i < terms.length - 2, \"Missing point on path: \".concat(path));\n      control = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n      assert(Point.valid(control));\n      i += 2;\n    }\n\n    assert(i < terms.length - 2, \"Missing point on path: \".concat(path));\n    const end = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n    assert(Point.valid(end));\n    i += 2;\n\n    if (Point.equal(current, end)) {\n      continue;\n    }\n\n    if (control !== undefined && (Point.equal(control, current) || Point.equal(control, end))) {\n      control = undefined;\n    }\n\n    result[result.length - 1].push({\n      start: Point.clone(current),\n      control: control,\n      end: end\n    });\n    current = Point.clone(end);\n  }\n}; // Takes a TrueType font command list (as provided by opentype.js) and returns\n// a normal-form SVG path string as defined above.\n\n\nsvg.convertCommandsToPath = commands => {\n  const terms = [];\n\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    assert('LMQZ'.indexOf(command.type) >= 0, command.type);\n\n    if (command.type === 'Z') {\n      assert(i === commands.length - 1);\n      break;\n    }\n\n    terms.push(command.type);\n    assert(command.x1 !== undefined === (command.type === 'Q'));\n\n    if (command.x1 !== undefined) {\n      terms.push(command.x1);\n      terms.push(command.y1);\n    }\n\n    assert(command.x !== undefined);\n    terms.push(command.x);\n    terms.push(command.y);\n  }\n\n  terms.push('Z');\n  return terms.join(' ');\n}; // Converts a normal-form SVG path string to a list of paths. The paths obey an\n// orientation constraint: the external paths are oriented counter-clockwise,\n// while the internal paths are oriented clockwise.\n\n\nsvg.convertSVGPathToPaths = path => {\n  return orientPaths(splitPath(path));\n}; // Takes the given list of paths and returns a normal-form SVG path string.\n\n\nsvg.convertPathsToSVGPath = paths => {\n  const terms = [];\n\n  for (let path of paths) {\n    assert(path.length > 0);\n    terms.push('M');\n    terms.push(path[0].start[0]);\n    terms.push(path[0].start[1]);\n\n    for (let segment of path) {\n      if (segment.control === undefined) {\n        terms.push('L');\n      } else {\n        terms.push('Q');\n        terms.push(segment.control[0]);\n        terms.push(segment.control[1]);\n      }\n\n      terms.push(segment.end[0]);\n      terms.push(segment.end[1]);\n    }\n  }\n\n  terms.push('Z');\n  return terms.join(' ');\n}; // Takes a path (a list of segments) and returns a polygon approximation to it.\n// The polygon is given as a list of pairs of points.\n//\n// The approximation error is an upper-bound on the distance between consecutive\n// points in the polygon approximation used to compute the area. The default\n// error of 64 is chosen because the glyphs have a total size of 1024x1024.\n\n\nsvg.getPolygonApproximation = (path, approximation_error) => {\n  const result = [];\n  approximation_error = approximation_error || 64;\n\n  for (let x of path) {\n    const control = x.control || Point.midpoint(x.start, x.end);\n    const distance = Math.sqrt(Point.distance2(x.start, x.end));\n    const num_points = Math.floor(distance / approximation_error);\n\n    for (let i = 0; i < num_points; i++) {\n      const t = (i + 1) / (num_points + 1);\n      const s = 1 - t;\n      result.push([s * s * x.start[0] + 2 * s * t * control[0] + t * t * x.end[0], s * s * x.start[1] + 2 * s * t * control[1] + t * t * x.end[1]]);\n    }\n\n    result.push(x.end);\n  }\n\n  return result;\n}; // Returns true if the given point is contained inside the given polygon.\n\n\nsvg.polygonContainsPoint = (polygon, point) => {\n  const x = point[0];\n  const y = point[1];\n  let crossings = 0;\n\n  for (let i = 0; i < polygon.length; i++) {\n    const segment = {\n      start: polygon[i],\n      end: polygon[(i + 1) % polygon.length]\n    };\n\n    if (segment.start[0] < x && x < segment.end[0] || segment.start[0] > x && x > segment.end[0]) {\n      const t = (x - segment.end[0]) / (segment.start[0] - segment.end[0]);\n      const cy = t * segment.start[1] + (1 - t) * segment.end[1];\n\n      if (y > cy) {\n        crossings += 1;\n      }\n    } else if (segment.start[0] === x && segment.start[1] <= y) {\n      if (segment.end[0] > x) {\n        crossings += 1;\n      }\n\n      const last = polygon[(i + polygon.length - 1) % polygon.length];\n\n      if (last[0] > x) {\n        crossings += 1;\n      }\n    }\n  }\n\n  return crossings % 2 === 1;\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"server\":{\"index.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// server/index.js                                                                                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nlet Glyphs;\nmodule.link(\"/lib/glyphs\", {\n  Glyphs(v) {\n    Glyphs = v;\n  }\n\n}, 0);\nMeteor.publish('index', Glyphs.findGlyphsForRadical);\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"migration.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// server/migration.js                                                                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nlet getAnimationData;\nmodule.link(\"/lib/animation\", {\n  getAnimationData(v) {\n    getAnimationData = v;\n  }\n\n}, 0);\nlet assert, getPWD, Point;\nmodule.link(\"/lib/base\", {\n  assert(v) {\n    assert = v;\n  },\n\n  getPWD(v) {\n    getPWD = v;\n  },\n\n  Point(v) {\n    Point = v;\n  }\n\n}, 1);\nlet cjklib;\nmodule.link(\"/lib/cjklib\", {\n  cjklib(v) {\n    cjklib = v;\n  }\n\n}, 2);\nlet Glyphs;\nmodule.link(\"/lib/glyphs\", {\n  Glyphs(v) {\n    Glyphs = v;\n  }\n\n}, 3);\nlet fixStrokes;\nmodule.link(\"/lib/stroke_caps/fixStrokes\", {\n  fixStrokes(v) {\n    fixStrokes = v;\n  }\n\n}, 4);\nlet stroke_extractor;\nmodule.link(\"/lib/stroke_extractor\", {\n  stroke_extractor(v) {\n    stroke_extractor = v;\n  }\n\n}, 5);\nlet svg;\nmodule.link(\"/lib/svg\", {\n  svg(v) {\n    svg = v;\n  }\n\n}, 6);\n\nconst addFrequencyField = glyph => {\n  const data = cjklib.getCharacterData(glyph.character);\n  glyph.metadata.frequency = data.frequency;\n  Glyphs.save(glyph);\n};\n\nconst addSimplifiedAndTraditionalFields = glyph => {\n  const data = cjklib.getCharacterData(glyph.character);\n  glyph.simplified = data.simplified;\n  glyph.traditional = data.traditional;\n  Glyphs.save(glyph);\n};\n\nconst addStrokeCaps = glyph => {\n  const raw = glyph.stages.strokes;\n  if (raw.raw || raw.corrected) return;\n  glyph.stages.strokes = {\n    corrected: fixStrokes(raw),\n    raw\n  };\n  Glyphs.save(glyph);\n};\n\nconst checkStrokeExtractorStability = glyph => {\n  const strokes = stroke_extractor.getStrokes(glyph.stages.path, glyph.stages.bridges);\n\n  if (!_.isEqual(strokes.strokes.sort(), glyph.stages.strokes.sort())) {\n    console.log(\"Different strokes for \".concat(glyph.character));\n  }\n};\n\nconst convertOldPathSchemaToSVGPath = path => {\n  const terms = [];\n\n  for (let segment of path) {\n    assert('LMQZ'.indexOf(segment.type) >= 0, segment.type);\n    terms.push(segment.type);\n\n    if (segment.x1 !== undefined) {\n      terms.push(segment.x1);\n      terms.push(segment.y1);\n    }\n\n    if (segment.x !== undefined) {\n      terms.push(segment.x);\n      terms.push(segment.y);\n    }\n  }\n\n  return terms.join(' ');\n};\n\nconst dumpGlyph = (dictionary, graphics) => glyph => {\n  if (!glyph.stages.verified) {\n    return;\n  }\n\n  const analysis = glyph.stages.analysis;\n  const order = glyph.stages.order;\n  const data = cjklib.getCharacterData(glyph.character);\n  const pinyin = (glyph.metadata.pinyin || data.pinyin || '').split(',').map(x => x.trim()).filter(x => x);\n  const strokes = order.map(x => glyph.stages.strokes.corrected[x.stroke]);\n  const medians = order.map(x => x.median);\n  strokes.map(x => assert(x));\n  medians.map(x => assert(x));\n  const has_etymology = analysis.etymology.hint || analysis.etymology.type === 'pictophonetic';\n  dictionary.write(JSON.stringify({\n    character: glyph.character,\n    definition: glyph.metadata.definition || data.definition,\n    pinyin: pinyin,\n    decomposition: analysis.decomposition || '？',\n    etymology: has_etymology ? analysis.etymology : undefined,\n    radical: analysis.radical,\n    matches: order.map(x => x.match)\n  }) + '\\n');\n  graphics.write(JSON.stringify({\n    character: glyph.character,\n    strokes: strokes,\n    medians: medians\n  }) + '\\n');\n};\n\nconst fixBrokenMedians = (glyph, threshold) => {\n  threshold = threshold || 16;\n\n  for (let stroke of glyph.stages.order) {\n    const distance = Math.sqrt(Point.distance2(stroke.median[0], stroke.median[stroke.median.length - 1]));\n\n    if (distance < threshold) {\n      console.log(\"Found broken median in \".concat(glyph.character));\n      const paths = svg.convertSVGPathToPaths(glyph.stages.strokes[stroke.stroke]);\n      assert(paths.length === 1);\n      const polygon = svg.getPolygonApproximation(paths[0], threshold);\n      let best_point = null;\n      let best_value = -Infinity;\n\n      for (let point of polygon) {\n        const value = Point.distance2(point, stroke.median[0]);\n\n        if (value > best_value) {\n          best_point = point;\n          best_value = value;\n        }\n      }\n\n      assert(best_point !== null);\n      stroke.median = [best_point, stroke.median[0]];\n      Glyphs.save(glyph);\n    }\n  }\n};\n\nconst migrateOldGlyphSchemaToNew = glyph => {\n  const codepoint = parseInt(glyph.name.substr(3), 16);\n  const character = String.fromCodePoint(codepoint);\n  const data = cjklib.getCharacterData(character);\n  assert(glyph.manual && glyph.manual.verified !== undefined, \"Glyph \".concat(character, \" was not verified.\")); // Pull definition and pinyin from simplified character, if available.\n\n  let definition = undefined;\n  let pinyin = undefined;\n\n  if (data.simplified) {\n    const simplified = Glyphs.get(data.simplified);\n    const metadata = (simplified || {\n      metadata: {}\n    }).metadata;\n    const base = cjklib.getCharacterData(data.simplified);\n    definition = metadata.definition || base.definition;\n    pinyin = metadata.pinyin || base.pinyin;\n  }\n\n  const result = {\n    character: character,\n    codepoint: codepoint,\n    metadata: {\n      definition: definition,\n      frequency: data.frequency,\n      kangxi_index: data.kangxi_index,\n      pinyin: pinyin,\n      strokes: undefined\n    },\n    stages: {\n      path: convertOldPathSchemaToSVGPath(glyph.path),\n      bridges: glyph.manual.bridges,\n      strokes: glyph.derived.strokes,\n      analysis: undefined,\n      order: undefined,\n      verified: undefined\n    },\n    simplified: data.simplified,\n    traditional: data.traditional\n  };\n  assert(result.stages.path !== undefined);\n  assert(result.stages.bridges !== undefined);\n  assert(result.stages.strokes !== undefined);\n  return result;\n}; // Meteor methods that make use of the migration system follow.\n\n\nconst dumpToNewSchemaJSON = () => {\n  const fs = Npm.require('fs');\n\n  const path = Npm.require('path');\n\n  const pwd = getPWD();\n  const dictionary = fs.createWriteStream(path.join(pwd, 'dictionary.txt'));\n  const graphics = fs.createWriteStream(path.join(pwd, 'graphics.txt'));\n  runMigration(dumpGlyph(dictionary, graphics), () => {\n    dictionary.end();\n    graphics.end();\n  });\n};\n\nconst exportSVGs = () => {\n  const fs = Npm.require('fs');\n\n  const path = Npm.require('path');\n\n  const pwd = getPWD();\n  const directory = path.join(pwd, '.svgs');\n  fs.mkdirSync(directory);\n  runMigration(glyph => {\n    const codepoint = glyph.character.codePointAt(0);\n    const medians = glyph.stages.order.map(x => x.median);\n    const strokes = glyph.stages.order.map(x => glyph.stages.strokes.corrected[x.stroke]);\n    const raw = SSR.render('animation', getAnimationData(strokes, medians));\n    const svg = raw.replace(/\\n  /g, '\\n').split('\\n').slice(1, -2).join('\\n');\n    fs.writeFileSync(path.join(directory, \"\".concat(codepoint, \".svg\")), svg);\n  }, () => {});\n};\n\nconst loadFromOldSchemaJSON = filename => {\n  const fs = Npm.require('fs');\n\n  const path = Npm.require('path');\n\n  const filepath = path.join(getPWD(), 'public', filename);\n  fs.readFile(filepath, 'utf8', Meteor.bindEnvironment((error, data) => {\n    if (error) throw error;\n    const lines = data.split('\\n').filter(x => x.length > 0);\n    console.log(\"Loaded \".concat(lines.length, \" old-schema glyphs.\"));\n    let migrated = 0;\n    let definition = 0;\n    let pinyin = 0;\n\n    for (var line of lines) {\n      try {\n        const old_glyph = JSON.parse(line);\n        const new_glyph = migrateOldGlyphSchemaToNew(old_glyph);\n        const glyph = Glyphs.get(new_glyph.character);\n\n        if (glyph && glyph.stages.verified) {\n          console.log(\"Glyph already verified: \".concat(glyph.character));\n          continue;\n        }\n\n        Glyphs.save(new_glyph);\n        migrated += 1;\n        definition += new_glyph.metadata.definition ? 1 : 0;\n        pinyin += new_glyph.metadata.pinyin ? 1 : 0;\n      } catch (error) {\n        console.error(error);\n      }\n    }\n\n    console.log(\"Successfully migrated \".concat(migrated, \" glyphs.\"));\n    console.log(\"Pulled definitions for \".concat(definition, \" glyphs.\"));\n    console.log(\"Pulled pinyin for \".concat(pinyin, \" glyphs.\"));\n  }));\n}; // Runs the given per-glyph callback for each glyph in the database.\n// When all the glyphs are migrated, runs the completion callback.\n\n\nconst runMigration = (per_glyph_callback, completion_callback) => {\n  console.log('Running migration...');\n\n  if (per_glyph_callback) {\n    const codepoints = Glyphs.find({}, {\n      fields: {\n        codepoint: 1\n      },\n      sort: {\n        codepoint: 1\n      }\n    }).fetch();\n\n    for (let i = 0; i < codepoints.length; i++) {\n      const glyph = Glyphs.findOne({\n        codepoint: codepoints[i].codepoint\n      });\n      assert(glyph, 'Glyphs changed during migration!');\n      per_glyph_callback(glyph);\n\n      if ((i + 1) % 1000 === 0) {\n        console.log(\"Migrated \".concat(i + 1, \" glyphs.\"));\n      }\n    }\n  }\n\n  if (completion_callback) {\n    completion_callback();\n  }\n\n  console.log('Migration complete.');\n};\n\nMeteor.methods({\n  'export': () => {\n    cjklib.promise.then(Meteor.bindEnvironment(dumpToNewSchemaJSON)).catch(console.error.bind(console));\n  },\n  'exportSVGs': exportSVGs,\n  'loadFromOldSchemaJSON': filename => {\n    cjklib.promise.then(Meteor.bindEnvironment(() => loadFromOldSchemaJSON(filename))).catch(console.error.bind(console));\n  }\n});\nMeteor.startup(() => {\n  SSR.compileTemplate('animation', Assets.getText('animation.html'));\n  const completion_callback = undefined;\n  const per_glyph_callback = undefined;\n\n  if (!per_glyph_callback && !completion_callback) {\n    return;\n  }\n\n  console.log('Preparing for migration...');\n\n  const migration = () => runMigration(per_glyph_callback, completion_callback);\n\n  cjklib.promise.then(Meteor.bindEnvironment(migration)).catch(console.error.bind(console));\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"persistence.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// server/persistence.js                                                                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nlet getPWD;\nmodule.link(\"/lib/base\", {\n  getPWD(v) {\n    getPWD = v;\n  }\n\n}, 0);\nlet Progress;\nmodule.link(\"/lib/glyphs\", {\n  Progress(v) {\n    Progress = v;\n  }\n\n}, 1);\n\nconst child_process = Npm.require('child_process');\n\nconst path = Npm.require('path');\n\nconst getBackupPath = () => {\n  return path.join(getPWD(), 'server', 'backup');\n};\n\nMeteor.methods({\n  backup() {\n    const path = getBackupPath();\n    child_process.spawn('mongodump', ['--port', '3001', '--out', path]);\n    Progress.update({}, {\n      $set: {\n        backup: true\n      }\n    });\n  },\n\n  restore() {\n    const path = getBackupPath();\n    console.log(path);\n    child_process.spawn('mongorestore', ['--port', '3001', '--drop', path]);\n  }\n\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"training.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// server/training.js                                                                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nlet assert;\nmodule.link(\"/lib/base\", {\n  assert(v) {\n    assert = v;\n  }\n\n}, 0);\nlet Glyphs;\nmodule.link(\"/lib/glyphs\", {\n  Glyphs(v) {\n    Glyphs = v;\n  }\n\n}, 1);\n\nfunction evaluate(glyphs, classifier) {\n  var num_correct = 0;\n\n  for (var i = 0; i < glyphs.length; i++) {\n    if (check_classifier_on_glyph(glyphs[i], classifier)) {\n      num_correct += 1;\n    }\n  }\n\n  return num_correct / glyphs.length;\n}\n\nfunction train_neural_net() {\n  var glyphs = Glyphs.find({\n    'manual.verified': true\n  }).fetch();\n\n  var sample = _.sample(glyphs, 400);\n\n  console.log('Hand-tuned accuracy:', evaluate(sample, hand_tuned_classifier));\n  var training_data = [];\n\n  for (var i = 0; i < glyphs.length; i++) {\n    var glyph_data = get_glyph_training_data(glyphs[i]);\n    var positive_data = glyph_data.filter(function (x) {\n      return x[1] > 0;\n    });\n    var negative_data = glyph_data.filter(function (x) {\n      return x[1] === 0;\n    });\n\n    if (positive_data.length > negative_data.length) {\n      positive_data = _.sample(positive_data, negative_data.length);\n    } else {\n      negative_data = _.sample(negative_data, positive_data.length);\n    }\n\n    glyph_data = negative_data.concat(positive_data);\n\n    for (var j = 0; j < glyph_data.length; j++) {\n      training_data.push(glyph_data[j]);\n    }\n  }\n\n  console.log('Got ' + training_data.length + ' rows of training data.');\n  var net = new convnetjs.Net();\n  net.makeLayers([{\n    type: 'input',\n    out_sx: 1,\n    out_sy: 1,\n    out_depth: 8\n  }, {\n    type: 'fc',\n    num_neurons: 8,\n    activation: 'tanh'\n  }, {\n    type: 'fc',\n    num_neurons: 8,\n    activation: 'tanh'\n  }, {\n    type: 'softmax',\n    num_classes: 2\n  }]);\n  var trainer = new convnetjs.Trainer(net, {\n    method: 'adadelta',\n    l2_decay: 0.001,\n    batch_size: 10\n  });\n  var input = new convnetjs.Vol(1, 1, 8);\n\n  for (var iteration = 0; iteration < 10; iteration++) {\n    var loss = 0;\n\n    var round_data = _.sample(training_data, 4000);\n\n    for (var i = 0; i < round_data.length; i++) {\n      assert(input.w.length === round_data[i][0].length);\n      input.w = round_data[i][0];\n      var stats = trainer.train(input, round_data[i][1]);\n      assert(!isNaN(stats.loss));\n      loss += stats.loss;\n    }\n\n    console.log('Iteration', iteration, 'mean loss:', loss / round_data.length);\n  }\n\n  console.log('Trained neural network:', JSON.stringify(net.toJSON()));\n\n  function net_classifier(features) {\n    assert(input.w.length === features.length);\n    input.w = features;\n    var softmax = net.forward(input).w;\n    assert(softmax.length === 2);\n    return softmax[1] - softmax[0];\n  }\n\n  console.log('Neural-net accuracy:', evaluate(sample, net_classifier));\n\n  function combined_classifier(weight) {\n    return function (features) {\n      return hand_tuned_classifier(features) + weight * net_classifier(features);\n    };\n  }\n\n  var weights = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1];\n\n  for (var i = 0; i < weights.length; i++) {\n    console.log('Weight', weights[i], 'combined accuracy:', evaluate(sample, combined_classifier(weights[i])));\n  }\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nrequire(\"/lib/external/convnet/1.1.0/convnet.js\");\nrequire(\"/lib/external/simplify/1.2.2/simplify.js\");\nrequire(\"/lib/external/voronoi/0.98/rhill-voronoi-core.js\");\nrequire(\"/lib/stroke_caps/fixStrokes.js\");\nrequire(\"/lib/stroke_caps/utils.js\");\nrequire(\"/lib/animation.js\");\nrequire(\"/lib/base.js\");\nrequire(\"/lib/cjklib.js\");\nrequire(\"/lib/classifier.js\");\nrequire(\"/lib/decomposition_util.js\");\nrequire(\"/lib/glyphs.js\");\nrequire(\"/lib/hungarian.js\");\nrequire(\"/lib/median_util.js\");\nrequire(\"/lib/net.js\");\nrequire(\"/lib/pinyin_util.js\");\nrequire(\"/lib/stroke_extractor.js\");\nrequire(\"/lib/svg.js\");\nrequire(\"/server/index.js\");\nrequire(\"/server/migration.js\");\nrequire(\"/server/persistence.js\");\nrequire(\"/server/training.js\");","hash":"56ae35711d69930cce05f4e38871835c0c56b69e","servePath":"/app.js","sourceMap":{"version":3,"sources":["lib/external/convnet/1.1.0/convnet.js","lib/external/simplify/1.2.2/simplify.js","lib/external/voronoi/0.98/rhill-voronoi-core.js","lib/stroke_caps/fixStrokes.js","lib/stroke_caps/utils.js","lib/animation.js","lib/base.js","lib/cjklib.js","lib/classifier.js","lib/decomposition_util.js","lib/glyphs.js","lib/hungarian.js","lib/median_util.js","lib/net.js","lib/pinyin_util.js","lib/stroke_extractor.js","lib/svg.js","server/index.js","server/migration.js","server/persistence.js","server/training.js"],"names":["convnetjs","REVISION","global","return_v","v_val","gaussRandom","u","Math","random","v","r","c","sqrt","log","randf","a","b","randi","floor","randn","mu","std","zeros","n","isNaN","ArrayBuffer","arr","Array","i","Float64Array","arrContains","elt","length","arrUnique","push","maxmin","w","maxv","minv","maxi","mini","dv","randperm","j","temp","array","q","weightedSample","lst","probs","p","cumprob","k","getopt","opt","field_name","default_value","Vol","sx","sy","depth","Object","prototype","toString","call","dw","scale","get","x","y","d","ix","set","add","get_grad","set_grad","add_grad","cloneAndZero","clone","V","addFrom","addFromScaled","setConst","toJSON","json","fromJSON","augment","crop","dx","dy","fliplr","W","W2","img_to_vol","img","convert_grayscale","canvas","document","createElement","width","height","ctx","getContext","drawImage","e","name","img_data","getImageData","data","H","pv","x1","ConvLayer","out_depth","filters","in_depth","in_sx","in_sy","stride","pad","l1_decay_mul","l2_decay_mul","out_sx","out_sy","layer_type","bias","bias_pref","biases","forward","is_training","in_act","A","V_sx","V_sy","xy_stride","f","ay","ax","fy","oy","fx","ox","fd","out_act","backward","chain_grad","ix1","ix2","getParamsAndGrads","response","params","grads","FullyConnLayer","num_neurons","num_inputs","Vw","wi","tfi","PoolLayer","switchx","switchy","winx","winy","InputLayer","SoftmaxLayer","as","amax","es","esum","exp","indicator","mul","RegressionLayer","loss","dim","yi","val","SVMLayer","yscore","margin","ReluLayer","V2","N","V2w","SigmoidLayer","v2wi","MaxoutLayer","group_size","switches","ai","a2","tanh","TanhLayer","DropoutLayer","drop_prob","dropped","LocalResponseNormalizationLayer","alpha","beta","console","S_cache_","n2","den","max","min","aa","pow","S","SB","SB2","aj","g","Net","options","layers","makeLayers","defs","type","desugar","new_defs","def","num_classes","activation","tensor","gs","prev","QuadTransformLayer","act","getCostLoss","layer_reponse","getPrediction","Lj","t","L","Trainer","net","learning_rate","l1_decay","l2_decay","batch_size","method","momentum","ro","eps","gsum","xsum","train","start","Date","getTime","end","fwd_time","cost_loss","l2_decay_loss","l1_decay_loss","bwd_time","pglist","pg","plen","abs","l1grad","l2grad","gij","gsumi","xsumi","softmax_loss","SGDTrainer","MagicNet","labels","train_ratio","num_folds","num_candidates","num_epochs","ensemble_size","batch_size_min","batch_size_max","l2_decay_min","l2_decay_max","learning_rate_min","learning_rate_max","momentum_min","momentum_max","neurons_min","neurons_max","folds","candidates","evaluated_candidates","unique_labels","iter","foldix","finish_fold_callback","finish_batch_callback","sampleFolds","sampleCandidates","num_train","train_ix","slice","test_ix","sampleCandidate","input_depth","layer_defs","nl","ni","dp","bs","l2","lr","mom","tp","trainer_def","trainer","cand","acc","accv","step","fold","dataix","l","lastiter","val_acc","evalValErrors","sort","vals","yhat","predict_soft","nv","xout","predict","stats","predicted_label","nets","dummy_candidate","onFinishFold","onFinishBatch","simplify","getSqDist","p1","p2","getSqSegDist","simplifyRadialDist","points","sqTolerance","prevPoint","newPoints","point","len","simplifyDPStep","first","last","simplified","maxSqDist","index","sqDist","simplifyDouglasPeucker","tolerance","highestQuality","undefined","define","amd","module","exports","Voronoi","vertices","edges","cells","toRecycle","beachsectionJunkyard","circleEventJunkyard","vertexJunkyard","edgeJunkyard","cellJunkyard","reset","beachline","RBTree","root","beachsection","getFirst","rbNext","circleEvents","firstCircleEvent","ε","invε","equalWithEpsilon","greaterThanWithEpsilon","greaterThanOrEqualWithEpsilon","lessThanWithEpsilon","lessThanOrEqualWithEpsilon","rbInsertSuccessor","node","successor","parent","rbPrevious","rbRight","rbLeft","rbParent","rbRed","grandpa","uncle","rbRotateLeft","rbRotateRight","rbRemoveNode","left","right","next","isRed","sibling","getLast","Diagram","site","Cell","halfedges","closeMe","init","createCell","cell","pop","prepareHalfedges","iHalfedge","edge","vb","va","splice","angle","getNeighborIds","neighbors","lSite","voronoiId","rSite","getBbox","xmin","Infinity","ymin","xmax","ymax","vx","vy","getStartpoint","pointIntersection","halfedge","p0","getEndpoint","Vertex","Edge","Halfedge","atan2","createHalfedge","createVertex","createEdge","setEdgeStartpoint","setEdgeEndpoint","createBorderEdge","vertex","Beachsection","createBeachsection","leftBreakPoint","arc","directrix","rfocx","rfocy","pby2","lArc","lfocx","lfocy","plby2","hl","aby2","rightBreakPoint","rArc","detachBeachsection","detachCircleEvent","removeBeachsection","circle","circleEvent","ycenter","previous","disappearingTransitions","abs_fn","unshift","nArcs","iArc","attachCircleEvent","addBeachsection","dxl","dxr","newArc","bx","by","cx","cy","hb","hc","CircleEvent","cSite","ha","predecessor","connectEdge","bbox","xl","xr","yt","yb","lx","ly","rx","ry","fm","fb","clipEdge","t0","t1","clipEdges","iEdge","closeCells","iCell","iLeft","nHalfedges","vz","lastBorderSegment","quantizeSites","sites","recycle","diagram","compute","startTime","concat","siteEvents","siteid","xsitex","xsitey","stopTime","execTime","distToPath","getCosSimAroundPoint","getLinesIntersectPoint","getOutlinePoints","extendPointOnLine","estimateTanPoints","roundPathPoints","ptEq","dist","require","CLIP_THRESH","LOWER_COS_SIM_THRESH","UPPER_COS_SIM_THRESH","Bridge","constructor","pointString","stroke","estTanPoints","outline","getClips","cosSim0","cosSim1","character","strokes","filter","dist0","dist1","map","clippingStroke","Clip","bridge","clippedBy","isDouble","canMerge","otherClip","mergeIntoDouble","middlePoint","replace","getNewStrokeTip","maxControlPoint","maxDistControl0","maxDistControl1","distControl0","distControl1","midDist0","midDist1","controlPoint0","controlPoint1","pString","round","Stroke","pathString","strokeNum","getBridges","pointStringParts","match","pointStringPart","fullPointStringRegex","RegExp","parts","split","num","parseFloat","fixPathString","bridges","clips","forEach","clip","lastClip","modifiedPathString","newTip","isModified","isDoubleClipped","find","Character","pathStrings","path","fixStrokesWithDetails","strokePathStrings","fixedStrokesInfo","modified","summary","hasDoubleClippedStroke","modifiedStrokes","fixStrokesOnce","corrected","fixStrokes","svgPathUtils","norm","vect","subtract","count","delta","svgPoint","at","l1p1","l1p2","l2p1","l2p2","x2","x3","x4","y1","y2","y3","y4","xNumerator","yNumerator","denominator","getPointIndex","pathOutline","dists","outlinePoint","indexOf","getIndexAtDelta","pointIndex","preIndex","postIndex","vect1","vect2","distance","mag","floats","fixedPathString","float","clipPoints","cpIndex0","cpIndex1","export","getAnimationData","kIdPrefix","kWidth","distance2","point1","point2","diff","getMedianLength","median","result","getMedianPath","join","medians","delay","speed","lengths","paths","animations","total_duration","offset","duration","fraction","animation_id","clip_id","keyframes","spacing","module1","assert","getPWD","maybeRequire","Angle","Point","condition","message","error","Error","isNumber","Number","isFinite","Meteor","isServer","Npm","npmRequire","process","env","PWD","cwd","unique","seen","String","applyMapping","mapping","angle1","angle2","PI","penalty","dot","equal","key","midpoint","valid","cjklib","link","fs","CHARACTER_FIELDS","characters","gb2312","promise","radicals","primary_radical","index_to_radical_map","radical_to_index_map","radical_to_character_map","getCharacterData","field","traditional","getCJKLibRows","lines","line","entry","getFrequencyRows","getUnihanRows","parseUnicodeStr","str","fromCodePoint","parseInt","substr","readFile","filename","Promise","resolve","reject","filepath","$","code","fillDecompositions","decompositions","glyphs","all","then","rows","row","fillDefinitions","readings","fillFrequencies","fillKangxiIndex","getIndex","adotb","fillPinyin","fillStrokeCounts","dictionary_like_data","fillRadicalData","locale","hasOwnProperty","fillRadicalToCharacterMap","radical_equivalent_characters","fillVariants","variants","source","target","swap","_","fillGB2312","from","codepoint","codePointAt","keys","parseLocaleGlyphMap","cleanupCJKLibData","convert_astral_characters","radical_to_character","decomposition","primary","radical","startup","bind","radical_isolated_characters","frequencies","radical_stroke_counts","definition","frequency","kangxi_index","pinyin","catch","NEURAL_NET_TRAINED_FOR_STROKE_EXTRACTION","stroke_extractor","input","weight","trainedClassifier","features","softmax","combinedClassifier","handTunedClassifier","decomposition_util","ids_data","label","arity","ideograph_description_characters","UNKNOWN_COMPONENT","augmentTreeWithPathData","tree","children","parseSubtree","current","value","serializeSubtree","subtree","collectComponents","child","convertDecompositionToTree","convertTreeToDecomposition","getSubtree","Glyphs","Progress","defaultGlyph","metadata","stages","glyph","base","verified","Mongo","Collection","clearDependencies","stack","visited","dependencies","$regex","$ne","fetch","update","$in","$set","multi","findOne","getAll","getNext","clause","extend","$gt","getNextUnverified","getNextVerified","getPrevious","$lt","getPreviousUnverified","getPreviousVerified","loadAll","upsert","refresh","save","check","syncDefinitionAndPinyin","sentinel","remove","targets","total","complete","backup","_ensureIndex","methods","method_names","loadAllGlyphs","saveGlyphs","publish","Hungarian","fn","me","apply","arguments","cost_matrix","last_matched","ref","ref1","results","get_final_score","update_labels","find_root_and_slacks","cost","find_greedy_solution","reduce_cost_matrix","range","matched","x_label","len1","ref2","results1","y_label","x_match","y_match","len2","len3","max_cost","ref3","cur_x","cur_y","delta_x","delta_y","new_slack","next_y","slack","slack_x","x_in_tree","y_parent","original_matrix","Util","sum","median_util","default","svg","size","rise","num_to_match","voronoi","filterMedian","distances","position","total_so_far","findLongestShortestPath","adjacency","findPathFromFurthestNode","neighbor","candidate","findStrokeMedian","convertSVGPathToPaths","polygon","approximation","getPolygonApproximation","bounding_box","include","polygonContainsPoint","simple","normalizeForMatch","pinyin_util","vowel_to_tone","tokenSet","tokens","consonants","vowels","two_syllables","dropTones","append_number","option","toneless","numberedPinyinToTonePinyin","numbered","toLowerCase","tone","consonant","vowel","tonePinyinToNumberedPinyin","MAX_BRIDGE_DISTANCE","MIN_CORNER_ANGLE","MIN_CORNER_TANGENT_DISTANCE","REVERSAL_PENALTY","checkBridge","endpoints","classifier","corners","corner","matching","matchCorners","getFeatures","ins","out","trivial","angles","angle_penalty","distance_penalty","matrix","scoreCorners","reversed_score","Endpoint","indices","segments","tangents","threshold","control","addEdgeToAdjacency","extractStroke","endpoint_map","bridge_adjacency","extracted_indices","attempt_one","line_segments","self_intersecting","advance","index1","index2","endpoint","getIntersection","segment1","segment2","diff1","diff2","cross","s","indexToPoint","pushLineSegments","old_lines","selectBridge","indices1","indices2","intersection","reverse","result_length","new_key","cls","num_segments_on_path","extractStrokes","endpoint_position_map","xs","attempt","missed","getStrokes","stroke_paths","convertPathsToSVGPath","get2xArea","area","orientPaths","approximation_error","polygons","contains","should_reverse","segment","splitPath","terms","command","convertCommandsToPath","commands","num_points","crossings","findGlyphsForRadical","addFrequencyField","addSimplifiedAndTraditionalFields","addStrokeCaps","raw","checkStrokeExtractorStability","isEqual","convertOldPathSchemaToSVGPath","dumpGlyph","dictionary","graphics","analysis","order","trim","has_etymology","etymology","hint","write","JSON","stringify","matches","fixBrokenMedians","best_point","best_value","migrateOldGlyphSchemaToNew","manual","derived","dumpToNewSchemaJSON","pwd","createWriteStream","runMigration","exportSVGs","directory","mkdirSync","SSR","render","writeFileSync","loadFromOldSchemaJSON","bindEnvironment","migrated","old_glyph","parse","new_glyph","per_glyph_callback","completion_callback","codepoints","fields","compileTemplate","Assets","getText","migration","child_process","getBackupPath","spawn","restore","evaluate","num_correct","check_classifier_on_glyph","train_neural_net","sample","hand_tuned_classifier","training_data","glyph_data","get_glyph_training_data","positive_data","negative_data","iteration","round_data","net_classifier","combined_classifier","weights"],"mappings":";;;;;;;;AAAA,IAAIA,SAAS,GAAGA,SAAS,IAAI;AAAEC,UAAQ,EAAE;AAAZ,CAA7B;;AACA,CAAC,UAASC,MAAT,EAAiB;AAChB,eADgB,CAGhB;;AACA,MAAIC,QAAQ,GAAG,KAAf;AACA,MAAIC,KAAK,GAAG,GAAZ;;AACA,MAAIC,WAAW,GAAG,YAAW;AAC3B,QAAGF,QAAH,EAAa;AACXA,cAAQ,GAAG,KAAX;AACA,aAAOC,KAAP;AACD;;AACD,QAAIE,CAAC,GAAG,IAAEC,IAAI,CAACC,MAAL,EAAF,GAAgB,CAAxB;AACA,QAAIC,CAAC,GAAG,IAAEF,IAAI,CAACC,MAAL,EAAF,GAAgB,CAAxB;AACA,QAAIE,CAAC,GAAGJ,CAAC,GAACA,CAAF,GAAMG,CAAC,GAACA,CAAhB;AACA,QAAGC,CAAC,IAAI,CAAL,IAAUA,CAAC,GAAG,CAAjB,EAAoB,OAAOL,WAAW,EAAlB;AACpB,QAAIM,CAAC,GAAGJ,IAAI,CAACK,IAAL,CAAU,CAAC,CAAD,GAAGL,IAAI,CAACM,GAAL,CAASH,CAAT,CAAH,GAAeA,CAAzB,CAAR;AACAN,SAAK,GAAGK,CAAC,GAACE,CAAV,CAV2B,CAUd;;AACbR,YAAQ,GAAG,IAAX;AACA,WAAOG,CAAC,GAACK,CAAT;AACD,GAbD;;AAcA,MAAIG,KAAK,GAAG,UAASC,CAAT,EAAYC,CAAZ,EAAe;AAAE,WAAOT,IAAI,CAACC,MAAL,MAAeQ,CAAC,GAACD,CAAjB,IAAoBA,CAA3B;AAA+B,GAA5D;;AACA,MAAIE,KAAK,GAAG,UAASF,CAAT,EAAYC,CAAZ,EAAe;AAAE,WAAOT,IAAI,CAACW,KAAL,CAAWX,IAAI,CAACC,MAAL,MAAeQ,CAAC,GAACD,CAAjB,IAAoBA,CAA/B,CAAP;AAA2C,GAAxE;;AACA,MAAII,KAAK,GAAG,UAASC,EAAT,EAAaC,GAAb,EAAiB;AAAE,WAAOD,EAAE,GAACf,WAAW,KAAGgB,GAAxB;AAA8B,GAA7D,CAtBgB,CAwBhB;;;AACA,MAAIC,KAAK,GAAG,UAASC,CAAT,EAAY;AACtB,QAAG,OAAOA,CAAP,KAAY,WAAZ,IAA2BC,KAAK,CAACD,CAAD,CAAnC,EAAwC;AAAE,aAAO,EAAP;AAAY;;AACtD,QAAG,OAAOE,WAAP,KAAuB,WAA1B,EAAuC;AACrC;AACA,UAAIC,GAAG,GAAG,IAAIC,KAAJ,CAAUJ,CAAV,CAAV;;AACA,WAAI,IAAIK,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACL,CAAd,EAAgBK,CAAC,EAAjB,EAAqB;AAAEF,WAAG,CAACE,CAAD,CAAH,GAAQ,CAAR;AAAY;;AACnC,aAAOF,GAAP;AACD,KALD,MAKO;AACL,aAAO,IAAIG,YAAJ,CAAiBN,CAAjB,CAAP;AACD;AACF,GAVD;;AAYA,MAAIO,WAAW,GAAG,UAASJ,GAAT,EAAcK,GAAd,EAAmB;AACnC,SAAI,IAAIH,CAAC,GAAC,CAAN,EAAQL,CAAC,GAACG,GAAG,CAACM,MAAlB,EAAyBJ,CAAC,GAACL,CAA3B,EAA6BK,CAAC,EAA9B,EAAkC;AAChC,UAAGF,GAAG,CAACE,CAAD,CAAH,KAASG,GAAZ,EAAiB,OAAO,IAAP;AAClB;;AACD,WAAO,KAAP;AACD,GALD;;AAOA,MAAIE,SAAS,GAAG,UAASP,GAAT,EAAc;AAC5B,QAAIV,CAAC,GAAG,EAAR;;AACA,SAAI,IAAIY,CAAC,GAAC,CAAN,EAAQL,CAAC,GAACG,GAAG,CAACM,MAAlB,EAAyBJ,CAAC,GAACL,CAA3B,EAA6BK,CAAC,EAA9B,EAAkC;AAChC,UAAG,CAACE,WAAW,CAACd,CAAD,EAAIU,GAAG,CAACE,CAAD,CAAP,CAAf,EAA4B;AAC1BZ,SAAC,CAACkB,IAAF,CAAOR,GAAG,CAACE,CAAD,CAAV;AACD;AACF;;AACD,WAAOZ,CAAP;AACD,GARD,CA5CgB,CAsDhB;;;AACA,MAAImB,MAAM,GAAG,UAASC,CAAT,EAAY;AACvB,QAAGA,CAAC,CAACJ,MAAF,KAAa,CAAhB,EAAmB;AAAE,aAAO,EAAP;AAAY,KADV,CACW;;;AAClC,QAAIK,IAAI,GAAGD,CAAC,CAAC,CAAD,CAAZ;AACA,QAAIE,IAAI,GAAGF,CAAC,CAAC,CAAD,CAAZ;AACA,QAAIG,IAAI,GAAG,CAAX;AACA,QAAIC,IAAI,GAAG,CAAX;AACA,QAAIjB,CAAC,GAAGa,CAAC,CAACJ,MAAV;;AACA,SAAI,IAAIJ,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACL,CAAd,EAAgBK,CAAC,EAAjB,EAAqB;AACnB,UAAGQ,CAAC,CAACR,CAAD,CAAD,GAAOS,IAAV,EAAgB;AAAEA,YAAI,GAAGD,CAAC,CAACR,CAAD,CAAR;AAAaW,YAAI,GAAGX,CAAP;AAAW;;AAC1C,UAAGQ,CAAC,CAACR,CAAD,CAAD,GAAOU,IAAV,EAAgB;AAAEA,YAAI,GAAGF,CAAC,CAACR,CAAD,CAAR;AAAaY,YAAI,GAAGZ,CAAP;AAAW;AAC3C;;AACD,WAAO;AAACW,UAAI,EAAEA,IAAP;AAAaF,UAAI,EAAEA,IAAnB;AAAyBG,UAAI,EAAEA,IAA/B;AAAqCF,UAAI,EAAEA,IAA3C;AAAiDG,QAAE,EAACJ,IAAI,GAACC;AAAzD,KAAP;AACD,GAZD,CAvDgB,CAqEhB;;;AACA,MAAII,QAAQ,GAAG,UAASnB,CAAT,EAAY;AACzB,QAAIK,CAAC,GAAGL,CAAR;AAAA,QACIoB,CAAC,GAAG,CADR;AAAA,QAEIC,IAFJ;AAGA,QAAIC,KAAK,GAAG,EAAZ;;AACA,SAAI,IAAIC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACvB,CAAd,EAAgBuB,CAAC,EAAjB,EAAoBD,KAAK,CAACC,CAAD,CAAL,GAASA,CAAT;;AACpB,WAAOlB,CAAC,EAAR,EAAY;AACRe,OAAC,GAAGpC,IAAI,CAACW,KAAL,CAAWX,IAAI,CAACC,MAAL,MAAiBoB,CAAC,GAAC,CAAnB,CAAX,CAAJ;AACAgB,UAAI,GAAGC,KAAK,CAACjB,CAAD,CAAZ;AACAiB,WAAK,CAACjB,CAAD,CAAL,GAAWiB,KAAK,CAACF,CAAD,CAAhB;AACAE,WAAK,CAACF,CAAD,CAAL,GAAWC,IAAX;AACH;;AACD,WAAOC,KAAP;AACD,GAbD,CAtEgB,CAqFhB;AACA;;;AACA,MAAIE,cAAc,GAAG,UAASC,GAAT,EAAcC,KAAd,EAAqB;AACxC,QAAIC,CAAC,GAAGpC,KAAK,CAAC,CAAD,EAAI,GAAJ,CAAb;AACA,QAAIqC,OAAO,GAAG,GAAd;;AACA,SAAI,IAAIC,CAAC,GAAC,CAAN,EAAQ7B,CAAC,GAACyB,GAAG,CAAChB,MAAlB,EAAyBoB,CAAC,GAAC7B,CAA3B,EAA6B6B,CAAC,EAA9B,EAAkC;AAChCD,aAAO,IAAIF,KAAK,CAACG,CAAD,CAAhB;;AACA,UAAGF,CAAC,GAAGC,OAAP,EAAgB;AAAE,eAAOH,GAAG,CAACI,CAAD,CAAV;AAAgB;AACnC;AACF,GAPD,CAvFgB,CAgGhB;;;AACA,MAAIC,MAAM,GAAG,UAASC,GAAT,EAAcC,UAAd,EAA0BC,aAA1B,EAAyC;AACpD,WAAO,OAAOF,GAAG,CAACC,UAAD,CAAV,KAA2B,WAA3B,GAAyCD,GAAG,CAACC,UAAD,CAA5C,GAA2DC,aAAlE;AACD,GAFD;;AAIAtD,QAAM,CAACY,KAAP,GAAeA,KAAf;AACAZ,QAAM,CAACe,KAAP,GAAeA,KAAf;AACAf,QAAM,CAACiB,KAAP,GAAeA,KAAf;AACAjB,QAAM,CAACoB,KAAP,GAAeA,KAAf;AACApB,QAAM,CAACiC,MAAP,GAAgBA,MAAhB;AACAjC,QAAM,CAACwC,QAAP,GAAkBA,QAAlB;AACAxC,QAAM,CAAC6C,cAAP,GAAwBA,cAAxB;AACA7C,QAAM,CAAC+B,SAAP,GAAmBA,SAAnB;AACA/B,QAAM,CAAC4B,WAAP,GAAqBA,WAArB;AACA5B,QAAM,CAACmD,MAAP,GAAgBA,MAAhB;AAED,CAhHD,EAgHGrD,SAhHH;;AAiHA,CAAC,UAASE,MAAT,EAAiB;AAChB,eADgB,CAGhB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIuD,GAAG,GAAG,UAASC,EAAT,EAAaC,EAAb,EAAiBC,KAAjB,EAAwBjD,CAAxB,EAA2B;AACnC;AACA,QAAGkD,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BN,EAA/B,MAAuC,gBAA1C,EAA4D;AAC1D;AACA,WAAKA,EAAL,GAAU,CAAV;AACA,WAAKC,EAAL,GAAU,CAAV;AACA,WAAKC,KAAL,GAAaF,EAAE,CAAC1B,MAAhB,CAJ0D,CAK1D;AACA;;AACA,WAAKI,CAAL,GAASlC,MAAM,CAACoB,KAAP,CAAa,KAAKsC,KAAlB,CAAT;AACA,WAAKK,EAAL,GAAU/D,MAAM,CAACoB,KAAP,CAAa,KAAKsC,KAAlB,CAAV;;AACA,WAAI,IAAIhC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKgC,KAAnB,EAAyBhC,CAAC,EAA1B,EAA8B;AAC5B,aAAKQ,CAAL,CAAOR,CAAP,IAAY8B,EAAE,CAAC9B,CAAD,CAAd;AACD;AACF,KAZD,MAYO;AACL;AACA,WAAK8B,EAAL,GAAUA,EAAV;AACA,WAAKC,EAAL,GAAUA,EAAV;AACA,WAAKC,KAAL,GAAaA,KAAb;AACA,UAAIrC,CAAC,GAAGmC,EAAE,GAACC,EAAH,GAAMC,KAAd;AACA,WAAKxB,CAAL,GAASlC,MAAM,CAACoB,KAAP,CAAaC,CAAb,CAAT;AACA,WAAK0C,EAAL,GAAU/D,MAAM,CAACoB,KAAP,CAAaC,CAAb,CAAV;;AACA,UAAG,OAAOZ,CAAP,KAAa,WAAhB,EAA6B;AAC3B;AACA;AACA;AACA,YAAIuD,KAAK,GAAG3D,IAAI,CAACK,IAAL,CAAU,OAAK8C,EAAE,GAACC,EAAH,GAAMC,KAAX,CAAV,CAAZ;;AACA,aAAI,IAAIhC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACL,CAAd,EAAgBK,CAAC,EAAjB,EAAqB;AACnB,eAAKQ,CAAL,CAAOR,CAAP,IAAY1B,MAAM,CAACiB,KAAP,CAAa,GAAb,EAAkB+C,KAAlB,CAAZ;AACD;AACF,OARD,MAQO;AACL,aAAI,IAAItC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACL,CAAd,EAAgBK,CAAC,EAAjB,EAAqB;AACnB,eAAKQ,CAAL,CAAOR,CAAP,IAAYjB,CAAZ;AACD;AACF;AACF;AACF,GApCD;;AAsCA8C,KAAG,CAACK,SAAJ,GAAgB;AACdK,OAAG,EAAE,UAASC,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkB;AACrB,UAAIC,EAAE,GAAC,CAAE,KAAKb,EAAL,GAAUW,CAAX,GAAcD,CAAf,IAAkB,KAAKR,KAAvB,GAA6BU,CAApC;AACA,aAAO,KAAKlC,CAAL,CAAOmC,EAAP,CAAP;AACD,KAJa;AAKdC,OAAG,EAAE,UAASJ,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkB7D,CAAlB,EAAqB;AACxB,UAAI8D,EAAE,GAAC,CAAE,KAAKb,EAAL,GAAUW,CAAX,GAAcD,CAAf,IAAkB,KAAKR,KAAvB,GAA6BU,CAApC;AACA,WAAKlC,CAAL,CAAOmC,EAAP,IAAa9D,CAAb;AACD,KARa;AASdgE,OAAG,EAAE,UAASL,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkB7D,CAAlB,EAAqB;AACxB,UAAI8D,EAAE,GAAC,CAAE,KAAKb,EAAL,GAAUW,CAAX,GAAcD,CAAf,IAAkB,KAAKR,KAAvB,GAA6BU,CAApC;AACA,WAAKlC,CAAL,CAAOmC,EAAP,KAAc9D,CAAd;AACD,KAZa;AAadiE,YAAQ,EAAE,UAASN,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkB;AAC1B,UAAIC,EAAE,GAAG,CAAE,KAAKb,EAAL,GAAUW,CAAX,GAAcD,CAAf,IAAkB,KAAKR,KAAvB,GAA6BU,CAAtC;AACA,aAAO,KAAKL,EAAL,CAAQM,EAAR,CAAP;AACD,KAhBa;AAiBdI,YAAQ,EAAE,UAASP,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkB7D,CAAlB,EAAqB;AAC7B,UAAI8D,EAAE,GAAG,CAAE,KAAKb,EAAL,GAAUW,CAAX,GAAcD,CAAf,IAAkB,KAAKR,KAAvB,GAA6BU,CAAtC;AACA,WAAKL,EAAL,CAAQM,EAAR,IAAc9D,CAAd;AACD,KApBa;AAqBdmE,YAAQ,EAAE,UAASR,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkB7D,CAAlB,EAAqB;AAC7B,UAAI8D,EAAE,GAAG,CAAE,KAAKb,EAAL,GAAUW,CAAX,GAAcD,CAAf,IAAkB,KAAKR,KAAvB,GAA6BU,CAAtC;AACA,WAAKL,EAAL,CAAQM,EAAR,KAAe9D,CAAf;AACD,KAxBa;AAyBdoE,gBAAY,EAAE,YAAW;AAAE,aAAO,IAAIpB,GAAJ,CAAQ,KAAKC,EAAb,EAAiB,KAAKC,EAAtB,EAA0B,KAAKC,KAA/B,EAAsC,GAAtC,CAAP;AAAkD,KAzB/D;AA0BdkB,SAAK,EAAE,YAAW;AAChB,UAAIC,CAAC,GAAG,IAAItB,GAAJ,CAAQ,KAAKC,EAAb,EAAiB,KAAKC,EAAtB,EAA0B,KAAKC,KAA/B,EAAsC,GAAtC,CAAR;AACA,UAAIrC,CAAC,GAAG,KAAKa,CAAL,CAAOJ,MAAf;;AACA,WAAI,IAAIJ,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACL,CAAd,EAAgBK,CAAC,EAAjB,EAAqB;AAAEmD,SAAC,CAAC3C,CAAF,CAAIR,CAAJ,IAAS,KAAKQ,CAAL,CAAOR,CAAP,CAAT;AAAqB;;AAC5C,aAAOmD,CAAP;AACD,KA/Ba;AAgCdC,WAAO,EAAE,UAASD,CAAT,EAAY;AAAE,WAAI,IAAI3B,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKhB,CAAL,CAAOJ,MAArB,EAA4BoB,CAAC,EAA7B,EAAiC;AAAE,aAAKhB,CAAL,CAAOgB,CAAP,KAAa2B,CAAC,CAAC3C,CAAF,CAAIgB,CAAJ,CAAb;AAAsB;AAAC,KAhCnE;AAiCd6B,iBAAa,EAAE,UAASF,CAAT,EAAYhE,CAAZ,EAAe;AAAE,WAAI,IAAIqC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKhB,CAAL,CAAOJ,MAArB,EAA4BoB,CAAC,EAA7B,EAAiC;AAAE,aAAKhB,CAAL,CAAOgB,CAAP,KAAarC,CAAC,GAACgE,CAAC,CAAC3C,CAAF,CAAIgB,CAAJ,CAAf;AAAwB;AAAC,KAjC9E;AAkCd8B,YAAQ,EAAE,UAASnE,CAAT,EAAY;AAAE,WAAI,IAAIqC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKhB,CAAL,CAAOJ,MAArB,EAA4BoB,CAAC,EAA7B,EAAiC;AAAE,aAAKhB,CAAL,CAAOgB,CAAP,IAAYrC,CAAZ;AAAgB;AAAC,KAlC9D;AAoCdoE,UAAM,EAAE,YAAW;AACjB;AACA,UAAIC,IAAI,GAAG,EAAX;AACAA,UAAI,CAAC1B,EAAL,GAAU,KAAKA,EAAf;AACA0B,UAAI,CAACzB,EAAL,GAAU,KAAKA,EAAf;AACAyB,UAAI,CAACxB,KAAL,GAAa,KAAKA,KAAlB;AACAwB,UAAI,CAAChD,CAAL,GAAS,KAAKA,CAAd;AACA,aAAOgD,IAAP,CAPiB,CAQjB;AACD,KA7Ca;AA8CdC,YAAQ,EAAE,UAASD,IAAT,EAAe;AACvB,WAAK1B,EAAL,GAAU0B,IAAI,CAAC1B,EAAf;AACA,WAAKC,EAAL,GAAUyB,IAAI,CAACzB,EAAf;AACA,WAAKC,KAAL,GAAawB,IAAI,CAACxB,KAAlB;AAEA,UAAIrC,CAAC,GAAG,KAAKmC,EAAL,GAAQ,KAAKC,EAAb,GAAgB,KAAKC,KAA7B;AACA,WAAKxB,CAAL,GAASlC,MAAM,CAACoB,KAAP,CAAaC,CAAb,CAAT;AACA,WAAK0C,EAAL,GAAU/D,MAAM,CAACoB,KAAP,CAAaC,CAAb,CAAV,CAPuB,CAQvB;;AACA,WAAI,IAAIK,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACL,CAAd,EAAgBK,CAAC,EAAjB,EAAqB;AACnB,aAAKQ,CAAL,CAAOR,CAAP,IAAYwD,IAAI,CAAChD,CAAL,CAAOR,CAAP,CAAZ;AACD;AACF;AA1Da,GAAhB;AA6DA1B,QAAM,CAACuD,GAAP,GAAaA,GAAb;AACD,CA9GD,EA8GGzD,SA9GH;;AA+GA,CAAC,UAASE,MAAT,EAAiB;AAChB;;AACA,MAAIuD,GAAG,GAAGvD,MAAM,CAACuD,GAAjB,CAFgB,CAEM;AAEtB;AACA;AACA;AACA;AACA;;AACA,MAAI6B,OAAO,GAAG,UAASP,CAAT,EAAYQ,IAAZ,EAAkBC,EAAlB,EAAsBC,EAAtB,EAA0BC,MAA1B,EAAkC;AAC9C;AACA,QAAG,OAAOA,MAAP,KAAiB,WAApB,EAAiC,IAAIA,MAAM,GAAG,KAAb;AACjC,QAAG,OAAOF,EAAP,KAAa,WAAhB,EAA6B,IAAIA,EAAE,GAAGtF,MAAM,CAACe,KAAP,CAAa,CAAb,EAAgB8D,CAAC,CAACrB,EAAF,GAAO6B,IAAvB,CAAT;AAC7B,QAAG,OAAOE,EAAP,KAAa,WAAhB,EAA6B,IAAIA,EAAE,GAAGvF,MAAM,CAACe,KAAP,CAAa,CAAb,EAAgB8D,CAAC,CAACpB,EAAF,GAAO4B,IAAvB,CAAT,CAJiB,CAM9C;;AACA,QAAII,CAAJ;;AACA,QAAGJ,IAAI,KAAKR,CAAC,CAACrB,EAAX,IAAiB8B,EAAE,KAAG,CAAtB,IAA2BC,EAAE,KAAG,CAAnC,EAAsC;AACpCE,OAAC,GAAG,IAAIlC,GAAJ,CAAQ8B,IAAR,EAAcA,IAAd,EAAoBR,CAAC,CAACnB,KAAtB,EAA6B,GAA7B,CAAJ;;AACA,WAAI,IAAIQ,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACmB,IAAd,EAAmBnB,CAAC,EAApB,EAAwB;AACtB,aAAI,IAAIC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACkB,IAAd,EAAmBlB,CAAC,EAApB,EAAwB;AACtB,cAAGD,CAAC,GAACoB,EAAF,GAAK,CAAL,IAAUpB,CAAC,GAACoB,EAAF,IAAMT,CAAC,CAACrB,EAAlB,IAAwBW,CAAC,GAACoB,EAAF,GAAK,CAA7B,IAAkCpB,CAAC,GAACoB,EAAF,IAAMV,CAAC,CAACpB,EAA7C,EAAiD,SAD3B,CACqC;;AAC3D,eAAI,IAAIW,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACS,CAAC,CAACnB,KAAhB,EAAsBU,CAAC,EAAvB,EAA2B;AAC1BqB,aAAC,CAACnB,GAAF,CAAMJ,CAAN,EAAQC,CAAR,EAAUC,CAAV,EAAYS,CAAC,CAACZ,GAAF,CAAMC,CAAC,GAACoB,EAAR,EAAWnB,CAAC,GAACoB,EAAb,EAAgBnB,CAAhB,CAAZ,EAD0B,CACO;AACjC;AACF;AACF;AACF,KAVD,MAUO;AACLqB,OAAC,GAAGZ,CAAJ;AACD;;AAED,QAAGW,MAAH,EAAW;AACT;AACA,UAAIE,EAAE,GAAGD,CAAC,CAACd,YAAF,EAAT;;AACA,WAAI,IAAIT,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACuB,CAAC,CAACjC,EAAhB,EAAmBU,CAAC,EAApB,EAAwB;AACtB,aAAI,IAAIC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACsB,CAAC,CAAChC,EAAhB,EAAmBU,CAAC,EAApB,EAAwB;AACtB,eAAI,IAAIC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACqB,CAAC,CAAC/B,KAAhB,EAAsBU,CAAC,EAAvB,EAA2B;AAC1BsB,cAAE,CAACpB,GAAH,CAAOJ,CAAP,EAASC,CAAT,EAAWC,CAAX,EAAaqB,CAAC,CAACxB,GAAF,CAAMwB,CAAC,CAACjC,EAAF,GAAOU,CAAP,GAAW,CAAjB,EAAmBC,CAAnB,EAAqBC,CAArB,CAAb,EAD0B,CACa;AACvC;AACF;AACF;;AACDqB,OAAC,GAAGC,EAAJ,CAVS,CAUD;AACT;;AACD,WAAOD,CAAP;AACD,GAnCD,CATgB,CA8ChB;AACA;;;AACA,MAAIE,UAAU,GAAG,UAASC,GAAT,EAAcC,iBAAd,EAAiC;AAEhD,QAAG,OAAOA,iBAAP,KAA4B,WAA/B,EAA4C,IAAIA,iBAAiB,GAAG,KAAxB;AAE5C,QAAIC,MAAM,GAAGC,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAb;AACAF,UAAM,CAACG,KAAP,GAAeL,GAAG,CAACK,KAAnB;AACAH,UAAM,CAACI,MAAP,GAAgBN,GAAG,CAACM,MAApB;AACA,QAAIC,GAAG,GAAGL,MAAM,CAACM,UAAP,CAAkB,IAAlB,CAAV,CAPgD,CAShD;;AACA,QAAI;AACFD,SAAG,CAACE,SAAJ,CAAcT,GAAd,EAAmB,CAAnB,EAAsB,CAAtB;AACD,KAFD,CAEE,OAAOU,CAAP,EAAU;AACV,UAAIA,CAAC,CAACC,IAAF,KAAW,wBAAf,EAAyC;AACvC;AACA,eAAO,KAAP;AACD,OAHD,MAGO;AACL,cAAMD,CAAN;AACD;AACF;;AAED,QAAI;AACF,UAAIE,QAAQ,GAAGL,GAAG,CAACM,YAAJ,CAAiB,CAAjB,EAAoB,CAApB,EAAuBX,MAAM,CAACG,KAA9B,EAAqCH,MAAM,CAACI,MAA5C,CAAf;AACD,KAFD,CAEE,OAAOI,CAAP,EAAU;AACV,UAAGA,CAAC,CAACC,IAAF,KAAW,gBAAd,EAAgC;AAC9B,eAAO,KAAP,CAD8B,CAChB;AACf,OAFD,MAEO;AACL,cAAMD,CAAN;AACD;AACF,KA7B+C,CA+BhD;;;AACA,QAAItD,CAAC,GAAGwD,QAAQ,CAACE,IAAjB;AACA,QAAIjB,CAAC,GAAGG,GAAG,CAACK,KAAZ;AACA,QAAIU,CAAC,GAAGf,GAAG,CAACM,MAAZ;AACA,QAAIU,EAAE,GAAG,EAAT;;AACA,SAAI,IAAIlF,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACsB,CAAC,CAAClB,MAAhB,EAAuBJ,CAAC,EAAxB,EAA4B;AAC1BkF,QAAE,CAAC5E,IAAH,CAAQgB,CAAC,CAACtB,CAAD,CAAD,GAAK,KAAL,GAAW,GAAnB,EAD0B,CACD;AAC1B;;AACD,QAAIwC,CAAC,GAAG,IAAIX,GAAJ,CAAQkC,CAAR,EAAWkB,CAAX,EAAc,CAAd,EAAiB,GAAjB,CAAR,CAvCgD,CAuCjB;;AAC/BzC,KAAC,CAAChC,CAAF,GAAM0E,EAAN;;AAEA,QAAGf,iBAAH,EAAsB;AACpB;AACA,UAAIgB,EAAE,GAAG,IAAItD,GAAJ,CAAQkC,CAAR,EAAWkB,CAAX,EAAc,CAAd,EAAiB,GAAjB,CAAT;;AACA,WAAI,IAAIjF,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC+D,CAAd,EAAgB/D,CAAC,EAAjB,EAAqB;AACnB,aAAI,IAAIe,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACkE,CAAd,EAAgBlE,CAAC,EAAjB,EAAqB;AACnBoE,YAAE,CAACvC,GAAH,CAAO5C,CAAP,EAASe,CAAT,EAAW,CAAX,EAAayB,CAAC,CAACD,GAAF,CAAMvC,CAAN,EAAQe,CAAR,EAAU,CAAV,CAAb;AACD;AACF;;AACDyB,OAAC,GAAG2C,EAAJ;AACD;;AAED,WAAO3C,CAAP;AACD,GAtDD;;AAwDAlE,QAAM,CAACoF,OAAP,GAAiBA,OAAjB;AACApF,QAAM,CAAC2F,UAAP,GAAoBA,UAApB;AAED,CA3GD,EA2GG7F,SA3GH;;AA4GA,CAAC,UAASE,MAAT,EAAiB;AAChB;;AACA,MAAIuD,GAAG,GAAGvD,MAAM,CAACuD,GAAjB,CAFgB,CAEM;AAEtB;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIuD,SAAS,GAAG,UAAS1D,GAAT,EAAc;AAC5B,QAAIA,GAAG,GAAGA,GAAG,IAAI,EAAjB,CAD4B,CAG5B;;AACA,SAAK2D,SAAL,GAAiB3D,GAAG,CAAC4D,OAArB;AACA,SAAKxD,EAAL,GAAUJ,GAAG,CAACI,EAAd,CAL4B,CAKV;;AAClB,SAAKyD,QAAL,GAAgB7D,GAAG,CAAC6D,QAApB;AACA,SAAKC,KAAL,GAAa9D,GAAG,CAAC8D,KAAjB;AACA,SAAKC,KAAL,GAAa/D,GAAG,CAAC+D,KAAjB,CAR4B,CAU5B;;AACA,SAAK1D,EAAL,GAAU,OAAOL,GAAG,CAACK,EAAX,KAAkB,WAAlB,GAAgCL,GAAG,CAACK,EAApC,GAAyC,KAAKD,EAAxD;AACA,SAAK4D,MAAL,GAAc,OAAOhE,GAAG,CAACgE,MAAX,KAAsB,WAAtB,GAAoChE,GAAG,CAACgE,MAAxC,GAAiD,CAA/D,CAZ4B,CAYsC;;AAClE,SAAKC,GAAL,GAAW,OAAOjE,GAAG,CAACiE,GAAX,KAAmB,WAAnB,GAAiCjE,GAAG,CAACiE,GAArC,GAA2C,CAAtD,CAb4B,CAa6B;;AACzD,SAAKC,YAAL,GAAoB,OAAOlE,GAAG,CAACkE,YAAX,KAA4B,WAA5B,GAA0ClE,GAAG,CAACkE,YAA9C,GAA6D,GAAjF;AACA,SAAKC,YAAL,GAAoB,OAAOnE,GAAG,CAACmE,YAAX,KAA4B,WAA5B,GAA0CnE,GAAG,CAACmE,YAA9C,GAA6D,GAAjF,CAf4B,CAiB5B;AACA;AACA;AACA;;AACA,SAAKC,MAAL,GAAcnH,IAAI,CAACW,KAAL,CAAW,CAAC,KAAKkG,KAAL,GAAa,KAAKG,GAAL,GAAW,CAAxB,GAA4B,KAAK7D,EAAlC,IAAwC,KAAK4D,MAA7C,GAAsD,CAAjE,CAAd;AACA,SAAKK,MAAL,GAAcpH,IAAI,CAACW,KAAL,CAAW,CAAC,KAAKmG,KAAL,GAAa,KAAKE,GAAL,GAAW,CAAxB,GAA4B,KAAK5D,EAAlC,IAAwC,KAAK2D,MAA7C,GAAsD,CAAjE,CAAd;AACA,SAAKM,UAAL,GAAkB,MAAlB,CAvB4B,CAyB5B;;AACA,QAAIC,IAAI,GAAG,OAAOvE,GAAG,CAACwE,SAAX,KAAyB,WAAzB,GAAuCxE,GAAG,CAACwE,SAA3C,GAAuD,GAAlE;AACA,SAAKZ,OAAL,GAAe,EAAf;;AACA,SAAI,IAAItF,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKqF,SAAnB,EAA6BrF,CAAC,EAA9B,EAAkC;AAAE,WAAKsF,OAAL,CAAahF,IAAb,CAAkB,IAAIuB,GAAJ,CAAQ,KAAKC,EAAb,EAAiB,KAAKC,EAAtB,EAA0B,KAAKwD,QAA/B,CAAlB;AAA8D;;AAClG,SAAKY,MAAL,GAAc,IAAItE,GAAJ,CAAQ,CAAR,EAAW,CAAX,EAAc,KAAKwD,SAAnB,EAA8BY,IAA9B,CAAd;AACD,GA9BD;;AA+BAb,WAAS,CAAClD,SAAV,GAAsB;AACpBkE,WAAO,EAAE,UAASjD,CAAT,EAAYkD,WAAZ,EAAyB;AAChC;AAEA,WAAKC,MAAL,GAAcnD,CAAd;AACA,UAAIoD,CAAC,GAAG,IAAI1E,GAAJ,CAAQ,KAAKiE,MAAL,GAAa,CAArB,EAAwB,KAAKC,MAAL,GAAa,CAArC,EAAwC,KAAKV,SAAL,GAAgB,CAAxD,EAA2D,GAA3D,CAAR;AAEA,UAAImB,IAAI,GAAGrD,CAAC,CAACrB,EAAF,GAAM,CAAjB;AACA,UAAI2E,IAAI,GAAGtD,CAAC,CAACpB,EAAF,GAAM,CAAjB;AACA,UAAI2E,SAAS,GAAG,KAAKhB,MAAL,GAAa,CAA7B;;AAEA,WAAI,IAAIhD,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAK2C,SAAnB,EAA6B3C,CAAC,EAA9B,EAAkC;AAChC,YAAIiE,CAAC,GAAG,KAAKrB,OAAL,CAAa5C,CAAb,CAAR;AACA,YAAIF,CAAC,GAAG,CAAC,KAAKmD,GAAN,GAAW,CAAnB;AACA,YAAIlD,CAAC,GAAG,CAAC,KAAKkD,GAAN,GAAW,CAAnB;;AACA,aAAI,IAAIiB,EAAE,GAAC,CAAX,EAAcA,EAAE,GAAC,KAAKb,MAAtB,EAA8BtD,CAAC,IAAEiE,SAAH,EAAaE,EAAE,EAA7C,EAAiD;AAAG;AAClDpE,WAAC,GAAG,CAAC,KAAKmD,GAAN,GAAW,CAAf;;AACA,eAAI,IAAIkB,EAAE,GAAC,CAAX,EAAcA,EAAE,GAAC,KAAKf,MAAtB,EAA8BtD,CAAC,IAAEkE,SAAH,EAAaG,EAAE,EAA7C,EAAiD;AAAG;AAElD;AACA,gBAAI1H,CAAC,GAAG,GAAR;;AACA,iBAAI,IAAI2H,EAAE,GAAC,CAAX,EAAaA,EAAE,GAACH,CAAC,CAAC5E,EAAlB,EAAqB+E,EAAE,EAAvB,EAA2B;AACzB,kBAAIC,EAAE,GAAGtE,CAAC,GAACqE,EAAX,CADyB,CACV;;AACf,mBAAI,IAAIE,EAAE,GAAC,CAAX,EAAaA,EAAE,GAACL,CAAC,CAAC7E,EAAlB,EAAqBkF,EAAE,EAAvB,EAA2B;AACzB,oBAAIC,EAAE,GAAGzE,CAAC,GAACwE,EAAX;;AACA,oBAAGD,EAAE,IAAE,CAAJ,IAASA,EAAE,GAACN,IAAZ,IAAoBQ,EAAE,IAAE,CAAxB,IAA6BA,EAAE,GAACT,IAAnC,EAAyC;AACvC,uBAAI,IAAIU,EAAE,GAAC,CAAX,EAAaA,EAAE,GAACP,CAAC,CAAC3E,KAAlB,EAAwBkF,EAAE,EAA1B,EAA8B;AAC5B;AACA/H,qBAAC,IAAIwH,CAAC,CAACnG,CAAF,CAAI,CAAEmG,CAAC,CAAC7E,EAAF,GAAOgF,EAAR,GAAYE,EAAb,IAAiBL,CAAC,CAAC3E,KAAnB,GAAyBkF,EAA7B,IAAmC/D,CAAC,CAAC3C,CAAF,CAAI,CAAEgG,IAAI,GAAGO,EAAR,GAAYE,EAAb,IAAiB9D,CAAC,CAACnB,KAAnB,GAAyBkF,EAA7B,CAAxC;AACD;AACF;AACF;AACF;;AACD/H,aAAC,IAAI,KAAKgH,MAAL,CAAY3F,CAAZ,CAAckC,CAAd,CAAL;AACA6D,aAAC,CAAC3D,GAAF,CAAMiE,EAAN,EAAUD,EAAV,EAAclE,CAAd,EAAiBvD,CAAjB;AACD;AACF;AACF;;AACD,WAAKgI,OAAL,GAAeZ,CAAf;AACA,aAAO,KAAKY,OAAZ;AACD,KAxCmB;AAyCpBC,YAAQ,EAAE,YAAW;AAEnB,UAAIjE,CAAC,GAAG,KAAKmD,MAAb;AACAnD,OAAC,CAACd,EAAF,GAAO/D,MAAM,CAACoB,KAAP,CAAayD,CAAC,CAAC3C,CAAF,CAAIJ,MAAjB,CAAP,CAHmB,CAGc;;AAEjC,UAAIoG,IAAI,GAAGrD,CAAC,CAACrB,EAAF,GAAM,CAAjB;AACA,UAAI2E,IAAI,GAAGtD,CAAC,CAACpB,EAAF,GAAM,CAAjB;AACA,UAAI2E,SAAS,GAAG,KAAKhB,MAAL,GAAa,CAA7B;;AAEA,WAAI,IAAIhD,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAK2C,SAAnB,EAA6B3C,CAAC,EAA9B,EAAkC;AAChC,YAAIiE,CAAC,GAAG,KAAKrB,OAAL,CAAa5C,CAAb,CAAR;AACA,YAAIF,CAAC,GAAG,CAAC,KAAKmD,GAAN,GAAW,CAAnB;AACA,YAAIlD,CAAC,GAAG,CAAC,KAAKkD,GAAN,GAAW,CAAnB;;AACA,aAAI,IAAIiB,EAAE,GAAC,CAAX,EAAcA,EAAE,GAAC,KAAKb,MAAtB,EAA8BtD,CAAC,IAAEiE,SAAH,EAAaE,EAAE,EAA7C,EAAiD;AAAG;AAClDpE,WAAC,GAAG,CAAC,KAAKmD,GAAN,GAAW,CAAf;;AACA,eAAI,IAAIkB,EAAE,GAAC,CAAX,EAAcA,EAAE,GAAC,KAAKf,MAAtB,EAA8BtD,CAAC,IAAEkE,SAAH,EAAaG,EAAE,EAA7C,EAAiD;AAAG;AAElD;AACA,gBAAIQ,UAAU,GAAG,KAAKF,OAAL,CAAarE,QAAb,CAAsB+D,EAAtB,EAAyBD,EAAzB,EAA4BlE,CAA5B,CAAjB,CAH+C,CAGE;;AACjD,iBAAI,IAAIoE,EAAE,GAAC,CAAX,EAAaA,EAAE,GAACH,CAAC,CAAC5E,EAAlB,EAAqB+E,EAAE,EAAvB,EAA2B;AACzB,kBAAIC,EAAE,GAAGtE,CAAC,GAACqE,EAAX,CADyB,CACV;;AACf,mBAAI,IAAIE,EAAE,GAAC,CAAX,EAAaA,EAAE,GAACL,CAAC,CAAC7E,EAAlB,EAAqBkF,EAAE,EAAvB,EAA2B;AACzB,oBAAIC,EAAE,GAAGzE,CAAC,GAACwE,EAAX;;AACA,oBAAGD,EAAE,IAAE,CAAJ,IAASA,EAAE,GAACN,IAAZ,IAAoBQ,EAAE,IAAE,CAAxB,IAA6BA,EAAE,GAACT,IAAnC,EAAyC;AACvC,uBAAI,IAAIU,EAAE,GAAC,CAAX,EAAaA,EAAE,GAACP,CAAC,CAAC3E,KAAlB,EAAwBkF,EAAE,EAA1B,EAA8B;AAC5B;AACA,wBAAII,GAAG,GAAG,CAAEd,IAAI,GAAGO,EAAR,GAAYE,EAAb,IAAiB9D,CAAC,CAACnB,KAAnB,GAAyBkF,EAAnC;AACA,wBAAIK,GAAG,GAAG,CAAEZ,CAAC,CAAC7E,EAAF,GAAOgF,EAAR,GAAYE,EAAb,IAAiBL,CAAC,CAAC3E,KAAnB,GAAyBkF,EAAnC;AACAP,qBAAC,CAACtE,EAAF,CAAKkF,GAAL,KAAapE,CAAC,CAAC3C,CAAF,CAAI8G,GAAJ,IAASD,UAAtB;AACAlE,qBAAC,CAACd,EAAF,CAAKiF,GAAL,KAAaX,CAAC,CAACnG,CAAF,CAAI+G,GAAJ,IAASF,UAAtB;AACD;AACF;AACF;AACF;;AACD,iBAAKlB,MAAL,CAAY9D,EAAZ,CAAeK,CAAf,KAAqB2E,UAArB;AACD;AACF;AACF;AACF,KA/EmB;AAgFpBG,qBAAiB,EAAE,YAAW;AAC5B,UAAIC,QAAQ,GAAG,EAAf;;AACA,WAAI,IAAIzH,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKqF,SAAnB,EAA6BrF,CAAC,EAA9B,EAAkC;AAChCyH,gBAAQ,CAACnH,IAAT,CAAc;AAACoH,gBAAM,EAAE,KAAKpC,OAAL,CAAatF,CAAb,EAAgBQ,CAAzB;AAA4BmH,eAAK,EAAE,KAAKrC,OAAL,CAAatF,CAAb,EAAgBqC,EAAnD;AAAuDwD,sBAAY,EAAE,KAAKA,YAA1E;AAAwFD,sBAAY,EAAE,KAAKA;AAA3G,SAAd;AACD;;AACD6B,cAAQ,CAACnH,IAAT,CAAc;AAACoH,cAAM,EAAE,KAAKvB,MAAL,CAAY3F,CAArB;AAAwBmH,aAAK,EAAE,KAAKxB,MAAL,CAAY9D,EAA3C;AAA+CuD,oBAAY,EAAE,GAA7D;AAAkEC,oBAAY,EAAE;AAAhF,OAAd;AACA,aAAO4B,QAAP;AACD,KAvFmB;AAwFpBlE,UAAM,EAAE,YAAW;AACjB,UAAIC,IAAI,GAAG,EAAX;AACAA,UAAI,CAAC1B,EAAL,GAAU,KAAKA,EAAf,CAFiB,CAEE;;AACnB0B,UAAI,CAACzB,EAAL,GAAU,KAAKA,EAAf;AACAyB,UAAI,CAACkC,MAAL,GAAc,KAAKA,MAAnB;AACAlC,UAAI,CAAC+B,QAAL,GAAgB,KAAKA,QAArB;AACA/B,UAAI,CAAC6B,SAAL,GAAiB,KAAKA,SAAtB;AACA7B,UAAI,CAACsC,MAAL,GAAc,KAAKA,MAAnB;AACAtC,UAAI,CAACuC,MAAL,GAAc,KAAKA,MAAnB;AACAvC,UAAI,CAACwC,UAAL,GAAkB,KAAKA,UAAvB;AACAxC,UAAI,CAACoC,YAAL,GAAoB,KAAKA,YAAzB;AACApC,UAAI,CAACqC,YAAL,GAAoB,KAAKA,YAAzB;AACArC,UAAI,CAACmC,GAAL,GAAW,KAAKA,GAAhB;AACAnC,UAAI,CAAC8B,OAAL,GAAe,EAAf;;AACA,WAAI,IAAItF,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKsF,OAAL,CAAalF,MAA3B,EAAkCJ,CAAC,EAAnC,EAAuC;AACrCwD,YAAI,CAAC8B,OAAL,CAAahF,IAAb,CAAkB,KAAKgF,OAAL,CAAatF,CAAb,EAAgBuD,MAAhB,EAAlB;AACD;;AACDC,UAAI,CAAC2C,MAAL,GAAc,KAAKA,MAAL,CAAY5C,MAAZ,EAAd;AACA,aAAOC,IAAP;AACD,KA3GmB;AA4GpBC,YAAQ,EAAE,UAASD,IAAT,EAAe;AACvB,WAAK6B,SAAL,GAAiB7B,IAAI,CAAC6B,SAAtB;AACA,WAAKS,MAAL,GAActC,IAAI,CAACsC,MAAnB;AACA,WAAKC,MAAL,GAAcvC,IAAI,CAACuC,MAAnB;AACA,WAAKC,UAAL,GAAkBxC,IAAI,CAACwC,UAAvB;AACA,WAAKlE,EAAL,GAAU0B,IAAI,CAAC1B,EAAf,CALuB,CAKJ;;AACnB,WAAKC,EAAL,GAAUyB,IAAI,CAACzB,EAAf;AACA,WAAK2D,MAAL,GAAclC,IAAI,CAACkC,MAAnB;AACA,WAAKH,QAAL,GAAgB/B,IAAI,CAAC+B,QAArB,CARuB,CAQQ;;AAC/B,WAAKD,OAAL,GAAe,EAAf;AACA,WAAKM,YAAL,GAAoB,OAAOpC,IAAI,CAACoC,YAAZ,KAA6B,WAA7B,GAA2CpC,IAAI,CAACoC,YAAhD,GAA+D,GAAnF;AACA,WAAKC,YAAL,GAAoB,OAAOrC,IAAI,CAACqC,YAAZ,KAA6B,WAA7B,GAA2CrC,IAAI,CAACqC,YAAhD,GAA+D,GAAnF;AACA,WAAKF,GAAL,GAAW,OAAOnC,IAAI,CAACmC,GAAZ,KAAoB,WAApB,GAAkCnC,IAAI,CAACmC,GAAvC,GAA6C,CAAxD;;AACA,WAAI,IAAI3F,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACwD,IAAI,CAAC8B,OAAL,CAAalF,MAA3B,EAAkCJ,CAAC,EAAnC,EAAuC;AACrC,YAAInB,CAAC,GAAG,IAAIgD,GAAJ,CAAQ,CAAR,EAAU,CAAV,EAAY,CAAZ,EAAc,CAAd,CAAR;AACAhD,SAAC,CAAC4E,QAAF,CAAWD,IAAI,CAAC8B,OAAL,CAAatF,CAAb,CAAX;AACA,aAAKsF,OAAL,CAAahF,IAAb,CAAkBzB,CAAlB;AACD;;AACD,WAAKsH,MAAL,GAAc,IAAItE,GAAJ,CAAQ,CAAR,EAAU,CAAV,EAAY,CAAZ,EAAc,CAAd,CAAd;AACA,WAAKsE,MAAL,CAAY1C,QAAZ,CAAqBD,IAAI,CAAC2C,MAA1B;AACD;AAhImB,GAAtB;;AAmIA,MAAIyB,cAAc,GAAG,UAASlG,GAAT,EAAc;AACjC,QAAIA,GAAG,GAAGA,GAAG,IAAI,EAAjB,CADiC,CAGjC;AACA;;AACA,SAAK2D,SAAL,GAAiB,OAAO3D,GAAG,CAACmG,WAAX,KAA2B,WAA3B,GAAyCnG,GAAG,CAACmG,WAA7C,GAA2DnG,GAAG,CAAC4D,OAAhF,CALiC,CAOjC;;AACA,SAAKM,YAAL,GAAoB,OAAOlE,GAAG,CAACkE,YAAX,KAA4B,WAA5B,GAA0ClE,GAAG,CAACkE,YAA9C,GAA6D,GAAjF;AACA,SAAKC,YAAL,GAAoB,OAAOnE,GAAG,CAACmE,YAAX,KAA4B,WAA5B,GAA0CnE,GAAG,CAACmE,YAA9C,GAA6D,GAAjF,CATiC,CAWjC;;AACA,SAAKiC,UAAL,GAAkBpG,GAAG,CAAC8D,KAAJ,GAAY9D,GAAG,CAAC+D,KAAhB,GAAwB/D,GAAG,CAAC6D,QAA9C;AACA,SAAKO,MAAL,GAAc,CAAd;AACA,SAAKC,MAAL,GAAc,CAAd;AACA,SAAKC,UAAL,GAAkB,IAAlB,CAfiC,CAiBjC;;AACA,QAAIC,IAAI,GAAG,OAAOvE,GAAG,CAACwE,SAAX,KAAyB,WAAzB,GAAuCxE,GAAG,CAACwE,SAA3C,GAAuD,GAAlE;AACA,SAAKZ,OAAL,GAAe,EAAf;;AACA,SAAI,IAAItF,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKqF,SAAnB,EAA8BrF,CAAC,EAA/B,EAAmC;AAAE,WAAKsF,OAAL,CAAahF,IAAb,CAAkB,IAAIuB,GAAJ,CAAQ,CAAR,EAAW,CAAX,EAAc,KAAKiG,UAAnB,CAAlB;AAAoD;;AACzF,SAAK3B,MAAL,GAAc,IAAItE,GAAJ,CAAQ,CAAR,EAAW,CAAX,EAAc,KAAKwD,SAAnB,EAA8BY,IAA9B,CAAd;AACD,GAtBD;;AAwBA2B,gBAAc,CAAC1F,SAAf,GAA2B;AACzBkE,WAAO,EAAE,UAASjD,CAAT,EAAYkD,WAAZ,EAAyB;AAChC,WAAKC,MAAL,GAAcnD,CAAd;AACA,UAAIoD,CAAC,GAAG,IAAI1E,GAAJ,CAAQ,CAAR,EAAW,CAAX,EAAc,KAAKwD,SAAnB,EAA8B,GAA9B,CAAR;AACA,UAAI0C,EAAE,GAAG5E,CAAC,CAAC3C,CAAX;;AACA,WAAI,IAAIR,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKqF,SAAnB,EAA6BrF,CAAC,EAA9B,EAAkC;AAChC,YAAIb,CAAC,GAAG,GAAR;AACA,YAAI6I,EAAE,GAAG,KAAK1C,OAAL,CAAatF,CAAb,EAAgBQ,CAAzB;;AACA,aAAI,IAAIkC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKoF,UAAnB,EAA8BpF,CAAC,EAA/B,EAAmC;AACjCvD,WAAC,IAAI4I,EAAE,CAACrF,CAAD,CAAF,GAAQsF,EAAE,CAACtF,CAAD,CAAf,CADiC,CACb;AACrB;;AACDvD,SAAC,IAAI,KAAKgH,MAAL,CAAY3F,CAAZ,CAAcR,CAAd,CAAL;AACAuG,SAAC,CAAC/F,CAAF,CAAIR,CAAJ,IAASb,CAAT;AACD;;AACD,WAAKgI,OAAL,GAAeZ,CAAf;AACA,aAAO,KAAKY,OAAZ;AACD,KAhBwB;AAiBzBC,YAAQ,EAAE,YAAW;AACnB,UAAIjE,CAAC,GAAG,KAAKmD,MAAb;AACAnD,OAAC,CAACd,EAAF,GAAO/D,MAAM,CAACoB,KAAP,CAAayD,CAAC,CAAC3C,CAAF,CAAIJ,MAAjB,CAAP,CAFmB,CAEc;AAEjC;;AACA,WAAI,IAAIJ,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKqF,SAAnB,EAA6BrF,CAAC,EAA9B,EAAkC;AAChC,YAAIiI,GAAG,GAAG,KAAK3C,OAAL,CAAatF,CAAb,CAAV;AACA,YAAIqH,UAAU,GAAG,KAAKF,OAAL,CAAa9E,EAAb,CAAgBrC,CAAhB,CAAjB;;AACA,aAAI,IAAI0C,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKoF,UAAnB,EAA8BpF,CAAC,EAA/B,EAAmC;AACjCS,WAAC,CAACd,EAAF,CAAKK,CAAL,KAAWuF,GAAG,CAACzH,CAAJ,CAAMkC,CAAN,IAAS2E,UAApB,CADiC,CACD;;AAChCY,aAAG,CAAC5F,EAAJ,CAAOK,CAAP,KAAaS,CAAC,CAAC3C,CAAF,CAAIkC,CAAJ,IAAO2E,UAApB,CAFiC,CAED;AACjC;;AACD,aAAKlB,MAAL,CAAY9D,EAAZ,CAAerC,CAAf,KAAqBqH,UAArB;AACD;AACF,KA/BwB;AAgCzBG,qBAAiB,EAAE,YAAW;AAC5B,UAAIC,QAAQ,GAAG,EAAf;;AACA,WAAI,IAAIzH,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKqF,SAAnB,EAA6BrF,CAAC,EAA9B,EAAkC;AAChCyH,gBAAQ,CAACnH,IAAT,CAAc;AAACoH,gBAAM,EAAE,KAAKpC,OAAL,CAAatF,CAAb,EAAgBQ,CAAzB;AAA4BmH,eAAK,EAAE,KAAKrC,OAAL,CAAatF,CAAb,EAAgBqC,EAAnD;AAAuDuD,sBAAY,EAAE,KAAKA,YAA1E;AAAwFC,sBAAY,EAAE,KAAKA;AAA3G,SAAd;AACD;;AACD4B,cAAQ,CAACnH,IAAT,CAAc;AAACoH,cAAM,EAAE,KAAKvB,MAAL,CAAY3F,CAArB;AAAwBmH,aAAK,EAAE,KAAKxB,MAAL,CAAY9D,EAA3C;AAA+CuD,oBAAY,EAAE,GAA7D;AAAkEC,oBAAY,EAAE;AAAhF,OAAd;AACA,aAAO4B,QAAP;AACD,KAvCwB;AAwCzBlE,UAAM,EAAE,YAAW;AACjB,UAAIC,IAAI,GAAG,EAAX;AACAA,UAAI,CAAC6B,SAAL,GAAiB,KAAKA,SAAtB;AACA7B,UAAI,CAACsC,MAAL,GAAc,KAAKA,MAAnB;AACAtC,UAAI,CAACuC,MAAL,GAAc,KAAKA,MAAnB;AACAvC,UAAI,CAACwC,UAAL,GAAkB,KAAKA,UAAvB;AACAxC,UAAI,CAACsE,UAAL,GAAkB,KAAKA,UAAvB;AACAtE,UAAI,CAACoC,YAAL,GAAoB,KAAKA,YAAzB;AACApC,UAAI,CAACqC,YAAL,GAAoB,KAAKA,YAAzB;AACArC,UAAI,CAAC8B,OAAL,GAAe,EAAf;;AACA,WAAI,IAAItF,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKsF,OAAL,CAAalF,MAA3B,EAAkCJ,CAAC,EAAnC,EAAuC;AACrCwD,YAAI,CAAC8B,OAAL,CAAahF,IAAb,CAAkB,KAAKgF,OAAL,CAAatF,CAAb,EAAgBuD,MAAhB,EAAlB;AACD;;AACDC,UAAI,CAAC2C,MAAL,GAAc,KAAKA,MAAL,CAAY5C,MAAZ,EAAd;AACA,aAAOC,IAAP;AACD,KAvDwB;AAwDzBC,YAAQ,EAAE,UAASD,IAAT,EAAe;AACvB,WAAK6B,SAAL,GAAiB7B,IAAI,CAAC6B,SAAtB;AACA,WAAKS,MAAL,GAActC,IAAI,CAACsC,MAAnB;AACA,WAAKC,MAAL,GAAcvC,IAAI,CAACuC,MAAnB;AACA,WAAKC,UAAL,GAAkBxC,IAAI,CAACwC,UAAvB;AACA,WAAK8B,UAAL,GAAkBtE,IAAI,CAACsE,UAAvB;AACA,WAAKlC,YAAL,GAAoB,OAAOpC,IAAI,CAACoC,YAAZ,KAA6B,WAA7B,GAA2CpC,IAAI,CAACoC,YAAhD,GAA+D,GAAnF;AACA,WAAKC,YAAL,GAAoB,OAAOrC,IAAI,CAACqC,YAAZ,KAA6B,WAA7B,GAA2CrC,IAAI,CAACqC,YAAhD,GAA+D,GAAnF;AACA,WAAKP,OAAL,GAAe,EAAf;;AACA,WAAI,IAAItF,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACwD,IAAI,CAAC8B,OAAL,CAAalF,MAA3B,EAAkCJ,CAAC,EAAnC,EAAuC;AACrC,YAAInB,CAAC,GAAG,IAAIgD,GAAJ,CAAQ,CAAR,EAAU,CAAV,EAAY,CAAZ,EAAc,CAAd,CAAR;AACAhD,SAAC,CAAC4E,QAAF,CAAWD,IAAI,CAAC8B,OAAL,CAAatF,CAAb,CAAX;AACA,aAAKsF,OAAL,CAAahF,IAAb,CAAkBzB,CAAlB;AACD;;AACD,WAAKsH,MAAL,GAAc,IAAItE,GAAJ,CAAQ,CAAR,EAAU,CAAV,EAAY,CAAZ,EAAc,CAAd,CAAd;AACA,WAAKsE,MAAL,CAAY1C,QAAZ,CAAqBD,IAAI,CAAC2C,MAA1B;AACD;AAxEwB,GAA3B;AA2EA7H,QAAM,CAAC8G,SAAP,GAAmBA,SAAnB;AACA9G,QAAM,CAACsJ,cAAP,GAAwBA,cAAxB;AAED,CAlRD,EAkRGxJ,SAlRH;;AAmRA,CAAC,UAASE,MAAT,EAAiB;AAChB;;AACA,MAAIuD,GAAG,GAAGvD,MAAM,CAACuD,GAAjB,CAFgB,CAEM;;AAEtB,MAAIqG,SAAS,GAAG,UAASxG,GAAT,EAAc;AAE5B,QAAIA,GAAG,GAAGA,GAAG,IAAI,EAAjB,CAF4B,CAI5B;;AACA,SAAKI,EAAL,GAAUJ,GAAG,CAACI,EAAd,CAL4B,CAKV;;AAClB,SAAKyD,QAAL,GAAgB7D,GAAG,CAAC6D,QAApB;AACA,SAAKC,KAAL,GAAa9D,GAAG,CAAC8D,KAAjB;AACA,SAAKC,KAAL,GAAa/D,GAAG,CAAC+D,KAAjB,CAR4B,CAU5B;;AACA,SAAK1D,EAAL,GAAU,OAAOL,GAAG,CAACK,EAAX,KAAkB,WAAlB,GAAgCL,GAAG,CAACK,EAApC,GAAyC,KAAKD,EAAxD;AACA,SAAK4D,MAAL,GAAc,OAAOhE,GAAG,CAACgE,MAAX,KAAsB,WAAtB,GAAoChE,GAAG,CAACgE,MAAxC,GAAiD,CAA/D;AACA,SAAKC,GAAL,GAAW,OAAOjE,GAAG,CAACiE,GAAX,KAAmB,WAAnB,GAAiCjE,GAAG,CAACiE,GAArC,GAA2C,CAAtD,CAb4B,CAa6B;AAEzD;;AACA,SAAKN,SAAL,GAAiB,KAAKE,QAAtB;AACA,SAAKO,MAAL,GAAcnH,IAAI,CAACW,KAAL,CAAW,CAAC,KAAKkG,KAAL,GAAa,KAAKG,GAAL,GAAW,CAAxB,GAA4B,KAAK7D,EAAlC,IAAwC,KAAK4D,MAA7C,GAAsD,CAAjE,CAAd;AACA,SAAKK,MAAL,GAAcpH,IAAI,CAACW,KAAL,CAAW,CAAC,KAAKmG,KAAL,GAAa,KAAKE,GAAL,GAAW,CAAxB,GAA4B,KAAK5D,EAAlC,IAAwC,KAAK2D,MAA7C,GAAsD,CAAjE,CAAd;AACA,SAAKM,UAAL,GAAkB,MAAlB,CAnB4B,CAoB5B;;AACA,SAAKmC,OAAL,GAAe7J,MAAM,CAACoB,KAAP,CAAa,KAAKoG,MAAL,GAAY,KAAKC,MAAjB,GAAwB,KAAKV,SAA1C,CAAf;AACA,SAAK+C,OAAL,GAAe9J,MAAM,CAACoB,KAAP,CAAa,KAAKoG,MAAL,GAAY,KAAKC,MAAjB,GAAwB,KAAKV,SAA1C,CAAf;AACD,GAvBD;;AAyBA6C,WAAS,CAAChG,SAAV,GAAsB;AACpBkE,WAAO,EAAE,UAASjD,CAAT,EAAYkD,WAAZ,EAAyB;AAChC,WAAKC,MAAL,GAAcnD,CAAd;AAEA,UAAIoD,CAAC,GAAG,IAAI1E,GAAJ,CAAQ,KAAKiE,MAAb,EAAqB,KAAKC,MAA1B,EAAkC,KAAKV,SAAvC,EAAkD,GAAlD,CAAR;AAEA,UAAI1F,CAAC,GAAC,CAAN,CALgC,CAKvB;;AACT,WAAI,IAAI+C,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAK2C,SAAnB,EAA6B3C,CAAC,EAA9B,EAAkC;AAChC,YAAIF,CAAC,GAAG,CAAC,KAAKmD,GAAd;AACA,YAAIlD,CAAC,GAAG,CAAC,KAAKkD,GAAd;;AACA,aAAI,IAAIkB,EAAE,GAAC,CAAX,EAAcA,EAAE,GAAC,KAAKf,MAAtB,EAA8BtD,CAAC,IAAE,KAAKkD,MAAR,EAAemB,EAAE,EAA/C,EAAmD;AACjDpE,WAAC,GAAG,CAAC,KAAKkD,GAAV;;AACA,eAAI,IAAIiB,EAAE,GAAC,CAAX,EAAcA,EAAE,GAAC,KAAKb,MAAtB,EAA8BtD,CAAC,IAAE,KAAKiD,MAAR,EAAekB,EAAE,EAA/C,EAAmD;AAEjD;AACA,gBAAIzH,CAAC,GAAG,CAAC,KAAT,CAHiD,CAGjC;;AAChB,gBAAIkJ,IAAI,GAAC,CAAC,CAAV;AAAA,gBAAYC,IAAI,GAAC,CAAC,CAAlB;;AACA,iBAAI,IAAItB,EAAE,GAAC,CAAX,EAAaA,EAAE,GAAC,KAAKlF,EAArB,EAAwBkF,EAAE,EAA1B,EAA8B;AAC5B,mBAAI,IAAIF,EAAE,GAAC,CAAX,EAAaA,EAAE,GAAC,KAAK/E,EAArB,EAAwB+E,EAAE,EAA1B,EAA8B;AAC5B,oBAAIC,EAAE,GAAGtE,CAAC,GAACqE,EAAX;AACA,oBAAIG,EAAE,GAAGzE,CAAC,GAACwE,EAAX;;AACA,oBAAGD,EAAE,IAAE,CAAJ,IAASA,EAAE,GAAC5D,CAAC,CAACpB,EAAd,IAAoBkF,EAAE,IAAE,CAAxB,IAA6BA,EAAE,GAAC9D,CAAC,CAACrB,EAArC,EAAyC;AACvC,sBAAIjD,CAAC,GAAGsE,CAAC,CAACZ,GAAF,CAAM0E,EAAN,EAAUF,EAAV,EAAcrE,CAAd,CAAR,CADuC,CAEvC;AACA;AACA;;AACA,sBAAG7D,CAAC,GAAGM,CAAP,EAAU;AAAEA,qBAAC,GAAGN,CAAJ;AAAOwJ,wBAAI,GAACpB,EAAL;AAASqB,wBAAI,GAACvB,EAAL;AAAS;AACtC;AACF;AACF;;AACD,iBAAKoB,OAAL,CAAaxI,CAAb,IAAkB0I,IAAlB;AACA,iBAAKD,OAAL,CAAazI,CAAb,IAAkB2I,IAAlB;AACA3I,aAAC;AACD4G,aAAC,CAAC3D,GAAF,CAAMiE,EAAN,EAAUD,EAAV,EAAclE,CAAd,EAAiBvD,CAAjB;AACD;AACF;AACF;;AACD,WAAKgI,OAAL,GAAeZ,CAAf;AACA,aAAO,KAAKY,OAAZ;AACD,KAvCmB;AAwCpBC,YAAQ,EAAE,YAAW;AACnB;AACA;AACA,UAAIjE,CAAC,GAAG,KAAKmD,MAAb;AACAnD,OAAC,CAACd,EAAF,GAAO/D,MAAM,CAACoB,KAAP,CAAayD,CAAC,CAAC3C,CAAF,CAAIJ,MAAjB,CAAP,CAJmB,CAIc;;AACjC,UAAImG,CAAC,GAAG,KAAKY,OAAb,CALmB,CAKG;;AAEtB,UAAIxH,CAAC,GAAG,CAAR;;AACA,WAAI,IAAI+C,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAK2C,SAAnB,EAA6B3C,CAAC,EAA9B,EAAkC;AAChC,YAAIF,CAAC,GAAG,CAAC,KAAKmD,GAAd;AACA,YAAIlD,CAAC,GAAG,CAAC,KAAKkD,GAAd;;AACA,aAAI,IAAIkB,EAAE,GAAC,CAAX,EAAcA,EAAE,GAAC,KAAKf,MAAtB,EAA8BtD,CAAC,IAAE,KAAKkD,MAAR,EAAemB,EAAE,EAA/C,EAAmD;AACjDpE,WAAC,GAAG,CAAC,KAAKkD,GAAV;;AACA,eAAI,IAAIiB,EAAE,GAAC,CAAX,EAAcA,EAAE,GAAC,KAAKb,MAAtB,EAA8BtD,CAAC,IAAE,KAAKiD,MAAR,EAAekB,EAAE,EAA/C,EAAmD;AAEjD,gBAAIS,UAAU,GAAG,KAAKF,OAAL,CAAarE,QAAb,CAAsB+D,EAAtB,EAAyBD,EAAzB,EAA4BlE,CAA5B,CAAjB;AACAS,aAAC,CAACH,QAAF,CAAW,KAAKmF,OAAL,CAAaxI,CAAb,CAAX,EAA4B,KAAKyI,OAAL,CAAazI,CAAb,CAA5B,EAA6C+C,CAA7C,EAAgD2E,UAAhD;AACA1H,aAAC;AAEF;AACF;AACF;AACF,KA9DmB;AA+DpB6H,qBAAiB,EAAE,YAAW;AAC5B,aAAO,EAAP;AACD,KAjEmB;AAkEpBjE,UAAM,EAAE,YAAW;AACjB,UAAIC,IAAI,GAAG,EAAX;AACAA,UAAI,CAAC1B,EAAL,GAAU,KAAKA,EAAf;AACA0B,UAAI,CAACzB,EAAL,GAAU,KAAKA,EAAf;AACAyB,UAAI,CAACkC,MAAL,GAAc,KAAKA,MAAnB;AACAlC,UAAI,CAAC+B,QAAL,GAAgB,KAAKA,QAArB;AACA/B,UAAI,CAAC6B,SAAL,GAAiB,KAAKA,SAAtB;AACA7B,UAAI,CAACsC,MAAL,GAAc,KAAKA,MAAnB;AACAtC,UAAI,CAACuC,MAAL,GAAc,KAAKA,MAAnB;AACAvC,UAAI,CAACwC,UAAL,GAAkB,KAAKA,UAAvB;AACAxC,UAAI,CAACmC,GAAL,GAAW,KAAKA,GAAhB;AACA,aAAOnC,IAAP;AACD,KA9EmB;AA+EpBC,YAAQ,EAAE,UAASD,IAAT,EAAe;AACvB,WAAK6B,SAAL,GAAiB7B,IAAI,CAAC6B,SAAtB;AACA,WAAKS,MAAL,GAActC,IAAI,CAACsC,MAAnB;AACA,WAAKC,MAAL,GAAcvC,IAAI,CAACuC,MAAnB;AACA,WAAKC,UAAL,GAAkBxC,IAAI,CAACwC,UAAvB;AACA,WAAKlE,EAAL,GAAU0B,IAAI,CAAC1B,EAAf;AACA,WAAKC,EAAL,GAAUyB,IAAI,CAACzB,EAAf;AACA,WAAK2D,MAAL,GAAclC,IAAI,CAACkC,MAAnB;AACA,WAAKH,QAAL,GAAgB/B,IAAI,CAAC+B,QAArB;AACA,WAAKI,GAAL,GAAW,OAAOnC,IAAI,CAACmC,GAAZ,KAAoB,WAApB,GAAkCnC,IAAI,CAACmC,GAAvC,GAA6C,CAAxD,CATuB,CASoC;;AAC3D,WAAKwC,OAAL,GAAe7J,MAAM,CAACoB,KAAP,CAAa,KAAKoG,MAAL,GAAY,KAAKC,MAAjB,GAAwB,KAAKV,SAA1C,CAAf,CAVuB,CAU8C;;AACrE,WAAK+C,OAAL,GAAe9J,MAAM,CAACoB,KAAP,CAAa,KAAKoG,MAAL,GAAY,KAAKC,MAAjB,GAAwB,KAAKV,SAA1C,CAAf;AACD;AA3FmB,GAAtB;AA8FA/G,QAAM,CAAC4J,SAAP,GAAmBA,SAAnB;AAED,CA7HD,EA6HG9J,SA7HH;;AA+HA,CAAC,UAASE,MAAT,EAAiB;AAChB;;AACA,MAAIuD,GAAG,GAAGvD,MAAM,CAACuD,GAAjB,CAFgB,CAEM;;AAEtB,MAAI0G,UAAU,GAAG,UAAS7G,GAAT,EAAc;AAC7B,QAAIA,GAAG,GAAGA,GAAG,IAAI,EAAjB,CAD6B,CAG7B;;AACA,SAAKoE,MAAL,GAAc,OAAOpE,GAAG,CAACoE,MAAX,KAAsB,WAAtB,GAAoCpE,GAAG,CAACoE,MAAxC,GAAiDpE,GAAG,CAAC8D,KAAnE;AACA,SAAKO,MAAL,GAAc,OAAOrE,GAAG,CAACqE,MAAX,KAAsB,WAAtB,GAAoCrE,GAAG,CAACqE,MAAxC,GAAiDrE,GAAG,CAAC+D,KAAnE;AACA,SAAKJ,SAAL,GAAiB,OAAO3D,GAAG,CAAC2D,SAAX,KAAyB,WAAzB,GAAuC3D,GAAG,CAAC2D,SAA3C,GAAuD3D,GAAG,CAAC6D,QAA5E;AACA,SAAKS,UAAL,GAAkB,OAAlB;AACD,GARD;;AASAuC,YAAU,CAACrG,SAAX,GAAuB;AACrBkE,WAAO,EAAE,UAASjD,CAAT,EAAYkD,WAAZ,EAAyB;AAChC,WAAKC,MAAL,GAAcnD,CAAd;AACA,WAAKgE,OAAL,GAAehE,CAAf;AACA,aAAO,KAAKgE,OAAZ,CAHgC,CAGX;AACtB,KALoB;AAMrBC,YAAQ,EAAE,YAAW,CAAG,CANH;AAOrBI,qBAAiB,EAAE,YAAW;AAC5B,aAAO,EAAP;AACD,KAToB;AAUrBjE,UAAM,EAAE,YAAW;AACjB,UAAIC,IAAI,GAAG,EAAX;AACAA,UAAI,CAAC6B,SAAL,GAAiB,KAAKA,SAAtB;AACA7B,UAAI,CAACsC,MAAL,GAAc,KAAKA,MAAnB;AACAtC,UAAI,CAACuC,MAAL,GAAc,KAAKA,MAAnB;AACAvC,UAAI,CAACwC,UAAL,GAAkB,KAAKA,UAAvB;AACA,aAAOxC,IAAP;AACD,KAjBoB;AAkBrBC,YAAQ,EAAE,UAASD,IAAT,EAAe;AACvB,WAAK6B,SAAL,GAAiB7B,IAAI,CAAC6B,SAAtB;AACA,WAAKS,MAAL,GAActC,IAAI,CAACsC,MAAnB;AACA,WAAKC,MAAL,GAAcvC,IAAI,CAACuC,MAAnB;AACA,WAAKC,UAAL,GAAkBxC,IAAI,CAACwC,UAAvB;AACD;AAvBoB,GAAvB;AA0BA1H,QAAM,CAACiK,UAAP,GAAoBA,UAApB;AACD,CAxCD,EAwCGnK,SAxCH;;AAyCA,CAAC,UAASE,MAAT,EAAiB;AAChB;;AACA,MAAIuD,GAAG,GAAGvD,MAAM,CAACuD,GAAjB,CAFgB,CAEM;AAEtB;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA,MAAI2G,YAAY,GAAG,UAAS9G,GAAT,EAAc;AAC/B,QAAIA,GAAG,GAAGA,GAAG,IAAI,EAAjB,CAD+B,CAG/B;;AACA,SAAKoG,UAAL,GAAkBpG,GAAG,CAAC8D,KAAJ,GAAY9D,GAAG,CAAC+D,KAAhB,GAAwB/D,GAAG,CAAC6D,QAA9C;AACA,SAAKF,SAAL,GAAiB,KAAKyC,UAAtB;AACA,SAAKhC,MAAL,GAAc,CAAd;AACA,SAAKC,MAAL,GAAc,CAAd;AACA,SAAKC,UAAL,GAAkB,SAAlB;AACD,GATD;;AAWAwC,cAAY,CAACtG,SAAb,GAAyB;AACvBkE,WAAO,EAAE,UAASjD,CAAT,EAAYkD,WAAZ,EAAyB;AAChC,WAAKC,MAAL,GAAcnD,CAAd;AAEA,UAAIoD,CAAC,GAAG,IAAI1E,GAAJ,CAAQ,CAAR,EAAW,CAAX,EAAc,KAAKwD,SAAnB,EAA8B,GAA9B,CAAR,CAHgC,CAKhC;;AACA,UAAIoD,EAAE,GAAGtF,CAAC,CAAC3C,CAAX;AACA,UAAIkI,IAAI,GAAGvF,CAAC,CAAC3C,CAAF,CAAI,CAAJ,CAAX;;AACA,WAAI,IAAIR,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKqF,SAAnB,EAA6BrF,CAAC,EAA9B,EAAkC;AAChC,YAAGyI,EAAE,CAACzI,CAAD,CAAF,GAAQ0I,IAAX,EAAiBA,IAAI,GAAGD,EAAE,CAACzI,CAAD,CAAT;AAClB,OAV+B,CAYhC;;;AACA,UAAI2I,EAAE,GAAGrK,MAAM,CAACoB,KAAP,CAAa,KAAK2F,SAAlB,CAAT;AACA,UAAIuD,IAAI,GAAG,GAAX;;AACA,WAAI,IAAI5I,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKqF,SAAnB,EAA6BrF,CAAC,EAA9B,EAAkC;AAChC,YAAI4E,CAAC,GAAGjG,IAAI,CAACkK,GAAL,CAASJ,EAAE,CAACzI,CAAD,CAAF,GAAQ0I,IAAjB,CAAR;AACAE,YAAI,IAAIhE,CAAR;AACA+D,UAAE,CAAC3I,CAAD,CAAF,GAAQ4E,CAAR;AACD,OAnB+B,CAqBhC;;;AACA,WAAI,IAAI5E,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKqF,SAAnB,EAA6BrF,CAAC,EAA9B,EAAkC;AAChC2I,UAAE,CAAC3I,CAAD,CAAF,IAAS4I,IAAT;AACArC,SAAC,CAAC/F,CAAF,CAAIR,CAAJ,IAAS2I,EAAE,CAAC3I,CAAD,CAAX;AACD;;AAED,WAAK2I,EAAL,GAAUA,EAAV,CA3BgC,CA2BlB;;AACd,WAAKxB,OAAL,GAAeZ,CAAf;AACA,aAAO,KAAKY,OAAZ;AACD,KA/BsB;AAgCvBC,YAAQ,EAAE,UAAS3E,CAAT,EAAY;AAEpB;AACA,UAAID,CAAC,GAAG,KAAK8D,MAAb;AACA9D,OAAC,CAACH,EAAF,GAAO/D,MAAM,CAACoB,KAAP,CAAa8C,CAAC,CAAChC,CAAF,CAAIJ,MAAjB,CAAP,CAJoB,CAIa;;AAEjC,WAAI,IAAIJ,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKqF,SAAnB,EAA6BrF,CAAC,EAA9B,EAAkC;AAChC,YAAI8I,SAAS,GAAG9I,CAAC,KAAKyC,CAAN,GAAU,GAAV,GAAgB,GAAhC;AACA,YAAIsG,GAAG,GAAG,EAAED,SAAS,GAAG,KAAKH,EAAL,CAAQ3I,CAAR,CAAd,CAAV;AACAwC,SAAC,CAACH,EAAF,CAAKrC,CAAL,IAAU+I,GAAV;AACD,OAVmB,CAYpB;;;AACA,aAAO,CAACpK,IAAI,CAACM,GAAL,CAAS,KAAK0J,EAAL,CAAQlG,CAAR,CAAT,CAAR;AACD,KA9CsB;AA+CvB+E,qBAAiB,EAAE,YAAW;AAC5B,aAAO,EAAP;AACD,KAjDsB;AAkDvBjE,UAAM,EAAE,YAAW;AACjB,UAAIC,IAAI,GAAG,EAAX;AACAA,UAAI,CAAC6B,SAAL,GAAiB,KAAKA,SAAtB;AACA7B,UAAI,CAACsC,MAAL,GAAc,KAAKA,MAAnB;AACAtC,UAAI,CAACuC,MAAL,GAAc,KAAKA,MAAnB;AACAvC,UAAI,CAACwC,UAAL,GAAkB,KAAKA,UAAvB;AACAxC,UAAI,CAACsE,UAAL,GAAkB,KAAKA,UAAvB;AACA,aAAOtE,IAAP;AACD,KA1DsB;AA2DvBC,YAAQ,EAAE,UAASD,IAAT,EAAe;AACvB,WAAK6B,SAAL,GAAiB7B,IAAI,CAAC6B,SAAtB;AACA,WAAKS,MAAL,GAActC,IAAI,CAACsC,MAAnB;AACA,WAAKC,MAAL,GAAcvC,IAAI,CAACuC,MAAnB;AACA,WAAKC,UAAL,GAAkBxC,IAAI,CAACwC,UAAvB;AACA,WAAK8B,UAAL,GAAkBtE,IAAI,CAACsE,UAAvB;AACD;AAjEsB,GAAzB,CAxBgB,CA4FhB;AACA;AACA;;AACA,MAAIkB,eAAe,GAAG,UAAStH,GAAT,EAAc;AAClC,QAAIA,GAAG,GAAGA,GAAG,IAAI,EAAjB,CADkC,CAGlC;;AACA,SAAKoG,UAAL,GAAkBpG,GAAG,CAAC8D,KAAJ,GAAY9D,GAAG,CAAC+D,KAAhB,GAAwB/D,GAAG,CAAC6D,QAA9C;AACA,SAAKF,SAAL,GAAiB,KAAKyC,UAAtB;AACA,SAAKhC,MAAL,GAAc,CAAd;AACA,SAAKC,MAAL,GAAc,CAAd;AACA,SAAKC,UAAL,GAAkB,YAAlB;AACD,GATD;;AAWAgD,iBAAe,CAAC9G,SAAhB,GAA4B;AAC1BkE,WAAO,EAAE,UAASjD,CAAT,EAAYkD,WAAZ,EAAyB;AAChC,WAAKC,MAAL,GAAcnD,CAAd;AACA,WAAKgE,OAAL,GAAehE,CAAf;AACA,aAAOA,CAAP,CAHgC,CAGtB;AACX,KALyB;AAM1B;AACAiE,YAAQ,EAAE,UAAS3E,CAAT,EAAY;AAEpB;AACA,UAAID,CAAC,GAAG,KAAK8D,MAAb;AACA9D,OAAC,CAACH,EAAF,GAAO/D,MAAM,CAACoB,KAAP,CAAa8C,CAAC,CAAChC,CAAF,CAAIJ,MAAjB,CAAP,CAJoB,CAIa;;AACjC,UAAI6I,IAAI,GAAG,GAAX;;AACA,UAAGxG,CAAC,YAAY1C,KAAb,IAAsB0C,CAAC,YAAYxC,YAAtC,EAAoD;AAClD,aAAI,IAAID,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKqF,SAAnB,EAA6BrF,CAAC,EAA9B,EAAkC;AAChC,cAAI6D,EAAE,GAAGrB,CAAC,CAAChC,CAAF,CAAIR,CAAJ,IAASyC,CAAC,CAACzC,CAAD,CAAnB;AACAwC,WAAC,CAACH,EAAF,CAAKrC,CAAL,IAAU6D,EAAV;AACAoF,cAAI,IAAI,IAAEpF,EAAF,GAAKA,EAAb;AACD;AACF,OAND,MAMO;AACL;AACA;AACA,YAAI7D,CAAC,GAAGyC,CAAC,CAACyG,GAAV;AACA,YAAIC,EAAE,GAAG1G,CAAC,CAAC2G,GAAX;AACA,YAAIvF,EAAE,GAAGrB,CAAC,CAAChC,CAAF,CAAIR,CAAJ,IAASmJ,EAAlB;AACA3G,SAAC,CAACH,EAAF,CAAKrC,CAAL,IAAU6D,EAAV;AACAoF,YAAI,IAAI,IAAEpF,EAAF,GAAKA,EAAb;AACD;;AACD,aAAOoF,IAAP;AACD,KA7ByB;AA8B1BzB,qBAAiB,EAAE,YAAW;AAC5B,aAAO,EAAP;AACD,KAhCyB;AAiC1BjE,UAAM,EAAE,YAAW;AACjB,UAAIC,IAAI,GAAG,EAAX;AACAA,UAAI,CAAC6B,SAAL,GAAiB,KAAKA,SAAtB;AACA7B,UAAI,CAACsC,MAAL,GAAc,KAAKA,MAAnB;AACAtC,UAAI,CAACuC,MAAL,GAAc,KAAKA,MAAnB;AACAvC,UAAI,CAACwC,UAAL,GAAkB,KAAKA,UAAvB;AACAxC,UAAI,CAACsE,UAAL,GAAkB,KAAKA,UAAvB;AACA,aAAOtE,IAAP;AACD,KAzCyB;AA0C1BC,YAAQ,EAAE,UAASD,IAAT,EAAe;AACvB,WAAK6B,SAAL,GAAiB7B,IAAI,CAAC6B,SAAtB;AACA,WAAKS,MAAL,GAActC,IAAI,CAACsC,MAAnB;AACA,WAAKC,MAAL,GAAcvC,IAAI,CAACuC,MAAnB;AACA,WAAKC,UAAL,GAAkBxC,IAAI,CAACwC,UAAvB;AACA,WAAK8B,UAAL,GAAkBtE,IAAI,CAACsE,UAAvB;AACD;AAhDyB,GAA5B;;AAmDA,MAAIuB,QAAQ,GAAG,UAAS3H,GAAT,EAAc;AAC3B,QAAIA,GAAG,GAAGA,GAAG,IAAI,EAAjB,CAD2B,CAG3B;;AACA,SAAKoG,UAAL,GAAkBpG,GAAG,CAAC8D,KAAJ,GAAY9D,GAAG,CAAC+D,KAAhB,GAAwB/D,GAAG,CAAC6D,QAA9C;AACA,SAAKF,SAAL,GAAiB,KAAKyC,UAAtB;AACA,SAAKhC,MAAL,GAAc,CAAd;AACA,SAAKC,MAAL,GAAc,CAAd;AACA,SAAKC,UAAL,GAAkB,KAAlB;AACD,GATD;;AAWAqD,UAAQ,CAACnH,SAAT,GAAqB;AACnBkE,WAAO,EAAE,UAASjD,CAAT,EAAYkD,WAAZ,EAAyB;AAChC,WAAKC,MAAL,GAAcnD,CAAd;AACA,WAAKgE,OAAL,GAAehE,CAAf,CAFgC,CAEd;;AAClB,aAAOA,CAAP;AACD,KALkB;AAMnBiE,YAAQ,EAAE,UAAS3E,CAAT,EAAY;AAEpB;AACA,UAAID,CAAC,GAAG,KAAK8D,MAAb;AACA9D,OAAC,CAACH,EAAF,GAAO/D,MAAM,CAACoB,KAAP,CAAa8C,CAAC,CAAChC,CAAF,CAAIJ,MAAjB,CAAP,CAJoB,CAIa;;AAEjC,UAAIkJ,MAAM,GAAG9G,CAAC,CAAChC,CAAF,CAAIiC,CAAJ,CAAb,CANoB,CAMC;;AACrB,UAAI8G,MAAM,GAAG,GAAb;AACA,UAAIN,IAAI,GAAG,GAAX;;AACA,WAAI,IAAIjJ,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKqF,SAAnB,EAA6BrF,CAAC,EAA9B,EAAkC;AAChC,YAAG,CAACsJ,MAAD,GAAU9G,CAAC,CAAChC,CAAF,CAAIR,CAAJ,CAAV,GAAmBuJ,MAAnB,GAA4B,CAA/B,EAAkC;AAChC;AACA;AACA;AACA;AACA;AACA/G,WAAC,CAACH,EAAF,CAAKrC,CAAL,KAAW,CAAX;AACAwC,WAAC,CAACH,EAAF,CAAKI,CAAL,KAAW,CAAX;AACAwG,cAAI,IAAI,CAACK,MAAD,GAAU9G,CAAC,CAAChC,CAAF,CAAIR,CAAJ,CAAV,GAAmBuJ,MAA3B;AACD;AACF;;AAED,aAAON,IAAP;AACD,KA7BkB;AA8BnBzB,qBAAiB,EAAE,YAAW;AAC5B,aAAO,EAAP;AACD,KAhCkB;AAiCnBjE,UAAM,EAAE,YAAW;AACjB,UAAIC,IAAI,GAAG,EAAX;AACAA,UAAI,CAAC6B,SAAL,GAAiB,KAAKA,SAAtB;AACA7B,UAAI,CAACsC,MAAL,GAAc,KAAKA,MAAnB;AACAtC,UAAI,CAACuC,MAAL,GAAc,KAAKA,MAAnB;AACAvC,UAAI,CAACwC,UAAL,GAAkB,KAAKA,UAAvB;AACAxC,UAAI,CAACsE,UAAL,GAAkB,KAAKA,UAAvB;AACA,aAAOtE,IAAP;AACD,KAzCkB;AA0CnBC,YAAQ,EAAE,UAASD,IAAT,EAAe;AACvB,WAAK6B,SAAL,GAAiB7B,IAAI,CAAC6B,SAAtB;AACA,WAAKS,MAAL,GAActC,IAAI,CAACsC,MAAnB;AACA,WAAKC,MAAL,GAAcvC,IAAI,CAACuC,MAAnB;AACA,WAAKC,UAAL,GAAkBxC,IAAI,CAACwC,UAAvB;AACA,WAAK8B,UAAL,GAAkBtE,IAAI,CAACsE,UAAvB;AACD;AAhDkB,GAArB;AAmDAxJ,QAAM,CAAC0K,eAAP,GAAyBA,eAAzB;AACA1K,QAAM,CAACkK,YAAP,GAAsBA,YAAtB;AACAlK,QAAM,CAAC+K,QAAP,GAAkBA,QAAlB;AAED,CA/ND,EA+NGjL,SA/NH;;AAiOA,CAAC,UAASE,MAAT,EAAiB;AAChB;;AACA,MAAIuD,GAAG,GAAGvD,MAAM,CAACuD,GAAjB,CAFgB,CAEM;AAEtB;AACA;AACA;;AACA,MAAI2H,SAAS,GAAG,UAAS9H,GAAT,EAAc;AAC5B,QAAIA,GAAG,GAAGA,GAAG,IAAI,EAAjB,CAD4B,CAG5B;;AACA,SAAKoE,MAAL,GAAcpE,GAAG,CAAC8D,KAAlB;AACA,SAAKO,MAAL,GAAcrE,GAAG,CAAC+D,KAAlB;AACA,SAAKJ,SAAL,GAAiB3D,GAAG,CAAC6D,QAArB;AACA,SAAKS,UAAL,GAAkB,MAAlB;AACD,GARD;;AASAwD,WAAS,CAACtH,SAAV,GAAsB;AACpBkE,WAAO,EAAE,UAASjD,CAAT,EAAYkD,WAAZ,EAAyB;AAChC,WAAKC,MAAL,GAAcnD,CAAd;AACA,UAAIsG,EAAE,GAAGtG,CAAC,CAACD,KAAF,EAAT;AACA,UAAIwG,CAAC,GAAGvG,CAAC,CAAC3C,CAAF,CAAIJ,MAAZ;AACA,UAAIuJ,GAAG,GAAGF,EAAE,CAACjJ,CAAb;;AACA,WAAI,IAAIR,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC0J,CAAd,EAAgB1J,CAAC,EAAjB,EAAqB;AACnB,YAAG2J,GAAG,CAAC3J,CAAD,CAAH,GAAS,CAAZ,EAAe2J,GAAG,CAAC3J,CAAD,CAAH,GAAS,CAAT,CADI,CACQ;AAC5B;;AACD,WAAKmH,OAAL,GAAesC,EAAf;AACA,aAAO,KAAKtC,OAAZ;AACD,KAXmB;AAYpBC,YAAQ,EAAE,YAAW;AACnB,UAAIjE,CAAC,GAAG,KAAKmD,MAAb,CADmB,CACE;;AACrB,UAAImD,EAAE,GAAG,KAAKtC,OAAd;AACA,UAAIuC,CAAC,GAAGvG,CAAC,CAAC3C,CAAF,CAAIJ,MAAZ;AACA+C,OAAC,CAACd,EAAF,GAAO/D,MAAM,CAACoB,KAAP,CAAagK,CAAb,CAAP,CAJmB,CAIK;;AACxB,WAAI,IAAI1J,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC0J,CAAd,EAAgB1J,CAAC,EAAjB,EAAqB;AACnB,YAAGyJ,EAAE,CAACjJ,CAAH,CAAKR,CAAL,KAAW,CAAd,EAAiBmD,CAAC,CAACd,EAAF,CAAKrC,CAAL,IAAU,CAAV,CAAjB,CAA8B;AAA9B,aACKmD,CAAC,CAACd,EAAF,CAAKrC,CAAL,IAAUyJ,EAAE,CAACpH,EAAH,CAAMrC,CAAN,CAAV;AACN;AACF,KArBmB;AAsBpBwH,qBAAiB,EAAE,YAAW;AAC5B,aAAO,EAAP;AACD,KAxBmB;AAyBpBjE,UAAM,EAAE,YAAW;AACjB,UAAIC,IAAI,GAAG,EAAX;AACAA,UAAI,CAAC6B,SAAL,GAAiB,KAAKA,SAAtB;AACA7B,UAAI,CAACsC,MAAL,GAAc,KAAKA,MAAnB;AACAtC,UAAI,CAACuC,MAAL,GAAc,KAAKA,MAAnB;AACAvC,UAAI,CAACwC,UAAL,GAAkB,KAAKA,UAAvB;AACA,aAAOxC,IAAP;AACD,KAhCmB;AAiCpBC,YAAQ,EAAE,UAASD,IAAT,EAAe;AACvB,WAAK6B,SAAL,GAAiB7B,IAAI,CAAC6B,SAAtB;AACA,WAAKS,MAAL,GAActC,IAAI,CAACsC,MAAnB;AACA,WAAKC,MAAL,GAAcvC,IAAI,CAACuC,MAAnB;AACA,WAAKC,UAAL,GAAkBxC,IAAI,CAACwC,UAAvB;AACD;AAtCmB,GAAtB,CAhBgB,CAyDhB;AACA;AACA;;AACA,MAAI4D,YAAY,GAAG,UAASlI,GAAT,EAAc;AAC/B,QAAIA,GAAG,GAAGA,GAAG,IAAI,EAAjB,CAD+B,CAG/B;;AACA,SAAKoE,MAAL,GAAcpE,GAAG,CAAC8D,KAAlB;AACA,SAAKO,MAAL,GAAcrE,GAAG,CAAC+D,KAAlB;AACA,SAAKJ,SAAL,GAAiB3D,GAAG,CAAC6D,QAArB;AACA,SAAKS,UAAL,GAAkB,SAAlB;AACD,GARD;;AASA4D,cAAY,CAAC1H,SAAb,GAAyB;AACvBkE,WAAO,EAAE,UAASjD,CAAT,EAAYkD,WAAZ,EAAyB;AAChC,WAAKC,MAAL,GAAcnD,CAAd;AACA,UAAIsG,EAAE,GAAGtG,CAAC,CAACF,YAAF,EAAT;AACA,UAAIyG,CAAC,GAAGvG,CAAC,CAAC3C,CAAF,CAAIJ,MAAZ;AACA,UAAIuJ,GAAG,GAAGF,EAAE,CAACjJ,CAAb;AACA,UAAIuH,EAAE,GAAG5E,CAAC,CAAC3C,CAAX;;AACA,WAAI,IAAIR,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC0J,CAAd,EAAgB1J,CAAC,EAAjB,EAAqB;AACnB2J,WAAG,CAAC3J,CAAD,CAAH,GAAS,OAAK,MAAIrB,IAAI,CAACkK,GAAL,CAAS,CAACd,EAAE,CAAC/H,CAAD,CAAZ,CAAT,CAAT;AACD;;AACD,WAAKmH,OAAL,GAAesC,EAAf;AACA,aAAO,KAAKtC,OAAZ;AACD,KAZsB;AAavBC,YAAQ,EAAE,YAAW;AACnB,UAAIjE,CAAC,GAAG,KAAKmD,MAAb,CADmB,CACE;;AACrB,UAAImD,EAAE,GAAG,KAAKtC,OAAd;AACA,UAAIuC,CAAC,GAAGvG,CAAC,CAAC3C,CAAF,CAAIJ,MAAZ;AACA+C,OAAC,CAACd,EAAF,GAAO/D,MAAM,CAACoB,KAAP,CAAagK,CAAb,CAAP,CAJmB,CAIK;;AACxB,WAAI,IAAI1J,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC0J,CAAd,EAAgB1J,CAAC,EAAjB,EAAqB;AACnB,YAAI6J,IAAI,GAAGJ,EAAE,CAACjJ,CAAH,CAAKR,CAAL,CAAX;AACAmD,SAAC,CAACd,EAAF,CAAKrC,CAAL,IAAW6J,IAAI,IAAI,MAAMA,IAAV,CAAJ,GAAsBJ,EAAE,CAACpH,EAAH,CAAMrC,CAAN,CAAjC;AACD;AACF,KAtBsB;AAuBvBwH,qBAAiB,EAAE,YAAW;AAC5B,aAAO,EAAP;AACD,KAzBsB;AA0BvBjE,UAAM,EAAE,YAAW;AACjB,UAAIC,IAAI,GAAG,EAAX;AACAA,UAAI,CAAC6B,SAAL,GAAiB,KAAKA,SAAtB;AACA7B,UAAI,CAACsC,MAAL,GAAc,KAAKA,MAAnB;AACAtC,UAAI,CAACuC,MAAL,GAAc,KAAKA,MAAnB;AACAvC,UAAI,CAACwC,UAAL,GAAkB,KAAKA,UAAvB;AACA,aAAOxC,IAAP;AACD,KAjCsB;AAkCvBC,YAAQ,EAAE,UAASD,IAAT,EAAe;AACvB,WAAK6B,SAAL,GAAiB7B,IAAI,CAAC6B,SAAtB;AACA,WAAKS,MAAL,GAActC,IAAI,CAACsC,MAAnB;AACA,WAAKC,MAAL,GAAcvC,IAAI,CAACuC,MAAnB;AACA,WAAKC,UAAL,GAAkBxC,IAAI,CAACwC,UAAvB;AACD;AAvCsB,GAAzB,CArEgB,CA+GhB;AACA;AACA;AACA;;AACA,MAAI8D,WAAW,GAAG,UAASpI,GAAT,EAAc;AAC9B,QAAIA,GAAG,GAAGA,GAAG,IAAI,EAAjB,CAD8B,CAG9B;;AACA,SAAKqI,UAAL,GAAkB,OAAOrI,GAAG,CAACqI,UAAX,KAA0B,WAA1B,GAAwCrI,GAAG,CAACqI,UAA5C,GAAyD,CAA3E,CAJ8B,CAM9B;;AACA,SAAKjE,MAAL,GAAcpE,GAAG,CAAC8D,KAAlB;AACA,SAAKO,MAAL,GAAcrE,GAAG,CAAC+D,KAAlB;AACA,SAAKJ,SAAL,GAAiB1G,IAAI,CAACW,KAAL,CAAWoC,GAAG,CAAC6D,QAAJ,GAAe,KAAKwE,UAA/B,CAAjB;AACA,SAAK/D,UAAL,GAAkB,QAAlB;AAEA,SAAKgE,QAAL,GAAgB1L,MAAM,CAACoB,KAAP,CAAa,KAAKoG,MAAL,GAAY,KAAKC,MAAjB,GAAwB,KAAKV,SAA1C,CAAhB,CAZ8B,CAYwC;AACvE,GAbD;;AAcAyE,aAAW,CAAC5H,SAAZ,GAAwB;AACtBkE,WAAO,EAAE,UAASjD,CAAT,EAAYkD,WAAZ,EAAyB;AAChC,WAAKC,MAAL,GAAcnD,CAAd;AACA,UAAIuG,CAAC,GAAG,KAAKrE,SAAb;AACA,UAAIoE,EAAE,GAAG,IAAI5H,GAAJ,CAAQ,KAAKiE,MAAb,EAAqB,KAAKC,MAA1B,EAAkC,KAAKV,SAAvC,EAAkD,GAAlD,CAAT,CAHgC,CAKhC;AACA;AACA;;AACA,UAAG,KAAKS,MAAL,KAAgB,CAAhB,IAAqB,KAAKC,MAAL,KAAgB,CAAxC,EAA2C;AACzC,aAAI,IAAI/F,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC0J,CAAd,EAAgB1J,CAAC,EAAjB,EAAqB;AACnB,cAAI2C,EAAE,GAAG3C,CAAC,GAAG,KAAK+J,UAAlB,CADmB,CACW;;AAC9B,cAAI5K,CAAC,GAAGgE,CAAC,CAAC3C,CAAF,CAAImC,EAAJ,CAAR;AACA,cAAIsH,EAAE,GAAG,CAAT;;AACA,eAAI,IAAIlJ,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKgJ,UAAnB,EAA8BhJ,CAAC,EAA/B,EAAmC;AACjC,gBAAImJ,EAAE,GAAG/G,CAAC,CAAC3C,CAAF,CAAImC,EAAE,GAAC5B,CAAP,CAAT;;AACA,gBAAGmJ,EAAE,GAAG/K,CAAR,EAAW;AACTA,eAAC,GAAG+K,EAAJ;AACAD,gBAAE,GAAGlJ,CAAL;AACD;AACF;;AACD0I,YAAE,CAACjJ,CAAH,CAAKR,CAAL,IAAUb,CAAV;AACA,eAAK6K,QAAL,CAAchK,CAAd,IAAmB2C,EAAE,GAAGsH,EAAxB;AACD;AACF,OAfD,MAeO;AACL,YAAItK,CAAC,GAAC,CAAN,CADK,CACI;;AACT,aAAI,IAAI6C,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACW,CAAC,CAACrB,EAAhB,EAAmBU,CAAC,EAApB,EAAwB;AACtB,eAAI,IAAIC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACU,CAAC,CAACpB,EAAhB,EAAmBU,CAAC,EAApB,EAAwB;AACtB,iBAAI,IAAIzC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC0J,CAAd,EAAgB1J,CAAC,EAAjB,EAAqB;AACnB,kBAAI2C,EAAE,GAAG3C,CAAC,GAAG,KAAK+J,UAAlB;AACA,kBAAI5K,CAAC,GAAGgE,CAAC,CAACZ,GAAF,CAAMC,CAAN,EAASC,CAAT,EAAYE,EAAZ,CAAR;AACA,kBAAIsH,EAAE,GAAG,CAAT;;AACA,mBAAI,IAAIlJ,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKgJ,UAAnB,EAA8BhJ,CAAC,EAA/B,EAAmC;AACjC,oBAAImJ,EAAE,GAAG/G,CAAC,CAACZ,GAAF,CAAMC,CAAN,EAASC,CAAT,EAAYE,EAAE,GAAC5B,CAAf,CAAT;;AACA,oBAAGmJ,EAAE,GAAG/K,CAAR,EAAW;AACTA,mBAAC,GAAG+K,EAAJ;AACAD,oBAAE,GAAGlJ,CAAL;AACD;AACF;;AACD0I,gBAAE,CAAC7G,GAAH,CAAOJ,CAAP,EAASC,CAAT,EAAWzC,CAAX,EAAab,CAAb;AACA,mBAAK6K,QAAL,CAAcrK,CAAd,IAAmBgD,EAAE,GAAGsH,EAAxB;AACAtK,eAAC;AACF;AACF;AACF;AAEF;;AACD,WAAKwH,OAAL,GAAesC,EAAf;AACA,aAAO,KAAKtC,OAAZ;AACD,KAjDqB;AAkDtBC,YAAQ,EAAE,YAAW;AACnB,UAAIjE,CAAC,GAAG,KAAKmD,MAAb,CADmB,CACE;;AACrB,UAAImD,EAAE,GAAG,KAAKtC,OAAd;AACA,UAAIuC,CAAC,GAAG,KAAKrE,SAAb;AACAlC,OAAC,CAACd,EAAF,GAAO/D,MAAM,CAACoB,KAAP,CAAayD,CAAC,CAAC3C,CAAF,CAAIJ,MAAjB,CAAP,CAJmB,CAIc;AAEjC;;AACA,UAAG,KAAK0F,MAAL,KAAgB,CAAhB,IAAqB,KAAKC,MAAL,KAAgB,CAAxC,EAA2C;AACzC,aAAI,IAAI/F,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC0J,CAAd,EAAgB1J,CAAC,EAAjB,EAAqB;AACnB,cAAIqH,UAAU,GAAGoC,EAAE,CAACpH,EAAH,CAAMrC,CAAN,CAAjB;AACAmD,WAAC,CAACd,EAAF,CAAK,KAAK2H,QAAL,CAAchK,CAAd,CAAL,IAAyBqH,UAAzB;AACD;AACF,OALD,MAKO;AACL;AACA,YAAI1H,CAAC,GAAC,CAAN,CAFK,CAEI;;AACT,aAAI,IAAI6C,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACiH,EAAE,CAAC3H,EAAjB,EAAoBU,CAAC,EAArB,EAAyB;AACvB,eAAI,IAAIC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACgH,EAAE,CAAC1H,EAAjB,EAAoBU,CAAC,EAArB,EAAyB;AACvB,iBAAI,IAAIzC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC0J,CAAd,EAAgB1J,CAAC,EAAjB,EAAqB;AACnB,kBAAIqH,UAAU,GAAGoC,EAAE,CAAC3G,QAAH,CAAYN,CAAZ,EAAcC,CAAd,EAAgBzC,CAAhB,CAAjB;AACAmD,eAAC,CAACJ,QAAF,CAAWP,CAAX,EAAaC,CAAb,EAAe,KAAKuH,QAAL,CAAcrK,CAAd,CAAf,EAAgC0H,UAAhC;AACA1H,eAAC;AACF;AACF;AACF;AACF;AACF,KA3EqB;AA4EtB6H,qBAAiB,EAAE,YAAW;AAC5B,aAAO,EAAP;AACD,KA9EqB;AA+EtBjE,UAAM,EAAE,YAAW;AACjB,UAAIC,IAAI,GAAG,EAAX;AACAA,UAAI,CAAC6B,SAAL,GAAiB,KAAKA,SAAtB;AACA7B,UAAI,CAACsC,MAAL,GAAc,KAAKA,MAAnB;AACAtC,UAAI,CAACuC,MAAL,GAAc,KAAKA,MAAnB;AACAvC,UAAI,CAACwC,UAAL,GAAkB,KAAKA,UAAvB;AACAxC,UAAI,CAACuG,UAAL,GAAkB,KAAKA,UAAvB;AACA,aAAOvG,IAAP;AACD,KAvFqB;AAwFtBC,YAAQ,EAAE,UAASD,IAAT,EAAe;AACvB,WAAK6B,SAAL,GAAiB7B,IAAI,CAAC6B,SAAtB;AACA,WAAKS,MAAL,GAActC,IAAI,CAACsC,MAAnB;AACA,WAAKC,MAAL,GAAcvC,IAAI,CAACuC,MAAnB;AACA,WAAKC,UAAL,GAAkBxC,IAAI,CAACwC,UAAvB;AACA,WAAK+D,UAAL,GAAkBvG,IAAI,CAACuG,UAAvB;AACA,WAAKC,QAAL,GAAgB1L,MAAM,CAACoB,KAAP,CAAa,KAAKqK,UAAlB,CAAhB;AACD;AA/FqB,GAAxB,CAjIgB,CAmOhB;;AACA,WAASI,IAAT,CAAc3H,CAAd,EAAiB;AACf,QAAIC,CAAC,GAAG9D,IAAI,CAACkK,GAAL,CAAS,IAAIrG,CAAb,CAAR;AACA,WAAO,CAACC,CAAC,GAAG,CAAL,KAAWA,CAAC,GAAG,CAAf,CAAP;AACD,GAvOe,CAwOhB;AACA;AACA;;;AACA,MAAI2H,SAAS,GAAG,UAAS1I,GAAT,EAAc;AAC5B,QAAIA,GAAG,GAAGA,GAAG,IAAI,EAAjB,CAD4B,CAG5B;;AACA,SAAKoE,MAAL,GAAcpE,GAAG,CAAC8D,KAAlB;AACA,SAAKO,MAAL,GAAcrE,GAAG,CAAC+D,KAAlB;AACA,SAAKJ,SAAL,GAAiB3D,GAAG,CAAC6D,QAArB;AACA,SAAKS,UAAL,GAAkB,MAAlB;AACD,GARD;;AASAoE,WAAS,CAAClI,SAAV,GAAsB;AACpBkE,WAAO,EAAE,UAASjD,CAAT,EAAYkD,WAAZ,EAAyB;AAChC,WAAKC,MAAL,GAAcnD,CAAd;AACA,UAAIsG,EAAE,GAAGtG,CAAC,CAACF,YAAF,EAAT;AACA,UAAIyG,CAAC,GAAGvG,CAAC,CAAC3C,CAAF,CAAIJ,MAAZ;;AACA,WAAI,IAAIJ,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC0J,CAAd,EAAgB1J,CAAC,EAAjB,EAAqB;AACnByJ,UAAE,CAACjJ,CAAH,CAAKR,CAAL,IAAUmK,IAAI,CAAChH,CAAC,CAAC3C,CAAF,CAAIR,CAAJ,CAAD,CAAd;AACD;;AACD,WAAKmH,OAAL,GAAesC,EAAf;AACA,aAAO,KAAKtC,OAAZ;AACD,KAVmB;AAWpBC,YAAQ,EAAE,YAAW;AACnB,UAAIjE,CAAC,GAAG,KAAKmD,MAAb,CADmB,CACE;;AACrB,UAAImD,EAAE,GAAG,KAAKtC,OAAd;AACA,UAAIuC,CAAC,GAAGvG,CAAC,CAAC3C,CAAF,CAAIJ,MAAZ;AACA+C,OAAC,CAACd,EAAF,GAAO/D,MAAM,CAACoB,KAAP,CAAagK,CAAb,CAAP,CAJmB,CAIK;;AACxB,WAAI,IAAI1J,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC0J,CAAd,EAAgB1J,CAAC,EAAjB,EAAqB;AACnB,YAAI6J,IAAI,GAAGJ,EAAE,CAACjJ,CAAH,CAAKR,CAAL,CAAX;AACAmD,SAAC,CAACd,EAAF,CAAKrC,CAAL,IAAU,CAAC,MAAM6J,IAAI,GAAGA,IAAd,IAAsBJ,EAAE,CAACpH,EAAH,CAAMrC,CAAN,CAAhC;AACD;AACF,KApBmB;AAqBpBwH,qBAAiB,EAAE,YAAW;AAC5B,aAAO,EAAP;AACD,KAvBmB;AAwBpBjE,UAAM,EAAE,YAAW;AACjB,UAAIC,IAAI,GAAG,EAAX;AACAA,UAAI,CAAC6B,SAAL,GAAiB,KAAKA,SAAtB;AACA7B,UAAI,CAACsC,MAAL,GAAc,KAAKA,MAAnB;AACAtC,UAAI,CAACuC,MAAL,GAAc,KAAKA,MAAnB;AACAvC,UAAI,CAACwC,UAAL,GAAkB,KAAKA,UAAvB;AACA,aAAOxC,IAAP;AACD,KA/BmB;AAgCpBC,YAAQ,EAAE,UAASD,IAAT,EAAe;AACvB,WAAK6B,SAAL,GAAiB7B,IAAI,CAAC6B,SAAtB;AACA,WAAKS,MAAL,GAActC,IAAI,CAACsC,MAAnB;AACA,WAAKC,MAAL,GAAcvC,IAAI,CAACuC,MAAnB;AACA,WAAKC,UAAL,GAAkBxC,IAAI,CAACwC,UAAvB;AACD;AArCmB,GAAtB;AAwCA1H,QAAM,CAAC8L,SAAP,GAAmBA,SAAnB;AACA9L,QAAM,CAACwL,WAAP,GAAqBA,WAArB;AACAxL,QAAM,CAACkL,SAAP,GAAmBA,SAAnB;AACAlL,QAAM,CAACsL,YAAP,GAAsBA,YAAtB;AAED,CAjSD,EAiSGxL,SAjSH;;AAmSA,CAAC,UAASE,MAAT,EAAiB;AAChB;;AACA,MAAIuD,GAAG,GAAGvD,MAAM,CAACuD,GAAjB,CAFgB,CAEM;AAEtB;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIwI,YAAY,GAAG,UAAS3I,GAAT,EAAc;AAC/B,QAAIA,GAAG,GAAGA,GAAG,IAAI,EAAjB,CAD+B,CAG/B;;AACA,SAAKoE,MAAL,GAAcpE,GAAG,CAAC8D,KAAlB;AACA,SAAKO,MAAL,GAAcrE,GAAG,CAAC+D,KAAlB;AACA,SAAKJ,SAAL,GAAiB3D,GAAG,CAAC6D,QAArB;AACA,SAAKS,UAAL,GAAkB,SAAlB;AACA,SAAKsE,SAAL,GAAiB,OAAO5I,GAAG,CAAC4I,SAAX,KAAyB,WAAzB,GAAuC5I,GAAG,CAAC4I,SAA3C,GAAuD,GAAxE;AACA,SAAKC,OAAL,GAAejM,MAAM,CAACoB,KAAP,CAAa,KAAKoG,MAAL,GAAY,KAAKC,MAAjB,GAAwB,KAAKV,SAA1C,CAAf;AACD,GAVD;;AAWAgF,cAAY,CAACnI,SAAb,GAAyB;AACvBkE,WAAO,EAAE,UAASjD,CAAT,EAAYkD,WAAZ,EAAyB;AAChC,WAAKC,MAAL,GAAcnD,CAAd;;AACA,UAAG,OAAOkD,WAAP,KAAsB,WAAzB,EAAsC;AAAEA,mBAAW,GAAG,KAAd;AAAsB,OAF9B,CAE+B;;;AAC/D,UAAIoD,EAAE,GAAGtG,CAAC,CAACD,KAAF,EAAT;AACA,UAAIwG,CAAC,GAAGvG,CAAC,CAAC3C,CAAF,CAAIJ,MAAZ;;AACA,UAAGiG,WAAH,EAAgB;AACd;AACA,aAAI,IAAIrG,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC0J,CAAd,EAAgB1J,CAAC,EAAjB,EAAqB;AACnB,cAAGrB,IAAI,CAACC,MAAL,KAAc,KAAK0L,SAAtB,EAAiC;AAAEb,cAAE,CAACjJ,CAAH,CAAKR,CAAL,IAAQ,CAAR;AAAW,iBAAKuK,OAAL,CAAavK,CAAb,IAAkB,IAAlB;AAAyB,WAAvE,CAAwE;AAAxE,eACK;AAAC,iBAAKuK,OAAL,CAAavK,CAAb,IAAkB,KAAlB;AAAyB;AAChC;AACF,OAND,MAMO;AACL;AACA,aAAI,IAAIA,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC0J,CAAd,EAAgB1J,CAAC,EAAjB,EAAqB;AAAEyJ,YAAE,CAACjJ,CAAH,CAAKR,CAAL,KAAS,KAAKsK,SAAd;AAA0B;AAClD;;AACD,WAAKnD,OAAL,GAAesC,EAAf;AACA,aAAO,KAAKtC,OAAZ,CAhBgC,CAgBX;AACtB,KAlBsB;AAmBvBC,YAAQ,EAAE,YAAW;AACnB,UAAIjE,CAAC,GAAG,KAAKmD,MAAb,CADmB,CACE;;AACrB,UAAIe,UAAU,GAAG,KAAKF,OAAtB;AACA,UAAIuC,CAAC,GAAGvG,CAAC,CAAC3C,CAAF,CAAIJ,MAAZ;AACA+C,OAAC,CAACd,EAAF,GAAO/D,MAAM,CAACoB,KAAP,CAAagK,CAAb,CAAP,CAJmB,CAIK;;AACxB,WAAI,IAAI1J,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC0J,CAAd,EAAgB1J,CAAC,EAAjB,EAAqB;AACnB,YAAG,CAAE,KAAKuK,OAAL,CAAavK,CAAb,CAAL,EAAuB;AACrBmD,WAAC,CAACd,EAAF,CAAKrC,CAAL,IAAUqH,UAAU,CAAChF,EAAX,CAAcrC,CAAd,CAAV,CADqB,CACO;AAC7B;AACF;AACF,KA7BsB;AA8BvBwH,qBAAiB,EAAE,YAAW;AAC5B,aAAO,EAAP;AACD,KAhCsB;AAiCvBjE,UAAM,EAAE,YAAW;AACjB,UAAIC,IAAI,GAAG,EAAX;AACAA,UAAI,CAAC6B,SAAL,GAAiB,KAAKA,SAAtB;AACA7B,UAAI,CAACsC,MAAL,GAAc,KAAKA,MAAnB;AACAtC,UAAI,CAACuC,MAAL,GAAc,KAAKA,MAAnB;AACAvC,UAAI,CAACwC,UAAL,GAAkB,KAAKA,UAAvB;AACAxC,UAAI,CAAC8G,SAAL,GAAiB,KAAKA,SAAtB;AACA,aAAO9G,IAAP;AACD,KAzCsB;AA0CvBC,YAAQ,EAAE,UAASD,IAAT,EAAe;AACvB,WAAK6B,SAAL,GAAiB7B,IAAI,CAAC6B,SAAtB;AACA,WAAKS,MAAL,GAActC,IAAI,CAACsC,MAAnB;AACA,WAAKC,MAAL,GAAcvC,IAAI,CAACuC,MAAnB;AACA,WAAKC,UAAL,GAAkBxC,IAAI,CAACwC,UAAvB;AACA,WAAKsE,SAAL,GAAiB9G,IAAI,CAAC8G,SAAtB;AACD;AAhDsB,GAAzB;AAoDAhM,QAAM,CAAC+L,YAAP,GAAsBA,YAAtB;AACD,CA1ED,EA0EGjM,SA1EH;;AA2EA,CAAC,UAASE,MAAT,EAAiB;AAChB;;AACA,MAAIuD,GAAG,GAAGvD,MAAM,CAACuD,GAAjB,CAFgB,CAEM;AAEtB;AACA;AACA;;AACA,MAAI2I,+BAA+B,GAAG,UAAS9I,GAAT,EAAc;AAClD,QAAIA,GAAG,GAAGA,GAAG,IAAI,EAAjB,CADkD,CAGlD;;AACA,SAAKF,CAAL,GAASE,GAAG,CAACF,CAAb;AACA,SAAK7B,CAAL,GAAS+B,GAAG,CAAC/B,CAAb;AACA,SAAK8K,KAAL,GAAa/I,GAAG,CAAC+I,KAAjB;AACA,SAAKC,IAAL,GAAYhJ,GAAG,CAACgJ,IAAhB,CAPkD,CASlD;;AACA,SAAK5E,MAAL,GAAcpE,GAAG,CAAC8D,KAAlB;AACA,SAAKO,MAAL,GAAcrE,GAAG,CAAC+D,KAAlB;AACA,SAAKJ,SAAL,GAAiB3D,GAAG,CAAC6D,QAArB;AACA,SAAKS,UAAL,GAAkB,KAAlB,CAbkD,CAelD;;AACA,QAAG,KAAKrG,CAAL,GAAO,CAAP,KAAa,CAAhB,EAAmB;AAAEgL,aAAO,CAAC1L,GAAR,CAAY,uCAAZ;AAAuD;AAC7E,GAjBD;;AAkBAuL,iCAA+B,CAACtI,SAAhC,GAA4C;AAC1CkE,WAAO,EAAE,UAASjD,CAAT,EAAYkD,WAAZ,EAAyB;AAChC,WAAKC,MAAL,GAAcnD,CAAd;AAEA,UAAIoD,CAAC,GAAGpD,CAAC,CAACF,YAAF,EAAR;AACA,WAAK2H,QAAL,GAAgBzH,CAAC,CAACF,YAAF,EAAhB;AACA,UAAI4H,EAAE,GAAGlM,IAAI,CAACW,KAAL,CAAW,KAAKK,CAAL,GAAO,CAAlB,CAAT;;AACA,WAAI,IAAI6C,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACW,CAAC,CAACrB,EAAhB,EAAmBU,CAAC,EAApB,EAAwB;AACtB,aAAI,IAAIC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACU,CAAC,CAACpB,EAAhB,EAAmBU,CAAC,EAApB,EAAwB;AACtB,eAAI,IAAIzC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACmD,CAAC,CAACnB,KAAhB,EAAsBhC,CAAC,EAAvB,EAA2B;AAEzB,gBAAIiK,EAAE,GAAG9G,CAAC,CAACZ,GAAF,CAAMC,CAAN,EAAQC,CAAR,EAAUzC,CAAV,CAAT,CAFyB,CAIzB;;AACA,gBAAI8K,GAAG,GAAG,GAAV;;AACA,iBAAI,IAAI/J,CAAC,GAACpC,IAAI,CAACoM,GAAL,CAAS,CAAT,EAAW/K,CAAC,GAAC6K,EAAb,CAAV,EAA2B9J,CAAC,IAAEpC,IAAI,CAACqM,GAAL,CAAShL,CAAC,GAAC6K,EAAX,EAAc1H,CAAC,CAACnB,KAAF,GAAQ,CAAtB,CAA9B,EAAuDjB,CAAC,EAAxD,EAA4D;AAC1D,kBAAIkK,EAAE,GAAG9H,CAAC,CAACZ,GAAF,CAAMC,CAAN,EAAQC,CAAR,EAAU1B,CAAV,CAAT;AACA+J,iBAAG,IAAIG,EAAE,GAACA,EAAV;AACD;;AACDH,eAAG,IAAI,KAAKL,KAAL,GAAa,KAAK9K,CAAzB;AACAmL,eAAG,IAAI,KAAKtJ,CAAZ;AACA,iBAAKoJ,QAAL,CAAchI,GAAd,CAAkBJ,CAAlB,EAAoBC,CAApB,EAAsBzC,CAAtB,EAAwB8K,GAAxB,EAZyB,CAYK;;AAC9BA,eAAG,GAAGnM,IAAI,CAACuM,GAAL,CAASJ,GAAT,EAAc,KAAKJ,IAAnB,CAAN;AACAnE,aAAC,CAAC3D,GAAF,CAAMJ,CAAN,EAAQC,CAAR,EAAUzC,CAAV,EAAYiK,EAAE,GAACa,GAAf;AACD;AACF;AACF;;AAED,WAAK3D,OAAL,GAAeZ,CAAf;AACA,aAAO,KAAKY,OAAZ,CA5BgC,CA4BX;AACtB,KA9ByC;AA+B1CC,YAAQ,EAAE,YAAW;AACnB;AACA,UAAIjE,CAAC,GAAG,KAAKmD,MAAb,CAFmB,CAEE;;AACrBnD,OAAC,CAACd,EAAF,GAAO/D,MAAM,CAACoB,KAAP,CAAayD,CAAC,CAAC3C,CAAF,CAAIJ,MAAjB,CAAP,CAHmB,CAGc;;AACjC,UAAImG,CAAC,GAAG,KAAKY,OAAb,CAJmB,CAIG;;AAEtB,UAAI0D,EAAE,GAAGlM,IAAI,CAACW,KAAL,CAAW,KAAKK,CAAL,GAAO,CAAlB,CAAT;;AACA,WAAI,IAAI6C,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACW,CAAC,CAACrB,EAAhB,EAAmBU,CAAC,EAApB,EAAwB;AACtB,aAAI,IAAIC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACU,CAAC,CAACpB,EAAhB,EAAmBU,CAAC,EAApB,EAAwB;AACtB,eAAI,IAAIzC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACmD,CAAC,CAACnB,KAAhB,EAAsBhC,CAAC,EAAvB,EAA2B;AAEzB,gBAAIqH,UAAU,GAAG,KAAKF,OAAL,CAAarE,QAAb,CAAsBN,CAAtB,EAAwBC,CAAxB,EAA0BzC,CAA1B,CAAjB;AACA,gBAAImL,CAAC,GAAG,KAAKP,QAAL,CAAcrI,GAAd,CAAkBC,CAAlB,EAAoBC,CAApB,EAAsBzC,CAAtB,CAAR;AACA,gBAAIoL,EAAE,GAAGzM,IAAI,CAACuM,GAAL,CAASC,CAAT,EAAY,KAAKT,IAAjB,CAAT;AACA,gBAAIW,GAAG,GAAGD,EAAE,GAACA,EAAb,CALyB,CAOzB;;AACA,iBAAI,IAAIrK,CAAC,GAACpC,IAAI,CAACoM,GAAL,CAAS,CAAT,EAAW/K,CAAC,GAAC6K,EAAb,CAAV,EAA2B9J,CAAC,IAAEpC,IAAI,CAACqM,GAAL,CAAShL,CAAC,GAAC6K,EAAX,EAAc1H,CAAC,CAACnB,KAAF,GAAQ,CAAtB,CAA9B,EAAuDjB,CAAC,EAAxD,EAA4D;AAC1D,kBAAIuK,EAAE,GAAGnI,CAAC,CAACZ,GAAF,CAAMC,CAAN,EAAQC,CAAR,EAAU1B,CAAV,CAAT;AACA,kBAAIwK,CAAC,GAAG,CAACD,EAAD,GAAI,KAAKZ,IAAT,GAAc/L,IAAI,CAACuM,GAAL,CAASC,CAAT,EAAW,KAAKT,IAAL,GAAU,CAArB,CAAd,GAAsC,KAAKD,KAA3C,GAAiD,KAAK9K,CAAtD,GAAwD,CAAxD,GAA0D2L,EAAlE;AACA,kBAAGvK,CAAC,KAAGf,CAAP,EAAUuL,CAAC,IAAGH,EAAJ;AACVG,eAAC,IAAIF,GAAL;AACAE,eAAC,IAAIlE,UAAL;AACAlE,eAAC,CAACH,QAAF,CAAWR,CAAX,EAAaC,CAAb,EAAe1B,CAAf,EAAiBwK,CAAjB;AACD;AAEF;AACF;AACF;AACF,KA5DyC;AA6D1C/D,qBAAiB,EAAE,YAAW;AAAE,aAAO,EAAP;AAAY,KA7DF;AA8D1CjE,UAAM,EAAE,YAAW;AACjB,UAAIC,IAAI,GAAG,EAAX;AACAA,UAAI,CAAChC,CAAL,GAAS,KAAKA,CAAd;AACAgC,UAAI,CAAC7D,CAAL,GAAS,KAAKA,CAAd;AACA6D,UAAI,CAACiH,KAAL,GAAa,KAAKA,KAAlB,CAJiB,CAIQ;;AACzBjH,UAAI,CAACkH,IAAL,GAAY,KAAKA,IAAjB;AACAlH,UAAI,CAACsC,MAAL,GAAc,KAAKA,MAAnB;AACAtC,UAAI,CAACuC,MAAL,GAAc,KAAKA,MAAnB;AACAvC,UAAI,CAAC6B,SAAL,GAAiB,KAAKA,SAAtB;AACA7B,UAAI,CAACwC,UAAL,GAAkB,KAAKA,UAAvB;AACA,aAAOxC,IAAP;AACD,KAzEyC;AA0E1CC,YAAQ,EAAE,UAASD,IAAT,EAAe;AACvB,WAAKhC,CAAL,GAASgC,IAAI,CAAChC,CAAd;AACA,WAAK7B,CAAL,GAAS6D,IAAI,CAAC7D,CAAd;AACA,WAAK8K,KAAL,GAAajH,IAAI,CAACiH,KAAlB,CAHuB,CAGE;;AACzB,WAAKC,IAAL,GAAYlH,IAAI,CAACkH,IAAjB;AACA,WAAK5E,MAAL,GAActC,IAAI,CAACsC,MAAnB;AACA,WAAKC,MAAL,GAAcvC,IAAI,CAACuC,MAAnB;AACA,WAAKV,SAAL,GAAiB7B,IAAI,CAAC6B,SAAtB;AACA,WAAKW,UAAL,GAAkBxC,IAAI,CAACwC,UAAvB;AACD;AAnFyC,GAA5C;AAuFA1H,QAAM,CAACkM,+BAAP,GAAyCA,+BAAzC;AACD,CAjHD,EAiHGpM,SAjHH;;AAkHA,CAAC,UAASE,MAAT,EAAiB;AAChB;;AACA,MAAIuD,GAAG,GAAGvD,MAAM,CAACuD,GAAjB,CAFgB,CAEM;AAEtB;AACA;;AACA,MAAI2J,GAAG,GAAG,UAASC,OAAT,EAAkB;AAC1B,SAAKC,MAAL,GAAc,EAAd;AACD,GAFD;;AAIAF,KAAG,CAACtJ,SAAJ,GAAgB;AAEd;AACAyJ,cAAU,EAAE,UAASC,IAAT,EAAe;AAEzB;AACA,UAAGA,IAAI,CAACxL,MAAL,GAAY,CAAf,EAAkB;AAACuK,eAAO,CAAC1L,GAAR,CAAY,wDAAZ;AAAuE;;AAC1F,UAAG2M,IAAI,CAAC,CAAD,CAAJ,CAAQC,IAAR,KAAiB,OAApB,EAA6B;AAAClB,eAAO,CAAC1L,GAAR,CAAY,6CAAZ;AAA4D,OAJjE,CAMzB;;;AACA,UAAI6M,OAAO,GAAG,YAAW;AACvB,YAAIC,QAAQ,GAAG,EAAf;;AACA,aAAI,IAAI/L,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC4L,IAAI,CAACxL,MAAnB,EAA0BJ,CAAC,EAA3B,EAA+B;AAC7B,cAAIgM,GAAG,GAAGJ,IAAI,CAAC5L,CAAD,CAAd;;AAEA,cAAGgM,GAAG,CAACH,IAAJ,KAAW,SAAX,IAAwBG,GAAG,CAACH,IAAJ,KAAW,KAAtC,EAA6C;AAC3C;AACA;AACAE,oBAAQ,CAACzL,IAAT,CAAc;AAACuL,kBAAI,EAAC,IAAN;AAAYhE,yBAAW,EAAEmE,GAAG,CAACC;AAA7B,aAAd;AACD;;AAED,cAAGD,GAAG,CAACH,IAAJ,KAAW,YAAd,EAA4B;AAC1B;AACA;AACAE,oBAAQ,CAACzL,IAAT,CAAc;AAACuL,kBAAI,EAAC,IAAN;AAAYhE,yBAAW,EAAEmE,GAAG,CAACnE;AAA7B,aAAd;AACD;;AAED,cAAG,CAACmE,GAAG,CAACH,IAAJ,KAAW,IAAX,IAAmBG,GAAG,CAACH,IAAJ,KAAW,MAA/B,KACI,OAAOG,GAAG,CAAC9F,SAAX,KAA0B,WADjC,EAC6C;AAC3C8F,eAAG,CAAC9F,SAAJ,GAAgB,GAAhB;;AACA,gBAAG,OAAO8F,GAAG,CAACE,UAAX,KAA0B,WAA1B,IAAyCF,GAAG,CAACE,UAAJ,KAAmB,MAA/D,EAAuE;AACrEF,iBAAG,CAAC9F,SAAJ,GAAgB,GAAhB,CADqE,CAChD;AACrB;AACA;AACD;AACF;;AAED,cAAG,OAAO8F,GAAG,CAACG,MAAX,KAAsB,WAAzB,EAAsC;AACpC;AACA;AACA,gBAAGH,GAAG,CAACG,MAAP,EAAe;AACbJ,sBAAQ,CAACzL,IAAT,CAAc;AAACuL,oBAAI,EAAE;AAAP,eAAd;AACD;AACF;;AAEDE,kBAAQ,CAACzL,IAAT,CAAc0L,GAAd;;AAEA,cAAG,OAAOA,GAAG,CAACE,UAAX,KAA0B,WAA7B,EAA0C;AACxC,gBAAGF,GAAG,CAACE,UAAJ,KAAiB,MAApB,EAA4B;AAAEH,sBAAQ,CAACzL,IAAT,CAAc;AAACuL,oBAAI,EAAC;AAAN,eAAd;AAA+B,aAA7D,MACK,IAAIG,GAAG,CAACE,UAAJ,KAAiB,SAArB,EAAgC;AAAEH,sBAAQ,CAACzL,IAAT,CAAc;AAACuL,oBAAI,EAAC;AAAN,eAAd;AAAkC,aAApE,MACA,IAAIG,GAAG,CAACE,UAAJ,KAAiB,MAArB,EAA6B;AAAEH,sBAAQ,CAACzL,IAAT,CAAc;AAACuL,oBAAI,EAAC;AAAN,eAAd;AAA+B,aAA9D,MACA,IAAIG,GAAG,CAACE,UAAJ,KAAiB,QAArB,EAA+B;AAClC;AACA,kBAAIE,EAAE,GAAGJ,GAAG,CAACjC,UAAJ,KAAmB,WAAnB,GAAiCiC,GAAG,CAACjC,UAArC,GAAkD,CAA3D;AACAgC,sBAAQ,CAACzL,IAAT,CAAc;AAACuL,oBAAI,EAAC,QAAN;AAAgB9B,0BAAU,EAACqC;AAA3B,eAAd;AACD,aAJI,MAKA;AAAEzB,qBAAO,CAAC1L,GAAR,CAAY,kCAAkC+M,GAAG,CAACE,UAAlD;AAAgE;AACxE;;AACD,cAAG,OAAOF,GAAG,CAAC1B,SAAX,KAAyB,WAAzB,IAAwC0B,GAAG,CAACH,IAAJ,KAAa,SAAxD,EAAmE;AACjEE,oBAAQ,CAACzL,IAAT,CAAc;AAACuL,kBAAI,EAAC,SAAN;AAAiBvB,uBAAS,EAAE0B,GAAG,CAAC1B;AAAhC,aAAd;AACD;AAEF;;AACD,eAAOyB,QAAP;AACD,OAtDD;;AAuDAH,UAAI,GAAGE,OAAO,CAACF,IAAD,CAAd,CA9DyB,CAgEzB;;AACA,WAAKF,MAAL,GAAc,EAAd;;AACA,WAAI,IAAI1L,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC4L,IAAI,CAACxL,MAAnB,EAA0BJ,CAAC,EAA3B,EAA+B;AAC7B,YAAIgM,GAAG,GAAGJ,IAAI,CAAC5L,CAAD,CAAd;;AACA,YAAGA,CAAC,GAAC,CAAL,EAAQ;AACN,cAAIqM,IAAI,GAAG,KAAKX,MAAL,CAAY1L,CAAC,GAAC,CAAd,CAAX;AACAgM,aAAG,CAACxG,KAAJ,GAAY6G,IAAI,CAACvG,MAAjB;AACAkG,aAAG,CAACvG,KAAJ,GAAY4G,IAAI,CAACtG,MAAjB;AACAiG,aAAG,CAACzG,QAAJ,GAAe8G,IAAI,CAAChH,SAApB;AACD;;AAED,gBAAO2G,GAAG,CAACH,IAAX;AACE,eAAK,IAAL;AAAW,iBAAKH,MAAL,CAAYpL,IAAZ,CAAiB,IAAIhC,MAAM,CAACsJ,cAAX,CAA0BoE,GAA1B,CAAjB;AAAkD;;AAC7D,eAAK,KAAL;AAAY,iBAAKN,MAAL,CAAYpL,IAAZ,CAAiB,IAAIhC,MAAM,CAACkM,+BAAX,CAA2CwB,GAA3C,CAAjB;AAAmE;;AAC/E,eAAK,SAAL;AAAgB,iBAAKN,MAAL,CAAYpL,IAAZ,CAAiB,IAAIhC,MAAM,CAAC+L,YAAX,CAAwB2B,GAAxB,CAAjB;AAAgD;;AAChE,eAAK,OAAL;AAAc,iBAAKN,MAAL,CAAYpL,IAAZ,CAAiB,IAAIhC,MAAM,CAACiK,UAAX,CAAsByD,GAAtB,CAAjB;AAA8C;;AAC5D,eAAK,SAAL;AAAgB,iBAAKN,MAAL,CAAYpL,IAAZ,CAAiB,IAAIhC,MAAM,CAACkK,YAAX,CAAwBwD,GAAxB,CAAjB;AAAgD;;AAChE,eAAK,YAAL;AAAmB,iBAAKN,MAAL,CAAYpL,IAAZ,CAAiB,IAAIhC,MAAM,CAAC0K,eAAX,CAA2BgD,GAA3B,CAAjB;AAAmD;;AACtE,eAAK,MAAL;AAAa,iBAAKN,MAAL,CAAYpL,IAAZ,CAAiB,IAAIhC,MAAM,CAAC8G,SAAX,CAAqB4G,GAArB,CAAjB;AAA6C;;AAC1D,eAAK,MAAL;AAAa,iBAAKN,MAAL,CAAYpL,IAAZ,CAAiB,IAAIhC,MAAM,CAAC4J,SAAX,CAAqB8D,GAArB,CAAjB;AAA6C;;AAC1D,eAAK,MAAL;AAAa,iBAAKN,MAAL,CAAYpL,IAAZ,CAAiB,IAAIhC,MAAM,CAACkL,SAAX,CAAqBwC,GAArB,CAAjB;AAA6C;;AAC1D,eAAK,SAAL;AAAgB,iBAAKN,MAAL,CAAYpL,IAAZ,CAAiB,IAAIhC,MAAM,CAACsL,YAAX,CAAwBoC,GAAxB,CAAjB;AAAgD;;AAChE,eAAK,MAAL;AAAa,iBAAKN,MAAL,CAAYpL,IAAZ,CAAiB,IAAIhC,MAAM,CAAC8L,SAAX,CAAqB4B,GAArB,CAAjB;AAA6C;;AAC1D,eAAK,QAAL;AAAe,iBAAKN,MAAL,CAAYpL,IAAZ,CAAiB,IAAIhC,MAAM,CAACwL,WAAX,CAAuBkC,GAAvB,CAAjB;AAA+C;;AAC9D,eAAK,eAAL;AAAsB,iBAAKN,MAAL,CAAYpL,IAAZ,CAAiB,IAAIhC,MAAM,CAACgO,kBAAX,CAA8BN,GAA9B,CAAjB;AAAsD;;AAC5E,eAAK,KAAL;AAAY,iBAAKN,MAAL,CAAYpL,IAAZ,CAAiB,IAAIhC,MAAM,CAAC+K,QAAX,CAAoB2C,GAApB,CAAjB;AAA4C;;AACxD;AAASrB,mBAAO,CAAC1L,GAAR,CAAY,iCAAZ;AAfX;AAiBD;AACF,KAhGa;AAkGd;AACAmH,WAAO,EAAE,UAASjD,CAAT,EAAYkD,WAAZ,EAAyB;AAChC,UAAG,OAAOA,WAAP,KAAsB,WAAzB,EAAsCA,WAAW,GAAG,KAAd;AACtC,UAAIkG,GAAG,GAAG,KAAKb,MAAL,CAAY,CAAZ,EAAetF,OAAf,CAAuBjD,CAAvB,EAA0BkD,WAA1B,CAAV;;AACA,WAAI,IAAIrG,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAK0L,MAAL,CAAYtL,MAA1B,EAAiCJ,CAAC,EAAlC,EAAsC;AACpCuM,WAAG,GAAG,KAAKb,MAAL,CAAY1L,CAAZ,EAAeoG,OAAf,CAAuBmG,GAAvB,EAA4BlG,WAA5B,CAAN;AACD;;AACD,aAAOkG,GAAP;AACD,KA1Ga;AA4GdC,eAAW,EAAE,UAASrJ,CAAT,EAAYV,CAAZ,EAAe;AAC1B,WAAK2D,OAAL,CAAajD,CAAb,EAAgB,KAAhB;AACA,UAAIuG,CAAC,GAAG,KAAKgC,MAAL,CAAYtL,MAApB;AACA,UAAI6I,IAAI,GAAG,KAAKyC,MAAL,CAAYhC,CAAC,GAAC,CAAd,EAAiBtC,QAAjB,CAA0B3E,CAA1B,CAAX;AACA,aAAOwG,IAAP;AACD,KAjHa;AAmHd;AACA7B,YAAQ,EAAE,UAAS3E,CAAT,EAAY;AACpB,UAAIiH,CAAC,GAAG,KAAKgC,MAAL,CAAYtL,MAApB;AACA,UAAI6I,IAAI,GAAG,KAAKyC,MAAL,CAAYhC,CAAC,GAAC,CAAd,EAAiBtC,QAAjB,CAA0B3E,CAA1B,CAAX,CAFoB,CAEqB;;AACzC,WAAI,IAAIzC,CAAC,GAAC0J,CAAC,GAAC,CAAZ,EAAc1J,CAAC,IAAE,CAAjB,EAAmBA,CAAC,EAApB,EAAwB;AAAE;AACxB,aAAK0L,MAAL,CAAY1L,CAAZ,EAAeoH,QAAf;AACD;;AACD,aAAO6B,IAAP;AACD,KA3Ha;AA4HdzB,qBAAiB,EAAE,YAAW;AAC5B;AACA,UAAIC,QAAQ,GAAG,EAAf;;AACA,WAAI,IAAIzH,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAK0L,MAAL,CAAYtL,MAA1B,EAAiCJ,CAAC,EAAlC,EAAsC;AACpC,YAAIyM,aAAa,GAAG,KAAKf,MAAL,CAAY1L,CAAZ,EAAewH,iBAAf,EAApB;;AACA,aAAI,IAAIzG,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC0L,aAAa,CAACrM,MAA5B,EAAmCW,CAAC,EAApC,EAAwC;AACtC0G,kBAAQ,CAACnH,IAAT,CAAcmM,aAAa,CAAC1L,CAAD,CAA3B;AACD;AACF;;AACD,aAAO0G,QAAP;AACD,KAtIa;AAuIdiF,iBAAa,EAAE,YAAW;AACxB,UAAIvB,CAAC,GAAG,KAAKO,MAAL,CAAY,KAAKA,MAAL,CAAYtL,MAAZ,GAAmB,CAA/B,CAAR,CADwB,CACmB;;AAC3C,UAAIkB,CAAC,GAAG6J,CAAC,CAAChE,OAAF,CAAU3G,CAAlB;AACA,UAAIC,IAAI,GAAGa,CAAC,CAAC,CAAD,CAAZ;AACA,UAAIX,IAAI,GAAG,CAAX;;AACA,WAAI,IAAIX,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACsB,CAAC,CAAClB,MAAhB,EAAuBJ,CAAC,EAAxB,EAA4B;AAC1B,YAAGsB,CAAC,CAACtB,CAAD,CAAD,GAAOS,IAAV,EAAgB;AAAEA,cAAI,GAAGa,CAAC,CAACtB,CAAD,CAAR;AAAaW,cAAI,GAAGX,CAAP;AAAU;AAC1C;;AACD,aAAOW,IAAP;AACD,KAhJa;AAiJd4C,UAAM,EAAE,YAAW;AACjB,UAAIC,IAAI,GAAG,EAAX;AACAA,UAAI,CAACkI,MAAL,GAAc,EAAd;;AACA,WAAI,IAAI1L,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAK0L,MAAL,CAAYtL,MAA1B,EAAiCJ,CAAC,EAAlC,EAAsC;AACpCwD,YAAI,CAACkI,MAAL,CAAYpL,IAAZ,CAAiB,KAAKoL,MAAL,CAAY1L,CAAZ,EAAeuD,MAAf,EAAjB;AACD;;AACD,aAAOC,IAAP;AACD,KAxJa;AAyJdC,YAAQ,EAAE,UAASD,IAAT,EAAe;AACvB,WAAKkI,MAAL,GAAc,EAAd;;AACA,WAAI,IAAI1L,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACwD,IAAI,CAACkI,MAAL,CAAYtL,MAA1B,EAAiCJ,CAAC,EAAlC,EAAsC;AACpC,YAAI2M,EAAE,GAAGnJ,IAAI,CAACkI,MAAL,CAAY1L,CAAZ,CAAT;AACA,YAAI4M,CAAC,GAAGD,EAAE,CAAC3G,UAAX;AACA,YAAI6G,CAAJ;;AACA,YAAGD,CAAC,KAAG,OAAP,EAAgB;AAAEC,WAAC,GAAG,IAAIvO,MAAM,CAACiK,UAAX,EAAJ;AAA8B;;AAChD,YAAGqE,CAAC,KAAG,MAAP,EAAe;AAAEC,WAAC,GAAG,IAAIvO,MAAM,CAACkL,SAAX,EAAJ;AAA6B;;AAC9C,YAAGoD,CAAC,KAAG,SAAP,EAAkB;AAAEC,WAAC,GAAG,IAAIvO,MAAM,CAACsL,YAAX,EAAJ;AAAgC;;AACpD,YAAGgD,CAAC,KAAG,MAAP,EAAe;AAAEC,WAAC,GAAG,IAAIvO,MAAM,CAAC8L,SAAX,EAAJ;AAA6B;;AAC9C,YAAGwC,CAAC,KAAG,SAAP,EAAkB;AAAEC,WAAC,GAAG,IAAIvO,MAAM,CAAC+L,YAAX,EAAJ;AAAgC;;AACpD,YAAGuC,CAAC,KAAG,MAAP,EAAe;AAAEC,WAAC,GAAG,IAAIvO,MAAM,CAAC8G,SAAX,EAAJ;AAA6B;;AAC9C,YAAGwH,CAAC,KAAG,MAAP,EAAe;AAAEC,WAAC,GAAG,IAAIvO,MAAM,CAAC4J,SAAX,EAAJ;AAA6B;;AAC9C,YAAG0E,CAAC,KAAG,KAAP,EAAc;AAAEC,WAAC,GAAG,IAAIvO,MAAM,CAACkM,+BAAX,EAAJ;AAAmD;;AACnE,YAAGoC,CAAC,KAAG,SAAP,EAAkB;AAAEC,WAAC,GAAG,IAAIvO,MAAM,CAACkK,YAAX,EAAJ;AAAgC;;AACpD,YAAGoE,CAAC,KAAG,YAAP,EAAqB;AAAEC,WAAC,GAAG,IAAIvO,MAAM,CAAC0K,eAAX,EAAJ;AAAmC;;AAC1D,YAAG4D,CAAC,KAAG,IAAP,EAAa;AAAEC,WAAC,GAAG,IAAIvO,MAAM,CAACsJ,cAAX,EAAJ;AAAkC;;AACjD,YAAGgF,CAAC,KAAG,QAAP,EAAiB;AAAEC,WAAC,GAAG,IAAIvO,MAAM,CAACwL,WAAX,EAAJ;AAA+B;;AAClD,YAAG8C,CAAC,KAAG,eAAP,EAAwB;AAAEC,WAAC,GAAG,IAAIvO,MAAM,CAACgO,kBAAX,EAAJ;AAAsC;;AAChE,YAAGM,CAAC,KAAG,KAAP,EAAc;AAAEC,WAAC,GAAG,IAAIvO,MAAM,CAAC+K,QAAX,EAAJ;AAA4B;;AAC5CwD,SAAC,CAACpJ,QAAF,CAAWkJ,EAAX;AACA,aAAKjB,MAAL,CAAYpL,IAAZ,CAAiBuM,CAAjB;AACD;AACF;AAhLa,GAAhB;AAoLAvO,QAAM,CAACkN,GAAP,GAAaA,GAAb;AACD,CA/LD,EA+LGpN,SA/LH;;AAgMA,CAAC,UAASE,MAAT,EAAiB;AAChB;;AACA,MAAIuD,GAAG,GAAGvD,MAAM,CAACuD,GAAjB,CAFgB,CAEM;;AAEtB,MAAIiL,OAAO,GAAG,UAASC,GAAT,EAActB,OAAd,EAAuB;AAEnC,SAAKsB,GAAL,GAAWA,GAAX;AAEA,QAAItB,OAAO,GAAGA,OAAO,IAAI,EAAzB;AACA,SAAKuB,aAAL,GAAqB,OAAOvB,OAAO,CAACuB,aAAf,KAAiC,WAAjC,GAA+CvB,OAAO,CAACuB,aAAvD,GAAuE,IAA5F;AACA,SAAKC,QAAL,GAAgB,OAAOxB,OAAO,CAACwB,QAAf,KAA4B,WAA5B,GAA0CxB,OAAO,CAACwB,QAAlD,GAA6D,GAA7E;AACA,SAAKC,QAAL,GAAgB,OAAOzB,OAAO,CAACyB,QAAf,KAA4B,WAA5B,GAA0CzB,OAAO,CAACyB,QAAlD,GAA6D,GAA7E;AACA,SAAKC,UAAL,GAAkB,OAAO1B,OAAO,CAAC0B,UAAf,KAA8B,WAA9B,GAA4C1B,OAAO,CAAC0B,UAApD,GAAiE,CAAnF;AACA,SAAKC,MAAL,GAAc,OAAO3B,OAAO,CAAC2B,MAAf,KAA0B,WAA1B,GAAwC3B,OAAO,CAAC2B,MAAhD,GAAyD,KAAvE,CATmC,CAS2C;;AAE9E,SAAKC,QAAL,GAAgB,OAAO5B,OAAO,CAAC4B,QAAf,KAA4B,WAA5B,GAA0C5B,OAAO,CAAC4B,QAAlD,GAA6D,GAA7E;AACA,SAAKC,EAAL,GAAU,OAAO7B,OAAO,CAAC6B,EAAf,KAAsB,WAAtB,GAAoC7B,OAAO,CAAC6B,EAA5C,GAAiD,IAA3D,CAZmC,CAY8B;;AACjE,SAAKC,GAAL,GAAW,OAAO9B,OAAO,CAAC8B,GAAf,KAAuB,WAAvB,GAAqC9B,OAAO,CAAC8B,GAA7C,GAAmD,IAA9D,CAbmC,CAaiC;;AAEpE,SAAK/L,CAAL,GAAS,CAAT,CAfmC,CAevB;;AACZ,SAAKgM,IAAL,GAAY,EAAZ,CAhBmC,CAgBnB;;AAChB,SAAKC,IAAL,GAAY,EAAZ,CAjBmC,CAiBnB;AACjB,GAlBD;;AAoBAX,SAAO,CAAC5K,SAAR,GAAoB;AAClBwL,SAAK,EAAE,UAASlL,CAAT,EAAYC,CAAZ,EAAe;AAEpB,UAAIkL,KAAK,GAAG,IAAIC,IAAJ,GAAWC,OAAX,EAAZ;AACA,WAAKd,GAAL,CAAS3G,OAAT,CAAiB5D,CAAjB,EAAoB,IAApB,EAHoB,CAGO;;AAC3B,UAAIsL,GAAG,GAAG,IAAIF,IAAJ,GAAWC,OAAX,EAAV;AACA,UAAIE,QAAQ,GAAGD,GAAG,GAAGH,KAArB;AAEA,UAAIA,KAAK,GAAG,IAAIC,IAAJ,GAAWC,OAAX,EAAZ;AACA,UAAIG,SAAS,GAAG,KAAKjB,GAAL,CAAS3F,QAAT,CAAkB3E,CAAlB,CAAhB;AACA,UAAIwL,aAAa,GAAG,GAApB;AACA,UAAIC,aAAa,GAAG,GAApB;AACA,UAAIJ,GAAG,GAAG,IAAIF,IAAJ,GAAWC,OAAX,EAAV;AACA,UAAIM,QAAQ,GAAGL,GAAG,GAAGH,KAArB;AAEA,WAAKnM,CAAL;;AACA,UAAG,KAAKA,CAAL,GAAS,KAAK2L,UAAd,KAA6B,CAAhC,EAAmC;AAEjC,YAAIiB,MAAM,GAAG,KAAKrB,GAAL,CAASvF,iBAAT,EAAb,CAFiC,CAIjC;;AACA,YAAG,KAAKgG,IAAL,CAAUpN,MAAV,KAAqB,CAArB,KAA2B,KAAKgN,MAAL,KAAgB,KAAhB,IAAyB,KAAKC,QAAL,GAAgB,GAApE,CAAH,EAA6E;AAC3E;AACA;AACA;AACA;AACA,eAAI,IAAIrN,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACoO,MAAM,CAAChO,MAArB,EAA4BJ,CAAC,EAA7B,EAAiC;AAC/B,iBAAKwN,IAAL,CAAUlN,IAAV,CAAehC,MAAM,CAACoB,KAAP,CAAa0O,MAAM,CAACpO,CAAD,CAAN,CAAU0H,MAAV,CAAiBtH,MAA9B,CAAf;;AACA,gBAAG,KAAKgN,MAAL,KAAgB,UAAnB,EAA+B;AAC7B,mBAAKK,IAAL,CAAUnN,IAAV,CAAehC,MAAM,CAACoB,KAAP,CAAa0O,MAAM,CAACpO,CAAD,CAAN,CAAU0H,MAAV,CAAiBtH,MAA9B,CAAf;AACD,aAFD,MAEO;AACL,mBAAKqN,IAAL,CAAUnN,IAAV,CAAe,EAAf,EADK,CACe;AACrB;AACF;AACF,SAlBgC,CAoBjC;;;AACA,aAAI,IAAIN,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACoO,MAAM,CAAChO,MAArB,EAA4BJ,CAAC,EAA7B,EAAiC;AAC/B,cAAIqO,EAAE,GAAGD,MAAM,CAACpO,CAAD,CAAf,CAD+B,CACX;;AACpB,cAAIsB,CAAC,GAAG+M,EAAE,CAAC3G,MAAX;AACA,cAAI6D,CAAC,GAAG8C,EAAE,CAAC1G,KAAX,CAH+B,CAK/B;;AACA,cAAI9B,YAAY,GAAG,OAAOwI,EAAE,CAACxI,YAAV,KAA2B,WAA3B,GAAyCwI,EAAE,CAACxI,YAA5C,GAA2D,GAA9E;AACA,cAAID,YAAY,GAAG,OAAOyI,EAAE,CAACzI,YAAV,KAA2B,WAA3B,GAAyCyI,EAAE,CAACzI,YAA5C,GAA2D,GAA9E;AACA,cAAIsH,QAAQ,GAAG,KAAKA,QAAL,GAAgBrH,YAA/B;AACA,cAAIoH,QAAQ,GAAG,KAAKA,QAAL,GAAgBrH,YAA/B;AAEA,cAAI0I,IAAI,GAAGhN,CAAC,CAAClB,MAAb;;AACA,eAAI,IAAIW,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACuN,IAAd,EAAmBvN,CAAC,EAApB,EAAwB;AACtBkN,yBAAa,IAAIf,QAAQ,GAAC5L,CAAC,CAACP,CAAD,CAAV,GAAcO,CAAC,CAACP,CAAD,CAAf,GAAmB,CAApC,CADsB,CACiB;;AACvCmN,yBAAa,IAAIjB,QAAQ,GAACtO,IAAI,CAAC4P,GAAL,CAASjN,CAAC,CAACP,CAAD,CAAV,CAA1B;AACA,gBAAIyN,MAAM,GAAGvB,QAAQ,IAAI3L,CAAC,CAACP,CAAD,CAAD,GAAO,CAAP,GAAW,CAAX,GAAe,CAAC,CAApB,CAArB;AACA,gBAAI0N,MAAM,GAAGvB,QAAQ,GAAI5L,CAAC,CAACP,CAAD,CAA1B;AAEA,gBAAI2N,GAAG,GAAG,CAACD,MAAM,GAAGD,MAAT,GAAkBjD,CAAC,CAACxK,CAAD,CAApB,IAA2B,KAAKoM,UAA1C,CANsB,CAMgC;;AAEtD,gBAAIwB,KAAK,GAAG,KAAKnB,IAAL,CAAUxN,CAAV,CAAZ;AACA,gBAAI4O,KAAK,GAAG,KAAKnB,IAAL,CAAUzN,CAAV,CAAZ;;AACA,gBAAG,KAAKoN,MAAL,KAAgB,SAAnB,EAA8B;AAC5B;AACAuB,mBAAK,CAAC5N,CAAD,CAAL,GAAW4N,KAAK,CAAC5N,CAAD,CAAL,GAAW2N,GAAG,GAAGA,GAA5B;AACA,kBAAI9K,EAAE,GAAG,CAAE,KAAKoJ,aAAP,GAAuBrO,IAAI,CAACK,IAAL,CAAU2P,KAAK,CAAC5N,CAAD,CAAL,GAAW,KAAKwM,GAA1B,CAAvB,GAAwDmB,GAAjE;AACApN,eAAC,CAACP,CAAD,CAAD,IAAQ6C,EAAR;AACD,aALD,MAKO,IAAG,KAAKwJ,MAAL,KAAgB,YAAnB,EAAiC;AACtC;AACA;AACA;AACAuB,mBAAK,CAAC5N,CAAD,CAAL,GAAW,KAAKuM,EAAL,GAAUqB,KAAK,CAAC5N,CAAD,CAAf,GAAqB,CAAC,IAAE,KAAKuM,EAAR,IAAcoB,GAAd,GAAoBA,GAApD;AACA,kBAAI9K,EAAE,GAAG,CAAE,KAAKoJ,aAAP,GAAuBrO,IAAI,CAACK,IAAL,CAAU2P,KAAK,CAAC5N,CAAD,CAAL,GAAW,KAAKwM,GAA1B,CAAvB,GAAwDmB,GAAjE,CALsC,CAKgC;;AACtEpN,eAAC,CAACP,CAAD,CAAD,IAAQ6C,EAAR;AACD,aAPM,MAOA,IAAG,KAAKwJ,MAAL,KAAgB,UAAnB,EAA+B;AACpC;AACAuB,mBAAK,CAAC5N,CAAD,CAAL,GAAW,KAAKuM,EAAL,GAAUqB,KAAK,CAAC5N,CAAD,CAAf,GAAqB,CAAC,IAAE,KAAKuM,EAAR,IAAcoB,GAAd,GAAoBA,GAApD;AACA,kBAAI9K,EAAE,GAAG,CAAEjF,IAAI,CAACK,IAAL,CAAU,CAAC4P,KAAK,CAAC7N,CAAD,CAAL,GAAW,KAAKwM,GAAjB,KAAuBoB,KAAK,CAAC5N,CAAD,CAAL,GAAW,KAAKwM,GAAvC,CAAV,CAAF,GAA2DmB,GAApE;AACAE,mBAAK,CAAC7N,CAAD,CAAL,GAAW,KAAKuM,EAAL,GAAUsB,KAAK,CAAC7N,CAAD,CAAf,GAAqB,CAAC,IAAE,KAAKuM,EAAR,IAAc1J,EAAd,GAAmBA,EAAnD,CAJoC,CAImB;;AACvDtC,eAAC,CAACP,CAAD,CAAD,IAAQ6C,EAAR;AACD,aANM,MAMA;AACL;AACA,kBAAG,KAAKyJ,QAAL,GAAgB,GAAnB,EAAwB;AACtB;AACA,oBAAIzJ,EAAE,GAAG,KAAKyJ,QAAL,GAAgBsB,KAAK,CAAC5N,CAAD,CAArB,GAA2B,KAAKiM,aAAL,GAAqB0B,GAAzD,CAFsB,CAEwC;;AAC9DC,qBAAK,CAAC5N,CAAD,CAAL,GAAW6C,EAAX,CAHsB,CAGP;;AACftC,iBAAC,CAACP,CAAD,CAAD,IAAQ6C,EAAR,CAJsB,CAIV;AACb,eALD,MAKO;AACL;AACAtC,iBAAC,CAACP,CAAD,CAAD,IAAS,CAAE,KAAKiM,aAAP,GAAuB0B,GAAhC;AACD;AACF;;AACDnD,aAAC,CAACxK,CAAD,CAAD,GAAO,GAAP,CAxCsB,CAwCV;AACb;AACF;AACF,OA3FmB,CA6FpB;AACA;AACA;AACA;;;AACA,aAAO;AAACgN,gBAAQ,EAAEA,QAAX;AAAqBI,gBAAQ,EAAEA,QAA/B;AACCF,qBAAa,EAAEA,aADhB;AAC+BC,qBAAa,EAAEA,aAD9C;AAECF,iBAAS,EAAEA,SAFZ;AAEuBa,oBAAY,EAAEb,SAFrC;AAGC/E,YAAI,EAAE+E,SAAS,GAAGE,aAAZ,GAA4BD;AAHnC,OAAP;AAID;AAtGiB,GAApB;AAyGA3P,QAAM,CAACwO,OAAP,GAAiBA,OAAjB;AACAxO,QAAM,CAACwQ,UAAP,GAAoBhC,OAApB,CAlIgB,CAkIa;AAC9B,CAnID,EAmIG1O,SAnIH;;AAqIA,CAAC,UAASE,MAAT,EAAiB;AAChB,eADgB,CAGhB;;AACA,MAAIY,KAAK,GAAGZ,MAAM,CAACY,KAAnB;AACA,MAAIG,KAAK,GAAGf,MAAM,CAACe,KAAnB;AACA,MAAImM,GAAG,GAAGlN,MAAM,CAACkN,GAAjB;AACA,MAAIsB,OAAO,GAAGxO,MAAM,CAACwO,OAArB;AACA,MAAIvM,MAAM,GAAGjC,MAAM,CAACiC,MAApB;AACA,MAAIO,QAAQ,GAAGxC,MAAM,CAACwC,QAAtB;AACA,MAAIK,cAAc,GAAG7C,MAAM,CAAC6C,cAA5B;AACA,MAAIM,MAAM,GAAGnD,MAAM,CAACmD,MAApB;AACA,MAAIpB,SAAS,GAAG/B,MAAM,CAAC+B,SAAvB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,MAAI0O,QAAQ,GAAG,UAAS/J,IAAT,EAAegK,MAAf,EAAuBtN,GAAvB,EAA4B;AACzC,QAAIA,GAAG,GAAGA,GAAG,IAAI,EAAjB;;AACA,QAAG,OAAOsD,IAAP,KAAgB,WAAnB,EAAgC;AAAEA,UAAI,GAAG,EAAP;AAAY;;AAC9C,QAAG,OAAOgK,MAAP,KAAkB,WAArB,EAAkC;AAAEA,YAAM,GAAG,EAAT;AAAc,KAHT,CAKzC;;;AACA,SAAKhK,IAAL,GAAYA,IAAZ,CANyC,CAMvB;;AAClB,SAAKgK,MAAL,GAAcA,MAAd,CAPyC,CASzC;;AACA,SAAKC,WAAL,GAAmBxN,MAAM,CAACC,GAAD,EAAM,aAAN,EAAqB,GAArB,CAAzB;AACA,SAAKwN,SAAL,GAAiBzN,MAAM,CAACC,GAAD,EAAM,WAAN,EAAmB,EAAnB,CAAvB;AACA,SAAKyN,cAAL,GAAsB1N,MAAM,CAACC,GAAD,EAAM,gBAAN,EAAwB,EAAxB,CAA5B,CAZyC,CAYgB;AACzD;AACA;;AACA,SAAK0N,UAAL,GAAkB3N,MAAM,CAACC,GAAD,EAAM,YAAN,EAAoB,EAApB,CAAxB,CAfyC,CAgBzC;;AACA,SAAK2N,aAAL,GAAqB5N,MAAM,CAACC,GAAD,EAAM,eAAN,EAAuB,EAAvB,CAA3B,CAjByC,CAmBzC;;AACA,SAAK4N,cAAL,GAAsB7N,MAAM,CAACC,GAAD,EAAM,gBAAN,EAAwB,EAAxB,CAA5B;AACA,SAAK6N,cAAL,GAAsB9N,MAAM,CAACC,GAAD,EAAM,gBAAN,EAAwB,GAAxB,CAA5B;AACA,SAAK8N,YAAL,GAAoB/N,MAAM,CAACC,GAAD,EAAM,cAAN,EAAsB,CAAC,CAAvB,CAA1B;AACA,SAAK+N,YAAL,GAAoBhO,MAAM,CAACC,GAAD,EAAM,cAAN,EAAsB,CAAtB,CAA1B;AACA,SAAKgO,iBAAL,GAAyBjO,MAAM,CAACC,GAAD,EAAM,mBAAN,EAA2B,CAAC,CAA5B,CAA/B;AACA,SAAKiO,iBAAL,GAAyBlO,MAAM,CAACC,GAAD,EAAM,mBAAN,EAA2B,CAA3B,CAA/B;AACA,SAAKkO,YAAL,GAAoBnO,MAAM,CAACC,GAAD,EAAM,cAAN,EAAsB,GAAtB,CAA1B;AACA,SAAKmO,YAAL,GAAoBpO,MAAM,CAACC,GAAD,EAAM,cAAN,EAAsB,GAAtB,CAA1B;AACA,SAAKoO,WAAL,GAAmBrO,MAAM,CAACC,GAAD,EAAM,aAAN,EAAqB,CAArB,CAAzB;AACA,SAAKqO,WAAL,GAAmBtO,MAAM,CAACC,GAAD,EAAM,aAAN,EAAqB,EAArB,CAAzB,CA7ByC,CA+BzC;;AACA,SAAKsO,KAAL,GAAa,EAAb,CAhCyC,CAgCxB;;AACjB,SAAKC,UAAL,GAAkB,EAAlB,CAjCyC,CAiCnB;;AACtB,SAAKC,oBAAL,GAA4B,EAA5B,CAlCyC,CAkCT;;AAChC,SAAKC,aAAL,GAAqB9P,SAAS,CAAC2O,MAAD,CAA9B;AACA,SAAKoB,IAAL,GAAY,CAAZ,CApCyC,CAoC1B;;AACf,SAAKC,MAAL,GAAc,CAAd,CArCyC,CAqCxB;AAEjB;;AACA,SAAKC,oBAAL,GAA4B,IAA5B;AACA,SAAKC,qBAAL,GAA6B,IAA7B,CAzCyC,CA2CzC;;AACA,QAAG,KAAKvL,IAAL,CAAU5E,MAAV,GAAmB,CAAtB,EAAyB;AACvB,WAAKoQ,WAAL;AACA,WAAKC,gBAAL;AACD;AACF,GAhDD;;AAkDA1B,UAAQ,CAAC7M,SAAT,GAAqB;AAEnB;AACAsO,eAAW,EAAE,YAAW;AACtB,UAAI9G,CAAC,GAAG,KAAK1E,IAAL,CAAU5E,MAAlB;AACA,UAAIsQ,SAAS,GAAG/R,IAAI,CAACW,KAAL,CAAW,KAAK2P,WAAL,GAAmBvF,CAA9B,CAAhB;AACA,WAAKsG,KAAL,GAAa,EAAb,CAHsB,CAGL;;AACjB,WAAI,IAAIhQ,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKkP,SAAnB,EAA6BlP,CAAC,EAA9B,EAAkC;AAChC,YAAIsB,CAAC,GAAGR,QAAQ,CAAC4I,CAAD,CAAhB;AACA,aAAKsG,KAAL,CAAW1P,IAAX,CAAgB;AAACqQ,kBAAQ,EAAErP,CAAC,CAACsP,KAAF,CAAQ,CAAR,EAAWF,SAAX,CAAX;AAAkCG,iBAAO,EAAEvP,CAAC,CAACsP,KAAF,CAAQF,SAAR,EAAmBhH,CAAnB;AAA3C,SAAhB;AACD;AACF,KAXkB;AAanB;AACAoH,mBAAe,EAAE,YAAW;AAC1B,UAAIC,WAAW,GAAG,KAAK/L,IAAL,CAAU,CAAV,EAAaxE,CAAb,CAAeJ,MAAjC;AACA,UAAI6L,WAAW,GAAG,KAAKkE,aAAL,CAAmB/P,MAArC,CAF0B,CAI1B;;AACA,UAAI4Q,UAAU,GAAG,EAAjB;AACAA,gBAAU,CAAC1Q,IAAX,CAAgB;AAACuL,YAAI,EAAC,OAAN;AAAe/F,cAAM,EAAC,CAAtB;AAAyBC,cAAM,EAAC,CAAhC;AAAmCV,iBAAS,EAAE0L;AAA9C,OAAhB;AACA,UAAIE,EAAE,GAAG9P,cAAc,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAD,EAAY,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,CAAZ,CAAvB,CAP0B,CAOgC;;AAC1D,WAAI,IAAID,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC+P,EAAd,EAAiB/P,CAAC,EAAlB,EAAsB;AACpB,YAAIgQ,EAAE,GAAG7R,KAAK,CAAC,KAAKyQ,WAAN,EAAmB,KAAKC,WAAxB,CAAd;AACA,YAAIxD,GAAG,GAAG,CAAC,MAAD,EAAQ,QAAR,EAAiB,MAAjB,EAAyBlN,KAAK,CAAC,CAAD,EAAG,CAAH,CAA9B,CAAV;;AACA,YAAGH,KAAK,CAAC,CAAD,EAAG,CAAH,CAAL,GAAW,GAAd,EAAmB;AACjB,cAAIiS,EAAE,GAAGxS,IAAI,CAACC,MAAL,EAAT;AACAoS,oBAAU,CAAC1Q,IAAX,CAAgB;AAACuL,gBAAI,EAAC,IAAN;AAAYhE,uBAAW,EAAEqJ,EAAzB;AAA6BhF,sBAAU,EAAEK,GAAzC;AAA8CjC,qBAAS,EAAE6G;AAAzD,WAAhB;AACD,SAHD,MAGO;AACLH,oBAAU,CAAC1Q,IAAX,CAAgB;AAACuL,gBAAI,EAAC,IAAN;AAAYhE,uBAAW,EAAEqJ,EAAzB;AAA6BhF,sBAAU,EAAEK;AAAzC,WAAhB;AACD;AACF;;AACDyE,gBAAU,CAAC1Q,IAAX,CAAgB;AAACuL,YAAI,EAAC,SAAN;AAAiBI,mBAAW,EAAEA;AAA9B,OAAhB;AACA,UAAIc,GAAG,GAAG,IAAIvB,GAAJ,EAAV;AACAuB,SAAG,CAACpB,UAAJ,CAAeqF,UAAf,EApB0B,CAsB1B;;AACA,UAAII,EAAE,GAAG/R,KAAK,CAAC,KAAKiQ,cAAN,EAAsB,KAAKC,cAA3B,CAAd,CAvB0B,CAuBgC;;AAC1D,UAAI8B,EAAE,GAAG1S,IAAI,CAACuM,GAAL,CAAS,EAAT,EAAahM,KAAK,CAAC,KAAKsQ,YAAN,EAAoB,KAAKC,YAAzB,CAAlB,CAAT,CAxB0B,CAwB0C;;AACpE,UAAI6B,EAAE,GAAG3S,IAAI,CAACuM,GAAL,CAAS,EAAT,EAAahM,KAAK,CAAC,KAAKwQ,iBAAN,EAAyB,KAAKC,iBAA9B,CAAlB,CAAT,CAzB0B,CAyBoD;;AAC9E,UAAI4B,GAAG,GAAGrS,KAAK,CAAC,KAAK0Q,YAAN,EAAoB,KAAKC,YAAzB,CAAf,CA1B0B,CA0B6B;;AACvD,UAAI2B,EAAE,GAAGtS,KAAK,CAAC,CAAD,EAAG,CAAH,CAAd,CA3B0B,CA2BL;;AACrB,UAAIuS,WAAJ;;AACA,UAAGD,EAAE,GAAC,IAAN,EAAY;AACVC,mBAAW,GAAG;AAACrE,gBAAM,EAAC,UAAR;AAAoBD,oBAAU,EAACiE,EAA/B;AAAmClE,kBAAQ,EAACmE;AAA5C,SAAd;AACD,OAFD,MAEO,IAAGG,EAAE,GAAC,IAAN,EAAY;AACjBC,mBAAW,GAAG;AAACrE,gBAAM,EAAC,SAAR;AAAmBJ,uBAAa,EAAEsE,EAAlC;AAAsCnE,oBAAU,EAACiE,EAAjD;AAAqDlE,kBAAQ,EAACmE;AAA9D,SAAd;AACD,OAFM,MAEA;AACLI,mBAAW,GAAG;AAACrE,gBAAM,EAAC,KAAR;AAAeJ,uBAAa,EAAEsE,EAA9B;AAAkCjE,kBAAQ,EAAEkE,GAA5C;AAAiDpE,oBAAU,EAACiE,EAA5D;AAAgElE,kBAAQ,EAACmE;AAAzE,SAAd;AACD;;AAED,UAAIK,OAAO,GAAG,IAAI5E,OAAJ,CAAYC,GAAZ,EAAiB0E,WAAjB,CAAd;AAEA,UAAIE,IAAI,GAAG,EAAX;AACAA,UAAI,CAACC,GAAL,GAAW,EAAX;AACAD,UAAI,CAACE,IAAL,GAAY,CAAZ,CAzC0B,CAyCX;;AACfF,UAAI,CAACX,UAAL,GAAkBA,UAAlB;AACAW,UAAI,CAACF,WAAL,GAAmBA,WAAnB;AACAE,UAAI,CAAC5E,GAAL,GAAWA,GAAX;AACA4E,UAAI,CAACD,OAAL,GAAeA,OAAf;AACA,aAAOC,IAAP;AACD,KA7DkB;AA+DnB;AACAlB,oBAAgB,EAAE,YAAW;AAC3B,WAAKR,UAAL,GAAkB,EAAlB,CAD2B,CACL;;AACtB,WAAI,IAAIjQ,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKmP,cAAnB,EAAkCnP,CAAC,EAAnC,EAAuC;AACrC,YAAI2R,IAAI,GAAG,KAAKb,eAAL,EAAX;AACA,aAAKb,UAAL,CAAgB3P,IAAhB,CAAqBqR,IAArB;AACD;AACF,KAtEkB;AAwEnBG,QAAI,EAAE,YAAW;AAEf;AACA,WAAK1B,IAAL,GAHe,CAKf;;AACA,UAAI2B,IAAI,GAAG,KAAK/B,KAAL,CAAW,KAAKK,MAAhB,CAAX,CANe,CAMqB;;AACpC,UAAI2B,MAAM,GAAGD,IAAI,CAACpB,QAAL,CAActR,KAAK,CAAC,CAAD,EAAI0S,IAAI,CAACpB,QAAL,CAAcvQ,MAAlB,CAAnB,CAAb;;AACA,WAAI,IAAIoB,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKyO,UAAL,CAAgB7P,MAA9B,EAAqCoB,CAAC,EAAtC,EAA0C;AACxC,YAAIgB,CAAC,GAAG,KAAKwC,IAAL,CAAUgN,MAAV,CAAR;AACA,YAAIC,CAAC,GAAG,KAAKjD,MAAL,CAAYgD,MAAZ,CAAR;AACA,aAAK/B,UAAL,CAAgBzO,CAAhB,EAAmBkQ,OAAnB,CAA2BhE,KAA3B,CAAiClL,CAAjC,EAAoCyP,CAApC;AACD,OAZc,CAcf;;;AACA,UAAIC,QAAQ,GAAG,KAAK9C,UAAL,GAAkB2C,IAAI,CAACpB,QAAL,CAAcvQ,MAA/C;;AACA,UAAG,KAAKgQ,IAAL,IAAa8B,QAAhB,EAA0B;AACxB;AACA;AACA,YAAIC,OAAO,GAAG,KAAKC,aAAL,EAAd;;AACA,aAAI,IAAI5Q,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKyO,UAAL,CAAgB7P,MAA9B,EAAqCoB,CAAC,EAAtC,EAA0C;AACxC,cAAIzC,CAAC,GAAG,KAAKkR,UAAL,CAAgBzO,CAAhB,CAAR;AACAzC,WAAC,CAAC6S,GAAF,CAAMtR,IAAN,CAAW6R,OAAO,CAAC3Q,CAAD,CAAlB;AACAzC,WAAC,CAAC8S,IAAF,IAAUM,OAAO,CAAC3Q,CAAD,CAAjB;AACD;;AACD,aAAK4O,IAAL,GAAY,CAAZ,CATwB,CAST;;AACf,aAAKC,MAAL,GAVwB,CAUT;;AAEf,YAAG,KAAKC,oBAAL,KAA8B,IAAjC,EAAuC;AACrC,eAAKA,oBAAL;AACD;;AAED,YAAG,KAAKD,MAAL,IAAe,KAAKL,KAAL,CAAW5P,MAA7B,EAAqC;AACnC;AACA;AACA,eAAI,IAAIoB,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKyO,UAAL,CAAgB7P,MAA9B,EAAqCoB,CAAC,EAAtC,EAA0C;AACxC,iBAAK0O,oBAAL,CAA0B5P,IAA1B,CAA+B,KAAK2P,UAAL,CAAgBzO,CAAhB,CAA/B;AACD,WALkC,CAMnC;;;AACA,eAAK0O,oBAAL,CAA0BmC,IAA1B,CAA+B,UAASlT,CAAT,EAAYC,CAAZ,EAAe;AAC5C,mBAAQD,CAAC,CAAC0S,IAAF,GAAS1S,CAAC,CAACyS,GAAF,CAAMxR,MAAhB,GACChB,CAAC,CAACyS,IAAF,GAASzS,CAAC,CAACwS,GAAF,CAAMxR,MADhB,GAEA,CAAC,CAFD,GAEK,CAFZ;AAGD,WAJD,EAPmC,CAYnC;AACA;AACA;;AACA,cAAG,KAAK8P,oBAAL,CAA0B9P,MAA1B,GAAmC,IAAI,KAAKiP,aAA/C,EAA8D;AAC5D,iBAAKa,oBAAL,GAA4B,KAAKA,oBAAL,CAA0BU,KAA1B,CAAgC,CAAhC,EAAmC,IAAI,KAAKvB,aAA5C,CAA5B;AACD;;AACD,cAAG,KAAKkB,qBAAL,KAA+B,IAAlC,EAAwC;AACtC,iBAAKA,qBAAL;AACD;;AACD,eAAKE,gBAAL,GArBmC,CAqBV;;AACzB,eAAKJ,MAAL,GAAc,CAAd,CAtBmC,CAsBlB;AAClB,SAvBD,MAuBO;AACL;AACA,eAAI,IAAI7O,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKyO,UAAL,CAAgB7P,MAA9B,EAAqCoB,CAAC,EAAtC,EAA0C;AACxC,gBAAIzC,CAAC,GAAG,KAAKkR,UAAL,CAAgBzO,CAAhB,CAAR;AACA,gBAAIuL,GAAG,GAAG,IAAIvB,GAAJ,EAAV;AACAuB,eAAG,CAACpB,UAAJ,CAAe5M,CAAC,CAACiS,UAAjB;AACA,gBAAIU,OAAO,GAAG,IAAI5E,OAAJ,CAAYC,GAAZ,EAAiBhO,CAAC,CAAC0S,WAAnB,CAAd;AACA1S,aAAC,CAACgO,GAAF,GAAQA,GAAR;AACAhO,aAAC,CAAC2S,OAAF,GAAYA,OAAZ;AACD;AACF;AACF;AACF,KA3IkB;AA6InBU,iBAAa,EAAE,YAAW;AACxB;AACA;AACA,UAAIE,IAAI,GAAG,EAAX;AACA,UAAIP,IAAI,GAAG,KAAK/B,KAAL,CAAW,KAAKK,MAAhB,CAAX,CAJwB,CAIY;;AACpC,WAAI,IAAI7O,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKyO,UAAL,CAAgB7P,MAA9B,EAAqCoB,CAAC,EAAtC,EAA0C;AACxC,YAAIuL,GAAG,GAAG,KAAKkD,UAAL,CAAgBzO,CAAhB,EAAmBuL,GAA7B;AACA,YAAIlO,CAAC,GAAG,GAAR;;AACA,aAAI,IAAIqC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC6Q,IAAI,CAAClB,OAAL,CAAazQ,MAA3B,EAAkCc,CAAC,EAAnC,EAAuC;AACrC,cAAIsB,CAAC,GAAG,KAAKwC,IAAL,CAAU+M,IAAI,CAAClB,OAAL,CAAa3P,CAAb,CAAV,CAAR;AACA,cAAI+Q,CAAC,GAAG,KAAKjD,MAAL,CAAY+C,IAAI,CAAClB,OAAL,CAAa3P,CAAb,CAAZ,CAAR;AACA6L,aAAG,CAAC3G,OAAJ,CAAY5D,CAAZ;AACA,cAAI+P,IAAI,GAAGxF,GAAG,CAACL,aAAJ,EAAX;AACA7N,WAAC,IAAK0T,IAAI,KAAKN,CAAT,GAAa,GAAb,GAAmB,GAAzB,CALqC,CAKN;AAChC;;AACDpT,SAAC,IAAIkT,IAAI,CAAClB,OAAL,CAAazQ,MAAlB,CAVwC,CAUd;;AAC1BkS,YAAI,CAAChS,IAAL,CAAUzB,CAAV;AACD;;AACD,aAAOyT,IAAP;AACD,KAhKkB;AAkKnB;AACA;AACA;AACAE,gBAAY,EAAE,UAASxN,IAAT,EAAe;AAC3B;AACA;AACA,UAAIyN,EAAE,GAAG9T,IAAI,CAACqM,GAAL,CAAS,KAAKqE,aAAd,EAA6B,KAAKa,oBAAL,CAA0B9P,MAAvD,CAAT;;AACA,UAAGqS,EAAE,KAAK,CAAV,EAAa;AAAE,eAAO,IAAIrU,SAAS,CAACyD,GAAd,CAAkB,CAAlB,EAAoB,CAApB,EAAsB,CAAtB,CAAP;AAAkC,OAJtB,CAIuB;;;AAClD,UAAI6Q,IAAJ,EAAU/S,CAAV;;AACA,WAAI,IAAIoB,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC0R,EAAd,EAAiB1R,CAAC,EAAlB,EAAsB;AACpB,YAAIgM,GAAG,GAAG,KAAKmD,oBAAL,CAA0BnP,CAA1B,EAA6BgM,GAAvC;AACA,YAAIvK,CAAC,GAAGuK,GAAG,CAAC3G,OAAJ,CAAYpB,IAAZ,CAAR;;AACA,YAAGjE,CAAC,KAAG,CAAP,EAAU;AACR2R,cAAI,GAAGlQ,CAAP;AACA7C,WAAC,GAAG6C,CAAC,CAAChC,CAAF,CAAIJ,MAAR;AACD,SAHD,MAGO;AACL;AACA,eAAI,IAAIsC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC/C,CAAd,EAAgB+C,CAAC,EAAjB,EAAqB;AACnBgQ,gBAAI,CAAClS,CAAL,CAAOkC,CAAP,KAAaF,CAAC,CAAChC,CAAF,CAAIkC,CAAJ,CAAb;AACD;AACF;AACF,OAlB0B,CAmB3B;;;AACA,WAAI,IAAIA,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC/C,CAAd,EAAgB+C,CAAC,EAAjB,EAAqB;AACnBgQ,YAAI,CAAClS,CAAL,CAAOkC,CAAP,KAAa/C,CAAb;AACD;;AACD,aAAO+S,IAAP;AACD,KA7LkB;AA+LnBC,WAAO,EAAE,UAAS3N,IAAT,EAAe;AACtB,UAAI0N,IAAI,GAAG,KAAKF,YAAL,CAAkBxN,IAAlB,CAAX;;AACA,UAAG0N,IAAI,CAAClS,CAAL,CAAOJ,MAAP,KAAkB,CAArB,EAAwB;AACtB,YAAIwS,KAAK,GAAGrS,MAAM,CAACmS,IAAI,CAAClS,CAAN,CAAlB;AACA,YAAIqS,eAAe,GAAGD,KAAK,CAACjS,IAA5B;AACD,OAHD,MAGO;AACL,YAAIkS,eAAe,GAAG,CAAC,CAAvB,CADK,CACqB;AAC3B;;AACD,aAAOA,eAAP;AAED,KAzMkB;AA2MnBtP,UAAM,EAAE,YAAW;AACjB;AACA,UAAIkP,EAAE,GAAG9T,IAAI,CAACqM,GAAL,CAAS,KAAKqE,aAAd,EAA6B,KAAKa,oBAAL,CAA0B9P,MAAvD,CAAT;AACA,UAAIoD,IAAI,GAAG,EAAX;AACAA,UAAI,CAACsP,IAAL,GAAY,EAAZ;;AACA,WAAI,IAAI9S,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACyS,EAAd,EAAiBzS,CAAC,EAAlB,EAAsB;AACpBwD,YAAI,CAACsP,IAAL,CAAUxS,IAAV,CAAe,KAAK4P,oBAAL,CAA0BlQ,CAA1B,EAA6B+M,GAA7B,CAAiCxJ,MAAjC,EAAf;AACD;;AACD,aAAOC,IAAP;AACD,KApNkB;AAsNnBC,YAAQ,EAAE,UAASD,IAAT,EAAe;AACvB,WAAK6L,aAAL,GAAqB7L,IAAI,CAACsP,IAAL,CAAU1S,MAA/B;AACA,WAAK8P,oBAAL,GAA4B,EAA5B;;AACA,WAAI,IAAIlQ,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC,KAAKqP,aAAnB,EAAiCrP,CAAC,EAAlC,EAAsC;AACpC,YAAI+M,GAAG,GAAG,IAAIvB,GAAJ,EAAV;AACAuB,WAAG,CAACtJ,QAAJ,CAAaD,IAAI,CAACsP,IAAL,CAAU9S,CAAV,CAAb;AACA,YAAI+S,eAAe,GAAG,EAAtB;AACAA,uBAAe,CAAChG,GAAhB,GAAsBA,GAAtB;AACA,aAAKmD,oBAAL,CAA0B5P,IAA1B,CAA+ByS,eAA/B;AACD;AACF,KAhOkB;AAkOnB;AACA;AACAC,gBAAY,EAAE,UAASrM,CAAT,EAAY;AAAE,WAAK2J,oBAAL,GAA4B3J,CAA5B;AAAgC,KApOzC;AAqOnB;AACAsM,iBAAa,EAAE,UAAStM,CAAT,EAAY;AAAE,WAAK4J,qBAAL,GAA6B5J,CAA7B;AAAiC;AAtO3C,GAArB;AA0OArI,QAAM,CAACyQ,QAAP,GAAkBA,QAAlB;AACD,CAnTD,EAmTG3Q,SAnTH;;AAoTA,KAAKA,SAAL,GAAiBA,SAAjB,C;;;;;;;;;;;;AClkEA;AACA;AACA;AACA;AACA;AAEA,OAAK8U,QAAL,GAAiB,YAAY;AAAE,iBAAF,CAE7B;AACA;AAEA;;AACA,aAASC,SAAT,CAAmBC,EAAnB,EAAuBC,EAAvB,EAA2B;AAEvB,UAAIzP,EAAE,GAAGwP,EAAE,CAAC5Q,CAAH,GAAO6Q,EAAE,CAAC7Q,CAAnB;AAAA,UACIqB,EAAE,GAAGuP,EAAE,CAAC3Q,CAAH,GAAO4Q,EAAE,CAAC5Q,CADnB;AAGA,aAAOmB,EAAE,GAAGA,EAAL,GAAUC,EAAE,GAAGA,EAAtB;AACH,KAZ4B,CAc7B;;;AACA,aAASyP,YAAT,CAAsBhS,CAAtB,EAAyB8R,EAAzB,EAA6BC,EAA7B,EAAiC;AAE7B,UAAI7Q,CAAC,GAAG4Q,EAAE,CAAC5Q,CAAX;AAAA,UACIC,CAAC,GAAG2Q,EAAE,CAAC3Q,CADX;AAAA,UAEImB,EAAE,GAAGyP,EAAE,CAAC7Q,CAAH,GAAOA,CAFhB;AAAA,UAGIqB,EAAE,GAAGwP,EAAE,CAAC5Q,CAAH,GAAOA,CAHhB;;AAKA,UAAImB,EAAE,KAAK,CAAP,IAAYC,EAAE,KAAK,CAAvB,EAA0B;AAEtB,YAAI+I,CAAC,GAAG,CAAC,CAACtL,CAAC,CAACkB,CAAF,GAAMA,CAAP,IAAYoB,EAAZ,GAAiB,CAACtC,CAAC,CAACmB,CAAF,GAAMA,CAAP,IAAYoB,EAA9B,KAAqCD,EAAE,GAAGA,EAAL,GAAUC,EAAE,GAAGA,EAApD,CAAR;;AAEA,YAAI+I,CAAC,GAAG,CAAR,EAAW;AACPpK,WAAC,GAAG6Q,EAAE,CAAC7Q,CAAP;AACAC,WAAC,GAAG4Q,EAAE,CAAC5Q,CAAP;AAEH,SAJD,MAIO,IAAImK,CAAC,GAAG,CAAR,EAAW;AACdpK,WAAC,IAAIoB,EAAE,GAAGgJ,CAAV;AACAnK,WAAC,IAAIoB,EAAE,GAAG+I,CAAV;AACH;AACJ;;AAEDhJ,QAAE,GAAGtC,CAAC,CAACkB,CAAF,GAAMA,CAAX;AACAqB,QAAE,GAAGvC,CAAC,CAACmB,CAAF,GAAMA,CAAX;AAEA,aAAOmB,EAAE,GAAGA,EAAL,GAAUC,EAAE,GAAGA,EAAtB;AACH,KAxC4B,CAyC7B;AAEA;;;AACA,aAAS0P,kBAAT,CAA4BC,MAA5B,EAAoCC,WAApC,EAAiD;AAE7C,UAAIC,SAAS,GAAGF,MAAM,CAAC,CAAD,CAAtB;AAAA,UACIG,SAAS,GAAG,CAACD,SAAD,CADhB;AAAA,UAEIE,KAFJ;;AAIA,WAAK,IAAI5T,CAAC,GAAG,CAAR,EAAW6T,GAAG,GAAGL,MAAM,CAACpT,MAA7B,EAAqCJ,CAAC,GAAG6T,GAAzC,EAA8C7T,CAAC,EAA/C,EAAmD;AAC/C4T,aAAK,GAAGJ,MAAM,CAACxT,CAAD,CAAd;;AAEA,YAAImT,SAAS,CAACS,KAAD,EAAQF,SAAR,CAAT,GAA8BD,WAAlC,EAA+C;AAC3CE,mBAAS,CAACrT,IAAV,CAAesT,KAAf;AACAF,mBAAS,GAAGE,KAAZ;AACH;AACJ;;AAED,UAAIF,SAAS,KAAKE,KAAlB,EAAyBD,SAAS,CAACrT,IAAV,CAAesT,KAAf;AAEzB,aAAOD,SAAP;AACH;;AAED,aAASG,cAAT,CAAwBN,MAAxB,EAAgCO,KAAhC,EAAuCC,IAAvC,EAA6CP,WAA7C,EAA0DQ,UAA1D,EAAsE;AAClE,UAAIC,SAAS,GAAGT,WAAhB;AAAA,UACIU,KADJ;;AAGA,WAAK,IAAInU,CAAC,GAAG+T,KAAK,GAAG,CAArB,EAAwB/T,CAAC,GAAGgU,IAA5B,EAAkChU,CAAC,EAAnC,EAAuC;AACnC,YAAIoU,MAAM,GAAGd,YAAY,CAACE,MAAM,CAACxT,CAAD,CAAP,EAAYwT,MAAM,CAACO,KAAD,CAAlB,EAA2BP,MAAM,CAACQ,IAAD,CAAjC,CAAzB;;AAEA,YAAII,MAAM,GAAGF,SAAb,EAAwB;AACpBC,eAAK,GAAGnU,CAAR;AACAkU,mBAAS,GAAGE,MAAZ;AACH;AACJ;;AAED,UAAIF,SAAS,GAAGT,WAAhB,EAA6B;AACzB,YAAIU,KAAK,GAAGJ,KAAR,GAAgB,CAApB,EAAuBD,cAAc,CAACN,MAAD,EAASO,KAAT,EAAgBI,KAAhB,EAAuBV,WAAvB,EAAoCQ,UAApC,CAAd;AACvBA,kBAAU,CAAC3T,IAAX,CAAgBkT,MAAM,CAACW,KAAD,CAAtB;AACA,YAAIH,IAAI,GAAGG,KAAP,GAAe,CAAnB,EAAsBL,cAAc,CAACN,MAAD,EAASW,KAAT,EAAgBH,IAAhB,EAAsBP,WAAtB,EAAmCQ,UAAnC,CAAd;AACzB;AACJ,KAlF4B,CAoF7B;;;AACA,aAASI,sBAAT,CAAgCb,MAAhC,EAAwCC,WAAxC,EAAqD;AACjD,UAAIO,IAAI,GAAGR,MAAM,CAACpT,MAAP,GAAgB,CAA3B;AAEA,UAAI6T,UAAU,GAAG,CAACT,MAAM,CAAC,CAAD,CAAP,CAAjB;AACAM,oBAAc,CAACN,MAAD,EAAS,CAAT,EAAYQ,IAAZ,EAAkBP,WAAlB,EAA+BQ,UAA/B,CAAd;AACAA,gBAAU,CAAC3T,IAAX,CAAgBkT,MAAM,CAACQ,IAAD,CAAtB;AAEA,aAAOC,UAAP;AACH,KA7F4B,CA+F7B;;;AACA,aAASf,QAAT,CAAkBM,MAAlB,EAA0Bc,SAA1B,EAAqCC,cAArC,EAAqD;AAEjD,UAAIf,MAAM,CAACpT,MAAP,IAAiB,CAArB,EAAwB,OAAOoT,MAAP;AAExB,UAAIC,WAAW,GAAGa,SAAS,KAAKE,SAAd,GAA0BF,SAAS,GAAGA,SAAtC,GAAkD,CAApE;AAEAd,YAAM,GAAGe,cAAc,GAAGf,MAAH,GAAYD,kBAAkB,CAACC,MAAD,EAASC,WAAT,CAArD;AACAD,YAAM,GAAGa,sBAAsB,CAACb,MAAD,EAASC,WAAT,CAA/B;AAEA,aAAOD,MAAP;AACH,KA1G4B,CA4G7B;;;AACA,QAAI,OAAOiB,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAACC,GAA3C,EAAgDD,MAAM,CAAC,YAAW;AAAE,aAAOvB,QAAP;AAAkB,KAAhC,CAAN,CAAhD,KACK,IAAI,OAAOyB,MAAP,KAAkB,WAAtB,EAAmCA,MAAM,CAACC,OAAP,GAAiB1B,QAAjB,CAAnC,KACA,OAAOA,QAAP;AAEJ,GAjHe,EAAhB;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AAEA,WAAS2B,OAAT,GAAmB;AACf,SAAKC,QAAL,GAAgB,IAAhB;AACA,SAAKC,KAAL,GAAa,IAAb;AACA,SAAKC,KAAL,GAAa,IAAb;AACA,SAAKC,SAAL,GAAiB,IAAjB;AACA,SAAKC,oBAAL,GAA4B,EAA5B;AACA,SAAKC,mBAAL,GAA2B,EAA3B;AACA,SAAKC,cAAL,GAAsB,EAAtB;AACA,SAAKC,YAAL,GAAoB,EAApB;AACA,SAAKC,YAAL,GAAoB,EAApB;AACC,G,CAEL;;;AAEAT,SAAO,CAAC3S,SAAR,CAAkBqT,KAAlB,GAA0B,YAAW;AACjC,QAAI,CAAC,KAAKC,SAAV,EAAqB;AACjB,WAAKA,SAAL,GAAiB,IAAI,KAAKC,MAAT,EAAjB;AACC,KAH4B,CAIjC;;;AACA,QAAI,KAAKD,SAAL,CAAeE,IAAnB,EAAyB;AACrB,UAAIC,YAAY,GAAG,KAAKH,SAAL,CAAeI,QAAf,CAAwB,KAAKJ,SAAL,CAAeE,IAAvC,CAAnB;;AACA,aAAOC,YAAP,EAAqB;AACjB,aAAKT,oBAAL,CAA0B5U,IAA1B,CAA+BqV,YAA/B,EADiB,CAC6B;;AAC9CA,oBAAY,GAAGA,YAAY,CAACE,MAA5B;AACC;AACJ;;AACL,SAAKL,SAAL,CAAeE,IAAf,GAAsB,IAAtB;;AACA,QAAI,CAAC,KAAKI,YAAV,EAAwB;AACpB,WAAKA,YAAL,GAAoB,IAAI,KAAKL,MAAT,EAApB;AACC;;AACL,SAAKK,YAAL,CAAkBJ,IAAlB,GAAyB,KAAKK,gBAAL,GAAwB,IAAjD;AACA,SAAKjB,QAAL,GAAgB,EAAhB;AACA,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,KAAL,GAAa,EAAb;AACC,GApBL;;AAsBAH,SAAO,CAAC3S,SAAR,CAAkBlD,IAAlB,GAAyBL,IAAI,CAACK,IAA9B;AACA6V,SAAO,CAAC3S,SAAR,CAAkBqM,GAAlB,GAAwB5P,IAAI,CAAC4P,GAA7B;AACAsG,SAAO,CAAC3S,SAAR,CAAkB8T,CAAlB,GAAsBnB,OAAO,CAACmB,CAAR,GAAY,IAAlC;AACAnB,SAAO,CAAC3S,SAAR,CAAkB+T,IAAlB,GAAyBpB,OAAO,CAACoB,IAAR,GAAe,MAAMpB,OAAO,CAACmB,CAAtD;;AACAnB,SAAO,CAAC3S,SAAR,CAAkBgU,gBAAlB,GAAqC,UAAS/W,CAAT,EAAWC,CAAX,EAAa;AAAC,WAAO,KAAKmP,GAAL,CAASpP,CAAC,GAACC,CAAX,IAAc,IAArB;AAA2B,GAA9E;;AACAyV,SAAO,CAAC3S,SAAR,CAAkBiU,sBAAlB,GAA2C,UAAShX,CAAT,EAAWC,CAAX,EAAa;AAAC,WAAOD,CAAC,GAACC,CAAF,GAAI,IAAX;AAAiB,GAA1E;;AACAyV,SAAO,CAAC3S,SAAR,CAAkBkU,6BAAlB,GAAkD,UAASjX,CAAT,EAAWC,CAAX,EAAa;AAAC,WAAOA,CAAC,GAACD,CAAF,GAAI,IAAX;AAAiB,GAAjF;;AACA0V,SAAO,CAAC3S,SAAR,CAAkBmU,mBAAlB,GAAwC,UAASlX,CAAT,EAAWC,CAAX,EAAa;AAAC,WAAOA,CAAC,GAACD,CAAF,GAAI,IAAX;AAAiB,GAAvE;;AACA0V,SAAO,CAAC3S,SAAR,CAAkBoU,0BAAlB,GAA+C,UAASnX,CAAT,EAAWC,CAAX,EAAa;AAAC,WAAOD,CAAC,GAACC,CAAF,GAAI,IAAX;AAAiB,GAA9E,C,CAEA;AACA;AACA;;;AAEAyV,SAAO,CAAC3S,SAAR,CAAkBuT,MAAlB,GAA2B,YAAW;AAClC,SAAKC,IAAL,GAAY,IAAZ;AACC,GAFL;;AAIAb,SAAO,CAAC3S,SAAR,CAAkBuT,MAAlB,CAAyBvT,SAAzB,CAAmCqU,iBAAnC,GAAuD,UAASC,IAAT,EAAeC,SAAf,EAA0B;AAC7E,QAAIC,MAAJ;;AACA,QAAIF,IAAJ,EAAU;AACN;AACAC,eAAS,CAACE,UAAV,GAAuBH,IAAvB;AACAC,eAAS,CAACZ,MAAV,GAAmBW,IAAI,CAACX,MAAxB;;AACA,UAAIW,IAAI,CAACX,MAAT,EAAiB;AACbW,YAAI,CAACX,MAAL,CAAYc,UAAZ,GAAyBF,SAAzB;AACC;;AACLD,UAAI,CAACX,MAAL,GAAcY,SAAd,CAPM,CAQN;;AACA,UAAID,IAAI,CAACI,OAAT,EAAkB;AACd;AACAJ,YAAI,GAAGA,IAAI,CAACI,OAAZ;;AACA,eAAOJ,IAAI,CAACK,MAAZ,EAAoB;AAACL,cAAI,GAAGA,IAAI,CAACK,MAAZ;AAAoB;;AACzCL,YAAI,CAACK,MAAL,GAAcJ,SAAd;AACC,OALL,MAMK;AACDD,YAAI,CAACI,OAAL,GAAeH,SAAf;AACC;;AACLC,YAAM,GAAGF,IAAT;AACC,KAnBL,CAoBA;AACA;AArBA,SAsBK,IAAI,KAAKd,IAAT,EAAe;AAChBc,UAAI,GAAG,KAAKZ,QAAL,CAAc,KAAKF,IAAnB,CAAP,CADgB,CAEhB;;AACAe,eAAS,CAACE,UAAV,GAAuB,IAAvB;AACAF,eAAS,CAACZ,MAAV,GAAmBW,IAAnB;AACAA,UAAI,CAACG,UAAL,GAAkBF,SAAlB,CALgB,CAMhB;;AACAD,UAAI,CAACK,MAAL,GAAcJ,SAAd;AACAC,YAAM,GAAGF,IAAT;AACC,KATA,MAUA;AACD;AACAC,eAAS,CAACE,UAAV,GAAuBF,SAAS,CAACZ,MAAV,GAAmB,IAA1C,CAFC,CAGD;;AACA,WAAKH,IAAL,GAAYe,SAAZ;AACAC,YAAM,GAAG,IAAT;AACC;;AACLD,aAAS,CAACI,MAAV,GAAmBJ,SAAS,CAACG,OAAV,GAAoB,IAAvC;AACAH,aAAS,CAACK,QAAV,GAAqBJ,MAArB;AACAD,aAAS,CAACM,KAAV,GAAkB,IAAlB,CA3C6E,CA4C7E;AACA;AACA;;AACA,QAAIC,OAAJ,EAAaC,KAAb;AACAT,QAAI,GAAGC,SAAP;;AACA,WAAOC,MAAM,IAAIA,MAAM,CAACK,KAAxB,EAA+B;AAC3BC,aAAO,GAAGN,MAAM,CAACI,QAAjB;;AACA,UAAIJ,MAAM,KAAKM,OAAO,CAACH,MAAvB,EAA+B;AAC3BI,aAAK,GAAGD,OAAO,CAACJ,OAAhB;;AACA,YAAIK,KAAK,IAAIA,KAAK,CAACF,KAAnB,EAA0B;AACtBL,gBAAM,CAACK,KAAP,GAAeE,KAAK,CAACF,KAAN,GAAc,KAA7B;AACAC,iBAAO,CAACD,KAAR,GAAgB,IAAhB;AACAP,cAAI,GAAGQ,OAAP;AACC,SAJL,MAKK;AACD,cAAIR,IAAI,KAAKE,MAAM,CAACE,OAApB,EAA6B;AACzB,iBAAKM,YAAL,CAAkBR,MAAlB;AACAF,gBAAI,GAAGE,MAAP;AACAA,kBAAM,GAAGF,IAAI,CAACM,QAAd;AACC;;AACLJ,gBAAM,CAACK,KAAP,GAAe,KAAf;AACAC,iBAAO,CAACD,KAAR,GAAgB,IAAhB;AACA,eAAKI,aAAL,CAAmBH,OAAnB;AACC;AACJ,OAjBL,MAkBK;AACDC,aAAK,GAAGD,OAAO,CAACH,MAAhB;;AACA,YAAII,KAAK,IAAIA,KAAK,CAACF,KAAnB,EAA0B;AACtBL,gBAAM,CAACK,KAAP,GAAeE,KAAK,CAACF,KAAN,GAAc,KAA7B;AACAC,iBAAO,CAACD,KAAR,GAAgB,IAAhB;AACAP,cAAI,GAAGQ,OAAP;AACC,SAJL,MAKK;AACD,cAAIR,IAAI,KAAKE,MAAM,CAACG,MAApB,EAA4B;AACxB,iBAAKM,aAAL,CAAmBT,MAAnB;AACAF,gBAAI,GAAGE,MAAP;AACAA,kBAAM,GAAGF,IAAI,CAACM,QAAd;AACC;;AACLJ,gBAAM,CAACK,KAAP,GAAe,KAAf;AACAC,iBAAO,CAACD,KAAR,GAAgB,IAAhB;AACA,eAAKG,YAAL,CAAkBF,OAAlB;AACC;AACJ;;AACLN,YAAM,GAAGF,IAAI,CAACM,QAAd;AACC;;AACL,SAAKpB,IAAL,CAAUqB,KAAV,GAAkB,KAAlB;AACC,GA1FL;;AA4FAlC,SAAO,CAAC3S,SAAR,CAAkBuT,MAAlB,CAAyBvT,SAAzB,CAAmCkV,YAAnC,GAAkD,UAASZ,IAAT,EAAe;AAC7D;AACA,QAAIA,IAAI,CAACX,MAAT,EAAiB;AACbW,UAAI,CAACX,MAAL,CAAYc,UAAZ,GAAyBH,IAAI,CAACG,UAA9B;AACC;;AACL,QAAIH,IAAI,CAACG,UAAT,EAAqB;AACjBH,UAAI,CAACG,UAAL,CAAgBd,MAAhB,GAAyBW,IAAI,CAACX,MAA9B;AACC;;AACLW,QAAI,CAACX,MAAL,GAAcW,IAAI,CAACG,UAAL,GAAkB,IAAhC,CAR6D,CAS7D;;AACA,QAAID,MAAM,GAAGF,IAAI,CAACM,QAAlB;AAAA,QACIO,IAAI,GAAGb,IAAI,CAACK,MADhB;AAAA,QAEIS,KAAK,GAAGd,IAAI,CAACI,OAFjB;AAAA,QAGIW,IAHJ;;AAIA,QAAI,CAACF,IAAL,EAAW;AACPE,UAAI,GAAGD,KAAP;AACC,KAFL,MAGK,IAAI,CAACA,KAAL,EAAY;AACbC,UAAI,GAAGF,IAAP;AACC,KAFA,MAGA;AACDE,UAAI,GAAG,KAAK3B,QAAL,CAAc0B,KAAd,CAAP;AACC;;AACL,QAAIZ,MAAJ,EAAY;AACR,UAAIA,MAAM,CAACG,MAAP,KAAkBL,IAAtB,EAA4B;AACxBE,cAAM,CAACG,MAAP,GAAgBU,IAAhB;AACC,OAFL,MAGK;AACDb,cAAM,CAACE,OAAP,GAAiBW,IAAjB;AACC;AACJ,KAPL,MAQK;AACD,WAAK7B,IAAL,GAAY6B,IAAZ;AACC,KAjCwD,CAkC7D;;;AACA,QAAIC,KAAJ;;AACA,QAAIH,IAAI,IAAIC,KAAZ,EAAmB;AACfE,WAAK,GAAGD,IAAI,CAACR,KAAb;AACAQ,UAAI,CAACR,KAAL,GAAaP,IAAI,CAACO,KAAlB;AACAQ,UAAI,CAACV,MAAL,GAAcQ,IAAd;AACAA,UAAI,CAACP,QAAL,GAAgBS,IAAhB;;AACA,UAAIA,IAAI,KAAKD,KAAb,EAAoB;AAChBZ,cAAM,GAAGa,IAAI,CAACT,QAAd;AACAS,YAAI,CAACT,QAAL,GAAgBN,IAAI,CAACM,QAArB;AACAN,YAAI,GAAGe,IAAI,CAACX,OAAZ;AACAF,cAAM,CAACG,MAAP,GAAgBL,IAAhB;AACAe,YAAI,CAACX,OAAL,GAAeU,KAAf;AACAA,aAAK,CAACR,QAAN,GAAiBS,IAAjB;AACC,OAPL,MAQK;AACDA,YAAI,CAACT,QAAL,GAAgBJ,MAAhB;AACAA,cAAM,GAAGa,IAAT;AACAf,YAAI,GAAGe,IAAI,CAACX,OAAZ;AACC;AACJ,KAlBL,MAmBK;AACDY,WAAK,GAAGhB,IAAI,CAACO,KAAb;AACAP,UAAI,GAAGe,IAAP;AACC,KA1DwD,CA2D7D;AACA;;;AACA,QAAIf,IAAJ,EAAU;AACNA,UAAI,CAACM,QAAL,GAAgBJ,MAAhB;AACC,KA/DwD,CAgE7D;;;AACA,QAAIc,KAAJ,EAAW;AAAC;AAAQ;;AACpB,QAAIhB,IAAI,IAAIA,IAAI,CAACO,KAAjB,EAAwB;AACpBP,UAAI,CAACO,KAAL,GAAa,KAAb;AACA;AACC,KArEwD,CAsE7D;;;AACA,QAAIU,OAAJ;;AACA,OAAG;AACC,UAAIjB,IAAI,KAAK,KAAKd,IAAlB,EAAwB;AACpB;AACC;;AACL,UAAIc,IAAI,KAAKE,MAAM,CAACG,MAApB,EAA4B;AACxBY,eAAO,GAAGf,MAAM,CAACE,OAAjB;;AACA,YAAIa,OAAO,CAACV,KAAZ,EAAmB;AACfU,iBAAO,CAACV,KAAR,GAAgB,KAAhB;AACAL,gBAAM,CAACK,KAAP,GAAe,IAAf;AACA,eAAKG,YAAL,CAAkBR,MAAlB;AACAe,iBAAO,GAAGf,MAAM,CAACE,OAAjB;AACC;;AACL,YAAKa,OAAO,CAACZ,MAAR,IAAkBY,OAAO,CAACZ,MAAR,CAAeE,KAAlC,IAA6CU,OAAO,CAACb,OAAR,IAAmBa,OAAO,CAACb,OAAR,CAAgBG,KAApF,EAA4F;AACxF,cAAI,CAACU,OAAO,CAACb,OAAT,IAAoB,CAACa,OAAO,CAACb,OAAR,CAAgBG,KAAzC,EAAgD;AAC5CU,mBAAO,CAACZ,MAAR,CAAeE,KAAf,GAAuB,KAAvB;AACAU,mBAAO,CAACV,KAAR,GAAgB,IAAhB;AACA,iBAAKI,aAAL,CAAmBM,OAAnB;AACAA,mBAAO,GAAGf,MAAM,CAACE,OAAjB;AACC;;AACLa,iBAAO,CAACV,KAAR,GAAgBL,MAAM,CAACK,KAAvB;AACAL,gBAAM,CAACK,KAAP,GAAeU,OAAO,CAACb,OAAR,CAAgBG,KAAhB,GAAwB,KAAvC;AACA,eAAKG,YAAL,CAAkBR,MAAlB;AACAF,cAAI,GAAG,KAAKd,IAAZ;AACA;AACC;AACJ,OArBL,MAsBK;AACD+B,eAAO,GAAGf,MAAM,CAACG,MAAjB;;AACA,YAAIY,OAAO,CAACV,KAAZ,EAAmB;AACfU,iBAAO,CAACV,KAAR,GAAgB,KAAhB;AACAL,gBAAM,CAACK,KAAP,GAAe,IAAf;AACA,eAAKI,aAAL,CAAmBT,MAAnB;AACAe,iBAAO,GAAGf,MAAM,CAACG,MAAjB;AACC;;AACL,YAAKY,OAAO,CAACZ,MAAR,IAAkBY,OAAO,CAACZ,MAAR,CAAeE,KAAlC,IAA6CU,OAAO,CAACb,OAAR,IAAmBa,OAAO,CAACb,OAAR,CAAgBG,KAApF,EAA4F;AACxF,cAAI,CAACU,OAAO,CAACZ,MAAT,IAAmB,CAACY,OAAO,CAACZ,MAAR,CAAeE,KAAvC,EAA8C;AAC1CU,mBAAO,CAACb,OAAR,CAAgBG,KAAhB,GAAwB,KAAxB;AACAU,mBAAO,CAACV,KAAR,GAAgB,IAAhB;AACA,iBAAKG,YAAL,CAAkBO,OAAlB;AACAA,mBAAO,GAAGf,MAAM,CAACG,MAAjB;AACC;;AACLY,iBAAO,CAACV,KAAR,GAAgBL,MAAM,CAACK,KAAvB;AACAL,gBAAM,CAACK,KAAP,GAAeU,OAAO,CAACZ,MAAR,CAAeE,KAAf,GAAuB,KAAtC;AACA,eAAKI,aAAL,CAAmBT,MAAnB;AACAF,cAAI,GAAG,KAAKd,IAAZ;AACA;AACC;AACJ;;AACL+B,aAAO,CAACV,KAAR,GAAgB,IAAhB;AACAP,UAAI,GAAGE,MAAP;AACAA,YAAM,GAAGA,MAAM,CAACI,QAAhB;AACH,KAnDD,QAmDS,CAACN,IAAI,CAACO,KAnDf;;AAoDA,QAAIP,IAAJ,EAAU;AAACA,UAAI,CAACO,KAAL,GAAa,KAAb;AAAoB;AAC9B,GA7HL;;AA+HAlC,SAAO,CAAC3S,SAAR,CAAkBuT,MAAlB,CAAyBvT,SAAzB,CAAmCgV,YAAnC,GAAkD,UAASV,IAAT,EAAe;AAC7D,QAAIlV,CAAC,GAAGkV,IAAR;AAAA,QACItV,CAAC,GAAGsV,IAAI,CAACI,OADb;AAAA,QACsB;AAClBF,UAAM,GAAGpV,CAAC,CAACwV,QAFf;;AAGA,QAAIJ,MAAJ,EAAY;AACR,UAAIA,MAAM,CAACG,MAAP,KAAkBvV,CAAtB,EAAyB;AACrBoV,cAAM,CAACG,MAAP,GAAgB3V,CAAhB;AACC,OAFL,MAGK;AACDwV,cAAM,CAACE,OAAP,GAAiB1V,CAAjB;AACC;AACJ,KAPL,MAQK;AACD,WAAKwU,IAAL,GAAYxU,CAAZ;AACC;;AACLA,KAAC,CAAC4V,QAAF,GAAaJ,MAAb;AACApV,KAAC,CAACwV,QAAF,GAAa5V,CAAb;AACAI,KAAC,CAACsV,OAAF,GAAY1V,CAAC,CAAC2V,MAAd;;AACA,QAAIvV,CAAC,CAACsV,OAAN,EAAe;AACXtV,OAAC,CAACsV,OAAF,CAAUE,QAAV,GAAqBxV,CAArB;AACC;;AACLJ,KAAC,CAAC2V,MAAF,GAAWvV,CAAX;AACC,GAtBL;;AAwBAuT,SAAO,CAAC3S,SAAR,CAAkBuT,MAAlB,CAAyBvT,SAAzB,CAAmCiV,aAAnC,GAAmD,UAASX,IAAT,EAAe;AAC9D,QAAIlV,CAAC,GAAGkV,IAAR;AAAA,QACItV,CAAC,GAAGsV,IAAI,CAACK,MADb;AAAA,QACqB;AACjBH,UAAM,GAAGpV,CAAC,CAACwV,QAFf;;AAGA,QAAIJ,MAAJ,EAAY;AACR,UAAIA,MAAM,CAACG,MAAP,KAAkBvV,CAAtB,EAAyB;AACrBoV,cAAM,CAACG,MAAP,GAAgB3V,CAAhB;AACC,OAFL,MAGK;AACDwV,cAAM,CAACE,OAAP,GAAiB1V,CAAjB;AACC;AACJ,KAPL,MAQK;AACD,WAAKwU,IAAL,GAAYxU,CAAZ;AACC;;AACLA,KAAC,CAAC4V,QAAF,GAAaJ,MAAb;AACApV,KAAC,CAACwV,QAAF,GAAa5V,CAAb;AACAI,KAAC,CAACuV,MAAF,GAAW3V,CAAC,CAAC0V,OAAb;;AACA,QAAItV,CAAC,CAACuV,MAAN,EAAc;AACVvV,OAAC,CAACuV,MAAF,CAASC,QAAT,GAAoBxV,CAApB;AACC;;AACLJ,KAAC,CAAC0V,OAAF,GAAYtV,CAAZ;AACC,GAtBL;;AAwBAuT,SAAO,CAAC3S,SAAR,CAAkBuT,MAAlB,CAAyBvT,SAAzB,CAAmC0T,QAAnC,GAA8C,UAASY,IAAT,EAAe;AACzD,WAAOA,IAAI,CAACK,MAAZ,EAAoB;AAChBL,UAAI,GAAGA,IAAI,CAACK,MAAZ;AACC;;AACL,WAAOL,IAAP;AACC,GALL;;AAOA3B,SAAO,CAAC3S,SAAR,CAAkBuT,MAAlB,CAAyBvT,SAAzB,CAAmCwV,OAAnC,GAA6C,UAASlB,IAAT,EAAe;AACxD,WAAOA,IAAI,CAACI,OAAZ,EAAqB;AACjBJ,UAAI,GAAGA,IAAI,CAACI,OAAZ;AACC;;AACL,WAAOJ,IAAP;AACC,GALL,C,CAOA;AACA;;;AAEA3B,SAAO,CAAC3S,SAAR,CAAkByV,OAAlB,GAA4B,UAASC,IAAT,EAAe;AACvC,SAAKA,IAAL,GAAYA,IAAZ;AACC,GAFL,C,CAIA;AACA;;;AAEA/C,SAAO,CAAC3S,SAAR,CAAkB2V,IAAlB,GAAyB,UAASD,IAAT,EAAe;AACpC,SAAKA,IAAL,GAAYA,IAAZ;AACA,SAAKE,SAAL,GAAiB,EAAjB;AACA,SAAKC,OAAL,GAAe,KAAf;AACC,GAJL;;AAMAlD,SAAO,CAAC3S,SAAR,CAAkB2V,IAAlB,CAAuB3V,SAAvB,CAAiC8V,IAAjC,GAAwC,UAASJ,IAAT,EAAe;AACnD,SAAKA,IAAL,GAAYA,IAAZ;AACA,SAAKE,SAAL,GAAiB,EAAjB;AACA,SAAKC,OAAL,GAAe,KAAf;AACA,WAAO,IAAP;AACC,GALL;;AAOAlD,SAAO,CAAC3S,SAAR,CAAkB+V,UAAlB,GAA+B,UAASL,IAAT,EAAe;AAC1C,QAAIM,IAAI,GAAG,KAAK5C,YAAL,CAAkB6C,GAAlB,EAAX;;AACA,QAAKD,IAAL,EAAY;AACR,aAAOA,IAAI,CAACF,IAAL,CAAUJ,IAAV,CAAP;AACC;;AACL,WAAO,IAAI,KAAKC,IAAT,CAAcD,IAAd,CAAP;AACC,GANL;;AAQA/C,SAAO,CAAC3S,SAAR,CAAkB2V,IAAlB,CAAuB3V,SAAvB,CAAiCkW,gBAAjC,GAAoD,YAAW;AAC3D,QAAIN,SAAS,GAAG,KAAKA,SAArB;AAAA,QACIO,SAAS,GAAGP,SAAS,CAAC1X,MAD1B;AAAA,QAEIkY,IAFJ,CAD2D,CAI3D;AACA;AACA;;AACA,WAAOD,SAAS,EAAhB,EAAoB;AAChBC,UAAI,GAAGR,SAAS,CAACO,SAAD,CAAT,CAAqBC,IAA5B;;AACA,UAAI,CAACA,IAAI,CAACC,EAAN,IAAY,CAACD,IAAI,CAACE,EAAtB,EAA0B;AACtBV,iBAAS,CAACW,MAAV,CAAiBJ,SAAjB,EAA2B,CAA3B;AACC;AACJ,KAZsD,CAc3D;AACA;AACA;AACA;AACA;;;AACAP,aAAS,CAACzF,IAAV,CAAe,UAASlT,CAAT,EAAWC,CAAX,EAAa;AAAC,aAAOA,CAAC,CAACsZ,KAAF,GAAQvZ,CAAC,CAACuZ,KAAjB;AAAwB,KAArD;AACA,WAAOZ,SAAS,CAAC1X,MAAjB;AACC,GArBL,C,CAuBA;;;AACAyU,SAAO,CAAC3S,SAAR,CAAkB2V,IAAlB,CAAuB3V,SAAvB,CAAiCyW,cAAjC,GAAkD,YAAW;AACzD,QAAIC,SAAS,GAAG,EAAhB;AAAA,QACIP,SAAS,GAAG,KAAKP,SAAL,CAAe1X,MAD/B;AAAA,QAEIkY,IAFJ;;AAGA,WAAOD,SAAS,EAAhB,EAAmB;AACfC,UAAI,GAAG,KAAKR,SAAL,CAAeO,SAAf,EAA0BC,IAAjC;;AACA,UAAIA,IAAI,CAACO,KAAL,KAAe,IAAf,IAAuBP,IAAI,CAACO,KAAL,CAAWC,SAAX,IAAwB,KAAKlB,IAAL,CAAUkB,SAA7D,EAAwE;AACpEF,iBAAS,CAACtY,IAAV,CAAegY,IAAI,CAACO,KAAL,CAAWC,SAA1B;AACC,OAFL,MAGK,IAAIR,IAAI,CAACS,KAAL,KAAe,IAAf,IAAuBT,IAAI,CAACS,KAAL,CAAWD,SAAX,IAAwB,KAAKlB,IAAL,CAAUkB,SAA7D,EAAuE;AACxEF,iBAAS,CAACtY,IAAV,CAAegY,IAAI,CAACS,KAAL,CAAWD,SAA1B;AACC;AACJ;;AACL,WAAOF,SAAP;AACC,GAdL,C,CAgBA;AACA;;;AACA/D,SAAO,CAAC3S,SAAR,CAAkB2V,IAAlB,CAAuB3V,SAAvB,CAAiC8W,OAAjC,GAA2C,YAAW;AAClD,QAAIlB,SAAS,GAAG,KAAKA,SAArB;AAAA,QACIO,SAAS,GAAGP,SAAS,CAAC1X,MAD1B;AAAA,QAEI6Y,IAAI,GAAGC,QAFX;AAAA,QAGIC,IAAI,GAAGD,QAHX;AAAA,QAIIE,IAAI,GAAG,CAACF,QAJZ;AAAA,QAKIG,IAAI,GAAG,CAACH,QALZ;AAAA,QAMIra,CANJ;AAAA,QAMOya,EANP;AAAA,QAMWC,EANX;;AAOA,WAAOlB,SAAS,EAAhB,EAAoB;AAChBxZ,OAAC,GAAGiZ,SAAS,CAACO,SAAD,CAAT,CAAqBmB,aAArB,EAAJ;AACAF,QAAE,GAAGza,CAAC,CAAC2D,CAAP;AACA+W,QAAE,GAAG1a,CAAC,CAAC4D,CAAP;;AACA,UAAI6W,EAAE,GAAGL,IAAT,EAAe;AAACA,YAAI,GAAGK,EAAP;AAAW;;AAC3B,UAAIC,EAAE,GAAGJ,IAAT,EAAe;AAACA,YAAI,GAAGI,EAAP;AAAW;;AAC3B,UAAID,EAAE,GAAGF,IAAT,EAAe;AAACA,YAAI,GAAGE,EAAP;AAAW;;AAC3B,UAAIC,EAAE,GAAGF,IAAT,EAAe;AAACA,YAAI,GAAGE,EAAP;AAAW,OAPX,CAQhB;AACA;;AACC;;AACL,WAAO;AACH/W,OAAC,EAAEyW,IADA;AAEHxW,OAAC,EAAE0W,IAFA;AAGH5U,WAAK,EAAE6U,IAAI,GAACH,IAHT;AAIHzU,YAAM,EAAE6U,IAAI,GAACF;AAJV,KAAP;AAMC,GAzBL,C,CA2BA;AACA;AACA;AACA;AACA;;;AACAtE,SAAO,CAAC3S,SAAR,CAAkB2V,IAAlB,CAAuB3V,SAAvB,CAAiCuX,iBAAjC,GAAqD,UAASjX,CAAT,EAAYC,CAAZ,EAAe;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAIqV,SAAS,GAAG,KAAKA,SAArB;AAAA,QACIO,SAAS,GAAGP,SAAS,CAAC1X,MAD1B;AAAA,QAEIsZ,QAFJ;AAAA,QAGIC,EAHJ;AAAA,QAGQvG,EAHR;AAAA,QAGYtU,CAHZ;;AAIA,WAAOuZ,SAAS,EAAhB,EAAoB;AAChBqB,cAAQ,GAAG5B,SAAS,CAACO,SAAD,CAApB;AACAsB,QAAE,GAAGD,QAAQ,CAACF,aAAT,EAAL;AACApG,QAAE,GAAGsG,QAAQ,CAACE,WAAT,EAAL;AACA9a,OAAC,GAAG,CAAC2D,CAAC,GAACkX,EAAE,CAAClX,CAAN,KAAU2Q,EAAE,CAAC5Q,CAAH,GAAKmX,EAAE,CAACnX,CAAlB,IAAqB,CAACA,CAAC,GAACmX,EAAE,CAACnX,CAAN,KAAU4Q,EAAE,CAAC3Q,CAAH,GAAKkX,EAAE,CAAClX,CAAlB,CAAzB;;AACA,UAAI,CAAC3D,CAAL,EAAQ;AACJ,eAAO,CAAP;AACC;;AACL,UAAIA,CAAC,GAAG,CAAR,EAAW;AACP,eAAO,CAAC,CAAR;AACC;AACJ;;AACL,WAAO,CAAP;AACC,GA9BL,C,CAgCA;AACA;AACA;;;AAEA+V,SAAO,CAAC3S,SAAR,CAAkB2X,MAAlB,GAA2B,UAASrX,CAAT,EAAYC,CAAZ,EAAe;AACtC,SAAKD,CAAL,GAASA,CAAT;AACA,SAAKC,CAAL,GAASA,CAAT;AACC,GAHL;;AAKAoS,SAAO,CAAC3S,SAAR,CAAkB4X,IAAlB,GAAyB,UAASjB,KAAT,EAAgBE,KAAhB,EAAuB;AAC5C,SAAKF,KAAL,GAAaA,KAAb;AACA,SAAKE,KAAL,GAAaA,KAAb;AACA,SAAKP,EAAL,GAAU,KAAKD,EAAL,GAAU,IAApB;AACC,GAJL;;AAMA1D,SAAO,CAAC3S,SAAR,CAAkB6X,QAAlB,GAA6B,UAASzB,IAAT,EAAeO,KAAf,EAAsBE,KAAtB,EAA6B;AACtD,SAAKnB,IAAL,GAAYiB,KAAZ;AACA,SAAKP,IAAL,GAAYA,IAAZ,CAFsD,CAGtD;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAIS,KAAJ,EAAW;AACP,WAAKL,KAAL,GAAa/Z,IAAI,CAACqb,KAAL,CAAWjB,KAAK,CAACtW,CAAN,GAAQoW,KAAK,CAACpW,CAAzB,EAA4BsW,KAAK,CAACvW,CAAN,GAAQqW,KAAK,CAACrW,CAA1C,CAAb;AACC,KAFL,MAGK;AACD,UAAIgW,EAAE,GAAGF,IAAI,CAACE,EAAd;AAAA,UACID,EAAE,GAAGD,IAAI,CAACC,EADd,CADC,CAGD;AACA;;AACA,WAAKG,KAAL,GAAaJ,IAAI,CAACO,KAAL,KAAeA,KAAf,GACTla,IAAI,CAACqb,KAAL,CAAWzB,EAAE,CAAC/V,CAAH,GAAKgW,EAAE,CAAChW,CAAnB,EAAsBgW,EAAE,CAAC/V,CAAH,GAAK8V,EAAE,CAAC9V,CAA9B,CADS,GAET9D,IAAI,CAACqb,KAAL,CAAWxB,EAAE,CAAChW,CAAH,GAAK+V,EAAE,CAAC/V,CAAnB,EAAsB+V,EAAE,CAAC9V,CAAH,GAAK+V,EAAE,CAAC/V,CAA9B,CAFJ;AAGC;AACJ,GAtBL;;AAwBAoS,SAAO,CAAC3S,SAAR,CAAkB+X,cAAlB,GAAmC,UAAS3B,IAAT,EAAeO,KAAf,EAAsBE,KAAtB,EAA6B;AAC5D,WAAO,IAAI,KAAKgB,QAAT,CAAkBzB,IAAlB,EAAwBO,KAAxB,EAA+BE,KAA/B,CAAP;AACC,GAFL;;AAIAlE,SAAO,CAAC3S,SAAR,CAAkB6X,QAAlB,CAA2B7X,SAA3B,CAAqCsX,aAArC,GAAqD,YAAW;AAC5D,WAAO,KAAKlB,IAAL,CAAUO,KAAV,KAAoB,KAAKjB,IAAzB,GAAgC,KAAKU,IAAL,CAAUE,EAA1C,GAA+C,KAAKF,IAAL,CAAUC,EAAhE;AACC,GAFL;;AAIA1D,SAAO,CAAC3S,SAAR,CAAkB6X,QAAlB,CAA2B7X,SAA3B,CAAqC0X,WAArC,GAAmD,YAAW;AAC1D,WAAO,KAAKtB,IAAL,CAAUO,KAAV,KAAoB,KAAKjB,IAAzB,GAAgC,KAAKU,IAAL,CAAUC,EAA1C,GAA+C,KAAKD,IAAL,CAAUE,EAAhE;AACC,GAFL,C,CAMA;;;AAEA3D,SAAO,CAAC3S,SAAR,CAAkBgY,YAAlB,GAAiC,UAAS1X,CAAT,EAAYC,CAAZ,EAAe;AAC5C,QAAI5D,CAAC,GAAG,KAAKuW,cAAL,CAAoB+C,GAApB,EAAR;;AACA,QAAK,CAACtZ,CAAN,EAAU;AACNA,OAAC,GAAG,IAAI,KAAKgb,MAAT,CAAgBrX,CAAhB,EAAmBC,CAAnB,CAAJ;AACC,KAFL,MAGK;AACD5D,OAAC,CAAC2D,CAAF,GAAMA,CAAN;AACA3D,OAAC,CAAC4D,CAAF,GAAMA,CAAN;AACC;;AACL,SAAKqS,QAAL,CAAcxU,IAAd,CAAmBzB,CAAnB;AACA,WAAOA,CAAP;AACC,GAXL,C,CAaA;AACA;AACA;;;AAEAgW,SAAO,CAAC3S,SAAR,CAAkBiY,UAAlB,GAA+B,UAAStB,KAAT,EAAgBE,KAAhB,EAAuBP,EAAvB,EAA2BD,EAA3B,EAA+B;AAC1D,QAAID,IAAI,GAAG,KAAKjD,YAAL,CAAkB8C,GAAlB,EAAX;;AACA,QAAK,CAACG,IAAN,EAAa;AACTA,UAAI,GAAG,IAAI,KAAKwB,IAAT,CAAcjB,KAAd,EAAqBE,KAArB,CAAP;AACC,KAFL,MAGK;AACDT,UAAI,CAACO,KAAL,GAAaA,KAAb;AACAP,UAAI,CAACS,KAAL,GAAaA,KAAb;AACAT,UAAI,CAACE,EAAL,GAAUF,IAAI,CAACC,EAAL,GAAU,IAApB;AACC;;AAEL,SAAKxD,KAAL,CAAWzU,IAAX,CAAgBgY,IAAhB;;AACA,QAAIE,EAAJ,EAAQ;AACJ,WAAK4B,iBAAL,CAAuB9B,IAAvB,EAA6BO,KAA7B,EAAoCE,KAApC,EAA2CP,EAA3C;AACC;;AACL,QAAID,EAAJ,EAAQ;AACJ,WAAK8B,eAAL,CAAqB/B,IAArB,EAA2BO,KAA3B,EAAkCE,KAAlC,EAAyCR,EAAzC;AACC;;AACL,SAAKvD,KAAL,CAAW6D,KAAK,CAACC,SAAjB,EAA4BhB,SAA5B,CAAsCxX,IAAtC,CAA2C,KAAK2Z,cAAL,CAAoB3B,IAApB,EAA0BO,KAA1B,EAAiCE,KAAjC,CAA3C;AACA,SAAK/D,KAAL,CAAW+D,KAAK,CAACD,SAAjB,EAA4BhB,SAA5B,CAAsCxX,IAAtC,CAA2C,KAAK2Z,cAAL,CAAoB3B,IAApB,EAA0BS,KAA1B,EAAiCF,KAAjC,CAA3C;AACA,WAAOP,IAAP;AACC,GArBL;;AAuBAzD,SAAO,CAAC3S,SAAR,CAAkBoY,gBAAlB,GAAqC,UAASzB,KAAT,EAAgBL,EAAhB,EAAoBD,EAApB,EAAwB;AACzD,QAAID,IAAI,GAAG,KAAKjD,YAAL,CAAkB8C,GAAlB,EAAX;;AACA,QAAK,CAACG,IAAN,EAAa;AACTA,UAAI,GAAG,IAAI,KAAKwB,IAAT,CAAcjB,KAAd,EAAqB,IAArB,CAAP;AACC,KAFL,MAGK;AACDP,UAAI,CAACO,KAAL,GAAaA,KAAb;AACAP,UAAI,CAACS,KAAL,GAAa,IAAb;AACC;;AACLT,QAAI,CAACE,EAAL,GAAUA,EAAV;AACAF,QAAI,CAACC,EAAL,GAAUA,EAAV;AACA,SAAKxD,KAAL,CAAWzU,IAAX,CAAgBgY,IAAhB;AACA,WAAOA,IAAP;AACC,GAbL;;AAeAzD,SAAO,CAAC3S,SAAR,CAAkBkY,iBAAlB,GAAsC,UAAS9B,IAAT,EAAeO,KAAf,EAAsBE,KAAtB,EAA6BwB,MAA7B,EAAqC;AACvE,QAAI,CAACjC,IAAI,CAACE,EAAN,IAAY,CAACF,IAAI,CAACC,EAAtB,EAA0B;AACtBD,UAAI,CAACE,EAAL,GAAU+B,MAAV;AACAjC,UAAI,CAACO,KAAL,GAAaA,KAAb;AACAP,UAAI,CAACS,KAAL,GAAaA,KAAb;AACC,KAJL,MAKK,IAAIT,IAAI,CAACO,KAAL,KAAeE,KAAnB,EAA0B;AAC3BT,UAAI,CAACC,EAAL,GAAUgC,MAAV;AACC,KAFA,MAGA;AACDjC,UAAI,CAACE,EAAL,GAAU+B,MAAV;AACC;AACJ,GAZL;;AAcA1F,SAAO,CAAC3S,SAAR,CAAkBmY,eAAlB,GAAoC,UAAS/B,IAAT,EAAeO,KAAf,EAAsBE,KAAtB,EAA6BwB,MAA7B,EAAqC;AACrE,SAAKH,iBAAL,CAAuB9B,IAAvB,EAA6BS,KAA7B,EAAoCF,KAApC,EAA2C0B,MAA3C;AACC,GAFL,C,CAIA;AACA;AAEA;AACA;;;AACA1F,SAAO,CAAC3S,SAAR,CAAkBsY,YAAlB,GAAiC,YAAW,CACvC,CADL,C,CAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA3F,SAAO,CAAC3S,SAAR,CAAkBuY,kBAAlB,GAAuC,UAAS7C,IAAT,EAAe;AAClD,QAAIjC,YAAY,GAAG,KAAKT,oBAAL,CAA0BiD,GAA1B,EAAnB;;AACA,QAAI,CAACxC,YAAL,EAAmB;AACfA,kBAAY,GAAG,IAAI,KAAK6E,YAAT,EAAf;AACC;;AACL7E,gBAAY,CAACiC,IAAb,GAAoBA,IAApB;AACA,WAAOjC,YAAP;AACC,GAPL,C,CASA;AACA;;;AACAd,SAAO,CAAC3S,SAAR,CAAkBwY,cAAlB,GAAmC,UAASC,GAAT,EAAcC,SAAd,EAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA,QAAIhD,IAAI,GAAG+C,GAAG,CAAC/C,IAAf;AAAA,QACIiD,KAAK,GAAGjD,IAAI,CAACpV,CADjB;AAAA,QAEIsY,KAAK,GAAGlD,IAAI,CAACnV,CAFjB;AAAA,QAGIsY,IAAI,GAAGD,KAAK,GAACF,SAHjB,CAnCwD,CAuCxD;;AACA,QAAI,CAACG,IAAL,EAAW;AACP,aAAOF,KAAP;AACC;;AACL,QAAIG,IAAI,GAAGL,GAAG,CAAChE,UAAf;;AACA,QAAI,CAACqE,IAAL,EAAW;AACP,aAAO,CAAC9B,QAAR;AACC;;AACLtB,QAAI,GAAGoD,IAAI,CAACpD,IAAZ;AACA,QAAIqD,KAAK,GAAGrD,IAAI,CAACpV,CAAjB;AAAA,QACI0Y,KAAK,GAAGtD,IAAI,CAACnV,CADjB;AAAA,QAEI0Y,KAAK,GAAGD,KAAK,GAACN,SAFlB,CAhDwD,CAmDxD;;AACA,QAAI,CAACO,KAAL,EAAY;AACR,aAAOF,KAAP;AACC;;AACL,QAAIG,EAAE,GAAGH,KAAK,GAACJ,KAAf;AAAA,QACIQ,IAAI,GAAG,IAAEN,IAAF,GAAO,IAAEI,KADpB;AAAA,QAEI/b,CAAC,GAAGgc,EAAE,GAACD,KAFX;;AAGA,QAAIE,IAAJ,EAAU;AACN,aAAO,CAAC,CAACjc,CAAD,GAAG,KAAKJ,IAAL,CAAUI,CAAC,GAACA,CAAF,GAAI,IAAEic,IAAF,IAAQD,EAAE,GAACA,EAAH,IAAO,CAAC,CAAD,GAAGD,KAAV,IAAiBD,KAAjB,GAAuBC,KAAK,GAAC,CAA7B,GAA+BL,KAA/B,GAAqCC,IAAI,GAAC,CAAlD,CAAd,CAAJ,IAAyEM,IAAzE,GAA8ER,KAArF;AACC,KA5DmD,CA6DxD;;;AACA,WAAO,CAACA,KAAK,GAACI,KAAP,IAAc,CAArB;AACC,GA/DL,C,CAiEA;AACA;;;AACApG,SAAO,CAAC3S,SAAR,CAAkBoZ,eAAlB,GAAoC,UAASX,GAAT,EAAcC,SAAd,EAAyB;AACzD,QAAIW,IAAI,GAAGZ,GAAG,CAAC9E,MAAf;;AACA,QAAI0F,IAAJ,EAAU;AACN,aAAO,KAAKb,cAAL,CAAoBa,IAApB,EAA0BX,SAA1B,CAAP;AACC;;AACL,QAAIhD,IAAI,GAAG+C,GAAG,CAAC/C,IAAf;AACA,WAAOA,IAAI,CAACnV,CAAL,KAAWmY,SAAX,GAAuBhD,IAAI,CAACpV,CAA5B,GAAgC0W,QAAvC;AACC,GAPL;;AASArE,SAAO,CAAC3S,SAAR,CAAkBsZ,kBAAlB,GAAuC,UAAS7F,YAAT,EAAuB;AAC1D,SAAK8F,iBAAL,CAAuB9F,YAAvB,EAD0D,CACpB;;AACtC,SAAKH,SAAL,CAAe4B,YAAf,CAA4BzB,YAA5B,EAF0D,CAEf;;AAC3C,SAAKT,oBAAL,CAA0B5U,IAA1B,CAA+BqV,YAA/B,EAH0D,CAGZ;AAC7C,GAJL;;AAMAd,SAAO,CAAC3S,SAAR,CAAkBwZ,kBAAlB,GAAuC,UAAS/F,YAAT,EAAuB;AAC1D,QAAIgG,MAAM,GAAGhG,YAAY,CAACiG,WAA1B;AAAA,QACIpZ,CAAC,GAAGmZ,MAAM,CAACnZ,CADf;AAAA,QAEIC,CAAC,GAAGkZ,MAAM,CAACE,OAFf;AAAA,QAGItB,MAAM,GAAG,KAAKL,YAAL,CAAkB1X,CAAlB,EAAqBC,CAArB,CAHb;AAAA,QAIIqZ,QAAQ,GAAGnG,YAAY,CAACgB,UAJ5B;AAAA,QAKIY,IAAI,GAAG5B,YAAY,CAACE,MALxB;AAAA,QAMIkG,uBAAuB,GAAG,CAACpG,YAAD,CAN9B;AAAA,QAOIqG,MAAM,GAAGrd,IAAI,CAAC4P,GAPlB,CAD0D,CAU1D;;AACA,SAAKiN,kBAAL,CAAwB7F,YAAxB,EAX0D,CAa1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA,QAAIqF,IAAI,GAAGc,QAAX;;AACA,WAAOd,IAAI,CAACY,WAAL,IAAoBI,MAAM,CAACxZ,CAAC,GAACwY,IAAI,CAACY,WAAL,CAAiBpZ,CAApB,CAAN,GAA6B,IAAjD,IAAyDwZ,MAAM,CAACvZ,CAAC,GAACuY,IAAI,CAACY,WAAL,CAAiBC,OAApB,CAAN,GAAmC,IAAnG,EAAyG;AACrGC,cAAQ,GAAGd,IAAI,CAACrE,UAAhB;AACAoF,6BAAuB,CAACE,OAAxB,CAAgCjB,IAAhC;AACA,WAAKQ,kBAAL,CAAwBR,IAAxB,EAHqG,CAGtE;;AAC/BA,UAAI,GAAGc,QAAP;AACC,KA7BqD,CA8B1D;AACA;AACA;AACA;;;AACAC,2BAAuB,CAACE,OAAxB,CAAgCjB,IAAhC;AACA,SAAKS,iBAAL,CAAuBT,IAAvB,EAnC0D,CAqC1D;;AACA,QAAIO,IAAI,GAAGhE,IAAX;;AACA,WAAOgE,IAAI,CAACK,WAAL,IAAoBI,MAAM,CAACxZ,CAAC,GAAC+Y,IAAI,CAACK,WAAL,CAAiBpZ,CAApB,CAAN,GAA6B,IAAjD,IAAyDwZ,MAAM,CAACvZ,CAAC,GAAC8Y,IAAI,CAACK,WAAL,CAAiBC,OAApB,CAAN,GAAmC,IAAnG,EAAyG;AACrGtE,UAAI,GAAGgE,IAAI,CAAC1F,MAAZ;AACAkG,6BAAuB,CAACzb,IAAxB,CAA6Bib,IAA7B;AACA,WAAKC,kBAAL,CAAwBD,IAAxB,EAHqG,CAGtE;;AAC/BA,UAAI,GAAGhE,IAAP;AACC,KA5CqD,CA6C1D;AACA;AACA;;;AACAwE,2BAAuB,CAACzb,IAAxB,CAA6Bib,IAA7B;AACA,SAAKE,iBAAL,CAAuBF,IAAvB,EAjD0D,CAmD1D;AACA;;AACA,QAAIW,KAAK,GAAGH,uBAAuB,CAAC3b,MAApC;AAAA,QACI+b,IADJ;;AAEA,SAAKA,IAAI,GAAC,CAAV,EAAaA,IAAI,GAACD,KAAlB,EAAyBC,IAAI,EAA7B,EAAiC;AAC7BZ,UAAI,GAAGQ,uBAAuB,CAACI,IAAD,CAA9B;AACAnB,UAAI,GAAGe,uBAAuB,CAACI,IAAI,GAAC,CAAN,CAA9B;AACA,WAAK/B,iBAAL,CAAuBmB,IAAI,CAACjD,IAA5B,EAAkC0C,IAAI,CAACpD,IAAvC,EAA6C2D,IAAI,CAAC3D,IAAlD,EAAwD2C,MAAxD;AACC,KA3DqD,CA6D1D;AACA;AACA;AACA;AACA;;;AACAS,QAAI,GAAGe,uBAAuB,CAAC,CAAD,CAA9B;AACAR,QAAI,GAAGQ,uBAAuB,CAACG,KAAK,GAAC,CAAP,CAA9B;AACAX,QAAI,CAACjD,IAAL,GAAY,KAAK6B,UAAL,CAAgBa,IAAI,CAACpD,IAArB,EAA2B2D,IAAI,CAAC3D,IAAhC,EAAsCpD,SAAtC,EAAiD+F,MAAjD,CAAZ,CApE0D,CAsE1D;AACA;;AACA,SAAK6B,iBAAL,CAAuBpB,IAAvB;AACA,SAAKoB,iBAAL,CAAuBb,IAAvB;AACC,GA1EL;;AA4EA1G,SAAO,CAAC3S,SAAR,CAAkBma,eAAlB,GAAoC,UAASzE,IAAT,EAAe;AAC/C,QAAIpV,CAAC,GAAGoV,IAAI,CAACpV,CAAb;AAAA,QACIoY,SAAS,GAAGhD,IAAI,CAACnV,CADrB,CAD+C,CAI/C;AACA;AACA;AACA;;AACA,QAAIuY,IAAJ;AAAA,QAAUO,IAAV;AAAA,QACIe,GADJ;AAAA,QACSC,GADT;AAAA,QAEI/F,IAAI,GAAG,KAAKhB,SAAL,CAAeE,IAF1B;;AAIA,WAAOc,IAAP,EAAa;AACT8F,SAAG,GAAG,KAAK5B,cAAL,CAAoBlE,IAApB,EAAyBoE,SAAzB,IAAoCpY,CAA1C,CADS,CAET;;AACA,UAAI8Z,GAAG,GAAG,IAAV,EAAgB;AACZ;AACA;AACA;AACA;AACA;AACA9F,YAAI,GAAGA,IAAI,CAACK,MAAZ;AACC,OAPL,MAQK;AACD0F,WAAG,GAAG/Z,CAAC,GAAC,KAAK8Y,eAAL,CAAqB9E,IAArB,EAA0BoE,SAA1B,CAAR,CADC,CAED;;AACA,YAAI2B,GAAG,GAAG,IAAV,EAAgB;AACZ,cAAI,CAAC/F,IAAI,CAACI,OAAV,EAAmB;AACfoE,gBAAI,GAAGxE,IAAP;AACA;AACC;;AACLA,cAAI,GAAGA,IAAI,CAACI,OAAZ;AACC,SANL,MAOK;AACD;AACA,cAAI0F,GAAG,GAAG,CAAC,IAAX,EAAiB;AACbtB,gBAAI,GAAGxE,IAAI,CAACG,UAAZ;AACA4E,gBAAI,GAAG/E,IAAP;AACC,WAHL,CAIA;AAJA,eAKK,IAAI+F,GAAG,GAAG,CAAC,IAAX,EAAiB;AAClBvB,gBAAI,GAAGxE,IAAP;AACA+E,gBAAI,GAAG/E,IAAI,CAACX,MAAZ;AACC,WAHA,CAIL;AAJK,eAKA;AACDmF,gBAAI,GAAGO,IAAI,GAAG/E,IAAd;AACC;;AACL;AACC;AACJ;AACJ,KAnD0C,CAoD/C;AACA;AAEA;;;AACA,QAAIgG,MAAM,GAAG,KAAK/B,kBAAL,CAAwB7C,IAAxB,CAAb;AACA,SAAKpC,SAAL,CAAee,iBAAf,CAAiCyE,IAAjC,EAAuCwB,MAAvC,EAzD+C,CA2D/C;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAI,CAACxB,IAAD,IAAS,CAACO,IAAd,EAAoB;AAChB;AACC,KAvE0C,CAyE/C;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAIP,IAAI,KAAKO,IAAb,EAAmB;AACf;AACA,WAAKE,iBAAL,CAAuBT,IAAvB,EAFe,CAIf;;AACAO,UAAI,GAAG,KAAKd,kBAAL,CAAwBO,IAAI,CAACpD,IAA7B,CAAP;AACA,WAAKpC,SAAL,CAAee,iBAAf,CAAiCiG,MAAjC,EAAyCjB,IAAzC,EANe,CAQf;AACA;;AACAiB,YAAM,CAAClE,IAAP,GAAciD,IAAI,CAACjD,IAAL,GAAY,KAAK6B,UAAL,CAAgBa,IAAI,CAACpD,IAArB,EAA2B4E,MAAM,CAAC5E,IAAlC,CAA1B,CAVe,CAYf;AACA;AACA;;AACA,WAAKwE,iBAAL,CAAuBpB,IAAvB;AACA,WAAKoB,iBAAL,CAAuBb,IAAvB;AACA;AACC,KAlG0C,CAoG/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAIP,IAAI,IAAI,CAACO,IAAb,EAAmB;AACfiB,YAAM,CAAClE,IAAP,GAAc,KAAK6B,UAAL,CAAgBa,IAAI,CAACpD,IAArB,EAA0B4E,MAAM,CAAC5E,IAAjC,CAAd;AACA;AACC,KAhH0C,CAkH/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAIoD,IAAI,KAAKO,IAAb,EAAmB;AACf;AACA,WAAKE,iBAAL,CAAuBT,IAAvB;AACA,WAAKS,iBAAL,CAAuBF,IAAvB,EAHe,CAKf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAI1C,KAAK,GAAGmC,IAAI,CAACpD,IAAjB;AAAA,UACI/Q,EAAE,GAAGgS,KAAK,CAACrW,CADf;AAAA,UAEIoE,EAAE,GAAGiS,KAAK,CAACpW,CAFf;AAAA,UAGIga,EAAE,GAAC7E,IAAI,CAACpV,CAAL,GAAOqE,EAHd;AAAA,UAII6V,EAAE,GAAC9E,IAAI,CAACnV,CAAL,GAAOmE,EAJd;AAAA,UAKImS,KAAK,GAAGwC,IAAI,CAAC3D,IALjB;AAAA,UAMI+E,EAAE,GAAC5D,KAAK,CAACvW,CAAN,GAAQqE,EANf;AAAA,UAOI+V,EAAE,GAAC7D,KAAK,CAACtW,CAAN,GAAQmE,EAPf;AAAA,UAQIlE,CAAC,GAAC,KAAG+Z,EAAE,GAACG,EAAH,GAAMF,EAAE,GAACC,EAAZ,CARN;AAAA,UASIE,EAAE,GAACJ,EAAE,GAACA,EAAH,GAAMC,EAAE,GAACA,EAThB;AAAA,UAUII,EAAE,GAACH,EAAE,GAACA,EAAH,GAAMC,EAAE,GAACA,EAVhB;AAAA,UAWIrC,MAAM,GAAG,KAAKL,YAAL,CAAkB,CAAC0C,EAAE,GAACC,EAAH,GAAMH,EAAE,GAACI,EAAV,IAAcpa,CAAd,GAAgBmE,EAAlC,EAAsC,CAAC4V,EAAE,GAACK,EAAH,GAAMH,EAAE,GAACE,EAAV,IAAcna,CAAd,GAAgBkE,EAAtD,CAXb,CAbe,CA0Bf;;AACA,WAAKwT,iBAAL,CAAuBmB,IAAI,CAACjD,IAA5B,EAAkCO,KAAlC,EAAyCE,KAAzC,EAAgDwB,MAAhD,EA3Be,CA6Bf;;AACAiC,YAAM,CAAClE,IAAP,GAAc,KAAK6B,UAAL,CAAgBtB,KAAhB,EAAuBjB,IAAvB,EAA6BpD,SAA7B,EAAwC+F,MAAxC,CAAd;AACAgB,UAAI,CAACjD,IAAL,GAAY,KAAK6B,UAAL,CAAgBvC,IAAhB,EAAsBmB,KAAtB,EAA6BvE,SAA7B,EAAwC+F,MAAxC,CAAZ,CA/Be,CAiCf;AACA;;AACA,WAAK6B,iBAAL,CAAuBpB,IAAvB;AACA,WAAKoB,iBAAL,CAAuBb,IAAvB;AACA;AACC;AACJ,GA3KL,C,CA6KA;AACA;AAEA;AACA;;;AACA1G,SAAO,CAAC3S,SAAR,CAAkB6a,WAAlB,GAAgC,YAAW;AACvC;AACA,SAAKpC,GAAL,GAAW,IAAX;AACA,SAAK9D,MAAL,GAAc,IAAd;AACA,SAAKhB,MAAL,GAAc,IAAd;AACA,SAAKiB,QAAL,GAAgB,IAAhB;AACA,SAAKH,UAAL,GAAkB,IAAlB;AACA,SAAKI,KAAL,GAAa,KAAb;AACA,SAAKH,OAAL,GAAe,IAAf;AACA,SAAKgB,IAAL,GAAY,IAAZ;AACA,SAAKpV,CAAL,GAAS,KAAKC,CAAL,GAAS,KAAKoZ,OAAL,GAAe,CAAjC;AACC,GAXL;;AAaAhH,SAAO,CAAC3S,SAAR,CAAkBka,iBAAlB,GAAsC,UAASzB,GAAT,EAAc;AAChD,QAAIK,IAAI,GAAGL,GAAG,CAAChE,UAAf;AAAA,QACI4E,IAAI,GAAGZ,GAAG,CAAC9E,MADf;;AAEA,QAAI,CAACmF,IAAD,IAAS,CAACO,IAAd,EAAoB;AAAC;AAAQ,KAHmB,CAGlB;;;AAC9B,QAAI1C,KAAK,GAAGmC,IAAI,CAACpD,IAAjB;AAAA,QACIoF,KAAK,GAAGrC,GAAG,CAAC/C,IADhB;AAAA,QAEImB,KAAK,GAAGwC,IAAI,CAAC3D,IAFjB,CAJgD,CAQhD;AACA;;AACA,QAAIiB,KAAK,KAAGE,KAAZ,EAAmB;AAAC;AAAQ,KAVoB,CAYhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAI0D,EAAE,GAAGO,KAAK,CAACxa,CAAf;AAAA,QACIka,EAAE,GAAGM,KAAK,CAACva,CADf;AAAA,QAEIoE,EAAE,GAAGgS,KAAK,CAACrW,CAAN,GAAQia,EAFjB;AAAA,QAGI7V,EAAE,GAAGiS,KAAK,CAACpW,CAAN,GAAQia,EAHjB;AAAA,QAIIC,EAAE,GAAG5D,KAAK,CAACvW,CAAN,GAAQia,EAJjB;AAAA,QAKIG,EAAE,GAAG7D,KAAK,CAACtW,CAAN,GAAQia,EALjB,CAtBgD,CA6BhD;AACA;AACA;AACA;AACA;AACA;;AACA,QAAIha,CAAC,GAAG,KAAGmE,EAAE,GAAC+V,EAAH,GAAMhW,EAAE,GAAC+V,EAAZ,CAAR;;AACA,QAAIja,CAAC,IAAI,CAAC,KAAV,EAAgB;AAAC;AAAQ;;AAEzB,QAAIua,EAAE,GAAGpW,EAAE,GAACA,EAAH,GAAMD,EAAE,GAACA,EAAlB;AAAA,QACIkW,EAAE,GAAGH,EAAE,GAACA,EAAH,GAAMC,EAAE,GAACA,EADlB;AAAA,QAEIpa,CAAC,GAAG,CAACoa,EAAE,GAACK,EAAH,GAAMrW,EAAE,GAACkW,EAAV,IAAcpa,CAFtB;AAAA,QAGID,CAAC,GAAG,CAACoE,EAAE,GAACiW,EAAH,GAAMH,EAAE,GAACM,EAAV,IAAcva,CAHtB;AAAA,QAIImZ,OAAO,GAAGpZ,CAAC,GAACia,EAJhB,CAtCgD,CA4ChD;AACA;AAEA;;AACA,QAAId,WAAW,GAAG,KAAKzG,mBAAL,CAAyBgD,GAAzB,EAAlB;;AACA,QAAI,CAACyD,WAAL,EAAkB;AACdA,iBAAW,GAAG,IAAI,KAAKmB,WAAT,EAAd;AACC;;AACLnB,eAAW,CAACjB,GAAZ,GAAkBA,GAAlB;AACAiB,eAAW,CAAChE,IAAZ,GAAmBoF,KAAnB;AACApB,eAAW,CAACpZ,CAAZ,GAAgBA,CAAC,GAACia,EAAlB;AACAb,eAAW,CAACnZ,CAAZ,GAAgBoZ,OAAO,GAAC,KAAK7c,IAAL,CAAUwD,CAAC,GAACA,CAAF,GAAIC,CAAC,GAACA,CAAhB,CAAxB,CAvDgD,CAuDJ;;AAC5CmZ,eAAW,CAACC,OAAZ,GAAsBA,OAAtB;AACAlB,OAAG,CAACiB,WAAJ,GAAkBA,WAAlB,CAzDgD,CA2DhD;AACA;;AACA,QAAIsB,WAAW,GAAG,IAAlB;AAAA,QACI1G,IAAI,GAAG,KAAKV,YAAL,CAAkBJ,IAD7B;;AAEA,WAAOc,IAAP,EAAa;AACT,UAAIoF,WAAW,CAACnZ,CAAZ,GAAgB+T,IAAI,CAAC/T,CAArB,IAA2BmZ,WAAW,CAACnZ,CAAZ,KAAkB+T,IAAI,CAAC/T,CAAvB,IAA4BmZ,WAAW,CAACpZ,CAAZ,IAAiBgU,IAAI,CAAChU,CAAjF,EAAqF;AACjF,YAAIgU,IAAI,CAACK,MAAT,EAAiB;AACbL,cAAI,GAAGA,IAAI,CAACK,MAAZ;AACC,SAFL,MAGK;AACDqG,qBAAW,GAAG1G,IAAI,CAACG,UAAnB;AACA;AACC;AACJ,OARL,MASK;AACD,YAAIH,IAAI,CAACI,OAAT,EAAkB;AACdJ,cAAI,GAAGA,IAAI,CAACI,OAAZ;AACC,SAFL,MAGK;AACDsG,qBAAW,GAAG1G,IAAd;AACA;AACC;AACJ;AACJ;;AACL,SAAKV,YAAL,CAAkBS,iBAAlB,CAAoC2G,WAApC,EAAiDtB,WAAjD;;AACA,QAAI,CAACsB,WAAL,EAAkB;AACd,WAAKnH,gBAAL,GAAwB6F,WAAxB;AACC;AACJ,GAvFL;;AAyFA/G,SAAO,CAAC3S,SAAR,CAAkBuZ,iBAAlB,GAAsC,UAASd,GAAT,EAAc;AAChD,QAAIiB,WAAW,GAAGjB,GAAG,CAACiB,WAAtB;;AACA,QAAIA,WAAJ,EAAiB;AACb,UAAI,CAACA,WAAW,CAACjF,UAAjB,EAA6B;AACzB,aAAKZ,gBAAL,GAAwB6F,WAAW,CAAC/F,MAApC;AACC;;AACL,WAAKC,YAAL,CAAkBsB,YAAlB,CAA+BwE,WAA/B,EAJa,CAIgC;;AAC7C,WAAKzG,mBAAL,CAAyB7U,IAAzB,CAA8Bsb,WAA9B;AACAjB,SAAG,CAACiB,WAAJ,GAAkB,IAAlB;AACC;AACJ,GAVL,C,CAYA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AACA/G,SAAO,CAAC3S,SAAR,CAAkBib,WAAlB,GAAgC,UAAS7E,IAAT,EAAe8E,IAAf,EAAqB;AACjD;AACA,QAAI7E,EAAE,GAAGD,IAAI,CAACC,EAAd;;AACA,QAAI,CAAC,CAACA,EAAN,EAAU;AAAC,aAAO,IAAP;AAAa,KAHyB,CAKjD;;;AACA,QAAIC,EAAE,GAAGF,IAAI,CAACE,EAAd;AAAA,QACI6E,EAAE,GAAGD,IAAI,CAACC,EADd;AAAA,QAEIC,EAAE,GAAGF,IAAI,CAACE,EAFd;AAAA,QAGIC,EAAE,GAAGH,IAAI,CAACG,EAHd;AAAA,QAIIC,EAAE,GAAGJ,IAAI,CAACI,EAJd;AAAA,QAKI3E,KAAK,GAAGP,IAAI,CAACO,KALjB;AAAA,QAMIE,KAAK,GAAGT,IAAI,CAACS,KANjB;AAAA,QAOI0E,EAAE,GAAG5E,KAAK,CAACrW,CAPf;AAAA,QAQIkb,EAAE,GAAG7E,KAAK,CAACpW,CARf;AAAA,QASIkb,EAAE,GAAG5E,KAAK,CAACvW,CATf;AAAA,QAUIob,EAAE,GAAG7E,KAAK,CAACtW,CAVf;AAAA,QAWIuE,EAAE,GAAG,CAACyW,EAAE,GAACE,EAAJ,IAAQ,CAXjB;AAAA,QAYI7W,EAAE,GAAG,CAAC4W,EAAE,GAACE,EAAJ,IAAQ,CAZjB;AAAA,QAaIC,EAbJ;AAAA,QAaQC,EAbR,CANiD,CAqBjD;AACA;AACA;;AACA,SAAK9I,KAAL,CAAW6D,KAAK,CAACC,SAAjB,EAA4Bf,OAA5B,GAAsC,IAAtC;AACA,SAAK/C,KAAL,CAAW+D,KAAK,CAACD,SAAjB,EAA4Bf,OAA5B,GAAsC,IAAtC,CAzBiD,CA2BjD;;AACA,QAAI6F,EAAE,KAAKF,EAAX,EAAe;AACXG,QAAE,GAAG,CAACJ,EAAE,GAACE,EAAJ,KAASC,EAAE,GAACF,EAAZ,CAAL;AACAI,QAAE,GAAGhX,EAAE,GAAC+W,EAAE,GAAC7W,EAAX;AACC,KA/B4C,CAiCjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AACA,QAAI6W,EAAE,KAAKrJ,SAAX,EAAsB;AAClB;AACA,UAAIxN,EAAE,GAAGqW,EAAL,IAAWrW,EAAE,IAAIsW,EAArB,EAAyB;AAAC,eAAO,KAAP;AAAc,OAFtB,CAGlB;;;AACA,UAAIG,EAAE,GAAGE,EAAT,EAAa;AACT,YAAI,CAACnF,EAAD,IAAOA,EAAE,CAAC/V,CAAH,GAAO8a,EAAlB,EAAsB;AAClB/E,YAAE,GAAG,KAAK0B,YAAL,CAAkBlT,EAAlB,EAAsBuW,EAAtB,CAAL;AACC,SAFL,MAGK,IAAI/E,EAAE,CAAC/V,CAAH,IAAQ+a,EAAZ,EAAgB;AACjB,iBAAO,KAAP;AACC;;AACLjF,UAAE,GAAG,KAAK2B,YAAL,CAAkBlT,EAAlB,EAAsBwW,EAAtB,CAAL;AACC,OARL,CASA;AATA,WAUK;AACD,YAAI,CAAChF,EAAD,IAAOA,EAAE,CAAC/V,CAAH,GAAO+a,EAAlB,EAAsB;AAClBhF,YAAE,GAAG,KAAK0B,YAAL,CAAkBlT,EAAlB,EAAsBwW,EAAtB,CAAL;AACC,SAFL,MAGK,IAAIhF,EAAE,CAAC/V,CAAH,GAAO8a,EAAX,EAAe;AAChB,iBAAO,KAAP;AACC;;AACLhF,UAAE,GAAG,KAAK2B,YAAL,CAAkBlT,EAAlB,EAAsBuW,EAAtB,CAAL;AACC;AACJ,KAvBL,CAwBA;AACA;AAzBA,SA0BK,IAAIM,EAAE,GAAG,CAAC,CAAN,IAAWA,EAAE,GAAG,CAApB,EAAuB;AACxB;AACA,UAAIJ,EAAE,GAAGE,EAAT,EAAa;AACT,YAAI,CAACnF,EAAD,IAAOA,EAAE,CAAC/V,CAAH,GAAO8a,EAAlB,EAAsB;AAClB/E,YAAE,GAAG,KAAK0B,YAAL,CAAkB,CAACqD,EAAE,GAACO,EAAJ,IAAQD,EAA1B,EAA8BN,EAA9B,CAAL;AACC,SAFL,MAGK,IAAI/E,EAAE,CAAC/V,CAAH,IAAQ+a,EAAZ,EAAgB;AACjB,iBAAO,KAAP;AACC;;AACLjF,UAAE,GAAG,KAAK2B,YAAL,CAAkB,CAACsD,EAAE,GAACM,EAAJ,IAAQD,EAA1B,EAA8BL,EAA9B,CAAL;AACC,OARL,CASA;AATA,WAUK;AACD,YAAI,CAAChF,EAAD,IAAOA,EAAE,CAAC/V,CAAH,GAAO+a,EAAlB,EAAsB;AAClBhF,YAAE,GAAG,KAAK0B,YAAL,CAAkB,CAACsD,EAAE,GAACM,EAAJ,IAAQD,EAA1B,EAA8BL,EAA9B,CAAL;AACC,SAFL,MAGK,IAAIhF,EAAE,CAAC/V,CAAH,GAAO8a,EAAX,EAAe;AAChB,iBAAO,KAAP;AACC;;AACLhF,UAAE,GAAG,KAAK2B,YAAL,CAAkB,CAACqD,EAAE,GAACO,EAAJ,IAAQD,EAA1B,EAA8BN,EAA9B,CAAL;AACC;AACJ,KArBA,CAsBL;AACA;AAvBK,SAwBA;AACD;AACA,UAAIG,EAAE,GAAGE,EAAT,EAAa;AACT,YAAI,CAACpF,EAAD,IAAOA,EAAE,CAAChW,CAAH,GAAO6a,EAAlB,EAAsB;AAClB7E,YAAE,GAAG,KAAK0B,YAAL,CAAkBmD,EAAlB,EAAsBQ,EAAE,GAACR,EAAH,GAAMS,EAA5B,CAAL;AACC,SAFL,MAGK,IAAItF,EAAE,CAAChW,CAAH,IAAQ8a,EAAZ,EAAgB;AACjB,iBAAO,KAAP;AACC;;AACL/E,UAAE,GAAG,KAAK2B,YAAL,CAAkBoD,EAAlB,EAAsBO,EAAE,GAACP,EAAH,GAAMQ,EAA5B,CAAL;AACC,OARL,CASA;AATA,WAUK;AACD,YAAI,CAACtF,EAAD,IAAOA,EAAE,CAAChW,CAAH,GAAO8a,EAAlB,EAAsB;AAClB9E,YAAE,GAAG,KAAK0B,YAAL,CAAkBoD,EAAlB,EAAsBO,EAAE,GAACP,EAAH,GAAMQ,EAA5B,CAAL;AACC,SAFL,MAGK,IAAItF,EAAE,CAAChW,CAAH,GAAO6a,EAAX,EAAe;AAChB,iBAAO,KAAP;AACC;;AACL9E,UAAE,GAAG,KAAK2B,YAAL,CAAkBmD,EAAlB,EAAsBQ,EAAE,GAACR,EAAH,GAAMS,EAA5B,CAAL;AACC;AACJ;;AACLxF,QAAI,CAACE,EAAL,GAAUA,EAAV;AACAF,QAAI,CAACC,EAAL,GAAUA,EAAV;AAEA,WAAO,IAAP;AACC,GAnIL,C,CAqIA;AACA;AACA;AACA;AACA;;;AACA1D,SAAO,CAAC3S,SAAR,CAAkB6b,QAAlB,GAA6B,UAASzF,IAAT,EAAe8E,IAAf,EAAqB;AAC9C,QAAIvW,EAAE,GAAGyR,IAAI,CAACE,EAAL,CAAQhW,CAAjB;AAAA,QACIoE,EAAE,GAAG0R,IAAI,CAACE,EAAL,CAAQ/V,CADjB;AAAA,QAEIga,EAAE,GAAGnE,IAAI,CAACC,EAAL,CAAQ/V,CAFjB;AAAA,QAGIka,EAAE,GAAGpE,IAAI,CAACC,EAAL,CAAQ9V,CAHjB;AAAA,QAIIub,EAAE,GAAG,CAJT;AAAA,QAKIC,EAAE,GAAG,CALT;AAAA,QAMIra,EAAE,GAAG6Y,EAAE,GAAC5V,EANZ;AAAA,QAOIhD,EAAE,GAAG6Y,EAAE,GAAC9V,EAPZ,CAD8C,CAS9C;;AACA,QAAI1F,CAAC,GAAG2F,EAAE,GAACuW,IAAI,CAACC,EAAhB;;AACA,QAAIzZ,EAAE,KAAG,CAAL,IAAU1C,CAAC,GAAC,CAAhB,EAAmB;AAAC,aAAO,KAAP;AAAc;;AAClC,QAAIpC,CAAC,GAAG,CAACoC,CAAD,GAAG0C,EAAX;;AACA,QAAIA,EAAE,GAAC,CAAP,EAAU;AACN,UAAI9E,CAAC,GAACkf,EAAN,EAAU;AAAC,eAAO,KAAP;AAAc;;AACzB,UAAIlf,CAAC,GAACmf,EAAN,EAAU;AAACA,UAAE,GAACnf,CAAH;AAAM;AAChB,KAHL,MAIK,IAAI8E,EAAE,GAAC,CAAP,EAAU;AACX,UAAI9E,CAAC,GAACmf,EAAN,EAAU;AAAC,eAAO,KAAP;AAAc;;AACzB,UAAInf,CAAC,GAACkf,EAAN,EAAU;AAACA,UAAE,GAAClf,CAAH;AAAM;AAChB,KApByC,CAqB9C;;;AACAoC,KAAC,GAAGkc,IAAI,CAACE,EAAL,GAAQzW,EAAZ;;AACA,QAAIjD,EAAE,KAAG,CAAL,IAAU1C,CAAC,GAAC,CAAhB,EAAmB;AAAC,aAAO,KAAP;AAAc;;AAClCpC,KAAC,GAAGoC,CAAC,GAAC0C,EAAN;;AACA,QAAIA,EAAE,GAAC,CAAP,EAAU;AACN,UAAI9E,CAAC,GAACmf,EAAN,EAAU;AAAC,eAAO,KAAP;AAAc;;AACzB,UAAInf,CAAC,GAACkf,EAAN,EAAU;AAACA,UAAE,GAAClf,CAAH;AAAM;AAChB,KAHL,MAIK,IAAI8E,EAAE,GAAC,CAAP,EAAU;AACX,UAAI9E,CAAC,GAACkf,EAAN,EAAU;AAAC,eAAO,KAAP;AAAc;;AACzB,UAAIlf,CAAC,GAACmf,EAAN,EAAU;AAACA,UAAE,GAACnf,CAAH;AAAM;AAChB,KAhCyC,CAiC9C;;;AACAoC,KAAC,GAAG0F,EAAE,GAACwW,IAAI,CAACG,EAAZ;;AACA,QAAI1Z,EAAE,KAAG,CAAL,IAAU3C,CAAC,GAAC,CAAhB,EAAmB;AAAC,aAAO,KAAP;AAAc;;AAClCpC,KAAC,GAAG,CAACoC,CAAD,GAAG2C,EAAP;;AACA,QAAIA,EAAE,GAAC,CAAP,EAAU;AACN,UAAI/E,CAAC,GAACkf,EAAN,EAAU;AAAC,eAAO,KAAP;AAAc;;AACzB,UAAIlf,CAAC,GAACmf,EAAN,EAAU;AAACA,UAAE,GAACnf,CAAH;AAAM;AAChB,KAHL,MAIK,IAAI+E,EAAE,GAAC,CAAP,EAAU;AACX,UAAI/E,CAAC,GAACmf,EAAN,EAAU;AAAC,eAAO,KAAP;AAAc;;AACzB,UAAInf,CAAC,GAACkf,EAAN,EAAU;AAACA,UAAE,GAAClf,CAAH;AAAM;AAChB,KA5CyC,CA6C9C;;;AACAoC,KAAC,GAAGkc,IAAI,CAACI,EAAL,GAAQ5W,EAAZ;;AACA,QAAI/C,EAAE,KAAG,CAAL,IAAU3C,CAAC,GAAC,CAAhB,EAAmB;AAAC,aAAO,KAAP;AAAc;;AAClCpC,KAAC,GAAGoC,CAAC,GAAC2C,EAAN;;AACA,QAAIA,EAAE,GAAC,CAAP,EAAU;AACN,UAAI/E,CAAC,GAACmf,EAAN,EAAU;AAAC,eAAO,KAAP;AAAc;;AACzB,UAAInf,CAAC,GAACkf,EAAN,EAAU;AAACA,UAAE,GAAClf,CAAH;AAAM;AAChB,KAHL,MAIK,IAAI+E,EAAE,GAAC,CAAP,EAAU;AACX,UAAI/E,CAAC,GAACkf,EAAN,EAAU;AAAC,eAAO,KAAP;AAAc;;AACzB,UAAIlf,CAAC,GAACmf,EAAN,EAAU;AAACA,UAAE,GAACnf,CAAH;AAAM;AAChB,KAxDyC,CA0D9C;AAEA;AACA;AACA;AACA;;;AACA,QAAIkf,EAAE,GAAG,CAAT,EAAY;AACR1F,UAAI,CAACE,EAAL,GAAU,KAAK0B,YAAL,CAAkBrT,EAAE,GAACmX,EAAE,GAACpa,EAAxB,EAA4BgD,EAAE,GAACoX,EAAE,GAACna,EAAlC,CAAV;AACC,KAlEyC,CAoE9C;AACA;AACA;AACA;;;AACA,QAAIoa,EAAE,GAAG,CAAT,EAAY;AACR3F,UAAI,CAACC,EAAL,GAAU,KAAK2B,YAAL,CAAkBrT,EAAE,GAACoX,EAAE,GAACra,EAAxB,EAA4BgD,EAAE,GAACqX,EAAE,GAACpa,EAAlC,CAAV;AACC,KA1EyC,CA4E9C;AACA;;;AACA,QAAKma,EAAE,GAAG,CAAL,IAAUC,EAAE,GAAG,CAApB,EAAwB;AACpB,WAAKjJ,KAAL,CAAWsD,IAAI,CAACO,KAAL,CAAWC,SAAtB,EAAiCf,OAAjC,GAA2C,IAA3C;AACA,WAAK/C,KAAL,CAAWsD,IAAI,CAACS,KAAL,CAAWD,SAAtB,EAAiCf,OAAjC,GAA2C,IAA3C;AACH;;AAED,WAAO,IAAP;AACC,GApFL,C,CAsFA;;;AACAlD,SAAO,CAAC3S,SAAR,CAAkBgc,SAAlB,GAA8B,UAASd,IAAT,EAAe;AACzC;AACA;AACA,QAAIrI,KAAK,GAAG,KAAKA,KAAjB;AAAA,QACIoJ,KAAK,GAAGpJ,KAAK,CAAC3U,MADlB;AAAA,QAEIkY,IAFJ;AAAA,QAGI0D,MAAM,GAAGrd,IAAI,CAAC4P,GAHlB,CAHyC,CAQzC;;AACA,WAAO4P,KAAK,EAAZ,EAAgB;AACZ7F,UAAI,GAAGvD,KAAK,CAACoJ,KAAD,CAAZ,CADY,CAEZ;AACA;AACA;;AACA,UAAI,CAAC,KAAKhB,WAAL,CAAiB7E,IAAjB,EAAuB8E,IAAvB,CAAD,IACA,CAAC,KAAKW,QAAL,CAAczF,IAAd,EAAoB8E,IAApB,CADD,IAECpB,MAAM,CAAC1D,IAAI,CAACE,EAAL,CAAQhW,CAAR,GAAU8V,IAAI,CAACC,EAAL,CAAQ/V,CAAnB,CAAN,GAA4B,IAA5B,IAAoCwZ,MAAM,CAAC1D,IAAI,CAACE,EAAL,CAAQ/V,CAAR,GAAU6V,IAAI,CAACC,EAAL,CAAQ9V,CAAnB,CAAN,GAA4B,IAFrE,EAE4E;AACxE6V,YAAI,CAACE,EAAL,GAAUF,IAAI,CAACC,EAAL,GAAU,IAApB;AACAxD,aAAK,CAAC0D,MAAN,CAAa0F,KAAb,EAAmB,CAAnB;AACC;AACJ;AACJ,GArBL,C,CAuBA;AACA;AACA;AACA;;;AACAtJ,SAAO,CAAC3S,SAAR,CAAkBkc,UAAlB,GAA+B,UAAShB,IAAT,EAAe;AAC1C,QAAIC,EAAE,GAAGD,IAAI,CAACC,EAAd;AAAA,QACIC,EAAE,GAAGF,IAAI,CAACE,EADd;AAAA,QAEIC,EAAE,GAAGH,IAAI,CAACG,EAFd;AAAA,QAGIC,EAAE,GAAGJ,IAAI,CAACI,EAHd;AAAA,QAIIxI,KAAK,GAAG,KAAKA,KAJjB;AAAA,QAKIqJ,KAAK,GAAGrJ,KAAK,CAAC5U,MALlB;AAAA,QAMI8X,IANJ;AAAA,QAOIoG,KAPJ;AAAA,QAQIxG,SARJ;AAAA,QAQeyG,UARf;AAAA,QASIjG,IATJ;AAAA,QAUIE,EAVJ;AAAA,QAUQD,EAVR;AAAA,QAUYiG,EAVZ;AAAA,QAWIC,iBAXJ;AAAA,QAYIzC,MAAM,GAAGrd,IAAI,CAAC4P,GAZlB;;AAcA,WAAO8P,KAAK,EAAZ,EAAgB;AACZnG,UAAI,GAAGlD,KAAK,CAACqJ,KAAD,CAAZ,CADY,CAEZ;AACA;;AACA,UAAI,CAACnG,IAAI,CAACE,gBAAL,EAAL,EAA8B;AAC1B;AACC;;AACL,UAAI,CAACF,IAAI,CAACH,OAAV,EAAmB;AACf;AACC,OATO,CAUZ;AACA;AACA;;;AACAD,eAAS,GAAGI,IAAI,CAACJ,SAAjB;AACAyG,gBAAU,GAAGzG,SAAS,CAAC1X,MAAvB,CAdY,CAeZ;AACA;AAEA;;AACAke,WAAK,GAAG,CAAR;;AACA,aAAOA,KAAK,GAAGC,UAAf,EAA2B;AACvB/F,UAAE,GAAGV,SAAS,CAACwG,KAAD,CAAT,CAAiB1E,WAAjB,EAAL;AACA4E,UAAE,GAAG1G,SAAS,CAAC,CAACwG,KAAK,GAAC,CAAP,IAAYC,UAAb,CAAT,CAAkC/E,aAAlC,EAAL,CAFuB,CAGvB;AACA;;AACA,YAAIwC,MAAM,CAACxD,EAAE,CAAChW,CAAH,GAAKgc,EAAE,CAAChc,CAAT,CAAN,IAAmB,IAAnB,IAA2BwZ,MAAM,CAACxD,EAAE,CAAC/V,CAAH,GAAK+b,EAAE,CAAC/b,CAAT,CAAN,IAAmB,IAAlD,EAAwD;AAEpD;AACA;AACA;AAEA;AACA,kBAAQ,IAAR;AAEI;AACA,iBAAK,KAAKyT,gBAAL,CAAsBsC,EAAE,CAAChW,CAAzB,EAA2B6a,EAA3B,KAAkC,KAAKhH,mBAAL,CAAyBmC,EAAE,CAAC/V,CAA5B,EAA8B+a,EAA9B,CAAvC;AACIiB,+BAAiB,GAAG,KAAKvI,gBAAL,CAAsBsI,EAAE,CAAChc,CAAzB,EAA2B6a,EAA3B,CAApB;AACA9E,gBAAE,GAAG,KAAK2B,YAAL,CAAkBmD,EAAlB,EAAsBoB,iBAAiB,GAAGD,EAAE,CAAC/b,CAAN,GAAU+a,EAAjD,CAAL;AACAlF,kBAAI,GAAG,KAAKgC,gBAAL,CAAsBpC,IAAI,CAACN,IAA3B,EAAiCY,EAAjC,EAAqCD,EAArC,CAAP;AACA+F,mBAAK;AACLxG,uBAAS,CAACW,MAAV,CAAiB6F,KAAjB,EAAwB,CAAxB,EAA2B,KAAKrE,cAAL,CAAoB3B,IAApB,EAA0BJ,IAAI,CAACN,IAA/B,EAAqC,IAArC,CAA3B;AACA2G,wBAAU;;AACV,kBAAKE,iBAAL,EAAyB;AAAE;AAAQ;;AACnCjG,gBAAE,GAAGD,EAAL;AACA;AAEJ;;AACA,iBAAK,KAAKrC,gBAAL,CAAsBsC,EAAE,CAAC/V,CAAzB,EAA2B+a,EAA3B,KAAkC,KAAKnH,mBAAL,CAAyBmC,EAAE,CAAChW,CAA5B,EAA8B8a,EAA9B,CAAvC;AACImB,+BAAiB,GAAG,KAAKvI,gBAAL,CAAsBsI,EAAE,CAAC/b,CAAzB,EAA2B+a,EAA3B,CAApB;AACAjF,gBAAE,GAAG,KAAK2B,YAAL,CAAkBuE,iBAAiB,GAAGD,EAAE,CAAChc,CAAN,GAAU8a,EAA7C,EAAiDE,EAAjD,CAAL;AACAlF,kBAAI,GAAG,KAAKgC,gBAAL,CAAsBpC,IAAI,CAACN,IAA3B,EAAiCY,EAAjC,EAAqCD,EAArC,CAAP;AACA+F,mBAAK;AACLxG,uBAAS,CAACW,MAAV,CAAiB6F,KAAjB,EAAwB,CAAxB,EAA2B,KAAKrE,cAAL,CAAoB3B,IAApB,EAA0BJ,IAAI,CAACN,IAA/B,EAAqC,IAArC,CAA3B;AACA2G,wBAAU;;AACV,kBAAKE,iBAAL,EAAyB;AAAE;AAAQ;;AACnCjG,gBAAE,GAAGD,EAAL;AACA;AAEJ;;AACA,iBAAK,KAAKrC,gBAAL,CAAsBsC,EAAE,CAAChW,CAAzB,EAA2B8a,EAA3B,KAAkC,KAAKnH,sBAAL,CAA4BqC,EAAE,CAAC/V,CAA/B,EAAiC8a,EAAjC,CAAvC;AACIkB,+BAAiB,GAAG,KAAKvI,gBAAL,CAAsBsI,EAAE,CAAChc,CAAzB,EAA2B8a,EAA3B,CAApB;AACA/E,gBAAE,GAAG,KAAK2B,YAAL,CAAkBoD,EAAlB,EAAsBmB,iBAAiB,GAAGD,EAAE,CAAC/b,CAAN,GAAU8a,EAAjD,CAAL;AACAjF,kBAAI,GAAG,KAAKgC,gBAAL,CAAsBpC,IAAI,CAACN,IAA3B,EAAiCY,EAAjC,EAAqCD,EAArC,CAAP;AACA+F,mBAAK;AACLxG,uBAAS,CAACW,MAAV,CAAiB6F,KAAjB,EAAwB,CAAxB,EAA2B,KAAKrE,cAAL,CAAoB3B,IAApB,EAA0BJ,IAAI,CAACN,IAA/B,EAAqC,IAArC,CAA3B;AACA2G,wBAAU;;AACV,kBAAKE,iBAAL,EAAyB;AAAE;AAAQ;;AACnCjG,gBAAE,GAAGD,EAAL;AACA;AAEJ;;AACA,iBAAK,KAAKrC,gBAAL,CAAsBsC,EAAE,CAAC/V,CAAzB,EAA2B8a,EAA3B,KAAkC,KAAKpH,sBAAL,CAA4BqC,EAAE,CAAChW,CAA/B,EAAiC6a,EAAjC,CAAvC;AACIoB,+BAAiB,GAAG,KAAKvI,gBAAL,CAAsBsI,EAAE,CAAC/b,CAAzB,EAA2B8a,EAA3B,CAApB;AACAhF,gBAAE,GAAG,KAAK2B,YAAL,CAAkBuE,iBAAiB,GAAGD,EAAE,CAAChc,CAAN,GAAU6a,EAA7C,EAAiDE,EAAjD,CAAL;AACAjF,kBAAI,GAAG,KAAKgC,gBAAL,CAAsBpC,IAAI,CAACN,IAA3B,EAAiCY,EAAjC,EAAqCD,EAArC,CAAP;AACA+F,mBAAK;AACLxG,uBAAS,CAACW,MAAV,CAAiB6F,KAAjB,EAAwB,CAAxB,EAA2B,KAAKrE,cAAL,CAAoB3B,IAApB,EAA0BJ,IAAI,CAACN,IAA/B,EAAqC,IAArC,CAA3B;AACA2G,wBAAU;;AACV,kBAAKE,iBAAL,EAAyB;AAAE;AAAQ;;AACnCjG,gBAAE,GAAGD,EAAL,CARJ,CASI;AAEA;;AACAkG,+BAAiB,GAAG,KAAKvI,gBAAL,CAAsBsI,EAAE,CAAChc,CAAzB,EAA2B6a,EAA3B,CAApB;AACA9E,gBAAE,GAAG,KAAK2B,YAAL,CAAkBmD,EAAlB,EAAsBoB,iBAAiB,GAAGD,EAAE,CAAC/b,CAAN,GAAU+a,EAAjD,CAAL;AACAlF,kBAAI,GAAG,KAAKgC,gBAAL,CAAsBpC,IAAI,CAACN,IAA3B,EAAiCY,EAAjC,EAAqCD,EAArC,CAAP;AACA+F,mBAAK;AACLxG,uBAAS,CAACW,MAAV,CAAiB6F,KAAjB,EAAwB,CAAxB,EAA2B,KAAKrE,cAAL,CAAoB3B,IAApB,EAA0BJ,IAAI,CAACN,IAA/B,EAAqC,IAArC,CAA3B;AACA2G,wBAAU;;AACV,kBAAKE,iBAAL,EAAyB;AAAE;AAAQ;;AACnCjG,gBAAE,GAAGD,EAAL,CAnBJ,CAoBI;AAEA;;AACAkG,+BAAiB,GAAG,KAAKvI,gBAAL,CAAsBsI,EAAE,CAAC/b,CAAzB,EAA2B+a,EAA3B,CAApB;AACAjF,gBAAE,GAAG,KAAK2B,YAAL,CAAkBuE,iBAAiB,GAAGD,EAAE,CAAChc,CAAN,GAAU8a,EAA7C,EAAiDE,EAAjD,CAAL;AACAlF,kBAAI,GAAG,KAAKgC,gBAAL,CAAsBpC,IAAI,CAACN,IAA3B,EAAiCY,EAAjC,EAAqCD,EAArC,CAAP;AACA+F,mBAAK;AACLxG,uBAAS,CAACW,MAAV,CAAiB6F,KAAjB,EAAwB,CAAxB,EAA2B,KAAKrE,cAAL,CAAoB3B,IAApB,EAA0BJ,IAAI,CAACN,IAA/B,EAAqC,IAArC,CAA3B;AACA2G,wBAAU;;AACV,kBAAKE,iBAAL,EAAyB;AAAE;AAAQ;;AACnCjG,gBAAE,GAAGD,EAAL,CA9BJ,CA+BI;AAEA;;AACAkG,+BAAiB,GAAG,KAAKvI,gBAAL,CAAsBsI,EAAE,CAAChc,CAAzB,EAA2B8a,EAA3B,CAApB;AACA/E,gBAAE,GAAG,KAAK2B,YAAL,CAAkBoD,EAAlB,EAAsBmB,iBAAiB,GAAGD,EAAE,CAAC/b,CAAN,GAAU8a,EAAjD,CAAL;AACAjF,kBAAI,GAAG,KAAKgC,gBAAL,CAAsBpC,IAAI,CAACN,IAA3B,EAAiCY,EAAjC,EAAqCD,EAArC,CAAP;AACA+F,mBAAK;AACLxG,uBAAS,CAACW,MAAV,CAAiB6F,KAAjB,EAAwB,CAAxB,EAA2B,KAAKrE,cAAL,CAAoB3B,IAApB,EAA0BJ,IAAI,CAACN,IAA/B,EAAqC,IAArC,CAA3B;AACA2G,wBAAU;;AACV,kBAAKE,iBAAL,EAAyB;AAAE;AAAQ;;AACnC;;AAEJ;AACI,oBAAM,6CAAN;AAnFR;AAqFC;;AACLH,aAAK;AACJ;;AACLpG,UAAI,CAACH,OAAL,GAAe,KAAf;AACC;AACJ,GAzIL,C,CA2IA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAlD,SAAO,CAAC3S,SAAR,CAAkBwc,aAAlB,GAAkC,UAASC,KAAT,EAAgB;AAC9C,QAAI3I,CAAC,GAAG,KAAKA,CAAb;AAAA,QACIrW,CAAC,GAAGgf,KAAK,CAACve,MADd;AAAA,QAEIwX,IAFJ;;AAGA,WAAQjY,CAAC,EAAT,EAAc;AACViY,UAAI,GAAG+G,KAAK,CAAChf,CAAD,CAAZ;AACAiY,UAAI,CAACpV,CAAL,GAAS7D,IAAI,CAACW,KAAL,CAAWsY,IAAI,CAACpV,CAAL,GAASwT,CAApB,IAAyBA,CAAlC;AACA4B,UAAI,CAACnV,CAAL,GAAS9D,IAAI,CAACW,KAAL,CAAWsY,IAAI,CAACnV,CAAL,GAASuT,CAApB,IAAyBA,CAAlC;AACC;AACJ,GATL,C,CAWA;AACA;AACA;AACA;AACA;;;AAEAnB,SAAO,CAAC3S,SAAR,CAAkB0c,OAAlB,GAA4B,UAASC,OAAT,EAAkB;AAC1C,QAAKA,OAAL,EAAe;AACX,UAAKA,OAAO,YAAY,KAAKlH,OAA7B,EAAuC;AACnC,aAAK1C,SAAL,GAAiB4J,OAAjB;AACC,OAFL,MAGK;AACD,cAAM,mDAAN;AACC;AACJ;AACJ,GATL,C,CAWA;AACA;AAEA;AACA;AACA;AACA;;;AAEAhK,SAAO,CAAC3S,SAAR,CAAkB4c,OAAlB,GAA4B,UAASH,KAAT,EAAgBvB,IAAhB,EAAsB;AAC9C;AACA,QAAI2B,SAAS,GAAG,IAAInR,IAAJ,EAAhB,CAF8C,CAI9C;;AACA,SAAK2H,KAAL,GAL8C,CAO9C;AACA;;AACA,QAAK,KAAKN,SAAV,EAAsB;AAClB,WAAKG,cAAL,GAAsB,KAAKA,cAAL,CAAoB4J,MAApB,CAA2B,KAAK/J,SAAL,CAAeH,QAA1C,CAAtB;AACA,WAAKO,YAAL,GAAoB,KAAKA,YAAL,CAAkB2J,MAAlB,CAAyB,KAAK/J,SAAL,CAAeF,KAAxC,CAApB;AACA,WAAKO,YAAL,GAAoB,KAAKA,YAAL,CAAkB0J,MAAlB,CAAyB,KAAK/J,SAAL,CAAeD,KAAxC,CAApB;AACA,WAAKC,SAAL,GAAiB,IAAjB;AACC,KAdyC,CAgB9C;;;AACA,QAAIgK,UAAU,GAAGN,KAAK,CAAC/N,KAAN,CAAY,CAAZ,CAAjB;AACAqO,cAAU,CAAC5M,IAAX,CAAgB,UAASlT,CAAT,EAAWC,CAAX,EAAa;AACzB,UAAIN,CAAC,GAAGM,CAAC,CAACqD,CAAF,GAAMtD,CAAC,CAACsD,CAAhB;;AACA,UAAI3D,CAAJ,EAAO;AAAC,eAAOA,CAAP;AAAU;;AAClB,aAAOM,CAAC,CAACoD,CAAF,GAAMrD,CAAC,CAACqD,CAAf;AACC,KAJL,EAlB8C,CAwB9C;;AACA,QAAIoV,IAAI,GAAGqH,UAAU,CAAC9G,GAAX,EAAX;AAAA,QACI+G,MAAM,GAAG,CADb;AAAA,QAEIC,MAFJ;AAAA,QAEY;AACRC,UAHJ;AAAA,QAIIpK,KAAK,GAAG,KAAKA,KAJjB;AAAA,QAKI2G,MALJ,CAzB8C,CAgC9C;;AACA,aAAS;AACL;AACA;AACA;AACAA,YAAM,GAAG,KAAK5F,gBAAd,CAJK,CAML;;AACA,UAAI6B,IAAI,KAAK,CAAC+D,MAAD,IAAW/D,IAAI,CAACnV,CAAL,GAASkZ,MAAM,CAAClZ,CAA3B,IAAiCmV,IAAI,CAACnV,CAAL,KAAWkZ,MAAM,CAAClZ,CAAlB,IAAuBmV,IAAI,CAACpV,CAAL,GAASmZ,MAAM,CAACnZ,CAA7E,CAAR,EAA0F;AACtF;AACA,YAAIoV,IAAI,CAACpV,CAAL,KAAW2c,MAAX,IAAqBvH,IAAI,CAACnV,CAAL,KAAW2c,MAApC,EAA4C;AACxC;AACApK,eAAK,CAACkK,MAAD,CAAL,GAAgB,KAAKjH,UAAL,CAAgBL,IAAhB,CAAhB;AACAA,cAAI,CAACkB,SAAL,GAAiBoG,MAAM,EAAvB,CAHwC,CAIxC;;AACA,eAAK7C,eAAL,CAAqBzE,IAArB,EALwC,CAMxC;;AACAwH,gBAAM,GAAGxH,IAAI,CAACnV,CAAd;AACA0c,gBAAM,GAAGvH,IAAI,CAACpV,CAAd;AACC;;AACLoV,YAAI,GAAGqH,UAAU,CAAC9G,GAAX,EAAP;AACC,OAbL,CAeA;AAfA,WAgBK,IAAIwD,MAAJ,EAAY;AACb,aAAKD,kBAAL,CAAwBC,MAAM,CAAChB,GAA/B;AACC,OAFA,CAIL;AAJK,WAKA;AACD;AACC;AACJ,KAhEyC,CAkE9C;AACA;AACA;AACA;AACA;;;AACA,SAAKuD,SAAL,CAAed,IAAf,EAvE8C,CAyE9C;;AACA,SAAKgB,UAAL,CAAgBhB,IAAhB,EA1E8C,CA4E9C;;AACA,QAAIiC,QAAQ,GAAG,IAAIzR,IAAJ,EAAf,CA7E8C,CA+E9C;;AACA,QAAIiR,OAAO,GAAG,IAAI,KAAKlH,OAAT,EAAd;AACAkH,WAAO,CAAC7J,KAAR,GAAgB,KAAKA,KAArB;AACA6J,WAAO,CAAC9J,KAAR,GAAgB,KAAKA,KAArB;AACA8J,WAAO,CAAC/J,QAAR,GAAmB,KAAKA,QAAxB;AACA+J,WAAO,CAACS,QAAR,GAAmBD,QAAQ,CAACxR,OAAT,KAAmBkR,SAAS,CAAClR,OAAV,EAAtC,CApF8C,CAsF9C;;AACA,SAAK0H,KAAL;AAEA,WAAOsJ,OAAP;AACC,GA1FL;AA4FA;;;AAEA,MAAK,OAAOlK,MAAP,KAAkB,WAAvB,EAAqC;AACjCA,UAAM,CAACC,OAAP,GAAiBC,OAAjB;AACH;;AACD,OAAKA,OAAL,GAAeA,OAAf;;;;;;;;;;;;;AC5rDA,QAAM;AACJ0K,cADI;AAEJC,wBAFI;AAGJC,0BAHI;AAIJC,oBAJI;AAKJC,qBALI;AAMJC,qBANI;AAOJC,mBAPI;AAQJC,QARI;AASJC;AATI,MAUFC,OAAO,CAAC,SAAD,CAVX;;AAaAC,aAAW,GAAG,CAAd;AACAC,sBAAoB,GAAG,IAAvB;AACAC,sBAAoB,GAAG,IAAvB,C,CAEA;AACA;AACA;;AACA,QAAMC,MAAN,CAAa;AACXC,eAAW,CAAC7M,MAAD,EAAS8M,WAAT,EAAsBC,MAAtB,EAA8B;AACvC,WAAK/M,MAAL,GAAcA,MAAd;AACA,WAAK8M,WAAL,GAAmBA,WAAnB;AACA,WAAKC,MAAL,GAAcA,MAAd;AACA,WAAKC,YAAL,GAAoBZ,iBAAiB,CAACW,MAAM,CAACE,OAAR,EAAiBjN,MAAjB,CAArC;AACD;;AAEDkN,YAAQ,GAAG;AACT;AACA,UAAIX,IAAI,CAAC,KAAKvM,MAAL,CAAY,CAAZ,CAAD,EAAiB,KAAKA,MAAL,CAAY,CAAZ,CAAjB,CAAJ,GAAuC,GAA3C,EAAgD,OAAO,EAAP;AAChD,YAAMmN,OAAO,GAAGnB,oBAAoB,CAAC,KAAKhM,MAAL,CAAY,CAAZ,CAAD,EAAiB,KAAK+M,MAAL,CAAYE,OAA7B,CAApC;AACA,YAAMG,OAAO,GAAGpB,oBAAoB,CAAC,KAAKhM,MAAL,CAAY,CAAZ,CAAD,EAAiB,KAAK+M,MAAL,CAAYE,OAA7B,CAApC,CAJS,CAKT;;AACA,UAAI9hB,IAAI,CAACqM,GAAL,CAAS2V,OAAT,EAAkBC,OAAlB,IAA6BV,oBAA7B,IAAqDvhB,IAAI,CAACoM,GAAL,CAAS4V,OAAT,EAAkBC,OAAlB,IAA6BT,oBAAtF,EAA4G;AAC1G,eAAO,EAAP;AACD;;AACD,aAAO,KAAKI,MAAL,CAAYM,SAAZ,CAAsBC,OAAtB,CAA8BC,MAA9B,CAAqCR,MAAM,IAAI;AACpD,YAAIA,MAAM,KAAK,KAAKA,MAApB,EAA4B,OAAO,KAAP;AAC5B,cAAMS,KAAK,GAAGzB,UAAU,CAAC,KAAK/L,MAAL,CAAY,CAAZ,CAAD,EAAiB+M,MAAM,CAACE,OAAxB,CAAxB;AACA,cAAMQ,KAAK,GAAG1B,UAAU,CAAC,KAAK/L,MAAL,CAAY,CAAZ,CAAD,EAAiB+M,MAAM,CAACE,OAAxB,CAAxB;AACA,eAAOO,KAAK,IAAIf,WAAT,IAAwBgB,KAAK,IAAIhB,WAAxC;AACD,OALM,EAKJiB,GALI,CAKAC,cAAc,IAAI,IAAIC,IAAJ,CAAS,IAAT,EAAeD,cAAf,CALlB,CAAP;AAMD;;AAvBU;;AA0Bb,QAAMC,IAAN,CAAW;AACTf,eAAW,CAACgB,MAAD,EAASF,cAAT,EAAyB;AAClC,WAAK3N,MAAL,GAAc6N,MAAM,CAAC7N,MAArB;AACA,WAAKgN,YAAL,GAAoBa,MAAM,CAACb,YAA3B;AACA,WAAKF,WAAL,GAAmBe,MAAM,CAACf,WAA1B;AACA,WAAKgB,SAAL,GAAiB,CAACH,cAAD,CAAjB;AACA,WAAKI,QAAL,GAAgB,KAAhB;AACD;;AAEDC,YAAQ,CAACC,SAAD,EAAY;AAClB,aAAO3B,IAAI,CAAC,KAAKtM,MAAL,CAAY,CAAZ,CAAD,EAAiBiO,SAAS,CAACjO,MAAV,CAAiB,CAAjB,CAAjB,CAAX;AACD;;AAEDkO,mBAAe,CAACD,SAAD,EAAY;AACzB,WAAKF,QAAL,GAAgB,IAAhB;AACA,WAAKD,SAAL,GAAiB,KAAKA,SAAL,CAAetC,MAAf,CAAsByC,SAAS,CAACH,SAAhC,CAAjB;AACA,WAAKK,WAAL,GAAmBF,SAAS,CAACjO,MAAV,CAAiB,CAAjB,CAAnB;AACA,WAAKA,MAAL,CAAY,CAAZ,IAAiBiO,SAAS,CAACjO,MAAV,CAAiB,CAAjB,CAAjB;AACA,WAAKgN,YAAL,CAAkB,CAAlB,IAAuBiB,SAAS,CAACjB,YAAV,CAAuB,CAAvB,CAAvB;AACA,WAAKF,WAAL,IAAoBmB,SAAS,CAACnB,WAAV,CAAsBsB,OAAtB,CAA8B,KAA9B,EAAqC,IAArC,CAApB;AACD;;AAEDC,mBAAe,GAAG;AAChB,YAAMC,eAAe,GAAGrC,sBAAsB,CAC5C,KAAKe,YAAL,CAAkB,CAAlB,CAD4C,EAE5C,KAAKhN,MAAL,CAAY,CAAZ,CAF4C,EAG5C,KAAKgN,YAAL,CAAkB,CAAlB,CAH4C,EAI5C,KAAKhN,MAAL,CAAY,CAAZ,CAJ4C,CAA9C;AAOA,YAAMuO,eAAe,GAAGhC,IAAI,CAAC+B,eAAD,EAAkB,KAAKtO,MAAL,CAAY,CAAZ,CAAlB,CAA5B;AACA,YAAMwO,eAAe,GAAGjC,IAAI,CAAC+B,eAAD,EAAkB,KAAKtO,MAAL,CAAY,CAAZ,CAAlB,CAA5B;AACA,UAAIyO,YAAY,GAAGtjB,IAAI,CAACqM,GAAL,CAAS+W,eAAT,EAA0B,EAA1B,CAAnB;AACA,UAAIG,YAAY,GAAGvjB,IAAI,CAACqM,GAAL,CAASgX,eAAT,EAA0B,EAA1B,CAAnB,CAXgB,CAahB;;AACA,UAAIpiB,KAAK,CAACqiB,YAAD,CAAT,EAAyBA,YAAY,GAAG,EAAf;AACzB,UAAIriB,KAAK,CAACsiB,YAAD,CAAT,EAAyBA,YAAY,GAAG,EAAf;;AAEzB,UAAI,KAAKX,QAAT,EAAmB;AACjB,cAAMY,QAAQ,GAAGpC,IAAI,CAAC,KAAK4B,WAAN,EAAmB,KAAKnO,MAAL,CAAY,CAAZ,CAAnB,CAArB;AACA,cAAM4O,QAAQ,GAAGrC,IAAI,CAAC,KAAK4B,WAAN,EAAmB,KAAKnO,MAAL,CAAY,CAAZ,CAAnB,CAArB;AACAyO,oBAAY,GAAGtjB,IAAI,CAACoM,GAAL,CAASoX,QAAQ,GAAG,GAApB,EAAyBF,YAAzB,CAAf;AACAC,oBAAY,GAAGvjB,IAAI,CAACoM,GAAL,CAASqX,QAAQ,GAAG,GAApB,EAAyBF,YAAzB,CAAf;AACD;;AAED,YAAMG,aAAa,GAAG1C,iBAAiB,CAAC,KAAKa,YAAL,CAAkB,CAAlB,CAAD,EAAuB,KAAKhN,MAAL,CAAY,CAAZ,CAAvB,EAAuCyO,YAAvC,CAAvC;AACA,YAAMK,aAAa,GAAG3C,iBAAiB,CAAC,KAAKa,YAAL,CAAkB,CAAlB,CAAD,EAAuB,KAAKhN,MAAL,CAAY,CAAZ,CAAvB,EAAuC0O,YAAvC,CAAvC;;AAEA,YAAMK,OAAO,GAAG3O,KAAK,cAAOjV,IAAI,CAAC6jB,KAAL,CAAW5O,KAAK,CAACpR,CAAjB,CAAP,cAA8B7D,IAAI,CAAC6jB,KAAL,CAAW5O,KAAK,CAACnR,CAAjB,CAA9B,CAArB;;AAEA,uBAAU8f,OAAO,CAAC,KAAK/O,MAAL,CAAY,CAAZ,CAAD,CAAjB,gBAAuC+O,OAAO,CAACF,aAAD,CAA9C,cAAiEE,OAAO,CAACD,aAAD,CAAxE,cAA2FC,OAAO,CAAC,KAAK/O,MAAL,CAAY,CAAZ,CAAD,CAAlG;AACD;;AApDQ;;AAuDX,QAAMiP,MAAN,CAAa;AACXpC,eAAW,CAACqC,UAAD,EAAa7B,SAAb,EAAwB8B,SAAxB,EAAmC;AAC5C,WAAKD,UAAL,GAAkBA,UAAlB;AACA,WAAKjC,OAAL,GAAef,gBAAgB,CAACgD,UAAD,CAA/B;AACA,WAAK7B,SAAL,GAAiBA,SAAjB;AACA,WAAK8B,SAAL,GAAiBA,SAAjB;AACD;;AAEDC,cAAU,GAAG;AACX,YAAMC,gBAAgB,GAAG,KAAKH,UAAL,CAAgBI,KAAhB,CAAsB,qCAAtB,CAAzB;AACA,UAAI,CAACD,gBAAL,EAAuB,OAAO,EAAP;AACvB,aAAOA,gBAAgB,CAAC3B,GAAjB,CAAqB6B,eAAe,IAAI;AAC7C,cAAMC,oBAAoB,GAAG,IAAIC,MAAJ,WAAcF,eAAd,4CAA7B;AACA,cAAMzC,WAAW,GAAG,KAAKoC,UAAL,CAAgBI,KAAhB,CAAsBE,oBAAtB,EAA4C,CAA5C,CAApB;AACA,cAAME,KAAK,GAAG5C,WAAW,CAAC6C,KAAZ,CAAkB,SAAlB,EAA6BjC,GAA7B,CAAiCkC,GAAG,IAAIC,UAAU,CAACD,GAAD,CAAlD,CAAd;AACA,cAAM5P,MAAM,GAAG,CAAC;AAAChR,WAAC,EAAE0gB,KAAK,CAAC,CAAD,CAAT;AAAczgB,WAAC,EAAEygB,KAAK,CAAC,CAAD;AAAtB,SAAD,EAA6B;AAAC1gB,WAAC,EAAE0gB,KAAK,CAAC,CAAD,CAAT;AAAczgB,WAAC,EAAEygB,KAAK,CAAC,CAAD;AAAtB,SAA7B,CAAf;AACA,eAAO,IAAI9C,MAAJ,CAAW5M,MAAX,EAAmB8M,WAAnB,EAAgC,IAAhC,CAAP;AACD,OANM,CAAP;AAOD;;AAEDgD,iBAAa,GAAG;AACd,YAAMC,OAAO,GAAG,KAAKX,UAAL,EAAhB;AACA,UAAIY,KAAK,GAAG,EAAZ;AACAD,aAAO,CAACE,OAAR,CAAgBpC,MAAM,IAAI;AACxBA,cAAM,CAACX,QAAP,GAAkB+C,OAAlB,CAA0BC,IAAI,IAAI;AAChC,gBAAMC,QAAQ,GAAGH,KAAK,CAACA,KAAK,CAACpjB,MAAN,GAAe,CAAhB,CAAtB;;AACA,cAAIujB,QAAQ,IAAIA,QAAQ,CAACnC,QAAT,CAAkBkC,IAAlB,CAAhB,EAAyC;AACvCC,oBAAQ,CAACjC,eAAT,CAAyBgC,IAAzB;AACD,WAFD,MAEO;AACLF,iBAAK,CAACljB,IAAN,CAAWojB,IAAX;AACD;AACF,SAPD;AAQD,OATD;AAWA,UAAIE,kBAAkB,GAAG,KAAKlB,UAA9B;AACAc,WAAK,CAACC,OAAN,CAAcC,IAAI,IAAI;AACpB,cAAMG,MAAM,GAAGH,IAAI,CAAC7B,eAAL,EAAf;AACA+B,0BAAkB,GAAG/D,eAAe,CAAC+D,kBAAkB,CAAChC,OAAnB,CAA2B8B,IAAI,CAACpD,WAAhC,EAA6CuD,MAA7C,CAAD,CAApC;AACD,OAHD;AAKA,aAAO;AACLC,kBAAU,EAAEN,KAAK,CAACpjB,MAAN,GAAe,CADtB;AAEL2jB,uBAAe,EAAE,CAAC,CAACP,KAAK,CAACQ,IAAN,CAAWN,IAAI,IAAIA,IAAI,CAACnC,QAAxB,CAFd;AAGLmB,kBAAU,EAAEkB,kBAHP;AAILjB,iBAAS,EAAE,KAAKA;AAJX,OAAP;AAMD;;AA9CU;;AAiDb,QAAMsB,SAAN,CAAgB;AACd5D,eAAW,CAAC6D,WAAD,EAAc;AACvB,WAAKpD,OAAL,GAAeoD,WAAW,CAAChD,GAAZ,CAAgB,CAACiD,IAAD,EAAOnkB,CAAP,KAAa,IAAIyiB,MAAJ,CAAW0B,IAAX,EAAiB,IAAjB,EAAuBnkB,CAAvB,CAA7B,CAAf;AACD;;AAHa;;AAMhB,QAAMokB,qBAAqB,GAAIC,iBAAD,IAAuB;AACnD,UAAMxD,SAAS,GAAG,IAAIoD,SAAJ,CAAcI,iBAAd,CAAlB;AACA,UAAMC,gBAAgB,GAAGzD,SAAS,CAACC,OAAV,CAAkBI,GAAlB,CAAsBX,MAAM,IAAIA,MAAM,CAAC+C,aAAP,EAAhC,CAAzB;AAEA,WAAO;AACLiB,cAAQ,EAAE,CAAC,CAACD,gBAAgB,CAACN,IAAjB,CAAsBQ,OAAO,IAAIA,OAAO,CAACV,UAAzC,CADP;AAELW,4BAAsB,EAAE,CAAC,CAACH,gBAAgB,CAACN,IAAjB,CAAsBQ,OAAO,IAAIA,OAAO,CAACT,eAAzC,CAFrB;AAGLW,qBAAe,EAAEJ,gBAAgB,CAACvD,MAAjB,CAAwByD,OAAO,IAAIA,OAAO,CAACV,UAA3C,EAAuD5C,GAAvD,CAA2DsD,OAAO,IAAIA,OAAO,CAAC7B,SAA9E,CAHZ;AAIL7B,aAAO,EAAEwD,gBAAgB,CAACpD,GAAjB,CAAqBsD,OAAO,IAAIA,OAAO,CAAC9B,UAAxC;AAJJ,KAAP;AAMD,GAVD;;AAYA,QAAMiC,cAAc,GAAI7D,OAAD,IAAa;AAClC,UAAM8D,SAAS,GAAGR,qBAAqB,CAACtD,OAAD,CAAvC;AACA,WAAO8D,SAAS,CAACL,QAAV,GAAqBK,SAAS,CAAC9D,OAA/B,GAAyCA,OAAhD;AACD,GAHD;;AAKA,QAAM+D,UAAU,GAAI/D,OAAD,IAAa6D,cAAc,CAACA,cAAc,CAAC7D,OAAD,CAAf,CAA9C;;AAEAnM,QAAM,CAACC,OAAP,GAAiB;AAACiQ;AAAD,GAAjB;;;;;;;;;;;;;AC/KA,QAAMC,YAAY,GAAG9E,OAAO,CAAC,iBAAD,CAA5B;;AAEA,QAAMD,IAAI,GAAG,CAAC3M,EAAD,EAAKC,EAAL,KAAY1U,IAAI,CAACK,IAAL,CAAUL,IAAI,CAACuM,GAAL,CAASkI,EAAE,CAAC5Q,CAAH,GAAO6Q,EAAE,CAAC7Q,CAAnB,EAAsB,CAAtB,IAA2B7D,IAAI,CAACuM,GAAL,CAASkI,EAAE,CAAC3Q,CAAH,GAAO4Q,EAAE,CAAC5Q,CAAnB,EAAsB,CAAtB,CAArC,CAAzB;;AACA,QAAMsiB,IAAI,GAAIC,IAAD,IAAUjF,IAAI,CAACiF,IAAD,EAAO;AAACxiB,KAAC,EAAE,CAAJ;AAAOC,KAAC,EAAE;AAAV,GAAP,CAA3B;;AACA,QAAMwiB,QAAQ,GAAG,CAAC7R,EAAD,EAAKC,EAAL,MAAa;AAAC7Q,KAAC,EAAE4Q,EAAE,CAAC5Q,CAAH,GAAO6Q,EAAE,CAAC7Q,CAAd;AAAiBC,KAAC,EAAE2Q,EAAE,CAAC3Q,CAAH,GAAO4Q,EAAE,CAAC5Q;AAA9B,GAAb,CAAjB;;AACA,QAAMqd,IAAI,GAAG,CAAC1M,EAAD,EAAKC,EAAL,KAAYD,EAAE,CAAC5Q,CAAH,KAAS6Q,EAAE,CAAC7Q,CAAZ,IAAiB4Q,EAAE,CAAC3Q,CAAH,KAAS4Q,EAAE,CAAC5Q,CAAtD;;AAEA,QAAMid,gBAAgB,GAAG,UAACgD,UAAD,EAA8B;AAAA,QAAjBwC,KAAiB,uEAAT,IAAS;AACrD,UAAMf,IAAI,GAAGW,YAAY,CAACpC,UAAD,CAAzB;AACA,UAAMyC,KAAK,GAAGhB,IAAI,CAAC/jB,MAAL,KAAgB8kB,KAA9B;AACA,UAAMzE,OAAO,GAAG,EAAhB;;AACA,SAAK,IAAIzgB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGklB,KAApB,EAA2BllB,CAAC,IAAI,CAAhC,EAAmC;AACjC,YAAMolB,QAAQ,GAAGjB,IAAI,CAACkB,EAAL,CAAQrlB,CAAC,GAAGmlB,KAAZ,CAAjB;AACA1E,aAAO,CAACngB,IAAR,CAAa;AAACkC,SAAC,EAAE4iB,QAAQ,CAAC,CAAD,CAAZ;AAAiB3iB,SAAC,EAAE2iB,QAAQ,CAAC,CAAD;AAA5B,OAAb;AACD;;AACD,WAAO3E,OAAP;AACD,GATD,C,CAWA;AACA;;;AACA,QAAMhB,sBAAsB,GAAG,CAAC6F,IAAD,EAAOC,IAAP,EAAaC,IAAb,EAAmBC,IAAnB,KAA4B;AACzD,UAAMtgB,EAAE,GAAGmgB,IAAI,CAAC9iB,CAAhB;AACA,UAAMkjB,EAAE,GAAGH,IAAI,CAAC/iB,CAAhB;AACA,UAAMmjB,EAAE,GAAGH,IAAI,CAAChjB,CAAhB;AACA,UAAMojB,EAAE,GAAGH,IAAI,CAACjjB,CAAhB;AACA,UAAMqjB,EAAE,GAAGP,IAAI,CAAC7iB,CAAhB;AACA,UAAMqjB,EAAE,GAAGP,IAAI,CAAC9iB,CAAhB;AACA,UAAMsjB,EAAE,GAAGP,IAAI,CAAC/iB,CAAhB;AACA,UAAMujB,EAAE,GAAGP,IAAI,CAAChjB,CAAhB;AACA,UAAMwjB,UAAU,GAAG,CAAC9gB,EAAE,GAAG2gB,EAAL,GAAUD,EAAE,GAAGH,EAAhB,KAAuBC,EAAE,GAAGC,EAA5B,IAAkC,CAACzgB,EAAE,GAAGugB,EAAN,KAAaC,EAAE,GAAGK,EAAL,GAAUD,EAAE,GAAGH,EAA5B,CAArD;AACA,UAAMM,UAAU,GAAG,CAAC/gB,EAAE,GAAG2gB,EAAL,GAAUD,EAAE,GAAGH,EAAhB,KAAuBK,EAAE,GAAGC,EAA5B,IAAkC,CAACH,EAAE,GAAGC,EAAN,KAAaH,EAAE,GAAGK,EAAL,GAAUD,EAAE,GAAGH,EAA5B,CAArD;AACA,UAAMO,WAAW,GAAG,CAAChhB,EAAE,GAAGugB,EAAN,KAAaK,EAAE,GAAGC,EAAlB,IAAwB,CAACH,EAAE,GAAGC,EAAN,KAAaH,EAAE,GAAGC,EAAlB,CAA5C;AACA,WAAO;AAACpjB,OAAC,EAAEyjB,UAAU,GAAGE,WAAjB;AAA8B1jB,OAAC,EAAEyjB,UAAU,GAAGC;AAA9C,KAAP;AACD,GAbD;;AAeA,QAAMC,aAAa,GAAG,CAACxS,KAAD,EAAQyS,WAAR,KAAwB;AAC5C,UAAMC,KAAK,GAAGD,WAAW,CAACnF,GAAZ,CAAgBqF,YAAY,IAAIxG,IAAI,CAACnM,KAAD,EAAQ2S,YAAR,CAApC,CAAd;AACA,UAAMvb,GAAG,GAAGrM,IAAI,CAACqM,GAAL,CAAS,GAAGsb,KAAZ,CAAZ;AACA,WAAOA,KAAK,CAACE,OAAN,CAAcxb,GAAd,CAAP;AACD,GAJD;;AAMA,QAAMyb,eAAe,GAAG,CAACtS,KAAD,EAAQgR,KAAR,EAAekB,WAAf,KAA+B;AACrD,WAAO,CAACA,WAAW,CAACjmB,MAAZ,GAAqB+T,KAArB,GAA6BgR,KAA9B,IAAuCkB,WAAW,CAACjmB,MAA1D;AACD,GAFD;;AAIA,QAAMof,oBAAoB,GAAG,CAAC5L,KAAD,EAAQyS,WAAR,KAAwB;AACnD;AACA,UAAMK,UAAU,GAAGN,aAAa,CAACxS,KAAD,EAAQyS,WAAR,CAAhC;AACA,UAAMM,QAAQ,GAAGF,eAAe,CAACC,UAAD,EAAa,CAAC,CAAd,EAAiBL,WAAjB,CAAhC;AACA,UAAMO,SAAS,GAAGH,eAAe,CAACC,UAAD,EAAa,CAAb,EAAgBL,WAAhB,CAAjC;AACA,UAAMQ,KAAK,GAAG5B,QAAQ,CAACoB,WAAW,CAACK,UAAD,CAAZ,EAA0BL,WAAW,CAACM,QAAD,CAArC,CAAtB;AACA,UAAMG,KAAK,GAAG7B,QAAQ,CAACoB,WAAW,CAACO,SAAD,CAAZ,EAAyBP,WAAW,CAACK,UAAD,CAApC,CAAtB;AACA,WAAO,CAACG,KAAK,CAACrkB,CAAN,GAAUskB,KAAK,CAACtkB,CAAhB,GAAoBqkB,KAAK,CAACpkB,CAAN,GAAUqkB,KAAK,CAACrkB,CAArC,KAA2CsiB,IAAI,CAAC8B,KAAD,CAAJ,GAAc9B,IAAI,CAAC+B,KAAD,CAA7D,CAAP;AACD,GARD,C,CAUA;AACA;;;AACA,QAAMnH,iBAAiB,GAAG,CAACvM,EAAD,EAAKC,EAAL,EAAS0T,QAAT,KAAsB;AAC9C,UAAM/B,IAAI,GAAGC,QAAQ,CAAC5R,EAAD,EAAKD,EAAL,CAArB;AACA,UAAM4T,GAAG,GAAGD,QAAQ,GAAGhC,IAAI,CAACC,IAAD,CAA3B;AACA,WAAO;AAACxiB,OAAC,EAAE6Q,EAAE,CAAC7Q,CAAH,GAAOwkB,GAAG,GAAGhC,IAAI,CAACxiB,CAAtB;AAAyBC,OAAC,EAAE4Q,EAAE,CAAC5Q,CAAH,GAAOukB,GAAG,GAAGhC,IAAI,CAACviB;AAA9C,KAAP;AACD,GAJD;;AAMA,QAAM8c,UAAU,GAAG,CAAC3L,KAAD,EAAQyS,WAAR,KAAwB;AACzC,UAAMC,KAAK,GAAGD,WAAW,CAACnF,GAAZ,CAAgBqF,YAAY,IAAIxG,IAAI,CAACnM,KAAD,EAAQ2S,YAAR,CAApC,CAAd;AACA,WAAO5nB,IAAI,CAACqM,GAAL,CAAS,GAAGsb,KAAZ,CAAP;AACD,GAHD;;AAKA,QAAMzG,eAAe,GAAI6C,UAAD,IAAgB;AACtC,UAAMuE,MAAM,GAAGvE,UAAU,CAACI,KAAX,CAAiB,YAAjB,CAAf;AACA,QAAI,CAACmE,MAAL,EAAa,OAAOvE,UAAP;AACb,QAAIwE,eAAe,GAAGxE,UAAtB;AACAuE,UAAM,CAACxD,OAAP,CAAe0D,KAAK,IAAI;AACtBD,qBAAe,GAAGA,eAAe,CAACtF,OAAhB,CAAwBuF,KAAxB,EAA+BxoB,IAAI,CAAC6jB,KAAL,CAAWa,UAAU,CAAC8D,KAAD,CAArB,CAA/B,CAAlB;AACD,KAFD;AAGA,WAAOD,eAAP;AACD,GARD;;AAUA,QAAMtH,iBAAiB,GAAG,CAACyG,WAAD,EAAce,UAAd,KAA6B;AACrD,UAAMC,QAAQ,GAAGjB,aAAa,CAACgB,UAAU,CAAC,CAAD,CAAX,EAAgBf,WAAhB,CAA9B;AACA,UAAMiB,QAAQ,GAAGlB,aAAa,CAACgB,UAAU,CAAC,CAAD,CAAX,EAAgBf,WAAhB,CAA9B;AACA,WAAO,CACLA,WAAW,CAACI,eAAe,CAACY,QAAD,EAAW,CAAC,EAAZ,EAAgBhB,WAAhB,CAAhB,CADN,EAELA,WAAW,CAACI,eAAe,CAACa,QAAD,EAAW,EAAX,EAAejB,WAAf,CAAhB,CAFN,CAAP;AAID,GAPD;;AASA1R,QAAM,CAACC,OAAP,GAAiB;AACf2K,cADe;AAEfC,wBAFe;AAGfE,oBAHe;AAIfD,0BAJe;AAKfE,qBALe;AAMfC,qBANe;AAOfG,QAPe;AAQfD,QARe;AASfD;AATe,GAAjB;;;;;;;;;;;;ACvFAlL,MAAM,CAAC4S,MAAP,CAAc;AAACC,kBAAgB,EAAC,MAAIA;AAAtB,CAAd;AAAA,MAAMC,SAAS,GAAG,iBAAlB;AACA,MAAMC,MAAM,GAAG,GAAf;;AAEA,MAAMC,SAAS,GAAG,CAACC,MAAD,EAASC,MAAT,KAAoB;AACpC,QAAMC,IAAI,GAAG,CAACF,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,CAAC,CAAD,CAAnB,EAAwBD,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,CAAC,CAAD,CAA1C,CAAb;AACA,SAAOC,IAAI,CAAC,CAAD,CAAJ,GAAQA,IAAI,CAAC,CAAD,CAAZ,GAAkBA,IAAI,CAAC,CAAD,CAAJ,GAAQA,IAAI,CAAC,CAAD,CAArC;AACD,CAHD;;AAKA,MAAMC,eAAe,GAAIC,MAAD,IAAY;AAClC,MAAIC,MAAM,GAAG,CAAb;;AACA,OAAK,IAAIjoB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgoB,MAAM,CAAC5nB,MAAP,GAAgB,CAApC,EAAuCJ,CAAC,EAAxC,EAA4C;AAC1CioB,UAAM,IAAItpB,IAAI,CAACK,IAAL,CAAU2oB,SAAS,CAACK,MAAM,CAAChoB,CAAD,CAAP,EAAYgoB,MAAM,CAAChoB,CAAC,GAAG,CAAL,CAAlB,CAAnB,CAAV;AACD;;AACD,SAAOioB,MAAP;AACD,CAND;;AAQA,MAAMC,aAAa,GAAIF,MAAD,IAAY;AAChC,QAAMC,MAAM,GAAG,EAAf;;AACA,OAAK,IAAIrU,KAAT,IAAkBoU,MAAlB,EAA0B;AACxBC,UAAM,CAAC3nB,IAAP,CAAY2nB,MAAM,CAAC7nB,MAAP,KAAkB,CAAlB,GAAsB,GAAtB,GAA4B,GAAxC;AACA6nB,UAAM,CAAC3nB,IAAP,CAAY,KAAKsT,KAAK,CAAC,CAAD,CAAtB;AACAqU,UAAM,CAAC3nB,IAAP,CAAY,KAAKsT,KAAK,CAAC,CAAD,CAAtB;AACD;;AACD,SAAOqU,MAAM,CAACE,IAAP,CAAY,GAAZ,CAAP;AACD,CARD;;AAWA,MAAMX,gBAAgB,GAAG,CAAC1G,OAAD,EAAUsH,OAAV,EAAmB3c,OAAnB,KAA+B;AACtDA,SAAO,GAAGA,OAAO,IAAI,EAArB;AACA,QAAM4c,KAAK,GAAG,QAAQ5c,OAAO,CAAC4c,KAAR,IAAiB,GAAzB,CAAd;AACA,QAAMC,KAAK,GAAG,QAAQ7c,OAAO,CAAC6c,KAAR,IAAiB,IAAzB,CAAd;AAEA,QAAMC,OAAO,GAAGH,OAAO,CAAClH,GAAR,CAAa1e,CAAD,IAAOulB,eAAe,CAACvlB,CAAD,CAAf,GAAqBklB,MAAxC,EACQxG,GADR,CACYviB,IAAI,CAAC6jB,KADjB,CAAhB;AAEA,QAAMgG,KAAK,GAAGJ,OAAO,CAAClH,GAAR,CAAYgH,aAAZ,CAAd;AAEA,QAAMO,UAAU,GAAG,EAAnB;AACA,MAAIC,cAAc,GAAG,CAArB;;AACA,OAAK,IAAI1oB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8gB,OAAO,CAAC1gB,MAA5B,EAAoCJ,CAAC,EAArC,EAAyC;AACvC,UAAM2oB,MAAM,GAAGJ,OAAO,CAACvoB,CAAD,CAAP,GAAa0nB,MAA5B;AACA,UAAMkB,QAAQ,GAAG,CAACP,KAAK,GAAGM,MAAT,IAAmBL,KAAnB,GAA2B,EAA5C;AACA,UAAMO,QAAQ,GAAGlqB,IAAI,CAAC6jB,KAAL,CAAW,MAAMmG,MAAN,IAAgBN,KAAK,GAAGM,MAAxB,CAAX,CAAjB;AACAF,cAAU,CAACnoB,IAAX,CAAgB;AACdwoB,kBAAY,YAAKrB,SAAL,wBAA4BznB,CAA5B,CADE;AAEd+oB,aAAO,YAAKtB,SAAL,mBAAuBznB,CAAvB,CAFO;AAGd0C,OAAC,EAAE8lB,KAAK,CAACxoB,CAAD,CAHM;AAIdqoB,WAAK,YAAKK,cAAL,MAJS;AAKdE,cAAQ,YAAKA,QAAL,MALM;AAMdC,cAAQ,YAAKA,QAAL,MANM;AAOdG,eAAS,qBAAchpB,CAAd,CAPK;AAQdI,YAAM,EAAEmoB,OAAO,CAACvoB,CAAD,CARD;AASd2oB,YAAM,EAAEA,MATM;AAUdM,aAAO,EAAE,IAAIV,OAAO,CAACvoB,CAAD,CAVN;AAWdugB,YAAM,EAAEO,OAAO,CAAC9gB,CAAD,CAXD;AAYduE,WAAK,EAAEmjB;AAZO,KAAhB;AAcAgB,kBAAc,IAAIE,QAAlB;AACD;;AAED,SAAO;AAACH,cAAU,EAAEA,UAAb;AAAyB3H,WAAO,EAAEA;AAAlC,GAAP;AACD,CAjCD,C;;;;;;;;;;;;AC3BAoI,SAAO,CAAC3B,MAAR,CAAe;AAAC4B,UAAM,EAAC,MAAIA,MAAZ;AAAmBC,UAAM,EAAC,MAAIA,MAA9B;AAAqCC,gBAAY,EAAC,MAAIA,YAAtD;AAAmEC,SAAK,EAAC,MAAIA,KAA7E;AAAmFC,SAAK,EAAC,MAAIA;AAA7F,GAAf;;AAAA;AACA,QAAMJ,MAAM,GAAG,CAACK,SAAD,EAAYC,OAAZ,KAAwB;AACrC,QAAI,CAACD,SAAL,EAAgB;AACd7e,aAAO,CAAC+e,KAAR,CAAcD,OAAd;AACA,YAAM,IAAIE,KAAJ,EAAN;AACD;AACF,GALD;;AAOA,QAAMC,QAAQ,GAAIpnB,CAAD,IAAOqnB,MAAM,CAACC,QAAP,CAAgBtnB,CAAhB,KAAsB,CAACqnB,MAAM,CAACjqB,KAAP,CAAa4C,CAAb,CAA/C;;AAEA,QAAM6mB,YAAY,GAAI1U,MAAD,IAAYoV,MAAM,CAACC,QAAP,GAAkBC,GAAG,CAACjK,OAAJ,CAAYrL,MAAZ,CAAlB,GAAwC,IAAzE;;AAEA,MAAIyU,MAAM,GAAG,IAAb;;AAEA,MAAIW,MAAM,CAACC,QAAX,EAAqB;AACnBD,UAAM,CAACG,UAAP,CAAkB,UAAlB;;AACA,UAAM/F,IAAI,GAAG8F,GAAG,CAACjK,OAAJ,CAAY,MAAZ,CAAb;;AAEA,uBAAAoJ,MAAM,GAAG,MAAM;AACb;AACA;AACA,aAAOe,OAAO,CAACC,GAAR,IAAeD,OAAO,CAACC,GAAR,CAAYC,GAA3B,GACHF,OAAO,CAACC,GAAR,CAAYC,GADT,GACelG,IAAI,CAACgE,IAAL,CAAUgC,OAAO,CAACG,GAAR,EAAV,EAAyB,aAAzB,CADtB;AAED,KALD;AAMD,G,CAED;AACA;;;AACAvqB,OAAK,CAACmC,SAAN,CAAgBqoB,MAAhB,GAAyB,YAAW;AAClC,UAAMtC,MAAM,GAAG,EAAf;AACA,UAAMuC,IAAI,GAAG,EAAb;AACA,SAAKtJ,GAAL,CAAU1e,CAAD,IAAO;AACd,UAAI,CAACgoB,IAAI,CAAChoB,CAAD,CAAT,EAAc;AACZylB,cAAM,CAAC3nB,IAAP,CAAYkC,CAAZ;AACAgoB,YAAI,CAAChoB,CAAD,CAAJ,GAAU,IAAV;AACD;AACF,KALD;AAMA,WAAOylB,MAAP;AACD,GAVD,C,CAYA;AACA;;;AACAwC,QAAM,CAACvoB,SAAP,CAAiBwoB,YAAjB,GAAgC,UAASC,OAAT,EAAkB;AAChD,QAAI1C,MAAM,GAAG,EAAb;;AACA,SAAK,IAAIjoB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKI,MAAzB,EAAiCJ,CAAC,EAAlC,EAAsC;AACpCioB,YAAM,IAAI0C,OAAO,CAAC,KAAK3qB,CAAL,CAAD,CAAP,GAAmB2qB,OAAO,CAAC,KAAK3qB,CAAL,CAAD,CAA1B,GAAsC,KAAKA,CAAL,CAAhD;AACD;;AACD,WAAOioB,MAAP;AACD,GAND,C,CAQA;;;AACA,QAAMqB,KAAK,GAAG;AACZrE,YAAQ,EAAE,CAAC2F,MAAD,EAASC,MAAT,KAAoB;AAC5B,UAAI5C,MAAM,GAAG2C,MAAM,GAAGC,MAAtB;;AACA,UAAI5C,MAAM,GAAG,CAACtpB,IAAI,CAACmsB,EAAnB,EAAuB;AACrB7C,cAAM,IAAI,IAAEtpB,IAAI,CAACmsB,EAAjB;AACD;;AACD,UAAI7C,MAAM,IAAItpB,IAAI,CAACmsB,EAAnB,EAAuB;AACrB7C,cAAM,IAAI,IAAEtpB,IAAI,CAACmsB,EAAjB;AACD;;AACD,aAAO7C,MAAP;AACD,KAVW;AAWZ8C,WAAO,EAAGjD,IAAD,IAAUA,IAAI,GAACA;AAXZ,GAAd,C,CAcA;;AACA,QAAMyB,KAAK,GAAG;AACZ1mB,OAAG,EAAE,CAAC+kB,MAAD,EAASC,MAAT,KAAoB,CAACD,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,CAAC,CAAD,CAAnB,EAAwBD,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,CAAC,CAAD,CAA1C,CADb;AAEZnP,SAAK,EAAG9E,KAAD,IAAWjV,IAAI,CAACqb,KAAL,CAAWpG,KAAK,CAAC,CAAD,CAAhB,EAAqBA,KAAK,CAAC,CAAD,CAA1B,CAFN;AAGZ1Q,SAAK,EAAG0Q,KAAD,IAAW,CAACA,KAAK,CAAC,CAAD,CAAN,EAAWA,KAAK,CAAC,CAAD,CAAhB,CAHN;;AAIZ+T,aAAS,CAACC,MAAD,EAASC,MAAT,EAAiB;AACxB,UAAIC,IAAI,GAAGyB,KAAK,CAACtE,QAAN,CAAe2C,MAAf,EAAuBC,MAAvB,CAAX;AACA,aAAOlpB,IAAI,CAACuM,GAAL,CAAS4c,IAAI,CAAC,CAAD,CAAb,EAAkB,CAAlB,IAAuBnpB,IAAI,CAACuM,GAAL,CAAS4c,IAAI,CAAC,CAAD,CAAb,EAAkB,CAAlB,CAA9B;AACD,KAPW;;AAQZkD,OAAG,EAAE,CAACpD,MAAD,EAASC,MAAT,KAAoBD,MAAM,CAAC,CAAD,CAAN,GAAUC,MAAM,CAAC,CAAD,CAAhB,GAAsBD,MAAM,CAAC,CAAD,CAAN,GAAUC,MAAM,CAAC,CAAD,CARnD;AASZoD,SAAK,EAAE,CAACrD,MAAD,EAASC,MAAT,KAAoBD,MAAM,CAAC,CAAD,CAAN,KAAcC,MAAM,CAAC,CAAD,CAApB,IAA2BD,MAAM,CAAC,CAAD,CAAN,KAAcC,MAAM,CAAC,CAAD,CAT9D;AAUZqD,OAAG,EAAGtX,KAAD,IAAWA,KAAK,CAACuU,IAAN,CAAW,GAAX,CAVJ;AAWZgD,YAAQ,EAAE,CAACvD,MAAD,EAASC,MAAT,KAAoB;AAC5B,aAAO,CAAC,CAACD,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,CAAC,CAAD,CAAnB,IAAwB,CAAzB,EAA4B,CAACD,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,CAAC,CAAD,CAAnB,IAAwB,CAApD,CAAP;AACD,KAbW;AAcZ5C,YAAQ,EAAE,CAAC2C,MAAD,EAASC,MAAT,KAAoB,CAACD,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,CAAC,CAAD,CAAnB,EAAwBD,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,CAAC,CAAD,CAA1C,CAdlB;AAeZuD,SAAK,EAAGxX,KAAD,IAAWgW,QAAQ,CAAChW,KAAK,CAAC,CAAD,CAAN,CAAR,IAAsBgW,QAAQ,CAAChW,KAAK,CAAC,CAAD,CAAN;AAfpC,GAAd;;;;;;;;;;;;AClEAe,MAAM,CAAC4S,MAAP,CAAc;AAAC8D,QAAM,EAAC,MAAIA;AAAZ,CAAd;AAAmC,IAAIlC,MAAJ,EAAWC,MAAX,EAAkBC,YAAlB;AAA+B1U,MAAM,CAAC2W,IAAP,CAAY,WAAZ,EAAwB;AAACnC,QAAM,CAACtqB,CAAD,EAAG;AAACsqB,UAAM,GAACtqB,CAAP;AAAS,GAApB;;AAAqBuqB,QAAM,CAACvqB,CAAD,EAAG;AAACuqB,UAAM,GAACvqB,CAAP;AAAS,GAAxC;;AAAyCwqB,cAAY,CAACxqB,CAAD,EAAG;AAACwqB,gBAAY,GAACxqB,CAAb;AAAe;;AAAxE,CAAxB,EAAkG,CAAlG;AAElE,MAAM0sB,EAAE,GAAGlC,YAAY,CAAC,IAAD,CAAvB;AACA,MAAMlF,IAAI,GAAGkF,YAAY,CAAC,MAAD,CAAzB;AAEA,MAAMmC,gBAAgB,GAAG,CAAC,WAAD,EAAc,eAAd,EAA+B,YAA/B,EACC,WADD,EACc,cADd,EAC8B,QAD9B,EAEC,YAFD,EAEe,SAFf,EAE0B,aAF1B,CAAzB;AAIA,MAAMH,MAAM,GAAG;AACbI,YAAU,EAAE,EADC;AAEbC,QAAM,EAAE,EAFK;AAGbC,SAAO,EAAEnX,SAHI;AAIboX,UAAQ,EAAE;AACRC,mBAAe,EAAE,EADT;AAERC,wBAAoB,EAAE,EAFd;AAGRC,wBAAoB,EAAE,EAHd;AAIRC,4BAAwB,EAAE;AAJlB,GAJG;;AAUbC,kBAAgB,CAACpL,SAAD,EAAY;AAC1B,UAAMoH,MAAM,GAAG,EAAf;AACAuD,oBAAgB,CAACtK,GAAjB,CAAsBgL,KAAD,IACjBjE,MAAM,CAACiE,KAAD,CAAN,GAAgBb,MAAM,CAACI,UAAP,CAAkBS,KAAlB,EAAyBrL,SAAzB,CADpB;AAEAoH,UAAM,CAACpH,SAAP,GAAmBA,SAAnB;AACAoH,UAAM,CAACkE,WAAP,GAAqBlE,MAAM,CAACkE,WAAP,IAAsB,EAA3C;AACA,WAAOlE,MAAP;AACD;;AAjBY,CAAf;AAoBAuD,gBAAgB,CAACtK,GAAjB,CAAsBgL,KAAD,IAAWb,MAAM,CAACI,UAAP,CAAkBS,KAAlB,IAA2B,EAA3D,E,CAEA;AACA;;AACA,MAAME,aAAa,GAAIpnB,IAAD,IAAU;AAC9B,QAAMqnB,KAAK,GAAGrnB,IAAI,CAACme,KAAL,CAAW,IAAX,CAAd;AACA,SAAOkJ,KAAK,CAACtL,MAAN,CAAcuL,IAAD,IAAUA,IAAI,CAAClsB,MAAL,GAAc,CAAd,IAAmBksB,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAtD,EACMpL,GADN,CACWoL,IAAD,IAAUA,IAAI,CAACnJ,KAAL,CAAW,GAAX,EAAgBjC,GAAhB,CACVqL,KAAD,IAAWA,KAAK,CAAC3K,OAAN,CAAc,OAAd,EAAuB,EAAvB,CADA,CADpB,CAAP;AAGD,CALD,C,CAOA;AACA;;;AACA,MAAM4K,gBAAgB,GAAIxnB,IAAD,IAAU;AACjC,QAAMqnB,KAAK,GAAGrnB,IAAI,CAACme,KAAL,CAAW,IAAX,CAAd;AACA,SAAOkJ,KAAK,CAACtL,MAAN,CAAcuL,IAAD,IAAUA,IAAI,CAAClsB,MAAL,GAAc,CAAd,IAAmBksB,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAtD,EACMpL,GADN,CACWoL,IAAD,IAAUA,IAAI,CAACnJ,KAAL,CAAW,IAAX,CADpB,CAAP;AAED,CAJD,C,CAMA;AACA;;;AACA,MAAMsJ,aAAa,GAAIznB,IAAD,IAAU;AAC9B,QAAMqnB,KAAK,GAAGrnB,IAAI,CAACme,KAAL,CAAW,IAAX,CAAd;AACA,SAAOkJ,KAAK,CAACtL,MAAN,CAAcuL,IAAD,IAAUA,IAAI,CAAClsB,MAAL,GAAc,CAAd,IAAmBksB,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAtD,EACMpL,GADN,CACWoL,IAAD,IAAUA,IAAI,CAACnJ,KAAL,CAAW,IAAX,CADpB,CAAP;AAED,CAJD,C,CAMA;AACA;;;AACA,MAAMuJ,eAAe,GAChBC,GAAD,IAASlC,MAAM,CAACmC,aAAP,CAAqBC,QAAQ,CAACF,GAAG,CAACG,MAAJ,CAAW,CAAX,CAAD,EAAgB,EAAhB,CAA7B,CADb,C,CAGA;AACA;;;AACA,MAAMC,QAAQ,GAAIC,QAAD,IAAc,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC9D,MAAIpD,MAAM,CAACC,QAAX,EAAqB;AACnB,UAAMoD,QAAQ,GAAGjJ,IAAI,CAACgE,IAAL,CAAUiB,MAAM,EAAhB,EAAoB,QAApB,EAA8B4D,QAA9B,CAAjB;AACAzB,MAAE,CAACwB,QAAH,CAAYK,QAAZ,EAAsB,MAAtB,EAA8B,CAAC1D,KAAD,EAAQ1kB,IAAR,KAAiB;AAC7C,UAAI0kB,KAAJ,EAAW,MAAMA,KAAN;AACXwD,aAAO,CAACloB,IAAD,CAAP;AACD,KAHD;AAID,GAND,MAMO;AACLqoB,KAAC,CAAC9qB,GAAF,CAAMyqB,QAAN,EAAgB,CAAChoB,IAAD,EAAOsoB,IAAP,KAAgB;AAC9B,UAAIA,IAAI,KAAK,SAAb,EAAwB,MAAM,IAAI3D,KAAJ,CAAU2D,IAAV,CAAN;AACxBJ,aAAO,CAACloB,IAAD,CAAP;AACD,KAHD;AAID;AACF,CAb8B,CAA/B,C,CAeA;AAEA;AACA;AACA;;;AACA,MAAMuoB,kBAAkB,GAAG,CAACC,cAAD,EAAiBC,MAAjB,EAAyBxF,MAAzB,KAAoC;AAC7D,SAAOgF,OAAO,CAACS,GAAR,CAAY,CAACF,cAAD,EAAiBC,MAAjB,CAAZ,EAAsCE,IAAtC,CAA2C,QAAoB;AAAA,QAAnB,CAACC,IAAD,EAAOH,MAAP,CAAmB;AACpEG,QAAI,CAAC7M,MAAL,CAAa8M,GAAD,IAAShB,QAAQ,CAACgB,GAAG,CAAC,CAAD,CAAJ,EAAS,EAAT,CAAR,MAA0BJ,MAAM,CAACI,GAAG,CAAC,CAAD,CAAJ,CAAN,IAAkB,CAA5C,CAArB,EACK3M,GADL,CACU2M,GAAD,IAAS5F,MAAM,CAAC4F,GAAG,CAAC,CAAD,CAAJ,CAAN,GAAiBA,GAAG,CAAC,CAAD,CADtC;AAED,GAHM,CAAP;AAID,CALD,C,CAOA;;;AACA,MAAMC,eAAe,GAAG,CAACC,QAAD,EAAW9F,MAAX,KAAsB;AAC5C,SAAO8F,QAAQ,CAACJ,IAAT,CAAeC,IAAD,IAAU;AAC7BA,QAAI,CAAC7M,MAAL,CAAa8M,GAAD,IAASA,GAAG,CAAC,CAAD,CAAH,KAAW,aAAhC,EACK3M,GADL,CACU2M,GAAD,IAAS5F,MAAM,CAACyE,eAAe,CAACmB,GAAG,CAAC,CAAD,CAAJ,CAAhB,CAAN,GAAkCA,GAAG,CAAC,CAAD,CADvD;AAED,GAHM,CAAP;AAID,CALD,C,CAOA;;;AACA,MAAMG,eAAe,GAAG,CAACD,QAAD,EAAW9F,MAAX,KAAsB;AAC5C,SAAO8F,QAAQ,CAACJ,IAAT,CAAeC,IAAD,IAAU;AAC7BA,QAAI,CAAC1M,GAAL,CAAU2M,GAAD,IAAS5F,MAAM,CAAC4F,GAAG,CAAC,CAAD,CAAJ,CAAN,GAAiBhB,QAAQ,CAACgB,GAAG,CAAC,CAAD,CAAJ,EAAS,EAAT,CAA3C;AACD,GAFM,CAAP;AAGD,CAJD,C,CAMA;AACA;;;AACA,MAAMI,eAAe,GAAG,CAACF,QAAD,EAAW9F,MAAX,KAAsB;AAC5C,SAAO8F,QAAQ,CAACJ,IAAT,CAAeC,IAAD,IAAU;AAC7B,UAAMM,QAAQ,GAAIC,KAAD,IAAWA,KAAK,CAAChL,KAAN,CAAY,GAAZ,EAAiBjC,GAAjB,CAAsB1e,CAAD,IAAOqqB,QAAQ,CAACrqB,CAAD,EAAI,EAAJ,CAApC,CAA5B;;AACAorB,QAAI,CAAC7M,MAAL,CAAa8M,GAAD,IAASA,GAAG,CAAC,CAAD,CAAH,KAAW,WAAhC,EACK3M,GADL,CACU2M,GAAD,IAAS5F,MAAM,CAACyE,eAAe,CAACmB,GAAG,CAAC,CAAD,CAAJ,CAAhB,CAAN,GAAkCK,QAAQ,CAACL,GAAG,CAAC,CAAD,CAAJ,CAD5D;AAED,GAJM,CAAP;AAKD,CAND,C,CAQA;;;AACA,MAAMO,UAAU,GAAG,CAACL,QAAD,EAAW9F,MAAX,KAAsB;AACvC,SAAO8F,QAAQ,CAACJ,IAAT,CAAeC,IAAD,IAAU;AAC7BA,QAAI,CAAC7M,MAAL,CAAa8M,GAAD,IAASA,GAAG,CAAC,CAAD,CAAH,KAAW,WAAhC,EACK3M,GADL,CACU2M,GAAD,IAAS5F,MAAM,CAACyE,eAAe,CAACmB,GAAG,CAAC,CAAD,CAAJ,CAAhB,CAAN,GAAkCA,GAAG,CAAC,CAAD,CADvD;AAED,GAHM,CAAP;AAID,CALD,C,CAOA;;;AACA,MAAMQ,gBAAgB,GAAG,CAACC,oBAAD,EAAuBrG,MAAvB,KAAkC;AACzD,SAAOqG,oBAAoB,CAACX,IAArB,CAA2BC,IAAD,IAAU;AACzCA,QAAI,CAAC7M,MAAL,CAAa8M,GAAD,IAASA,GAAG,CAAC,CAAD,CAAH,KAAW,eAAhC,EACK3M,GADL,CACU2M,GAAD,IAAS5F,MAAM,CAACyE,eAAe,CAACmB,GAAG,CAAC,CAAD,CAAJ,CAAhB,CAAN,GAAkChB,QAAQ,CAACgB,GAAG,CAAC,CAAD,CAAJ,EAAS,EAAT,CAD5D;AAED,GAHM,CAAP;AAID,CALD,C,CAOA;AACA;AACA;AACA;;;AACA,MAAMU,eAAe,GAAG,CAACC,MAAD,EAAS5C,QAAT,EAAmB3D,MAAnB,KAA8B;AACpD,SAAO2D,QAAQ,CAAC+B,IAAT,CAAeC,IAAD,IAAU;AAC7BA,QAAI,CAAC1M,GAAL,CAAU2M,GAAD,IAAS;AAChB,UAAI,CAAC5F,MAAM,CAAC6D,oBAAP,CAA4B2C,cAA5B,CAA2CZ,GAAG,CAAC,CAAD,CAA9C,CAAL,EAAyD;AACvD5F,cAAM,CAAC6D,oBAAP,CAA4B+B,GAAG,CAAC,CAAD,CAA/B,IAAsC,EAAtC;AACD;;AACD5F,YAAM,CAAC6D,oBAAP,CAA4B+B,GAAG,CAAC,CAAD,CAA/B,EAAoCvtB,IAApC,CAAyCutB,GAAG,CAAC,CAAD,CAA5C;AACA5F,YAAM,CAAC8D,oBAAP,CAA4B8B,GAAG,CAAC,CAAD,CAA/B,IAAsCA,GAAG,CAAC,CAAD,CAAzC;;AACA,UAAIA,GAAG,CAAC,CAAD,CAAH,KAAW,GAAX,IAAkBA,GAAG,CAAC,CAAD,CAAH,CAAOrH,OAAP,CAAegI,MAAf,KAA0B,CAAhD,EAAmD;AACjDvG,cAAM,CAAC4D,eAAP,CAAuBgC,GAAG,CAAC,CAAD,CAA1B,IAAiCA,GAAG,CAAC,CAAD,CAApC;AACD;AACF,KATD;AAUD,GAXM,CAAP;AAYD,CAbD,C,CAeA;AACA;AACA;;;AACA,MAAMa,yBAAyB,GAC3B,CAACF,MAAD,EAASG,6BAAT,EAAwC1G,MAAxC,KAAmD;AACrD,SAAO0G,6BAA6B,CAAChB,IAA9B,CAAoCC,IAAD,IAAU;AAClDA,QAAI,CAAC7M,MAAL,CAAa8M,GAAD,IAASA,GAAG,CAAC,CAAD,CAAH,CAAOrH,OAAP,CAAegI,MAAf,KAA0B,CAA/C,EACKtN,GADL,CACU2M,GAAD,IAAS5F,MAAM,CAAC4F,GAAG,CAAC,CAAD,CAAJ,CAAN,GAAiBA,GAAG,CAAC,CAAD,CADtC;AAED,GAHM,CAAP;AAID,CAND,C,CAQA;AACA;;;AACA,MAAMe,YAAY,GAAG,CAAC3a,UAAD,EAAakY,WAAb,EAA0B0C,QAA1B,KAAuC;AAC1D,SAAOA,QAAQ,CAAClB,IAAT,CAAeC,IAAD,IAAU;AAC7BA,QAAI,CAAC1M,GAAL,CAAU2M,GAAD,IAAS;AAChB,UAAKA,GAAG,CAAC,CAAD,CAAH,KAAW,oBAAX,IACAA,GAAG,CAAC,CAAD,CAAH,KAAW,qBADZ,IAEAA,GAAG,CAAC,CAAD,CAAH,KAAWA,GAAG,CAAC,CAAD,CAFd,IAEqBA,GAAG,CAAC,CAAD,CAAH,KAAW,SAFpC,EAE+C;AAC7C;AACA;AACD;;AACD,UAAIiB,MAAM,GAAGpC,eAAe,CAACmB,GAAG,CAAC,CAAD,CAAJ,CAA5B;AACA,UAAIkB,MAAM,GAAGrC,eAAe,CAACmB,GAAG,CAAC,CAAD,CAAJ,CAA5B;AACA,YAAM1K,KAAK,GAAG0K,GAAG,CAAC,CAAD,CAAH,CAAO1K,KAAP,CAAa,GAAb,CAAd,CATgB,CAUhB;AACA;AACA;;AACA,UAAIA,KAAK,CAAC/iB,MAAN,KAAiB,CAAjB,IACA,CAAC,QAAD,EAAW,QAAX,EAAqB,QAArB,EAA+BomB,OAA/B,CAAuCqH,GAAG,CAAC,CAAD,CAA1C,KAAkD,CADtD,EACyD;AACvDkB,cAAM,GAAGrC,eAAe,CAACvJ,KAAK,CAAC,CAAD,CAAN,CAAxB;AACD;;AACD,UAAI2L,MAAM,KAAKC,MAAf,EAAuB;AACrB;AACD,OAFD,MAEO,IAAIlB,GAAG,CAAC,CAAD,CAAH,KAAW,qBAAf,EAAsC;AAC3C,cAAMmB,IAAI,GAAGD,MAAb;AACAA,cAAM,GAAGD,MAAT;AACAA,cAAM,GAAGE,IAAT;AACD,OAvBe,CAwBhB;AACA;;;AACA7F,YAAM,CAAC,CAAClV,UAAU,CAAC6a,MAAD,CAAX,IAAuB7a,UAAU,CAAC6a,MAAD,CAAV,KAAuBC,MAA/C,CAAN;AACA9a,gBAAU,CAAC6a,MAAD,CAAV,GAAqBC,MAArB;AACA5C,iBAAW,CAAC4C,MAAD,CAAX,GAAsBE,CAAC,CAAC1E,MAAF,CAClB,CAAC4B,WAAW,CAAC4C,MAAD,CAAX,IAAuB,EAAxB,EAA4B/P,MAA5B,CAAmC,CAAC8P,MAAD,CAAnC,CADkB,CAAtB;AAED,KA9BD;AA+BD,GAhCM,CAAP;AAiCD,CAlCD,C,CAoCA;;;AACA,MAAMI,UAAU,GAAG,CAAClqB,IAAD,EAAOijB,MAAP,KAAkB;AACnCloB,OAAK,CAACovB,IAAN,CAAWnqB,IAAX,EAAiBkc,GAAjB,CAAsBL,SAAD,IAAe;AAClC,QAAIA,SAAS,KAAK,IAAlB,EAAwB;AACxBsI,UAAM,CAACtI,SAAS,CAACzgB,MAAV,KAAqB,CAAtB,CAAN;AACA,UAAMgvB,SAAS,GAAGvO,SAAS,CAACwO,WAAV,CAAsB,CAAtB,CAAlB;AACAlG,UAAM,CAAC,UAAUiG,SAAV,IAAuBA,SAAS,IAAI,MAArC,CAAN;AACAnH,UAAM,CAACpH,SAAD,CAAN,GAAoB,IAApB;AACD,GAND;AAOAsI,QAAM,CAAClnB,MAAM,CAACqtB,IAAP,CAAYrH,MAAZ,EAAoB7nB,MAApB,KAA+B,IAAhC,CAAN;AACD,CATD,C,CAWA;AACA;;;AACA,MAAMmvB,mBAAmB,GAAG,CAACf,MAAD,EAASZ,IAAT,KAAkB;AAC5C,QAAM3F,MAAM,GAAG,EAAf;AACA2F,MAAI,CAAC7M,MAAL,CAAa8M,GAAD,IAASA,GAAG,CAAC,CAAD,CAAH,CAAOrH,OAAP,CAAegI,MAAf,KAA0B,CAA/C,EACKtN,GADL,CACU2M,GAAD,IAAS5F,MAAM,CAAC4F,GAAG,CAAC,CAAD,CAAJ,CAAN,GAAiBhB,QAAQ,CAACgB,GAAG,CAAC,CAAD,CAAJ,EAAS,EAAT,CAD3C;AAEA,SAAO5F,MAAP;AACD,CALD,C,CAOA;;;AAEA,MAAMuH,iBAAiB,GAAG,MAAM;AAC9B,QAAM/D,UAAU,GAAGJ,MAAM,CAACI,UAA1B;AACA,QAAMG,QAAQ,GAAGP,MAAM,CAACO,QAAxB;;AACA,QAAM6D,yBAAyB,GAAIjtB,CAAD,IAAOA,CAAC,CAACpC,MAAF,KAAa,CAAb,GAAiBoC,CAAjB,GAAqB,GAA9D;;AACA,QAAMktB,oBAAoB,GAAIltB,CAAD,IAAOopB,QAAQ,CAACI,wBAAT,CAAkCxpB,CAAlC,KAAwCA,CAA5E;;AACAP,QAAM,CAACqtB,IAAP,CAAY7D,UAAU,CAACkE,aAAvB,EAAsCzO,GAAtC,CAA2CL,SAAD,IAAe;AACvD;AACA;AACA;AACA,UAAM8O,aAAa,GAAGlE,UAAU,CAACkE,aAAX,CAAyB9O,SAAzB,CAAtB;AACA4K,cAAU,CAACkE,aAAX,CAAyB9O,SAAzB,IACI9gB,KAAK,CAACovB,IAAN,CAAWQ,aAAX,EAA0BzO,GAA1B,CAA8BuO,yBAA9B,EAC0BvO,GAD1B,CAC8BwO,oBAD9B,EACoDvH,IADpD,CACyD,EADzD,CADJ;AAGD,GARD;;AASA,OAAK,IAAInoB,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,GAArB,EAA0BA,CAAC,EAA3B,EAA+B;AAC7B;AACA,UAAM4vB,OAAO,GAAGhE,QAAQ,CAACC,eAAT,CAAyB7rB,CAAzB,CAAhB;AACAmpB,UAAM,CAACyC,QAAQ,CAACI,wBAAT,CAAkCyC,cAAlC,CAAiDmB,OAAjD,CAAD,CAAN;AACAhE,YAAQ,CAACC,eAAT,CAAyB7rB,CAAzB,IAA8B4rB,QAAQ,CAACI,wBAAT,CAAkC4D,OAAlC,CAA9B;AACAhE,YAAQ,CAACE,oBAAT,CAA8B9rB,CAA9B,IACI4rB,QAAQ,CAACE,oBAAT,CAA8B9rB,CAA9B,EAAiCkhB,GAAjC,CAAqCwO,oBAArC,EAA2DnF,MAA3D,EADJ;AAED;;AACDtoB,QAAM,CAACqtB,IAAP,CAAY1D,QAAQ,CAACG,oBAArB,EAA2C7K,GAA3C,CAAgD2O,OAAD,IAAa;AAC1D,UAAMhP,SAAS,GAAG6O,oBAAoB,CAACG,OAAD,CAAtC;;AACA,QAAIhP,SAAS,KAAKgP,OAAlB,EAA2B;AACzBjE,cAAQ,CAACG,oBAAT,CAA8BlL,SAA9B,IACI+K,QAAQ,CAACG,oBAAT,CAA8B8D,OAA9B,CADJ;AAEA,aAAOjE,QAAQ,CAACG,oBAAT,CAA8B8D,OAA9B,CAAP;AACD;AACF,GAPD;AAQA,SAAOjE,QAAQ,CAACI,wBAAhB;AACD,CA/BD;;AAiCAjC,MAAM,CAAC+F,OAAP,CAAe,MAAM;AACnB;AACA,QAAMtB,MAAM,GAAG,GAAf;AACA,QAAMmB,aAAa,GACf5C,QAAQ,CAAC,mCAAD,CAAR,CAA8CY,IAA9C,CAAmDvB,aAAnD,CADJ;AAEA,QAAMqB,MAAM,GAAGV,QAAQ,CAAC,iCAAD,CAAR,CACKY,IADL,CACUvB,aADV,EAEKuB,IAFL,CAEU4B,mBAAmB,CAACQ,IAApB,CAAyB,IAAzB,EAA+BvB,MAA/B,CAFV,CAAf;AAGA,QAAM5C,QAAQ,GAAGmB,QAAQ,CAAC,0BAAD,CAAR,CAAqCY,IAArC,CAA0CvB,aAA1C,CAAjB;AACA,QAAMuC,6BAA6B,GAC/B5B,QAAQ,CAAC,uCAAD,CAAR,CAAkDY,IAAlD,CAAuDvB,aAAvD,CADJ;AAEA,QAAM4D,2BAA2B,GAC7BjD,QAAQ,CAAC,2CAAD,CAAR,CAAsDY,IAAtD,CAA2DvB,aAA3D,CADJ,CAXmB,CAcnB;;AACA,QAAM6D,WAAW,GAAGlD,QAAQ,CAAC,+BAAD,CAAR,CACKY,IADL,CACUnB,gBADV,CAApB,CAfmB,CAkBnB;;AACA,QAAM8B,oBAAoB,GACtBvB,QAAQ,CAAC,sCAAD,CAAR,CAAiDY,IAAjD,CAAsDlB,aAAtD,CADJ;AAEA,QAAMyD,qBAAqB,GACvBnD,QAAQ,CAAC,uCAAD,CAAR,CAAkDY,IAAlD,CAAuDlB,aAAvD,CADJ;AAEA,QAAMsB,QAAQ,GAAGhB,QAAQ,CAAC,4BAAD,CAAR,CAAuCY,IAAvC,CAA4ClB,aAA5C,CAAjB;AACA,QAAMoC,QAAQ,GAAG9B,QAAQ,CAAC,4BAAD,CAAR,CAAuCY,IAAvC,CAA4ClB,aAA5C,CAAjB;AAEApB,QAAM,CAACM,OAAP,GAAiBsB,OAAO,CAACS,GAAR,CAAY,CACzB;AACAH,oBAAkB,CAACoC,aAAD,EAAgBlC,MAAhB,EACCpC,MAAM,CAACI,UAAP,CAAkBkE,aADnB,CAFO,EAIzB7B,eAAe,CAACC,QAAD,EAAW1C,MAAM,CAACI,UAAP,CAAkB0E,UAA7B,CAJU,EAKzBnC,eAAe,CAACiC,WAAD,EAAc5E,MAAM,CAACI,UAAP,CAAkB2E,SAAhC,CALU,EAMzBnC,eAAe,CAACiC,qBAAD,EAAwB7E,MAAM,CAACI,UAAP,CAAkB4E,YAA1C,CANU,EAOzBjC,UAAU,CAACL,QAAD,EAAW1C,MAAM,CAACI,UAAP,CAAkB6E,MAA7B,CAPe,EAQzBjC,gBAAgB,CAACC,oBAAD,EAAuBjD,MAAM,CAACI,UAAP,CAAkB3K,OAAzC,CARS,EASzB;AACAyN,iBAAe,CAACC,MAAD,EAAS5C,QAAT,EAAmBP,MAAM,CAACO,QAA1B,CAVU,EAWzB2C,eAAe,CAACC,MAAD,EAASwB,2BAAT,EAAsC3E,MAAM,CAACO,QAA7C,CAXU,EAYzB8C,yBAAyB,CAACF,MAAD,EAASG,6BAAT,EACCtD,MAAM,CAACO,QAAP,CAAgBI,wBADjB,CAZA,EAczB4C,YAAY,CAACvD,MAAM,CAACI,UAAP,CAAkBxX,UAAnB,EACCoX,MAAM,CAACI,UAAP,CAAkBU,WADnB,EACgC0C,QADhC,CAda,EAgBzB;AACA9B,UAAQ,CAAC,QAAD,CAAR,CAAmBY,IAAnB,CAAyB3oB,IAAD,IAAUkqB,UAAU,CAAClqB,IAAD,EAAOqmB,MAAM,CAACK,MAAd,CAA5C,CAjByB,CAAZ,EAkBdiC,IAlBc,CAkBT6B,iBAlBS,CAAjB;AAmBAnE,QAAM,CAACM,OAAP,CAAe4E,KAAf,CAAqB5lB,OAAO,CAAC+e,KAAR,CAAcqG,IAAd,CAAmBplB,OAAnB,CAArB;AACD,CA9CD,E;;;;;;;;;;;AC/PA,IAAI6lB,wCAAJ;AAA6C7b,MAAM,CAAC2W,IAAP,CAAY,UAAZ,EAAuB;AAACkF,0CAAwC,CAAC3xB,CAAD,EAAG;AAAC2xB,4CAAwC,GAAC3xB,CAAzC;AAA2C;;AAAxF,CAAvB,EAAiH,CAAjH;AAAoH,IAAI4xB,gBAAJ;AAAqB9b,MAAM,CAAC2W,IAAP,CAAY,uBAAZ,EAAoC;AAACmF,kBAAgB,CAAC5xB,CAAD,EAAG;AAAC4xB,oBAAgB,GAAC5xB,CAAjB;AAAmB;;AAAxC,CAApC,EAA8E,CAA9E;AAGtLkrB,MAAM,CAAC+F,OAAP,CAAe,MAAM;AACnB,QAAMY,KAAK,GAAG,IAAItyB,SAAS,CAACyD,GAAd,CAAkB,CAAlB,EAAqB,CAArB,EAAwB;AAAE;AAA1B,GAAd;AACA,QAAMkL,GAAG,GAAG,IAAI3O,SAAS,CAACoN,GAAd,EAAZ;AACAuB,KAAG,CAACtJ,QAAJ,CAAa+sB,wCAAb;AACA,QAAMG,MAAM,GAAG,GAAf;;AAEA,QAAMC,iBAAiB,GAAIC,QAAD,IAAc;AACtCH,SAAK,CAAClwB,CAAN,GAAUqwB,QAAV;AACA,UAAMC,OAAO,GAAG/jB,GAAG,CAAC3G,OAAJ,CAAYsqB,KAAZ,EAAmBlwB,CAAnC;AACA,WAAOswB,OAAO,CAAC,CAAD,CAAP,GAAaA,OAAO,CAAC,CAAD,CAA3B;AACD,GAJD;;AAMAL,kBAAgB,CAACM,kBAAjB,GAAuCF,QAAD,IAAc;AAClD,WAAOJ,gBAAgB,CAACO,mBAAjB,CAAqCH,QAArC,IACAF,MAAM,GAACC,iBAAiB,CAACC,QAAD,CAD/B;AAED,GAHD;AAID,CAhBD,E;;;;;;;;;;;ACHAlc,MAAM,CAAC4S,MAAP,CAAc;AAAC0J,oBAAkB,EAAC,MAAIA;AAAxB,CAAd;AAA2D,IAAI9H,MAAJ;AAAWxU,MAAM,CAAC2W,IAAP,CAAY,WAAZ,EAAwB;AAACnC,QAAM,CAACtqB,CAAD,EAAG;AAACsqB,UAAM,GAACtqB,CAAP;AAAS;;AAApB,CAAxB,EAA8C,CAA9C;AAEtE,MAAMoyB,kBAAkB,GAAG,EAA3B;AAEAA,kBAAkB,CAACC,QAAnB,GAA8B;AAC5B,OAAK;AAACC,SAAK,EAAE,eAAR;AAAyBC,SAAK,EAAE;AAAhC,GADuB;AAE5B,OAAK;AAACD,SAAK,EAAE,eAAR;AAAyBC,SAAK,EAAE;AAAhC,GAFuB;AAG5B,OAAK;AAACD,SAAK,EAAE,UAAR;AAAoBC,SAAK,EAAE;AAA3B,GAHuB;AAI5B,OAAK;AAACD,SAAK,EAAE,qBAAR;AAA+BC,SAAK,EAAE;AAAtC,GAJuB;AAK5B,OAAK;AAACD,SAAK,EAAE,qBAAR;AAA+BC,SAAK,EAAE;AAAtC,GALuB;AAM5B,OAAK;AAACD,SAAK,EAAE,oBAAR;AAA8BC,SAAK,EAAE;AAArC,GANuB;AAO5B,OAAK;AAACD,SAAK,EAAE,0BAAR;AAAoCC,SAAK,EAAE;AAA3C,GAPuB;AAQ5B,OAAK;AAACD,SAAK,EAAE,2BAAR;AAAqCC,SAAK,EAAE;AAA5C,GARuB;AAS5B,OAAK;AAACD,SAAK,EAAE,0BAAR;AAAoCC,SAAK,EAAE;AAA3C,GATuB;AAU5B,OAAK;AAACD,SAAK,EAAE,UAAR;AAAoBC,SAAK,EAAE;AAA3B,GAVuB;AAW5B,OAAK;AAACD,SAAK,EAAE,yBAAR;AAAmCC,SAAK,EAAE;AAA1C,GAXuB;AAY5B,OAAK;AAACD,SAAK,EAAE,yBAAR;AAAmCC,SAAK,EAAE;AAA1C;AAZuB,CAA9B;AAcAH,kBAAkB,CAACI,gCAAnB,GACIpvB,MAAM,CAACqtB,IAAP,CAAY2B,kBAAkB,CAACC,QAA/B,CADJ;AAGA,MAAMI,iBAAiB,GAAG,GAA1B;;AAEA,MAAMC,uBAAuB,GAAG,CAACC,IAAD,EAAOrN,IAAP,KAAgB;AAC9CqN,MAAI,CAACrN,IAAL,GAAYA,IAAZ;AACA,QAAMsN,QAAQ,GAAG,CAACD,IAAI,CAACC,QAAL,IAAiB,EAAlB,EAAsBrxB,MAAvC;;AACA,OAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyxB,QAApB,EAA8BzxB,CAAC,EAA/B,EAAmC;AACjCuxB,2BAAuB,CAACC,IAAI,CAACC,QAAL,CAAczxB,CAAd,CAAD,EAAmBmkB,IAAI,CAACnF,MAAL,CAAY,CAAChf,CAAD,CAAZ,CAAnB,CAAvB;AACD;;AACD,SAAOwxB,IAAP;AACD,CAPD;;AASA,MAAME,YAAY,GAAG,CAAC/B,aAAD,EAAgBxb,KAAhB,KAA0B;AAC7CgV,QAAM,CAAChV,KAAK,CAAC,CAAD,CAAL,GAAWwb,aAAa,CAACvvB,MAA1B,qCAC6BuvB,aAD7B,OAAN;AAEA,QAAMgC,OAAO,GAAGhC,aAAa,CAACxb,KAAK,CAAC,CAAD,CAAN,CAA7B;AACAA,OAAK,CAAC,CAAD,CAAL,IAAY,CAAZ;;AACA,MAAI8c,kBAAkB,CAACC,QAAnB,CAA4BzC,cAA5B,CAA2CkD,OAA3C,CAAJ,EAAyD;AACvD,UAAM1J,MAAM,GAAG;AAACpc,UAAI,EAAE,UAAP;AAAmB+lB,WAAK,EAAED,OAA1B;AAAmCF,cAAQ,EAAE;AAA7C,KAAf;;AACA,SAAK,IAAIzxB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGixB,kBAAkB,CAACC,QAAnB,CAA4BS,OAA5B,EAAqCP,KAAzD,EAAgEpxB,CAAC,EAAjE,EAAqE;AACnEioB,YAAM,CAACwJ,QAAP,CAAgBnxB,IAAhB,CAAqBoxB,YAAY,CAAC/B,aAAD,EAAgBxb,KAAhB,CAAjC;AACD;;AACD,WAAO8T,MAAP;AACD,GAND,MAMO,IAAI0J,OAAO,KAAKL,iBAAhB,EAAmC;AACxC,WAAO;AAACzlB,UAAI,EAAE,WAAP;AAAoB+lB,WAAK,EAAE;AAA3B,KAAP;AACD,GAb4C,CAc7C;AACA;;;AACA,MAAIjC,aAAa,CAACxb,KAAK,CAAC,CAAD,CAAN,CAAb,KAA4B,GAAhC,EAAqC;AACnCgV,UAAM,CAAC,aAAa3C,OAAb,CAAqBmJ,aAAa,CAACxb,KAAK,CAAC,CAAD,CAAL,GAAW,CAAZ,CAAlC,KAAqD,CAAtD,CAAN;AACAgV,UAAM,CAACwG,aAAa,CAACxb,KAAK,CAAC,CAAD,CAAL,GAAW,CAAZ,CAAb,KAAgC,GAAjC,CAAN;AACAA,SAAK,CAAC,CAAD,CAAL,IAAY,CAAZ;AACD;;AACD,SAAO;AAACtI,QAAI,EAAE,WAAP;AAAoB+lB,SAAK,EAAED;AAA3B,GAAP;AACD,CAtBD;;AAwBA,MAAME,gBAAgB,GAAG,CAACC,OAAD,EAAU7J,MAAV,KAAqB;AAC5CA,QAAM,CAAC,CAAD,CAAN,IAAa6J,OAAO,CAACF,KAAR,KAAkB,GAAlB,GAAwBN,iBAAxB,GAA4CQ,OAAO,CAACF,KAAjE;AACA,QAAMH,QAAQ,GAAGK,OAAO,CAACL,QAAR,GAAmBK,OAAO,CAACL,QAAR,CAAiBrxB,MAApC,GAA6C,CAA9D;;AACA,OAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyxB,QAApB,EAA8BzxB,CAAC,EAA/B,EAAmC;AACjC6xB,oBAAgB,CAACC,OAAO,CAACL,QAAR,CAAiBzxB,CAAjB,CAAD,EAAsBioB,MAAtB,CAAhB;AACD;AACF,CAND;;AAQAgJ,kBAAkB,CAACc,iBAAnB,GAAuC,CAACP,IAAD,EAAOvJ,MAAP,KAAkB;AACvDA,QAAM,GAAGA,MAAM,IAAI,EAAnB;;AACA,MAAIuJ,IAAI,CAAC3lB,IAAL,KAAc,WAAd,IAA6B2lB,IAAI,CAACI,KAAL,KAAe,GAAhD,EAAqD;AACnD3J,UAAM,CAAC3nB,IAAP,CAAYkxB,IAAI,CAACI,KAAjB;AACD;;AACD,OAAK,IAAII,KAAT,IAAkBR,IAAI,CAACC,QAAL,IAAiB,EAAnC,EAAuC;AACrCR,sBAAkB,CAACc,iBAAnB,CAAqCC,KAArC,EAA4C/J,MAA5C;AACD;;AACD,SAAOA,MAAP;AACD,CATD;;AAWAgJ,kBAAkB,CAACgB,0BAAnB,GAAiDtC,aAAD,IAAmB;AACjE,QAAMxb,KAAK,GAAG,CAAC,CAAD,CAAd;AACAwb,eAAa,GAAGA,aAAa,IAAI2B,iBAAjC;AACA,QAAMrJ,MAAM,GAAGyJ,YAAY,CAAC/B,aAAD,EAAgBxb,KAAhB,CAA3B;AACAgV,QAAM,CAAChV,KAAK,CAAC,CAAD,CAAL,KAAawb,aAAa,CAACvvB,MAA5B,mCAC2BuvB,aAD3B,OAAN;AAEA,SAAO4B,uBAAuB,CAACtJ,MAAD,EAAS,EAAT,CAA9B;AACD,CAPD;;AASAgJ,kBAAkB,CAACiB,0BAAnB,GAAiDV,IAAD,IAAU;AACxD,QAAMvJ,MAAM,GAAG,CAAC,EAAD,CAAf;AACA4J,kBAAgB,CAACL,IAAD,EAAOvJ,MAAP,CAAhB;AACA,SAAOA,MAAM,CAAC,CAAD,CAAb;AACD,CAJD;;AAMAgJ,kBAAkB,CAACkB,UAAnB,GAAgC,CAACX,IAAD,EAAOrN,IAAP,KAAgB;AAC9C,MAAI2N,OAAO,GAAGN,IAAd;;AACA,OAAK,IAAIrd,KAAT,IAAkBgQ,IAAlB,EAAwB;AACtBgF,UAAM,CAAC,KAAKhV,KAAL,IAAcA,KAAK,GAAG2d,OAAO,CAACL,QAAR,CAAiBrxB,MAAxC,CAAN;AACA0xB,WAAO,GAAGA,OAAO,CAACL,QAAR,CAAiBtd,KAAjB,CAAV;AACD;;AACD,SAAO2d,OAAP;AACD,CAPD,C;;;;;;;;;;;AC1FAnd,MAAM,CAAC4S,MAAP,CAAc;AAAC6K,QAAM,EAAC,MAAIA,MAAZ;AAAmBC,UAAQ,EAAC,MAAIA;AAAhC,CAAd;AAAyD,IAAIlJ,MAAJ;AAAWxU,MAAM,CAAC2W,IAAP,CAAY,WAAZ,EAAwB;AAACnC,QAAM,CAACtqB,CAAD,EAAG;AAACsqB,UAAM,GAACtqB,CAAP;AAAS;;AAApB,CAAxB,EAA8C,CAA9C;AAAiD,IAAIwsB,MAAJ;AAAW1W,MAAM,CAAC2W,IAAP,CAAY,aAAZ,EAA0B;AAACD,QAAM,CAACxsB,CAAD,EAAG;AAACwsB,UAAM,GAACxsB,CAAP;AAAS;;AAApB,CAA1B,EAAgD,CAAhD;;AAGhI,MAAMyzB,YAAY,GAAIzR,SAAD,IAAe;AAClC,MAAI,CAACA,SAAL,EAAgB;AAChBsI,QAAM,CAACtI,SAAS,CAACzgB,MAAV,KAAqB,CAAtB,CAAN;AACA,QAAM4E,IAAI,GAAGqmB,MAAM,CAACY,gBAAP,CAAwBpL,SAAxB,CAAb;AACA,QAAMoH,MAAM,GAAG;AACbpH,aAAS,EAAEA,SADE;AAEbuO,aAAS,EAAEvO,SAAS,CAACwO,WAAV,CAAsB,CAAtB,CAFE;AAGbkD,YAAQ,EAAE;AACRnC,eAAS,EAAEprB,IAAI,CAACorB,SADR;AAERC,kBAAY,EAAErrB,IAAI,CAACqrB;AAFX,KAHG;AAObmC,UAAM,EAAE,EAPK;AAQbve,cAAU,EAAEjP,IAAI,CAACiP,UARJ;AASbkY,eAAW,EAAEnnB,IAAI,CAACmnB;AATL,GAAf;;AAWA,MAAInnB,IAAI,CAACiP,UAAT,EAAqB;AACnB,UAAMwe,KAAK,GAAGL,MAAM,CAAC7vB,GAAP,CAAWyC,IAAI,CAACiP,UAAhB,CAAd;AACA,UAAMye,IAAI,GAAGrH,MAAM,CAACY,gBAAP,CAAwBjnB,IAAI,CAACiP,UAA7B,CAAb;;AACA,QAAIwe,KAAK,CAACD,MAAN,CAAaG,QAAjB,EAA2B;AACzB,YAAMJ,QAAQ,GAAGE,KAAK,CAACF,QAAvB;AACAtK,YAAM,CAACsK,QAAP,CAAgBpC,UAAhB,GAA6BoC,QAAQ,CAACpC,UAAT,IAAuBuC,IAAI,CAACvC,UAAzD;AACAlI,YAAM,CAACsK,QAAP,CAAgBjC,MAAhB,GAAyBiC,QAAQ,CAACjC,MAAT,IAAmBoC,IAAI,CAACpC,MAAjD;AACD;AACF;;AACD,SAAOrI,MAAP;AACD,CAzBD;;AA2BA,MAAMmK,MAAM,GAAG,IAAIQ,KAAK,CAACC,UAAV,CAAqB,QAArB,CAAf;AACA,MAAMR,QAAQ,GAAG,IAAIO,KAAK,CAACC,UAAV,CAAqB,UAArB,CAAjB;;AAEAT,MAAM,CAACU,iBAAP,GAA4BjS,SAAD,IAAe;AACxC,QAAMkS,KAAK,GAAG,CAAClS,SAAD,CAAd;AACA,QAAMmS,OAAO,GAAG,EAAhB;AACAA,SAAO,CAACnS,SAAD,CAAP,GAAqB,IAArB;;AACA,SAAOkS,KAAK,CAAC3yB,MAAN,GAAe,CAAtB,EAAyB;AACvB,UAAMuxB,OAAO,GAAGoB,KAAK,CAAC5a,GAAN,EAAhB;AACA,UAAM8a,YAAY,GAAGb,MAAM,CAACpO,IAAP,CAAY;AAC/B,uCAAiC;AAACkP,cAAM,cAAOvB,OAAP;AAAP,OADF;AAE/B,sBAAgB;AAACwB,WAAG,EAAE;AAAN;AAFe,KAAZ,EAGlB;AAACtS,eAAS,EAAE;AAAZ,KAHkB,EAGFuS,KAHE,EAArB;AAIAH,gBAAY,CAAC/R,GAAb,CAAkB1e,CAAD,IAAOA,CAAC,CAACqe,SAA1B,EAAqCE,MAArC,CAA6Cve,CAAD,IAAO,CAACwwB,OAAO,CAACxwB,CAAD,CAA3D,EAAgE0e,GAAhE,CAAqE1e,CAAD,IAAO;AACzEuwB,WAAK,CAACzyB,IAAN,CAAWkC,CAAX;AACAwwB,aAAO,CAACxwB,CAAD,CAAP,GAAa,IAAb;AACD,KAHD;AAID;;AACD,SAAOwwB,OAAO,CAACnS,SAAD,CAAd;AACAuR,QAAM,CAACiB,MAAP,CAAc;AAACxS,aAAS,EAAE;AAACyS,SAAG,EAAErxB,MAAM,CAACqtB,IAAP,CAAY0D,OAAZ;AAAN;AAAZ,GAAd,EACc;AAACO,QAAI,EAAE;AAAC,sBAAgB,IAAjB;AAAuB,yBAAmB;AAA1C;AAAP,GADd,EAEc;AAACC,SAAK,EAAE;AAAR,GAFd;AAGD,CAnBD;;AAqBApB,MAAM,CAAC7vB,GAAP,GAAcse,SAAD,IACTuR,MAAM,CAACqB,OAAP,CAAe;AAAC5S,WAAS,EAAEA;AAAZ,CAAf,KAA0CyR,YAAY,CAACzR,SAAD,CAD1D;;AAGAuR,MAAM,CAACsB,MAAP,GAAiBjI,UAAD,IAAgB2G,MAAM,CAACpO,IAAP,CAAY;AAACnD,WAAS,EAAE;AAACyS,OAAG,EAAE7H;AAAN;AAAZ,CAAZ,CAAhC;;AAEA2G,MAAM,CAACuB,OAAP,GAAiB,CAAClB,KAAD,EAAQmB,MAAR,KAAmB;AAClCA,QAAM,GAAGA,MAAM,IAAI,EAAnB;AACA,QAAMxE,SAAS,GAAGqD,KAAK,GAAGA,KAAK,CAACrD,SAAT,GAAqB5a,SAA5C;;AACA,QAAMgV,SAAS,GAAGyF,CAAC,CAAC4E,MAAF,CAAS;AAACzE,aAAS,EAAE;AAAC0E,SAAG,EAAE1E;AAAN;AAAZ,GAAT,EAAwCwE,MAAxC,CAAlB;;AACA,QAAMrc,IAAI,GAAG6a,MAAM,CAACqB,OAAP,CAAejK,SAAf,EAA0B;AAACnX,QAAI,EAAE;AAAC+c,eAAS,EAAE;AAAZ;AAAP,GAA1B,CAAb;AACA,SAAO7X,IAAI,GAAGA,IAAH,GAAU6a,MAAM,CAACqB,OAAP,CAAeG,MAAf,EAAuB;AAACvhB,QAAI,EAAE;AAAC+c,eAAS,EAAE;AAAZ;AAAP,GAAvB,CAArB;AACD,CAND;;AAQAgD,MAAM,CAAC2B,iBAAP,GAA4BtB,KAAD,IAAW;AACpC,SAAOL,MAAM,CAACuB,OAAP,CAAelB,KAAf,EAAsB;AAAC,uBAAmB;AAApB,GAAtB,CAAP;AACD,CAFD;;AAIAL,MAAM,CAAC4B,eAAP,GAA0BvB,KAAD,IAAW;AAClC,SAAOL,MAAM,CAACuB,OAAP,CAAelB,KAAf,EAAsB;AAAC,uBAAmB;AAACU,SAAG,EAAE;AAAN;AAApB,GAAtB,CAAP;AACD,CAFD;;AAIAf,MAAM,CAAC6B,WAAP,GAAqB,CAACxB,KAAD,EAAQmB,MAAR,KAAmB;AACtCA,QAAM,GAAGA,MAAM,IAAI,EAAnB;AACA,QAAMxE,SAAS,GAAGqD,KAAK,GAAGA,KAAK,CAACrD,SAAT,GAAqB5a,SAA5C;;AACA,QAAMgV,SAAS,GAAGyF,CAAC,CAAC4E,MAAF,CAAS;AAACzE,aAAS,EAAE;AAAC8E,SAAG,EAAE9E;AAAN;AAAZ,GAAT,EAAwCwE,MAAxC,CAAlB;;AACA,QAAM9X,QAAQ,GAAGsW,MAAM,CAACqB,OAAP,CAAejK,SAAf,EAA0B;AAACnX,QAAI,EAAE;AAAC+c,eAAS,EAAE,CAAC;AAAb;AAAP,GAA1B,CAAjB;AACA,SAAOtT,QAAQ,GAAGA,QAAH,GAAcsW,MAAM,CAACqB,OAAP,CAAeG,MAAf,EAAuB;AAACvhB,QAAI,EAAE;AAAC+c,eAAS,EAAE,CAAC;AAAb;AAAP,GAAvB,CAA7B;AACD,CAND;;AAQAgD,MAAM,CAAC+B,qBAAP,GAAgC1B,KAAD,IAAW;AACxC,SAAOL,MAAM,CAAC6B,WAAP,CAAmBxB,KAAnB,EAA0B;AAAC,uBAAmB;AAApB,GAA1B,CAAP;AACD,CAFD;;AAIAL,MAAM,CAACgC,mBAAP,GAA8B3B,KAAD,IAAW;AACtC,SAAOL,MAAM,CAAC6B,WAAP,CAAmBxB,KAAnB,EAA0B;AAAC,uBAAmB;AAACU,SAAG,EAAE;AAAN;AAApB,GAA1B,CAAP;AACD,CAFD;;AAIAf,MAAM,CAACiC,OAAP,GAAkB5I,UAAD,IAAgB;AAC/B,OAAK,IAAI5K,SAAT,IAAsB4K,UAAtB,EAAkC;AAChC,UAAMgH,KAAK,GAAGL,MAAM,CAAC7vB,GAAP,CAAWse,SAAX,CAAd;;AACA,QAAI,CAAC4R,KAAK,CAACD,MAAN,CAAaG,QAAlB,EAA4B;AAC1BP,YAAM,CAACkC,MAAP,CAAc;AAACzT,iBAAS,EAAE4R,KAAK,CAAC5R;AAAlB,OAAd,EAA4C4R,KAA5C;AACD;AACF;;AACDJ,UAAQ,CAACkC,OAAT;AACD,CARD;;AAUAnC,MAAM,CAACoC,IAAP,GAAe/B,KAAD,IAAW;AACvBgC,OAAK,CAAChC,KAAK,CAAC5R,SAAP,EAAkB4J,MAAlB,CAAL;AACAtB,QAAM,CAACsJ,KAAK,CAAC5R,SAAN,CAAgBzgB,MAAhB,KAA2B,CAA5B,CAAN;AACA,QAAMuxB,OAAO,GAAGS,MAAM,CAAC7vB,GAAP,CAAWkwB,KAAK,CAAC5R,SAAjB,CAAhB;;AACA,MAAI8Q,OAAO,IAAIA,OAAO,CAACa,MAAR,CAAeG,QAA1B,IAAsC,CAACF,KAAK,CAACD,MAAN,CAAaG,QAAxD,EAAkE;AAChEP,UAAM,CAACU,iBAAP,CAAyBL,KAAK,CAAC5R,SAA/B;AACD;;AACDuR,QAAM,CAACsC,uBAAP,CAA+BjC,KAA/B;;AACA,MAAIA,KAAK,CAACD,MAAN,CAAarO,IAAb,IAAqB,CAACsO,KAAK,CAACD,MAAN,CAAarO,IAAb,CAAkBwQ,QAA5C,EAAsD;AACpDvC,UAAM,CAACkC,MAAP,CAAc;AAACzT,eAAS,EAAE4R,KAAK,CAAC5R;AAAlB,KAAd,EAA4C4R,KAA5C;AACD,GAFD,MAEO;AACLL,UAAM,CAACwC,MAAP,CAAc;AAAC/T,eAAS,EAAE4R,KAAK,CAAC5R;AAAlB,KAAd;AACD;;AACDwR,UAAQ,CAACkC,OAAT;AACD,CAdD;;AAgBAnC,MAAM,CAACsC,uBAAP,GAAkCjC,KAAD,IAAW;AAC1C,QAAMztB,IAAI,GAAGqmB,MAAM,CAACY,gBAAP,CAAwBwG,KAAK,CAAC5R,SAA9B,CAAb;AACA,QAAM6R,IAAI,GAAGrH,MAAM,CAACY,gBAAP,CAAwBjnB,IAAI,CAACiP,UAAL,IAAmBwe,KAAK,CAAC5R,SAAjD,CAAb;AACA,QAAMgU,OAAO,GAAG,CAACnC,IAAI,CAAC7R,SAAN,EAAiB7B,MAAjB,CAAwB0T,IAAI,CAACvG,WAA7B,CAAhB;;AACA,MAAI0I,OAAO,CAACz0B,MAAR,KAAmB,CAAnB,IAAwB,OAAOomB,OAAP,CAAeqO,OAAO,CAAC,CAAD,CAAtB,KAA8B,CAA1D,EAA6D;AAC3D;AACD;;AACD,QAAM1E,UAAU,GAAGsC,KAAK,CAACF,QAAN,CAAepC,UAAf,IAA6BnrB,IAAI,CAACmrB,UAArD;AACA,QAAMG,MAAM,GAAGmC,KAAK,CAACF,QAAN,CAAejC,MAAf,IAAyBtrB,IAAI,CAACsrB,MAA7C;AACA8B,QAAM,CAACiB,MAAP,CAAc;AAACxS,aAAS,EAAE;AAACyS,SAAG,EAAEuB;AAAN;AAAZ,GAAd,EAA2C;AAACtB,QAAI,EAAE;AAChD,6BAAuBpD,UADyB;AAEhD,yBAAmBG;AAF6B;AAAP,GAA3C,EAGI;AAACkD,SAAK,EAAE;AAAR,GAHJ;AAID,CAbD;;AAeAnB,QAAQ,CAACkC,OAAT,GAAmB,MAAM;AACvB,QAAMO,KAAK,GAAG1C,MAAM,CAACpO,IAAP,GAAckB,KAAd,EAAd;AACA,QAAM6P,QAAQ,GAAG3C,MAAM,CAACpO,IAAP,CAAY;AAAC,uBAAmB;AAACmP,SAAG,EAAE;AAAN;AAApB,GAAZ,EAA8CjO,KAA9C,EAAjB;AACAmN,UAAQ,CAACiC,MAAT,CAAgB,EAAhB,EAAoB;AAACQ,SAAK,EAAEA,KAAR;AAAeC,YAAQ,EAAEA,QAAzB;AAAmCC,UAAM,EAAE;AAA3C,GAApB;AACD,CAJD;;AAMA,IAAIjL,MAAM,CAACC,QAAX,EAAqB;AACnB;AACAoI,QAAM,CAAC6C,YAAP,CAAoB;AAACpU,aAAS,EAAE;AAAZ,GAApB,EAAoC;AAAC0J,UAAM,EAAE;AAAT,GAApC;;AACA6H,QAAM,CAAC6C,YAAP,CAAoB;AAAC7F,aAAS,EAAE;AAAZ,GAApB,EAAoC;AAAC7E,UAAM,EAAE;AAAT,GAApC;;AACA6H,QAAM,CAAC6C,YAAP,CAAoB;AAAC,uBAAmB;AAApB,GAApB,EAJmB,CAMnB;;;AACA5C,UAAQ,CAACkC,OAAT,GAPmB,CASnB;;AACA,QAAMW,OAAO,GAAG,EAAhB;AACA,QAAMC,YAAY,GAAG,CACjB,KADiB,EACV,SADU,EACC,mBADD,EACsB,iBADtB,EAEjB,aAFiB,EAEF,uBAFE,EAEuB,qBAFvB,EAE8C,MAF9C,CAArB;AAGAA,cAAY,CAACjU,GAAb,CAAkBrc,IAAD,IAAUqwB,OAAO,WAAIrwB,IAAJ,WAAP,GAA0ButB,MAAM,CAACvtB,IAAD,CAA3D;AACAqwB,SAAO,CAACE,aAAR,GAAwBhD,MAAM,CAACiC,OAA/B;;AACAa,SAAO,CAACG,UAAR,GAAsB5H,MAAD,IAAYA,MAAM,CAACvM,GAAP,CAAWkR,MAAM,CAACoC,IAAlB,CAAjC;;AACAzK,QAAM,CAACmL,OAAP,CAAeA,OAAf,EAjBmB,CAmBnB;;AACAnL,QAAM,CAACuL,OAAP,CAAe,cAAf,EAA+BlD,MAAM,CAACsB,MAAtC;AACA3J,QAAM,CAACuL,OAAP,CAAe,aAAf,EAA8BjD,QAAQ,CAACrO,IAAT,CAAc+L,IAAd,CAAmBsC,QAAnB,CAA9B;AACD,C;;;;;;;;;;;AChKD1d,MAAM,CAAC4S,MAAP,CAAc;AAACgO,WAAS,EAAC,MAAIA;AAAf,CAAd;;AAAA;AACA;AAEA,IAAIxF,IAAI,GAAG,UAASyF,EAAT,EAAaC,EAAb,EAAgB;AAAE,SAAO,YAAU;AAAE,WAAOD,EAAE,CAACE,KAAH,CAASD,EAAT,EAAaE,SAAb,CAAP;AAAiC,GAApD;AAAuD,CAApF;;AAEA,MAAMJ,SAAS,GAAI,YAAW;AAC5B,WAASA,SAAT,CAAmBK,WAAnB,EAAgC;AAC9B,QAAI51B,CAAJ,EAAOe,CAAP,EAAU80B,YAAV,EAAwBhiB,GAAxB,EAA6BiiB,GAA7B,EAAkCC,IAAlC,EAAwCC,OAAxC,EAAiDnI,GAAjD,EAAsDrrB,CAAtD,EAAyDC,CAAzD;AACA,SAAKmzB,WAAL,GAAmBA,WAAnB;AACA,SAAKK,eAAL,GAAuBlG,IAAI,CAAC,KAAKkG,eAAN,EAAuB,IAAvB,CAA3B;AACA,SAAKC,aAAL,GAAqBnG,IAAI,CAAC,KAAKmG,aAAN,EAAqB,IAArB,CAAzB;AACA,SAAKC,oBAAL,GAA4BpG,IAAI,CAAC,KAAKoG,oBAAN,EAA4B,IAA5B,CAAhC;AACA,SAAKzyB,OAAL,GAAeqsB,IAAI,CAAC,KAAKrsB,OAAN,EAAe,IAAf,CAAnB;AACA,SAAKof,KAAL,GAAaiN,IAAI,CAAC,KAAKjN,KAAN,EAAa,IAAb,CAAjB;AACA,SAAKsT,IAAL,GAAYrG,IAAI,CAAC,KAAKqG,IAAN,EAAY,IAAZ,CAAhB;AACA,SAAKC,oBAAL,GAA4BtG,IAAI,CAAC,KAAKsG,oBAAN,EAA4B,IAA5B,CAAhC;AACA,SAAKC,kBAAL,GAA0BvG,IAAI,CAAC,KAAKuG,kBAAN,EAA0B,IAA1B,CAA9B;AACA,SAAK32B,CAAL,GAAS,KAAKi2B,WAAL,CAAiBx1B,MAA1B;AACA01B,OAAG,GAAG,KAAKF,WAAX;;AACA,SAAK51B,CAAC,GAAG,CAAJ,EAAO6T,GAAG,GAAGiiB,GAAG,CAAC11B,MAAtB,EAA8BJ,CAAC,GAAG6T,GAAlC,EAAuC7T,CAAC,EAAxC,EAA4C;AAC1C6tB,SAAG,GAAGiI,GAAG,CAAC91B,CAAD,CAAT;;AACA,UAAI6tB,GAAG,CAACztB,MAAJ,KAAe,KAAKT,CAAxB,EAA2B;AACzB,cAAM,IAAIgqB,KAAJ,CAAU,6BAA6B,KAAKiM,WAA5C,CAAN;AACD;AACF;;AACD,SAAKW,KAAL,GAAc,YAAW;AACvBP,aAAO,GAAG,EAAV;;AACA,WAAK,IAAIj1B,CAAC,GAAG,CAAR,EAAWg1B,IAAI,GAAG,KAAKp2B,CAA5B,EAA+B,KAAKo2B,IAAL,GAAYh1B,CAAC,GAAGg1B,IAAhB,GAAuBh1B,CAAC,GAAGg1B,IAA1D,EAAgE,KAAKA,IAAL,GAAYh1B,CAAC,EAAb,GAAkBA,CAAC,EAAnF,EAAsF;AAAEi1B,eAAO,CAAC11B,IAAR,CAAaS,CAAb;AAAkB;;AAC1G,aAAOi1B,OAAP;AACD,KAJY,CAIVN,KAJU,CAIJ,IAJI,CAAb;;AAKA,SAAKc,OAAL,GAAe,CAAf;;AACA,SAAKC,OAAL,GAAgB,YAAW;AACzB,UAAIj1B,CAAJ,EAAOk1B,IAAP,EAAaC,IAAb,EAAmBC,QAAnB;AACAD,UAAI,GAAG,KAAKJ,KAAZ;AACAK,cAAQ,GAAG,EAAX;;AACA,WAAKp1B,CAAC,GAAG,CAAJ,EAAOk1B,IAAI,GAAGC,IAAI,CAACv2B,MAAxB,EAAgCoB,CAAC,GAAGk1B,IAApC,EAA0Cl1B,CAAC,EAA3C,EAA+C;AAC7CgB,SAAC,GAAGm0B,IAAI,CAACn1B,CAAD,CAAR;AACAo1B,gBAAQ,CAACt2B,IAAT,CAAc,CAAd;AACD;;AACD,aAAOs2B,QAAP;AACD,KATc,CASZx0B,IATY,CASP,IATO,CAAf;;AAUA,SAAKy0B,OAAL,GAAgB,YAAW;AACzB,UAAIr1B,CAAJ,EAAOk1B,IAAP,EAAaC,IAAb,EAAmBC,QAAnB;AACAD,UAAI,GAAG,KAAKJ,KAAZ;AACAK,cAAQ,GAAG,EAAX;;AACA,WAAKp1B,CAAC,GAAG,CAAJ,EAAOk1B,IAAI,GAAGC,IAAI,CAACv2B,MAAxB,EAAgCoB,CAAC,GAAGk1B,IAApC,EAA0Cl1B,CAAC,EAA3C,EAA+C;AAC7CiB,SAAC,GAAGk0B,IAAI,CAACn1B,CAAD,CAAR;AACAo1B,gBAAQ,CAACt2B,IAAT,CAAc,CAAd;AACD;;AACD,aAAOs2B,QAAP;AACD,KATc,CASZx0B,IATY,CASP,IATO,CAAf;;AAUA,SAAK00B,OAAL,GAAgB,YAAW;AACzB,UAAIt1B,CAAJ,EAAOk1B,IAAP,EAAaC,IAAb,EAAmBC,QAAnB;AACAD,UAAI,GAAG,KAAKJ,KAAZ;AACAK,cAAQ,GAAG,EAAX;;AACA,WAAKp1B,CAAC,GAAG,CAAJ,EAAOk1B,IAAI,GAAGC,IAAI,CAACv2B,MAAxB,EAAgCoB,CAAC,GAAGk1B,IAApC,EAA0Cl1B,CAAC,EAA3C,EAA+C;AAC7CgB,SAAC,GAAGm0B,IAAI,CAACn1B,CAAD,CAAR;AACAo1B,gBAAQ,CAACt2B,IAAT,CAAc,CAAC,CAAf;AACD;;AACD,aAAOs2B,QAAP;AACD,KATc,CASZx0B,IATY,CASP,IATO,CAAf;;AAUA,SAAK20B,OAAL,GAAgB,YAAW;AACzB,UAAIv1B,CAAJ,EAAOk1B,IAAP,EAAaC,IAAb,EAAmBC,QAAnB;AACAD,UAAI,GAAG,KAAKJ,KAAZ;AACAK,cAAQ,GAAG,EAAX;;AACA,WAAKp1B,CAAC,GAAG,CAAJ,EAAOk1B,IAAI,GAAGC,IAAI,CAACv2B,MAAxB,EAAgCoB,CAAC,GAAGk1B,IAApC,EAA0Cl1B,CAAC,EAA3C,EAA+C;AAC7CiB,SAAC,GAAGk0B,IAAI,CAACn1B,CAAD,CAAR;AACAo1B,gBAAQ,CAACt2B,IAAT,CAAc,CAAC,CAAf;AACD;;AACD,aAAOs2B,QAAP;AACD,KATc,CASZx0B,IATY,CASP,IATO,CAAf;;AAUA,SAAKk0B,kBAAL;AACA,SAAKD,oBAAL;;AACA,WAAO,KAAKG,OAAL,GAAe,KAAK72B,CAA3B,EAA8B;AAC5Bk2B,kBAAY,GAAG,KAAKW,OAApB;AACA,WAAK9yB,OAAL;;AACA,UAAI,KAAK8yB,OAAL,IAAgBX,YAApB,EAAkC;AAChC,cAAM,IAAIlM,KAAJ,CAAU,8CAAV,CAAN;AACD;AACF;AACF;;AAED4L,WAAS,CAACrzB,SAAV,CAAoBo0B,kBAApB,GAAyC,YAAW;AAClD,QAAIt2B,CAAJ,EAAOe,CAAP,EAAUS,CAAV,EAAayQ,CAAb,EAAgB4B,GAAhB,EAAqB6iB,IAArB,EAA2BM,IAA3B,EAAiCC,IAAjC,EAAuCC,QAAvC,EAAiDpB,GAAjD,EAAsDC,IAAtD,EAA4DY,IAA5D,EAAkEQ,IAAlE,EAAwEtJ,GAAxE,EAA6ErrB,CAA7E,EAAgFC,CAAhF;;AACA,SAAKmzB,WAAL,GAAoB,YAAW;AAC7B,UAAI51B,CAAJ,EAAO6T,GAAP,EAAYiiB,GAAZ,EAAiBE,OAAjB;AACAF,SAAG,GAAG,KAAKF,WAAX;AACAI,aAAO,GAAG,EAAV;;AACA,WAAKh2B,CAAC,GAAG,CAAJ,EAAO6T,GAAG,GAAGiiB,GAAG,CAAC11B,MAAtB,EAA8BJ,CAAC,GAAG6T,GAAlC,EAAuC7T,CAAC,EAAxC,EAA4C;AAC1C6tB,WAAG,GAAGiI,GAAG,CAAC91B,CAAD,CAAT;AACAg2B,eAAO,CAAC11B,IAAR,CAAautB,GAAG,CAACjd,KAAJ,EAAb;AACD;;AACD,aAAOolB,OAAP;AACD,KATkB,CAShB5zB,IATgB,CASX,IATW,CAAnB;;AAUA0zB,OAAG,GAAG,KAAKS,KAAX;;AACA,SAAKv2B,CAAC,GAAG,CAAJ,EAAO6T,GAAG,GAAGiiB,GAAG,CAAC11B,MAAtB,EAA8BJ,CAAC,GAAG6T,GAAlC,EAAuC7T,CAAC,EAAxC,EAA4C;AAC1CwC,OAAC,GAAGszB,GAAG,CAAC91B,CAAD,CAAP;AACAk3B,cAAQ,GAAGv4B,IAAI,CAACoM,GAAL,CAAS2qB,KAAT,CAAe,CAAf,EAAmB,YAAW;AACvC,YAAI30B,CAAJ,EAAO21B,IAAP,EAAaX,IAAb,EAAmBC,OAAnB;AACAD,YAAI,GAAG,KAAKQ,KAAZ;AACAP,eAAO,GAAG,EAAV;;AACA,aAAKj1B,CAAC,GAAG,CAAJ,EAAO21B,IAAI,GAAGX,IAAI,CAAC31B,MAAxB,EAAgCW,CAAC,GAAG21B,IAApC,EAA0C31B,CAAC,EAA3C,EAA+C;AAC7C0B,WAAC,GAAGszB,IAAI,CAACh1B,CAAD,CAAR;AACAi1B,iBAAO,CAAC11B,IAAR,CAAa,KAAKs1B,WAAL,CAAiBpzB,CAAjB,EAAoBC,CAApB,CAAb;AACD;;AACD,eAAOuzB,OAAP;AACD,OAT4B,CAS1B5zB,IAT0B,CASrB,IATqB,CAAlB,CAAX;AAUA2zB,UAAI,GAAG,KAAKQ,KAAZ;;AACA,WAAKx1B,CAAC,GAAG,CAAJ,EAAO21B,IAAI,GAAGX,IAAI,CAAC31B,MAAxB,EAAgCW,CAAC,GAAG21B,IAApC,EAA0C31B,CAAC,EAA3C,EAA+C;AAC7C0B,SAAC,GAAGszB,IAAI,CAACh1B,CAAD,CAAR;AACA,aAAK60B,WAAL,CAAiBpzB,CAAjB,EAAoBC,CAApB,KAA0By0B,QAA1B;AACD;;AACD,WAAKT,OAAL,CAAaj0B,CAAb,IAAkB,CAAlB;AACD;;AACDm0B,QAAI,GAAG,KAAKJ,KAAZ;;AACA,SAAK/0B,CAAC,GAAG,CAAJ,EAAOw1B,IAAI,GAAGL,IAAI,CAACv2B,MAAxB,EAAgCoB,CAAC,GAAGw1B,IAApC,EAA0Cx1B,CAAC,EAA3C,EAA+C;AAC7CiB,OAAC,GAAGk0B,IAAI,CAACn1B,CAAD,CAAR;AACA01B,cAAQ,GAAGv4B,IAAI,CAACoM,GAAL,CAAS2qB,KAAT,CAAe,CAAf,EAAmB,YAAW;AACvC,YAAIzjB,CAAJ,EAAOglB,IAAP,EAAaE,IAAb,EAAmBnB,OAAnB;AACAmB,YAAI,GAAG,KAAKZ,KAAZ;AACAP,eAAO,GAAG,EAAV;;AACA,aAAK/jB,CAAC,GAAG,CAAJ,EAAOglB,IAAI,GAAGE,IAAI,CAAC/2B,MAAxB,EAAgC6R,CAAC,GAAGglB,IAApC,EAA0ChlB,CAAC,EAA3C,EAA+C;AAC7CzP,WAAC,GAAG20B,IAAI,CAACllB,CAAD,CAAR;AACA+jB,iBAAO,CAAC11B,IAAR,CAAa,KAAKs1B,WAAL,CAAiBpzB,CAAjB,EAAoBC,CAApB,CAAb;AACD;;AACD,eAAOuzB,OAAP;AACD,OAT4B,CAS1B5zB,IAT0B,CASrB,IATqB,CAAlB,CAAX;AAUA+0B,UAAI,GAAG,KAAKZ,KAAZ;;AACA,WAAKtkB,CAAC,GAAG,CAAJ,EAAOglB,IAAI,GAAGE,IAAI,CAAC/2B,MAAxB,EAAgC6R,CAAC,GAAGglB,IAApC,EAA0ChlB,CAAC,EAA3C,EAA+C;AAC7CzP,SAAC,GAAG20B,IAAI,CAACllB,CAAD,CAAR;AACA,aAAK2jB,WAAL,CAAiBpzB,CAAjB,EAAoBC,CAApB,KAA0By0B,QAA1B;AACD;;AACD,WAAKL,OAAL,CAAap0B,CAAb,IAAkB,CAAlB;AACD;AACF,GApDD;;AAsDA8yB,WAAS,CAACrzB,SAAV,CAAoBm0B,oBAApB,GAA2C,YAAW;AACpD,QAAIr2B,CAAJ,EAAO6T,GAAP,EAAYiiB,GAAZ,EAAiBE,OAAjB,EAA0BxzB,CAA1B,EAA6BC,CAA7B;AACAqzB,OAAG,GAAG,KAAKS,KAAX;AACAP,WAAO,GAAG,EAAV;;AACA,SAAKh2B,CAAC,GAAG,CAAJ,EAAO6T,GAAG,GAAGiiB,GAAG,CAAC11B,MAAtB,EAA8BJ,CAAC,GAAG6T,GAAlC,EAAuC7T,CAAC,EAAxC,EAA4C;AAC1CwC,OAAC,GAAGszB,GAAG,CAAC91B,CAAD,CAAP;AACAg2B,aAAO,CAAC11B,IAAR,CAAc,YAAW;AACvB,YAAIS,CAAJ,EAAO21B,IAAP,EAAaX,IAAb,EAAmBa,QAAnB;AACAb,YAAI,GAAG,KAAKQ,KAAZ;AACAK,gBAAQ,GAAG,EAAX;;AACA,aAAK71B,CAAC,GAAG,CAAJ,EAAO21B,IAAI,GAAGX,IAAI,CAAC31B,MAAxB,EAAgCW,CAAC,GAAG21B,IAApC,EAA0C31B,CAAC,EAA3C,EAA+C;AAC7C0B,WAAC,GAAGszB,IAAI,CAACh1B,CAAD,CAAR;;AACA,cAAI,KAAK+1B,OAAL,CAAat0B,CAAb,MAAoB,CAAC,CAArB,IAA0B,KAAKu0B,OAAL,CAAat0B,CAAb,MAAoB,CAAC,CAA/C,IAAqD,KAAK2zB,IAAL,CAAU5zB,CAAV,EAAaC,CAAb,CAAD,KAAsB,CAA9E,EAAiF;AAC/E,iBAAKqgB,KAAL,CAAWtgB,CAAX,EAAcC,CAAd;AACAm0B,oBAAQ,CAACt2B,IAAT,CAAc,KAAKk2B,OAAL,IAAgB,CAA9B;AACD,WAHD,MAGO;AACLI,oBAAQ,CAACt2B,IAAT,CAAc,KAAK,CAAnB;AACD;AACF;;AACD,eAAOs2B,QAAP;AACD,OAdY,CAcVx0B,IAdU,CAcL,IAdK,CAAb;AAeD;;AACD,WAAO4zB,OAAP;AACD,GAvBD;;AAyBAT,WAAS,CAACrzB,SAAV,CAAoBk0B,IAApB,GAA2B,UAAS5zB,CAAT,EAAYC,CAAZ,EAAe;AACxC,WAAO,KAAKmzB,WAAL,CAAiBpzB,CAAjB,EAAoBC,CAApB,IAAyB,KAAKg0B,OAAL,CAAaj0B,CAAb,CAAzB,GAA2C,KAAKq0B,OAAL,CAAap0B,CAAb,CAAlD;AACD,GAFD;;AAIA8yB,WAAS,CAACrzB,SAAV,CAAoB4gB,KAApB,GAA4B,UAAStgB,CAAT,EAAYC,CAAZ,EAAe;AACzC,SAAKq0B,OAAL,CAAat0B,CAAb,IAAkBC,CAAlB;AACA,WAAO,KAAKs0B,OAAL,CAAat0B,CAAb,IAAkBD,CAAzB;AACD,GAHD;;AAKA+yB,WAAS,CAACrzB,SAAV,CAAoBwB,OAApB,GAA8B,YAAW;AACvC,QAAI0zB,KAAJ,EAAWC,KAAX,EAAkBlS,KAAlB,EAAyBmS,OAAzB,EAAkCC,OAAlC,EAA2Cv3B,CAA3C,EAA8Ce,CAA9C,EAAiD8S,GAAjD,EAAsD6iB,IAAtD,EAA4Dc,SAA5D,EAAuEC,MAAvE,EAA+E3B,GAA/E,EAAoFC,IAApF,EAA0FY,IAA1F,EAAgGjhB,IAAhG,EAAsGgiB,KAAtG,EAA6GC,OAA7G,EAAsHn1B,CAAtH,EAAyHo1B,SAAzH,EAAoIn1B,CAApI,EAAuIo1B,QAAvI;;AACAD,aAAS,GAAI,YAAW;AACtB,UAAI53B,CAAJ,EAAO6T,GAAP,EAAYiiB,GAAZ,EAAiBE,OAAjB;AACAF,SAAG,GAAG,KAAKS,KAAX;AACAP,aAAO,GAAG,EAAV;;AACA,WAAKh2B,CAAC,GAAG,CAAJ,EAAO6T,GAAG,GAAGiiB,GAAG,CAAC11B,MAAtB,EAA8BJ,CAAC,GAAG6T,GAAlC,EAAuC7T,CAAC,EAAxC,EAA4C;AAC1CwC,SAAC,GAAGszB,GAAG,CAAC91B,CAAD,CAAP;AACAg2B,eAAO,CAAC11B,IAAR,CAAa,KAAb;AACD;;AACD,aAAO01B,OAAP;AACD,KATW,CAST5zB,IATS,CASJ,IATI,CAAZ;;AAUAy1B,YAAQ,GAAI,YAAW;AACrB,UAAI73B,CAAJ,EAAO6T,GAAP,EAAYiiB,GAAZ,EAAiBE,OAAjB;AACAF,SAAG,GAAG,KAAKS,KAAX;AACAP,aAAO,GAAG,EAAV;;AACA,WAAKh2B,CAAC,GAAG,CAAJ,EAAO6T,GAAG,GAAGiiB,GAAG,CAAC11B,MAAtB,EAA8BJ,CAAC,GAAG6T,GAAlC,EAAuC7T,CAAC,EAAxC,EAA4C;AAC1CyC,SAAC,GAAGqzB,GAAG,CAAC91B,CAAD,CAAP;AACAg2B,eAAO,CAAC11B,IAAR,CAAa,CAAC,CAAd;AACD;;AACD,aAAO01B,OAAP;AACD,KATU,CASR5zB,IATQ,CASH,IATG,CAAX;;AAUA0zB,OAAG,GAAG,KAAKK,oBAAL,EAAN,EAAmCzgB,IAAI,GAAGogB,GAAG,CAAC,CAAD,CAA7C,EAAkD4B,KAAK,GAAG5B,GAAG,CAAC,CAAD,CAA7D,EAAkE6B,OAAO,GAAG7B,GAAG,CAAC,CAAD,CAA/E;AACA8B,aAAS,CAACliB,IAAD,CAAT,GAAkB,IAAlB;;AACA,WAAO,IAAP,EAAa;AACXyP,WAAK,GAAGjM,QAAR;AACA6c,UAAI,GAAG,KAAKQ,KAAZ;;AACA,WAAKv2B,CAAC,GAAG,CAAJ,EAAO6T,GAAG,GAAGkiB,IAAI,CAAC31B,MAAvB,EAA+BJ,CAAC,GAAG6T,GAAnC,EAAwC7T,CAAC,EAAzC,EAA6C;AAC3CyC,SAAC,GAAGszB,IAAI,CAAC/1B,CAAD,CAAR;;AACA,YAAI63B,QAAQ,CAACp1B,CAAD,CAAR,GAAc,CAAd,IAAmBi1B,KAAK,CAACj1B,CAAD,CAAL,GAAW0iB,KAAlC,EAAyC;AACvCA,eAAK,GAAGuS,KAAK,CAACj1B,CAAD,CAAb;AACA60B,iBAAO,GAAGK,OAAO,CAACl1B,CAAD,CAAjB;AACA80B,iBAAO,GAAG90B,CAAV;AACD;AACF;;AACD,WAAKyzB,aAAL,CAAmB/Q,KAAnB,EAA0ByS,SAA1B,EAAqCC,QAArC,EAA+CH,KAA/C;AACAG,cAAQ,CAACN,OAAD,CAAR,GAAoBD,OAApB;;AACA,UAAI,KAAKP,OAAL,CAAaQ,OAAb,IAAwB,CAA5B,EAA+B;AAC7BF,aAAK,GAAGE,OAAR;;AACA,eAAOF,KAAK,IAAI,CAAhB,EAAmB;AACjBD,eAAK,GAAGS,QAAQ,CAACR,KAAD,CAAhB;AACAI,gBAAM,GAAG,KAAKX,OAAL,CAAaM,KAAb,CAAT;AACA,eAAKtU,KAAL,CAAWsU,KAAX,EAAkBC,KAAlB;AACAA,eAAK,GAAGI,MAAR;AACD;;AACD,aAAKjB,OAAL,IAAgB,CAAhB;AACA;AACD;;AACDh0B,OAAC,GAAG,KAAKu0B,OAAL,CAAaQ,OAAb,CAAJ;AACAK,eAAS,CAACp1B,CAAD,CAAT,GAAe,IAAf;AACAm0B,UAAI,GAAG,KAAKJ,KAAZ;;AACA,WAAKx1B,CAAC,GAAG,CAAJ,EAAO21B,IAAI,GAAGC,IAAI,CAACv2B,MAAxB,EAAgCW,CAAC,GAAG21B,IAApC,EAA0C31B,CAAC,EAA3C,EAA+C;AAC7C0B,SAAC,GAAGk0B,IAAI,CAAC51B,CAAD,CAAR;;AACA,YAAI82B,QAAQ,CAACp1B,CAAD,CAAR,GAAc,CAAlB,EAAqB;AACnB+0B,mBAAS,GAAG,CAAE,KAAKpB,IAAL,CAAU5zB,CAAV,EAAaC,CAAb,CAAd;;AACA,cAAIi1B,KAAK,CAACj1B,CAAD,CAAL,GAAW+0B,SAAf,EAA0B;AACxBE,iBAAK,CAACj1B,CAAD,CAAL,GAAW+0B,SAAX;AACAG,mBAAO,CAACl1B,CAAD,CAAP,GAAaD,CAAb;AACD;AACF;AACF;AACF;AACF,GA9DD;;AAgEA+yB,WAAS,CAACrzB,SAAV,CAAoBi0B,oBAApB,GAA2C,YAAW;AACpD,QAAIn2B,CAAJ,EAAO6T,GAAP,EAAYiiB,GAAZ,EAAiBtzB,CAAjB,EAAoBC,CAApB;AACAqzB,OAAG,GAAG,KAAKS,KAAX;;AACA,SAAKv2B,CAAC,GAAG,CAAJ,EAAO6T,GAAG,GAAGiiB,GAAG,CAAC11B,MAAtB,EAA8BJ,CAAC,GAAG6T,GAAlC,EAAuC7T,CAAC,EAAxC,EAA4C;AAC1CwC,OAAC,GAAGszB,GAAG,CAAC91B,CAAD,CAAP;;AACA,UAAI,KAAK82B,OAAL,CAAat0B,CAAb,IAAkB,CAAtB,EAAyB;AACvB,eAAO,CACLA,CADK,EACD,YAAW;AACb,cAAIzB,CAAJ,EAAO21B,IAAP,EAAaX,IAAb,EAAmBC,OAAnB;AACAD,cAAI,GAAG,KAAKQ,KAAZ;AACAP,iBAAO,GAAG,EAAV;;AACA,eAAKj1B,CAAC,GAAG,CAAJ,EAAO21B,IAAI,GAAGX,IAAI,CAAC31B,MAAxB,EAAgCW,CAAC,GAAG21B,IAApC,EAA0C31B,CAAC,EAA3C,EAA+C;AAC7C0B,aAAC,GAAGszB,IAAI,CAACh1B,CAAD,CAAR;AACAi1B,mBAAO,CAAC11B,IAAR,CAAa,CAAE,KAAK81B,IAAL,CAAU5zB,CAAV,EAAaC,CAAb,CAAf;AACD;;AACD,iBAAOuzB,OAAP;AACD,SATE,CASA5zB,IATA,CASK,IATL,CADE,EAUW,YAAW;AACzB,cAAIrB,CAAJ,EAAO21B,IAAP,EAAaX,IAAb,EAAmBC,OAAnB;AACAD,cAAI,GAAG,KAAKQ,KAAZ;AACAP,iBAAO,GAAG,EAAV;;AACA,eAAKj1B,CAAC,GAAG,CAAJ,EAAO21B,IAAI,GAAGX,IAAI,CAAC31B,MAAxB,EAAgCW,CAAC,GAAG21B,IAApC,EAA0C31B,CAAC,EAA3C,EAA+C;AAC7C0B,aAAC,GAAGszB,IAAI,CAACh1B,CAAD,CAAR;AACAi1B,mBAAO,CAAC11B,IAAR,CAAakC,CAAb;AACD;;AACD,iBAAOwzB,OAAP;AACD,SATc,CASZ5zB,IATY,CASP,IATO,CAVV,CAAP;AAqBD;AACF;AACF,GA7BD;;AA+BAmzB,WAAS,CAACrzB,SAAV,CAAoBg0B,aAApB,GAAoC,UAAS/Q,KAAT,EAAgByS,SAAhB,EAA2BC,QAA3B,EAAqCH,KAArC,EAA4C;AAC9E,QAAI13B,CAAJ,EAAOe,CAAP,EAAU8S,GAAV,EAAe6iB,IAAf,EAAqBZ,GAArB,EAA0BC,IAA1B,EAAgCC,OAAhC,EAAyCxzB,CAAzC,EAA4CC,CAA5C;AACAqzB,OAAG,GAAG,KAAKS,KAAX;;AACA,SAAKv2B,CAAC,GAAG,CAAJ,EAAO6T,GAAG,GAAGiiB,GAAG,CAAC11B,MAAtB,EAA8BJ,CAAC,GAAG6T,GAAlC,EAAuC7T,CAAC,EAAxC,EAA4C;AAC1CwC,OAAC,GAAGszB,GAAG,CAAC91B,CAAD,CAAP;;AACA,UAAI43B,SAAS,CAACp1B,CAAD,CAAb,EAAkB;AAChB,aAAKi0B,OAAL,CAAaj0B,CAAb,KAAmB2iB,KAAnB;AACD;AACF;;AACD4Q,QAAI,GAAG,KAAKQ,KAAZ;AACAP,WAAO,GAAG,EAAV;;AACA,SAAKj1B,CAAC,GAAG,CAAJ,EAAO21B,IAAI,GAAGX,IAAI,CAAC31B,MAAxB,EAAgCW,CAAC,GAAG21B,IAApC,EAA0C31B,CAAC,EAA3C,EAA+C;AAC7C0B,OAAC,GAAGszB,IAAI,CAACh1B,CAAD,CAAR;;AACA,UAAI82B,QAAQ,CAACp1B,CAAD,CAAR,GAAc,CAAlB,EAAqB;AACnBuzB,eAAO,CAAC11B,IAAR,CAAao3B,KAAK,CAACj1B,CAAD,CAAL,IAAY0iB,KAAzB;AACD,OAFD,MAEO;AACL6Q,eAAO,CAAC11B,IAAR,CAAa,KAAKu2B,OAAL,CAAap0B,CAAb,KAAmB0iB,KAAhC;AACD;AACF;;AACD,WAAO6Q,OAAP;AACD,GApBD;;AAsBAT,WAAS,CAACrzB,SAAV,CAAoB+zB,eAApB,GAAsC,UAAS6B,eAAT,EAA0B;AAC9D,QAAIt1B,CAAJ;AACA,WAAOu1B,IAAI,CAACC,GAAL,CAAU,YAAW;AAC1B,UAAIh4B,CAAJ,EAAO6T,GAAP,EAAYiiB,GAAZ,EAAiBE,OAAjB;AACAF,SAAG,GAAG,KAAKS,KAAX;AACAP,aAAO,GAAG,EAAV;;AACA,WAAKh2B,CAAC,GAAG,CAAJ,EAAO6T,GAAG,GAAGiiB,GAAG,CAAC11B,MAAtB,EAA8BJ,CAAC,GAAG6T,GAAlC,EAAuC7T,CAAC,EAAxC,EAA4C;AAC1CwC,SAAC,GAAGszB,GAAG,CAAC91B,CAAD,CAAP;AACAg2B,eAAO,CAAC11B,IAAR,CAAaw3B,eAAe,CAACt1B,CAAD,CAAf,CAAmB,KAAKs0B,OAAL,CAAat0B,CAAb,CAAnB,CAAb;AACD;;AACD,aAAOwzB,OAAP;AACD,KATe,CASb5zB,IATa,CASR,IATQ,CAAT,CAAP;AAUD,GAZD;;AAcA,SAAOmzB,SAAP;AAED,CA1SiB,EAAlB,C;;;;;;;;;;;ACLA5gB,MAAM,CAAC4S,MAAP,CAAc;AAAC0Q,aAAW,EAAC,MAAIA;AAAjB,CAAd;AAA6C,IAAI/kB,QAAJ;AAAayB,MAAM,CAAC2W,IAAP,CAAY,uCAAZ,EAAoD;AAAC4M,SAAO,CAACr5B,CAAD,EAAG;AAACqU,YAAQ,GAACrU,CAAT;AAAW;;AAAvB,CAApD,EAA6E,CAA7E;AAAgF,IAAIsqB,MAAJ,EAAWI,KAAX;AAAiB5U,MAAM,CAAC2W,IAAP,CAAY,WAAZ,EAAwB;AAACnC,QAAM,CAACtqB,CAAD,EAAG;AAACsqB,UAAM,GAACtqB,CAAP;AAAS,GAApB;;AAAqB0qB,OAAK,CAAC1qB,CAAD,EAAG;AAAC0qB,SAAK,GAAC1qB,CAAN;AAAQ;;AAAtC,CAAxB,EAAgE,CAAhE;AAAmE,IAAIs5B,GAAJ;AAAQxjB,MAAM,CAAC2W,IAAP,CAAY,UAAZ,EAAuB;AAAC6M,KAAG,CAACt5B,CAAD,EAAG;AAACs5B,OAAG,GAACt5B,CAAJ;AAAM;;AAAd,CAAvB,EAAuC,CAAvC;AAKtO,MAAMu5B,IAAI,GAAG,IAAb;AACA,MAAMC,IAAI,GAAG,GAAb;AACA,MAAMC,YAAY,GAAG,CAArB;AAEA,IAAIC,OAAO,GAAG/jB,SAAd;;AAEA,MAAMgkB,YAAY,GAAG,CAACxQ,MAAD,EAASroB,CAAT,KAAe;AAClC,QAAM84B,SAAS,GAAGxJ,CAAC,CAACsH,KAAF,CAAQvO,MAAM,CAAC5nB,MAAP,GAAgB,CAAxB,EAA2B8gB,GAA3B,CACblhB,CAAD,IAAOrB,IAAI,CAACK,IAAL,CAAUuqB,KAAK,CAAC5B,SAAN,CAAgBK,MAAM,CAAChoB,CAAD,CAAtB,EAA2BgoB,MAAM,CAAChoB,CAAC,GAAG,CAAL,CAAjC,CAAV,CADO,CAAlB;;AAEA,MAAI80B,KAAK,GAAG,CAAZ;AACA2D,WAAS,CAACvX,GAAV,CAAe1e,CAAD,IAAOsyB,KAAK,IAAItyB,CAA9B;AACA,QAAMylB,MAAM,GAAG,EAAf;AACA,MAAI9T,KAAK,GAAG,CAAZ;AACA,MAAIukB,QAAQ,GAAG1Q,MAAM,CAAC,CAAD,CAArB;AACA,MAAI2Q,YAAY,GAAG,CAAnB;;AACA,OAAK,IAAI34B,CAAT,IAAcivB,CAAC,CAACsH,KAAF,CAAQ52B,CAAC,GAAG,CAAZ,CAAd,EAA8B;AAC5B,UAAMovB,MAAM,GAAG/uB,CAAC,GAAC80B,KAAF,IAASn1B,CAAC,GAAG,CAAb,CAAf;;AACA,WAAOg5B,YAAY,GAAG5J,MAAtB,EAA8B;AAC5B,YAAMjd,IAAI,GAAGnT,IAAI,CAACK,IAAL,CAAUuqB,KAAK,CAAC5B,SAAN,CAAgB+Q,QAAhB,EAA0B1Q,MAAM,CAAC7T,KAAK,GAAG,CAAT,CAAhC,CAAV,CAAb;;AACA,UAAIwkB,YAAY,GAAG7mB,IAAf,GAAsBid,MAA1B,EAAkC;AAChC5a,aAAK,IAAI,CAAT;AACAukB,gBAAQ,GAAG1Q,MAAM,CAAC7T,KAAD,CAAjB;AACAwkB,oBAAY,IAAI7mB,IAAhB;AACD,OAJD,MAIO;AACL,cAAMlF,CAAC,GAAG,CAACmiB,MAAM,GAAG4J,YAAV,IAAwB7mB,IAAlC;AACA4mB,gBAAQ,GAAG,CAAC,CAAC,IAAI9rB,CAAL,IAAQ8rB,QAAQ,CAAC,CAAD,CAAhB,GAAsB9rB,CAAC,GAACob,MAAM,CAAC7T,KAAK,GAAG,CAAT,CAAN,CAAkB,CAAlB,CAAzB,EACC,CAAC,IAAIvH,CAAL,IAAQ8rB,QAAQ,CAAC,CAAD,CAAhB,GAAsB9rB,CAAC,GAACob,MAAM,CAAC7T,KAAK,GAAG,CAAT,CAAN,CAAkB,CAAlB,CADzB,CAAX;AAEAwkB,oBAAY,GAAG5J,MAAf;AACD;AACF;;AACD9G,UAAM,CAAC3nB,IAAP,CAAYipB,KAAK,CAACrmB,KAAN,CAAYw1B,QAAZ,CAAZ;AACD;;AACDzQ,QAAM,CAAC3nB,IAAP,CAAY0nB,MAAM,CAACA,MAAM,CAAC5nB,MAAP,GAAgB,CAAjB,CAAlB;AACA,SAAO6nB,MAAP;AACD,CA5BD;;AA8BA,MAAM2Q,uBAAuB,GAAG,CAACC,SAAD,EAAY/jB,QAAZ,EAAsB0B,IAAtB,KAA+B;AAC7D,QAAM2N,IAAI,GAAG2U,wBAAwB,CAACD,SAAD,EAAY/jB,QAAZ,EAAsB0B,IAAtB,CAArC;AACA,SAAOsiB,wBAAwB,CAACD,SAAD,EAAY/jB,QAAZ,EAAsBqP,IAAI,CAAC,CAAD,CAA1B,CAA/B;AACD,CAHD;;AAKA,MAAM2U,wBAAwB,GAAG,CAACD,SAAD,EAAY/jB,QAAZ,EAAsB0B,IAAtB,EAA4Bwc,OAA5B,KAAwC;AACvEA,SAAO,GAAGA,OAAO,IAAI,EAArB;AACAA,SAAO,CAACxc,IAAD,CAAP,GAAgB,IAAhB;AACA,MAAIyR,MAAM,GAAG,EAAb;AACAA,QAAM,CAAClB,QAAP,GAAkB,CAAlB;;AACA,OAAK,IAAIgS,QAAT,IAAqBF,SAAS,CAACriB,IAAD,CAAT,IAAmB,EAAxC,EAA4C;AAC1C,QAAI,CAACwc,OAAO,CAAC+F,QAAD,CAAZ,EAAwB;AACtB,YAAMC,SAAS,GAAGF,wBAAwB,CACtCD,SADsC,EAC3B/jB,QAD2B,EACjBikB,QADiB,EACP/F,OADO,CAA1C;AAEAgG,eAAS,CAACjS,QAAV,IACIpoB,IAAI,CAACK,IAAL,CAAUuqB,KAAK,CAAC5B,SAAN,CAAgB7S,QAAQ,CAAC0B,IAAD,CAAxB,EAAgC1B,QAAQ,CAACikB,QAAD,CAAxC,CAAV,CADJ;;AAEA,UAAIC,SAAS,CAACjS,QAAV,GAAqBkB,MAAM,CAAClB,QAAhC,EAA0C;AACxCkB,cAAM,GAAG+Q,SAAT;AACD;AACF;AACF;;AACD/Q,QAAM,CAAC3nB,IAAP,CAAYkW,IAAZ;AACA,SAAOyR,MAAP;AACD,CAlBD;;AAoBA,MAAMgR,gBAAgB,GAAI1Y,MAAD,IAAY;AACnC,QAAMiI,KAAK,GAAG2P,GAAG,CAACe,qBAAJ,CAA0B3Y,MAA1B,CAAd;AACA4I,QAAM,CAACX,KAAK,CAACpoB,MAAN,KAAiB,CAAlB,4CAAwDmgB,MAAxD,EAAN;AAEA,MAAI4Y,OAAO,GAAG3kB,SAAd;AACA,MAAIqK,OAAO,GAAGrK,SAAd;;AACA,OAAK,IAAI4kB,aAAT,IAA0B,CAAC,EAAD,EAAK,EAAL,CAA1B,EAAoC;AAClCD,WAAO,GAAGhB,GAAG,CAACkB,uBAAJ,CAA4B7Q,KAAK,CAAC,CAAD,CAAjC,EAAsC4Q,aAAtC,CAAV;AACAb,WAAO,GAAGA,OAAO,IAAI,IAAI1jB,OAAJ,EAArB;AACA,UAAM8J,KAAK,GAAGwa,OAAO,CAACjY,GAAR,CAAatN,KAAD,KAAY;AAACpR,OAAC,EAAEoR,KAAK,CAAC,CAAD,CAAT;AAAcnR,OAAC,EAAEmR,KAAK,CAAC,CAAD;AAAtB,KAAZ,CAAZ,CAAd;AACA,UAAM0lB,YAAY,GAAG;AAACjc,QAAE,EAAE,CAAC+a,IAAN;AAAY9a,QAAE,EAAE8a,IAAhB;AAAsB7a,QAAE,EAAE,CAAC6a,IAA3B;AAAiC5a,QAAE,EAAE4a;AAArC,KAArB;;AACA,QAAI;AACFvZ,aAAO,GAAG0Z,OAAO,CAACzZ,OAAR,CAAgBH,KAAhB,EAAuB2a,YAAvB,CAAV;AACA;AACD,KAHD,CAGE,OAAM5P,KAAN,EAAa;AACb/e,aAAO,CAAC+e,KAAR,kDAAwD0P,aAAxD;AACD;AACF;;AACDjQ,QAAM,CAACtK,OAAD,EAAU,wCAAV,CAAN;AAEAA,SAAO,CAAC/J,QAAR,CAAiBoM,GAAjB,CAAqB,CAAC1e,CAAD,EAAIxC,CAAJ,KAAU;AAC7BwC,KAAC,CAAC+2B,OAAF,GAAYpB,GAAG,CAACqB,oBAAJ,CAAyBL,OAAzB,EAAkC,CAAC32B,CAAC,CAACA,CAAH,EAAMA,CAAC,CAACC,CAAR,CAAlC,CAAZ;AACAD,KAAC,CAAC2R,KAAF,GAAUnU,CAAV;AACD,GAHD;AAIA,QAAM8U,QAAQ,GAAG+J,OAAO,CAAC/J,QAAR,CAAiBoM,GAAjB,CAAsB1e,CAAD,IAAO,CAACA,CAAC,CAACA,CAAH,EAAMA,CAAC,CAACC,CAAR,EAAWye,GAAX,CAAeviB,IAAI,CAAC6jB,KAApB,CAA5B,CAAjB;AACA,QAAMzN,KAAK,GAAG8J,OAAO,CAAC9J,KAAR,CAAcmM,GAAd,CAAmB1e,CAAD,IAAO,CAACA,CAAC,CAACgW,EAAF,CAAKrE,KAAN,EAAa3R,CAAC,CAAC+V,EAAF,CAAKpE,KAAlB,CAAzB,EAAmD4M,MAAnD,CACTve,CAAD,IAAOqc,OAAO,CAAC/J,QAAR,CAAiBtS,CAAC,CAAC,CAAD,CAAlB,EAAuB+2B,OAAvB,IAAkC1a,OAAO,CAAC/J,QAAR,CAAiBtS,CAAC,CAAC,CAAD,CAAlB,EAAuB+2B,OADtD,CAAd;AAEAhB,SAAO,CAAC3Z,OAAR,CAAgBC,OAAhB;AAEAsK,QAAM,CAACpU,KAAK,CAAC3U,MAAN,GAAe,CAAhB,CAAN;AACA,QAAMy4B,SAAS,GAAG,EAAlB;;AACA,OAAK,IAAIvgB,IAAT,IAAiBvD,KAAjB,EAAwB;AACtB8jB,aAAS,CAACvgB,IAAI,CAAC,CAAD,CAAL,CAAT,GAAqBugB,SAAS,CAACvgB,IAAI,CAAC,CAAD,CAAL,CAAT,IAAsB,EAA3C;AACAugB,aAAS,CAACvgB,IAAI,CAAC,CAAD,CAAL,CAAT,CAAmBhY,IAAnB,CAAwBgY,IAAI,CAAC,CAAD,CAA5B;AACAugB,aAAS,CAACvgB,IAAI,CAAC,CAAD,CAAL,CAAT,GAAqBugB,SAAS,CAACvgB,IAAI,CAAC,CAAD,CAAL,CAAT,IAAsB,EAA3C;AACAugB,aAAS,CAACvgB,IAAI,CAAC,CAAD,CAAL,CAAT,CAAmBhY,IAAnB,CAAwBgY,IAAI,CAAC,CAAD,CAA5B;AACD;;AACD,QAAM5C,IAAI,GAAGX,KAAK,CAAC,CAAD,CAAL,CAAS,CAAT,CAAb;AACA,QAAMoP,IAAI,GAAGyU,uBAAuB,CAACC,SAAD,EAAY/jB,QAAZ,EAAsBY,IAAtB,CAApC;AACA,QAAMlC,MAAM,GAAG2Q,IAAI,CAACjD,GAAL,CAAUlhB,CAAD,IAAO8U,QAAQ,CAAC9U,CAAD,CAAxB,CAAf;AAEA,QAAMsU,SAAS,GAAG,CAAlB;AACA,QAAMmlB,MAAM,GAAGvmB,QAAQ,CAACM,MAAM,CAAC0N,GAAP,CAAY1e,CAAD,KAAQ;AAACA,KAAC,EAAEA,CAAC,CAAC,CAAD,CAAL;AAAUC,KAAC,EAAED,CAAC,CAAC,CAAD;AAAd,GAAR,CAAX,CAAD,EAA0C8R,SAA1C,CAAvB;AACA,SAAOmlB,MAAM,CAACvY,GAAP,CAAY1e,CAAD,IAAO,CAACA,CAAC,CAACA,CAAH,EAAMA,CAAC,CAACC,CAAR,CAAlB,CAAP;AACD,CA5CD;;AA8CA,MAAMi3B,iBAAiB,GAAI1R,MAAD,IAAY;AACpC,SAAOwQ,YAAY,CAACxQ,MAAD,EAASsQ,YAAT,CAAZ,CAAmCpX,GAAnC,CACF1e,CAAD,IAAO,CAACA,CAAC,CAAC,CAAD,CAAD,GAAK41B,IAAN,EAAY,CAACC,IAAI,GAAG71B,CAAC,CAAC,CAAD,CAAT,IAAc41B,IAA1B,CADJ,CAAP;AAED,CAHD;;AAKA,MAAMH,WAAW,GAAG;AAClBgB,kBAAgB,EAAEA,gBADA;AAElBS,mBAAiB,EAAEA;AAFD,CAApB,C;;;;;;;;;;;ACrHA/kB,MAAM,CAAC4S,MAAP,CAAc;AAACiJ,0CAAwC,EAAC,MAAIA;AAA9C,CAAd;AAAA,MAAMA,wCAAwC,GAAG;AAAC,YAAS,CAAC;AAAC,iBAAY,CAAb;AAAe,cAAS,CAAxB;AAA0B,cAAS,CAAnC;AAAqC,kBAAa;AAAlD,GAAD,EAA4D;AAAC,iBAAY,CAAb;AAAe,cAAS,CAAxB;AAA0B,cAAS,CAAnC;AAAqC,kBAAa,IAAlD;AAAuD,kBAAa,CAApE;AAAsE,oBAAe,CAArF;AAAuF,oBAAe,CAAtG;AAAwG,eAAU,CAAC;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,CAAC,kBAAN;AAAyB,aAAI,CAAC,mBAA9B;AAAkD,aAAI,mBAAtD;AAA0E,aAAI,kBAA9E;AAAiG,aAAI,mBAArG;AAAyH,aAAI,kBAA7H;AAAgJ,aAAI,oBAApJ;AAAyK,aAAI,CAAC,kBAA9K;AAAiM,6BAAoB,CAArN;AAAuN,kBAAS;AAAC,eAAI,GAAL;AAAS,eAAI,GAAb;AAAiB,eAAI,GAArB;AAAyB,eAAI,GAA7B;AAAiC,eAAI,GAArC;AAAyC,eAAI,GAA7C;AAAiD,eAAI,GAArD;AAAyD,eAAI,GAA7D;AAAiE,eAAI,GAArE;AAAyE,eAAI,GAA7E;AAAiF,gBAAK,EAAtF;AAAyF,gBAAK,GAA9F;AAAkG,gBAAK,EAAvG;AAA0G,gBAAK,GAA/G;AAAmH,gBAAK,GAAxH;AAA4H,gBAAK,GAAjI;AAAqI,gBAAK,GAA1I;AAA8I,gBAAK,GAAnJ;AAAuJ,gBAAK,GAA5J;AAAgK,gBAAK,EAArK;AAAwK,gBAAK,GAA7K;AAAiL,gBAAK,GAAtL;AAA0L,gBAAK,GAA/L;AAAmM,gBAAK,EAAxM;AAA2M,gBAAK,GAAhN;AAAoN,gBAAK,GAAzN;AAA6N,gBAAK,GAAlO;AAAsO,gBAAK,EAA3O;AAA8O,gBAAK,GAAnP;AAAuP,gBAAK,GAA5P;AAAgQ,gBAAK,GAArQ;AAAyQ,gBAAK,EAA9Q;AAAiR,gBAAK,GAAtR;AAA0R,gBAAK,EAA/R;AAAkS,gBAAK,GAAvS;AAA2S,gBAAK,GAAhT;AAAoT,gBAAK,EAAzT;AAA4T,gBAAK,EAAjU;AAAoU,gBAAK,GAAzU;AAA6U,gBAAK,EAAlV;AAAqV,gBAAK,EAA1V;AAA6V,gBAAK,GAAlW;AAAsW,gBAAK,GAA3W;AAA+W,gBAAK,EAApX;AAAuX,gBAAK,CAA5X;AAA8X,gBAAK,GAAnY;AAAuY,gBAAK,GAA5Y;AAAgZ,gBAAK,EAArZ;AAAwZ,gBAAK,EAA7Z;AAAga,gBAAK,GAAra;AAAya,gBAAK,GAA9a;AAAkb,gBAAK,GAAvb;AAA2b,gBAAK,GAAhc;AAAoc,gBAAK,GAAzc;AAA6c,gBAAK,GAAld;AAAsd,gBAAK,EAA3d;AAA8d,gBAAK,GAAne;AAAue,gBAAK,GAA5e;AAAgf,gBAAK,EAArf;AAAwf,gBAAK,GAA7f;AAAigB,gBAAK,EAAtgB;AAAygB,gBAAK,EAA9gB;AAAihB,gBAAK,GAAthB;AAA0hB,gBAAK,GAA/hB;AAAmiB,wBAAa;AAAhjB,SAAhO;AAAoxB,kBAAS,CAA7xB;AAA+xB,sBAAa,CAA5yB;AAA8yB,sBAAa;AAA3zB;AAA7B,KAAD,EAA81B;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,CAAC,kBAAN;AAAyB,aAAI,CAAC,kBAA9B;AAAiD,aAAI,CAAC,kBAAtD;AAAyE,aAAI,CAAC,mBAA9E;AAAkG,aAAI,mBAAtG;AAA0H,aAAI,CAAC,mBAA/H;AAAmJ,aAAI,kBAAvJ;AAA0K,aAAI,kBAA9K;AAAiM,6BAAoB,CAArN;AAAuN,kBAAS;AAAC,eAAI,GAAL;AAAS,eAAI,GAAb;AAAiB,eAAI,GAArB;AAAyB,eAAI,GAA7B;AAAiC,eAAI,GAArC;AAAyC,eAAI,GAA7C;AAAiD,eAAI,GAArD;AAAyD,eAAI,GAA7D;AAAiE,eAAI,GAArE;AAAyE,eAAI,GAA7E;AAAiF,gBAAK,GAAtF;AAA0F,gBAAK,GAA/F;AAAmG,gBAAK,GAAxG;AAA4G,gBAAK,GAAjH;AAAqH,gBAAK,GAA1H;AAA8H,gBAAK,GAAnI;AAAuI,gBAAK,GAA5I;AAAgJ,gBAAK,GAArJ;AAAyJ,gBAAK,GAA9J;AAAkK,gBAAK,GAAvK;AAA2K,gBAAK,EAAhL;AAAmL,gBAAK,GAAxL;AAA4L,gBAAK,GAAjM;AAAqM,gBAAK,GAA1M;AAA8M,gBAAK,GAAnN;AAAuN,gBAAK,GAA5N;AAAgO,gBAAK,GAArO;AAAyO,gBAAK,EAA9O;AAAiP,gBAAK,EAAtP;AAAyP,gBAAK,GAA9P;AAAkQ,gBAAK,GAAvQ;AAA2Q,gBAAK,GAAhR;AAAoR,gBAAK,GAAzR;AAA6R,gBAAK,EAAlS;AAAqS,gBAAK,EAA1S;AAA6S,gBAAK,GAAlT;AAAsT,gBAAK,EAA3T;AAA8T,gBAAK,EAAnU;AAAsU,gBAAK,GAA3U;AAA+U,gBAAK,EAApV;AAAuV,gBAAK,EAA5V;AAA+V,gBAAK,GAApW;AAAwW,gBAAK,GAA7W;AAAiX,gBAAK,EAAtX;AAAyX,gBAAK,EAA9X;AAAiY,gBAAK,EAAtY;AAAyY,gBAAK,GAA9Y;AAAkZ,gBAAK,GAAvZ;AAA2Z,gBAAK,EAAha;AAAma,gBAAK,EAAxa;AAA2a,gBAAK,GAAhb;AAAob,gBAAK,GAAzb;AAA6b,gBAAK,EAAlc;AAAqc,gBAAK,GAA1c;AAA8c,gBAAK,GAAnd;AAAud,gBAAK,EAA5d;AAA+d,gBAAK,GAApe;AAAwe,gBAAK,GAA7e;AAAif,gBAAK,GAAtf;AAA0f,gBAAK,GAA/f;AAAmgB,gBAAK,GAAxgB;AAA4gB,gBAAK,GAAjhB;AAAqhB,gBAAK,GAA1hB;AAA8hB,gBAAK,EAAniB;AAAsiB,wBAAa;AAAnjB,SAAhO;AAAuxB,kBAAS,CAAhyB;AAAkyB,sBAAa,CAA/yB;AAAizB,sBAAa;AAA9zB;AAA7B,KAA91B,EAA8rD;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,CAAC,kBAAN;AAAyB,aAAI,mBAA7B;AAAiD,aAAI,CAAC,oBAAtD;AAA2E,aAAI,oBAA/E;AAAoG,aAAI,CAAC,mBAAzG;AAA6H,aAAI,CAAC,mBAAlI;AAAsJ,aAAI,CAAC,kBAA3J;AAA8K,aAAI,CAAC,mBAAnL;AAAuM,6BAAoB,CAA3N;AAA6N,kBAAS;AAAC,eAAI,GAAL;AAAS,eAAI,GAAb;AAAiB,eAAI,GAArB;AAAyB,eAAI,GAA7B;AAAiC,eAAI,EAArC;AAAwC,eAAI,GAA5C;AAAgD,eAAI,GAApD;AAAwD,eAAI,GAA5D;AAAgE,eAAI,EAApE;AAAuE,eAAI,GAA3E;AAA+E,gBAAK,GAApF;AAAwF,gBAAK,EAA7F;AAAgG,gBAAK,EAArG;AAAwG,gBAAK,EAA7G;AAAgH,gBAAK,GAArH;AAAyH,gBAAK,EAA9H;AAAiI,gBAAK,GAAtI;AAA0I,gBAAK,GAA/I;AAAmJ,gBAAK,GAAxJ;AAA4J,gBAAK,EAAjK;AAAoK,gBAAK,EAAzK;AAA4K,gBAAK,GAAjL;AAAqL,gBAAK,GAA1L;AAA8L,gBAAK,GAAnM;AAAuM,gBAAK,EAA5M;AAA+M,gBAAK,GAApN;AAAwN,gBAAK,EAA7N;AAAgO,gBAAK,GAArO;AAAyO,gBAAK,GAA9O;AAAkP,gBAAK,EAAvP;AAA0P,gBAAK,GAA/P;AAAmQ,gBAAK,EAAxQ;AAA2Q,gBAAK,GAAhR;AAAoR,gBAAK,GAAzR;AAA6R,gBAAK,EAAlS;AAAqS,gBAAK,GAA1S;AAA8S,gBAAK,GAAnT;AAAuT,gBAAK,EAA5T;AAA+T,gBAAK,GAApU;AAAwU,gBAAK,GAA7U;AAAiV,gBAAK,GAAtV;AAA0V,gBAAK,GAA/V;AAAmW,gBAAK,GAAxW;AAA4W,gBAAK,GAAjX;AAAqX,gBAAK,GAA1X;AAA8X,gBAAK,GAAnY;AAAuY,gBAAK,GAA5Y;AAAgZ,gBAAK,GAArZ;AAAyZ,gBAAK,GAA9Z;AAAka,gBAAK,EAAva;AAA0a,gBAAK,EAA/a;AAAkb,gBAAK,GAAvb;AAA2b,gBAAK,GAAhc;AAAoc,gBAAK,GAAzc;AAA6c,gBAAK,GAAld;AAAsd,gBAAK,GAA3d;AAA+d,gBAAK,EAApe;AAAue,gBAAK,GAA5e;AAAgf,gBAAK,EAArf;AAAwf,gBAAK,GAA7f;AAAigB,gBAAK,GAAtgB;AAA0gB,gBAAK,GAA/gB;AAAmhB,gBAAK,GAAxhB;AAA4hB,gBAAK,GAAjiB;AAAqiB,wBAAa;AAAljB,SAAtO;AAA4xB,kBAAS,CAAryB;AAAuyB,sBAAa,CAApzB;AAAszB,sBAAa;AAAn0B;AAA7B,KAA9rD,EAAmiF;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,oBAAL;AAA0B,aAAI,mBAA9B;AAAkD,aAAI,CAAC,kBAAvD;AAA0E,aAAI,oBAA9E;AAAmG,aAAI,CAAC,kBAAxG;AAA2H,aAAI,CAAC,kBAAhI;AAAmJ,aAAI,CAAC,mBAAxJ;AAA4K,aAAI,CAAC,mBAAjL;AAAqM,6BAAoB,CAAzN;AAA2N,kBAAS;AAAC,eAAI,GAAL;AAAS,eAAI,GAAb;AAAiB,eAAI,GAArB;AAAyB,eAAI,GAA7B;AAAiC,eAAI,GAArC;AAAyC,eAAI,GAA7C;AAAiD,eAAI,GAArD;AAAyD,eAAI,EAA7D;AAAgE,eAAI,GAApE;AAAwE,eAAI,EAA5E;AAA+E,gBAAK,EAApF;AAAuF,gBAAK,EAA5F;AAA+F,gBAAK,GAApG;AAAwG,gBAAK,EAA7G;AAAgH,gBAAK,GAArH;AAAyH,gBAAK,EAA9H;AAAiI,gBAAK,GAAtI;AAA0I,gBAAK,EAA/I;AAAkJ,gBAAK,GAAvJ;AAA2J,gBAAK,GAAhK;AAAoK,gBAAK,CAAzK;AAA2K,gBAAK,EAAhL;AAAmL,gBAAK,GAAxL;AAA4L,gBAAK,GAAjM;AAAqM,gBAAK,EAA1M;AAA6M,gBAAK,EAAlN;AAAqN,gBAAK,EAA1N;AAA6N,gBAAK,EAAlO;AAAqO,gBAAK,GAA1O;AAA8O,gBAAK,GAAnP;AAAuP,gBAAK,GAA5P;AAAgQ,gBAAK,EAArQ;AAAwQ,gBAAK,GAA7Q;AAAiR,gBAAK,GAAtR;AAA0R,gBAAK,GAA/R;AAAmS,gBAAK,EAAxS;AAA2S,gBAAK,EAAhT;AAAmT,gBAAK,EAAxT;AAA2T,gBAAK,GAAhU;AAAoU,gBAAK,GAAzU;AAA6U,gBAAK,GAAlV;AAAsV,gBAAK,GAA3V;AAA+V,gBAAK,GAApW;AAAwW,gBAAK,EAA7W;AAAgX,gBAAK,EAArX;AAAwX,gBAAK,GAA7X;AAAiY,gBAAK,GAAtY;AAA0Y,gBAAK,GAA/Y;AAAmZ,gBAAK,GAAxZ;AAA4Z,gBAAK,GAAja;AAAqa,gBAAK,EAA1a;AAA6a,gBAAK,GAAlb;AAAsb,gBAAK,EAA3b;AAA8b,gBAAK,GAAnc;AAAuc,gBAAK,GAA5c;AAAgd,gBAAK,GAArd;AAAyd,gBAAK,GAA9d;AAAke,gBAAK,GAAve;AAA2e,gBAAK,EAAhf;AAAmf,gBAAK,GAAxf;AAA4f,gBAAK,EAAjgB;AAAogB,gBAAK,GAAzgB;AAA6gB,gBAAK,GAAlhB;AAAshB,gBAAK,GAA3hB;AAA+hB,wBAAa;AAA5iB,SAApO;AAAoxB,kBAAS,CAA7xB;AAA+xB,sBAAa,CAA5yB;AAA8yB,sBAAa;AAA3zB;AAA7B,KAAniF,EAAg4G;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,mBAAL;AAAyB,aAAI,CAAC,kBAA9B;AAAiD,aAAI,CAAC,kBAAtD;AAAyE,aAAI,CAAC,mBAA9E;AAAkG,aAAI,mBAAtG;AAA0H,aAAI,oBAA9H;AAAmJ,aAAI,CAAC,mBAAxJ;AAA4K,aAAI,CAAC,kBAAjL;AAAoM,6BAAoB,CAAxN;AAA0N,kBAAS;AAAC,eAAI,GAAL;AAAS,eAAI,GAAb;AAAiB,eAAI,GAArB;AAAyB,eAAI,EAA7B;AAAgC,eAAI,GAApC;AAAwC,eAAI,EAA5C;AAA+C,eAAI,GAAnD;AAAuD,eAAI,EAA3D;AAA8D,eAAI,CAAlE;AAAoE,eAAI,GAAxE;AAA4E,gBAAK,GAAjF;AAAqF,gBAAK,GAA1F;AAA8F,gBAAK,EAAnG;AAAsG,gBAAK,EAA3G;AAA8G,gBAAK,GAAnH;AAAuH,gBAAK,GAA5H;AAAgI,gBAAK,EAArI;AAAwI,gBAAK,GAA7I;AAAiJ,gBAAK,EAAtJ;AAAyJ,gBAAK,EAA9J;AAAiK,gBAAK,EAAtK;AAAyK,gBAAK,EAA9K;AAAiL,gBAAK,GAAtL;AAA0L,gBAAK,GAA/L;AAAmM,gBAAK,GAAxM;AAA4M,gBAAK,GAAjN;AAAqN,gBAAK,GAA1N;AAA8N,gBAAK,CAAnO;AAAqO,gBAAK,EAA1O;AAA6O,gBAAK,CAAlP;AAAoP,gBAAK,GAAzP;AAA6P,gBAAK,GAAlQ;AAAsQ,gBAAK,EAA3Q;AAA8Q,gBAAK,GAAnR;AAAuR,gBAAK,GAA5R;AAAgS,gBAAK,EAArS;AAAwS,gBAAK,EAA7S;AAAgT,gBAAK,GAArT;AAAyT,gBAAK,GAA9T;AAAkU,gBAAK,EAAvU;AAA0U,gBAAK,GAA/U;AAAmV,gBAAK,GAAxV;AAA4V,gBAAK,EAAjW;AAAoW,gBAAK,EAAzW;AAA4W,gBAAK,EAAjX;AAAoX,gBAAK,GAAzX;AAA6X,gBAAK,GAAlY;AAAsY,gBAAK,EAA3Y;AAA8Y,gBAAK,GAAnZ;AAAuZ,gBAAK,GAA5Z;AAAga,gBAAK,GAAra;AAAya,gBAAK,EAA9a;AAAib,gBAAK,GAAtb;AAA0b,gBAAK,EAA/b;AAAkc,gBAAK,GAAvc;AAA2c,gBAAK,GAAhd;AAAod,gBAAK,EAAzd;AAA4d,gBAAK,EAAje;AAAoe,gBAAK,GAAze;AAA6e,gBAAK,GAAlf;AAAsf,gBAAK,GAA3f;AAA+f,gBAAK,EAApgB;AAAugB,gBAAK,GAA5gB;AAAghB,gBAAK,GAArhB;AAAyhB,wBAAa;AAAtiB,SAAnO;AAA6wB,kBAAS,CAAtxB;AAAwxB,sBAAa,CAAryB;AAAuyB,sBAAa;AAApzB;AAA7B,KAAh4G,EAAstI;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,mBAAL;AAAyB,aAAI,kBAA7B;AAAgD,aAAI,CAAC,kBAArD;AAAwE,aAAI,CAAC,oBAA7E;AAAkG,aAAI,mBAAtG;AAA0H,aAAI,CAAC,kBAA/H;AAAkJ,aAAI,CAAC,kBAAvJ;AAA0K,aAAI,CAAC,mBAA/K;AAAmM,6BAAoB,CAAvN;AAAyN,kBAAS;AAAC,eAAI,EAAL;AAAQ,eAAI,GAAZ;AAAgB,eAAI,EAApB;AAAuB,eAAI,EAA3B;AAA8B,eAAI,GAAlC;AAAsC,eAAI,EAA1C;AAA6C,eAAI,GAAjD;AAAqD,eAAI,EAAzD;AAA4D,eAAI,EAAhE;AAAmE,eAAI,GAAvE;AAA2E,gBAAK,GAAhF;AAAoF,gBAAK,GAAzF;AAA6F,gBAAK,EAAlG;AAAqG,gBAAK,GAA1G;AAA8G,gBAAK,GAAnH;AAAuH,gBAAK,EAA5H;AAA+H,gBAAK,EAApI;AAAuI,gBAAK,EAA5I;AAA+I,gBAAK,EAApJ;AAAuJ,gBAAK,GAA5J;AAAgK,gBAAK,GAArK;AAAyK,gBAAK,EAA9K;AAAiL,gBAAK,GAAtL;AAA0L,gBAAK,GAA/L;AAAmM,gBAAK,GAAxM;AAA4M,gBAAK,GAAjN;AAAqN,gBAAK,GAA1N;AAA8N,gBAAK,EAAnO;AAAsO,gBAAK,GAA3O;AAA+O,gBAAK,GAApP;AAAwP,gBAAK,GAA7P;AAAiQ,gBAAK,GAAtQ;AAA0Q,gBAAK,GAA/Q;AAAmR,gBAAK,EAAxR;AAA2R,gBAAK,EAAhS;AAAmS,gBAAK,GAAxS;AAA4S,gBAAK,GAAjT;AAAqT,gBAAK,EAA1T;AAA6T,gBAAK,GAAlU;AAAsU,gBAAK,EAA3U;AAA8U,gBAAK,GAAnV;AAAuV,gBAAK,EAA5V;AAA+V,gBAAK,GAApW;AAAwW,gBAAK,EAA7W;AAAgX,gBAAK,CAArX;AAAuX,gBAAK,EAA5X;AAA+X,gBAAK,GAApY;AAAwY,gBAAK,GAA7Y;AAAiZ,gBAAK,EAAtZ;AAAyZ,gBAAK,GAA9Z;AAAka,gBAAK,EAAva;AAA0a,gBAAK,GAA/a;AAAmb,gBAAK,GAAxb;AAA4b,gBAAK,GAAjc;AAAqc,gBAAK,GAA1c;AAA8c,gBAAK,GAAnd;AAAud,gBAAK,GAA5d;AAAge,gBAAK,GAAre;AAAye,gBAAK,GAA9e;AAAkf,gBAAK,EAAvf;AAA0f,gBAAK,EAA/f;AAAkgB,gBAAK,GAAvgB;AAA2gB,gBAAK,GAAhhB;AAAohB,gBAAK,GAAzhB;AAA6hB,wBAAa;AAA1iB,SAAlO;AAAgxB,kBAAS,CAAzxB;AAA2xB,sBAAa,CAAxyB;AAA0yB,sBAAa;AAAvzB;AAA7B,KAAttI,EAA+iK;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,kBAAL;AAAwB,aAAI,kBAA5B;AAA+C,aAAI,CAAC,mBAApD;AAAwE,aAAI,CAAC,mBAA7E;AAAiG,aAAI,kBAArG;AAAwH,aAAI,mBAA5H;AAAgJ,aAAI,kBAApJ;AAAuK,aAAI,mBAA3K;AAA+L,6BAAoB,CAAnN;AAAqN,kBAAS;AAAC,eAAI,EAAL;AAAQ,eAAI,GAAZ;AAAgB,eAAI,GAApB;AAAwB,eAAI,GAA5B;AAAgC,eAAI,GAApC;AAAwC,eAAI,EAA5C;AAA+C,eAAI,GAAnD;AAAuD,eAAI,EAA3D;AAA8D,eAAI,EAAlE;AAAqE,eAAI,GAAzE;AAA6E,gBAAK,GAAlF;AAAsF,gBAAK,GAA3F;AAA+F,gBAAK,EAApG;AAAuG,gBAAK,GAA5G;AAAgH,gBAAK,GAArH;AAAyH,gBAAK,EAA9H;AAAiI,gBAAK,GAAtI;AAA0I,gBAAK,GAA/I;AAAmJ,gBAAK,EAAxJ;AAA2J,gBAAK,EAAhK;AAAmK,gBAAK,EAAxK;AAA2K,gBAAK,GAAhL;AAAoL,gBAAK,GAAzL;AAA6L,gBAAK,GAAlM;AAAsM,gBAAK,GAA3M;AAA+M,gBAAK,GAApN;AAAwN,gBAAK,GAA7N;AAAiO,gBAAK,GAAtO;AAA0O,gBAAK,GAA/O;AAAmP,gBAAK,GAAxP;AAA4P,gBAAK,GAAjQ;AAAqQ,gBAAK,GAA1Q;AAA8Q,gBAAK,GAAnR;AAAuR,gBAAK,EAA5R;AAA+R,gBAAK,EAApS;AAAuS,gBAAK,EAA5S;AAA+S,gBAAK,EAApT;AAAuT,gBAAK,EAA5T;AAA+T,gBAAK,GAApU;AAAwU,gBAAK,EAA7U;AAAgV,gBAAK,EAArV;AAAwV,gBAAK,GAA7V;AAAiW,gBAAK,EAAtW;AAAyW,gBAAK,GAA9W;AAAkX,gBAAK,EAAvX;AAA0X,gBAAK,GAA/X;AAAmY,gBAAK,GAAxY;AAA4Y,gBAAK,EAAjZ;AAAoZ,gBAAK,GAAzZ;AAA6Z,gBAAK,EAAla;AAAqa,gBAAK,EAA1a;AAA6a,gBAAK,EAAlb;AAAqb,gBAAK,EAA1b;AAA6b,gBAAK,GAAlc;AAAsc,gBAAK,GAA3c;AAA+c,gBAAK,EAApd;AAAud,gBAAK,GAA5d;AAAge,gBAAK,EAAre;AAAwe,gBAAK,EAA7e;AAAgf,gBAAK,GAArf;AAAyf,gBAAK,EAA9f;AAAigB,gBAAK,EAAtgB;AAAygB,gBAAK,GAA9gB;AAAkhB,gBAAK,EAAvhB;AAA0hB,wBAAa;AAAviB,SAA9N;AAAywB,kBAAS,CAAlxB;AAAoxB,sBAAa,CAAjyB;AAAmyB,sBAAa;AAAhzB;AAA7B,KAA/iK,EAAi4L;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,mBAAL;AAAyB,aAAI,CAAC,mBAA9B;AAAkD,aAAI,CAAC,kBAAvD;AAA0E,aAAI,CAAC,kBAA/E;AAAkG,aAAI,CAAC,kBAAvG;AAA0H,aAAI,CAAC,mBAA/H;AAAmJ,aAAI,kBAAvJ;AAA0K,aAAI,CAAC,kBAA/K;AAAkM,6BAAoB,CAAtN;AAAwN,kBAAS;AAAC,eAAI,GAAL;AAAS,eAAI,GAAb;AAAiB,eAAI,GAArB;AAAyB,eAAI,GAA7B;AAAiC,eAAI,GAArC;AAAyC,eAAI,GAA7C;AAAiD,eAAI,GAArD;AAAyD,eAAI,EAA7D;AAAgE,eAAI,EAApE;AAAuE,eAAI,GAA3E;AAA+E,gBAAK,GAApF;AAAwF,gBAAK,EAA7F;AAAgG,gBAAK,GAArG;AAAyG,gBAAK,EAA9G;AAAiH,gBAAK,GAAtH;AAA0H,gBAAK,GAA/H;AAAmI,gBAAK,EAAxI;AAA2I,gBAAK,CAAhJ;AAAkJ,gBAAK,GAAvJ;AAA2J,gBAAK,GAAhK;AAAoK,gBAAK,GAAzK;AAA6K,gBAAK,EAAlL;AAAqL,gBAAK,GAA1L;AAA8L,gBAAK,GAAnM;AAAuM,gBAAK,GAA5M;AAAgN,gBAAK,EAArN;AAAwN,gBAAK,EAA7N;AAAgO,gBAAK,CAArO;AAAuO,gBAAK,GAA5O;AAAgP,gBAAK,EAArP;AAAwP,gBAAK,GAA7P;AAAiQ,gBAAK,GAAtQ;AAA0Q,gBAAK,EAA/Q;AAAkR,gBAAK,GAAvR;AAA2R,gBAAK,GAAhS;AAAoS,gBAAK,GAAzS;AAA6S,gBAAK,EAAlT;AAAqT,gBAAK,EAA1T;AAA6T,gBAAK,GAAlU;AAAsU,gBAAK,GAA3U;AAA+U,gBAAK,GAApV;AAAwV,gBAAK,EAA7V;AAAgW,gBAAK,EAArW;AAAwW,gBAAK,EAA7W;AAAgX,gBAAK,GAArX;AAAyX,gBAAK,GAA9X;AAAkY,gBAAK,GAAvY;AAA2Y,gBAAK,GAAhZ;AAAoZ,gBAAK,EAAzZ;AAA4Z,gBAAK,GAAja;AAAqa,gBAAK,EAA1a;AAA6a,gBAAK,GAAlb;AAAsb,gBAAK,EAA3b;AAA8b,gBAAK,GAAnc;AAAuc,gBAAK,GAA5c;AAAgd,gBAAK,EAArd;AAAwd,gBAAK,EAA7d;AAAge,gBAAK,EAAre;AAAwe,gBAAK,GAA7e;AAAif,gBAAK,GAAtf;AAA0f,gBAAK,GAA/f;AAAmgB,gBAAK,GAAxgB;AAA4gB,gBAAK,GAAjhB;AAAqhB,gBAAK,GAA1hB;AAA8hB,wBAAa;AAA3iB,SAAjO;AAAgxB,kBAAS,CAAzxB;AAA2xB,sBAAa,CAAxyB;AAA0yB,sBAAa;AAAvzB;AAA7B,KAAj4L,CAAlH;AAA60N,cAAS;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,kBAAL;AAAwB,aAAI,CAAC,kBAA7B;AAAgD,aAAI,mBAApD;AAAwE,aAAI,CAAC,mBAA7E;AAAiG,aAAI,mBAArG;AAAyH,aAAI,kBAA7H;AAAgJ,aAAI,CAAC,mBAArJ;AAAyK,aAAI,mBAA7K;AAAiM,6BAAoB,CAArN;AAAuN,kBAAS;AAAC,eAAI,GAAL;AAAS,eAAI,GAAb;AAAiB,eAAI,GAArB;AAAyB,eAAI,EAA7B;AAAgC,eAAI,GAApC;AAAwC,eAAI,GAA5C;AAAgD,eAAI,GAApD;AAAwD,eAAI,EAA5D;AAA+D,eAAI,GAAnE;AAAuE,eAAI,EAA3E;AAA8E,gBAAK,GAAnF;AAAuF,gBAAK,GAA5F;AAAgG,gBAAK,EAArG;AAAwG,gBAAK,GAA7G;AAAiH,gBAAK,GAAtH;AAA0H,gBAAK,GAA/H;AAAmI,gBAAK,EAAxI;AAA2I,gBAAK,EAAhJ;AAAmJ,gBAAK,GAAxJ;AAA4J,gBAAK,GAAjK;AAAqK,gBAAK,GAA1K;AAA8K,gBAAK,GAAnL;AAAuL,gBAAK,GAA5L;AAAgM,gBAAK,EAArM;AAAwM,gBAAK,EAA7M;AAAgN,gBAAK,GAArN;AAAyN,gBAAK,EAA9N;AAAiO,gBAAK,GAAtO;AAA0O,gBAAK,GAA/O;AAAmP,gBAAK,GAAxP;AAA4P,gBAAK,GAAjQ;AAAqQ,gBAAK,GAA1Q;AAA8Q,gBAAK,GAAnR;AAAuR,gBAAK,EAA5R;AAA+R,gBAAK,EAApS;AAAuS,gBAAK,EAA5S;AAA+S,gBAAK,EAApT;AAAuT,gBAAK,CAA5T;AAA8T,gBAAK,GAAnU;AAAuU,gBAAK,EAA5U;AAA+U,gBAAK,GAApV;AAAwV,gBAAK,GAA7V;AAAiW,gBAAK,GAAtW;AAA0W,gBAAK,GAA/W;AAAmX,gBAAK,EAAxX;AAA2X,gBAAK,GAAhY;AAAoY,gBAAK,GAAzY;AAA6Y,gBAAK,EAAlZ;AAAqZ,gBAAK,EAA1Z;AAA6Z,gBAAK,GAAla;AAAsa,gBAAK,GAA3a;AAA+a,gBAAK,EAApb;AAAub,gBAAK,GAA5b;AAAgc,gBAAK,GAArc;AAAyc,gBAAK,GAA9c;AAAkd,gBAAK,GAAvd;AAA2d,gBAAK,GAAhe;AAAoe,gBAAK,GAAze;AAA6e,gBAAK,EAAlf;AAAqf,gBAAK,GAA1f;AAA8f,gBAAK,GAAngB;AAAugB,gBAAK,GAA5gB;AAAghB,gBAAK,GAArhB;AAAyhB,gBAAK,EAA9hB;AAAiiB,wBAAa;AAA9iB,SAAhO;AAAkxB,kBAAS,CAA3xB;AAA6xB,sBAAa,CAA1yB;AAA4yB,sBAAa;AAAzzB;AAA7B;AAAt1N,GAA5D,EAA8uP;AAAC,iBAAY,CAAb;AAAe,cAAS,CAAxB;AAA0B,cAAS,CAAnC;AAAqC,kBAAa;AAAlD,GAA9uP,EAAwyP;AAAC,iBAAY,CAAb;AAAe,cAAS,CAAxB;AAA0B,cAAS,CAAnC;AAAqC,kBAAa,IAAlD;AAAuD,kBAAa,CAApE;AAAsE,oBAAe,CAArF;AAAuF,oBAAe,CAAtG;AAAwG,eAAU,CAAC;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,CAAC,mBAAN;AAA0B,aAAI,kBAA9B;AAAiD,aAAI,CAAC,mBAAtD;AAA0E,aAAI,CAAC,mBAA/E;AAAmG,aAAI,CAAC,mBAAxG;AAA4H,aAAI,CAAC,mBAAjI;AAAqJ,aAAI,kBAAzJ;AAA4K,aAAI,CAAC,kBAAjL;AAAoM,6BAAoB,CAAxN;AAA0N,kBAAS;AAAC,eAAI,GAAL;AAAS,eAAI,EAAb;AAAgB,eAAI,EAApB;AAAuB,eAAI,GAA3B;AAA+B,eAAI,EAAnC;AAAsC,eAAI,GAA1C;AAA8C,eAAI,GAAlD;AAAsD,eAAI,GAA1D;AAA8D,eAAI,EAAlE;AAAqE,eAAI,GAAzE;AAA6E,gBAAK,GAAlF;AAAsF,gBAAK,EAA3F;AAA8F,gBAAK,EAAnG;AAAsG,gBAAK,EAA3G;AAA8G,gBAAK,GAAnH;AAAuH,gBAAK,EAA5H;AAA+H,gBAAK,GAApI;AAAwI,gBAAK,EAA7I;AAAgJ,gBAAK,GAArJ;AAAyJ,gBAAK,EAA9J;AAAiK,gBAAK,GAAtK;AAA0K,gBAAK,GAA/K;AAAmL,gBAAK,GAAxL;AAA4L,gBAAK,GAAjM;AAAqM,gBAAK,EAA1M;AAA6M,gBAAK,GAAlN;AAAsN,gBAAK,GAA3N;AAA+N,gBAAK,GAApO;AAAwO,gBAAK,EAA7O;AAAgP,gBAAK,EAArP;AAAwP,gBAAK,GAA7P;AAAiQ,gBAAK,GAAtQ;AAA0Q,gBAAK,GAA/Q;AAAmR,gBAAK,GAAxR;AAA4R,gBAAK,GAAjS;AAAqS,gBAAK,GAA1S;AAA8S,gBAAK,GAAnT;AAAuT,gBAAK,EAA5T;AAA+T,gBAAK,GAApU;AAAwU,gBAAK,GAA7U;AAAiV,gBAAK,GAAtV;AAA0V,gBAAK,GAA/V;AAAmW,gBAAK,EAAxW;AAA2W,gBAAK,GAAhX;AAAoX,gBAAK,GAAzX;AAA6X,gBAAK,GAAlY;AAAsY,gBAAK,GAA3Y;AAA+Y,gBAAK,GAApZ;AAAwZ,gBAAK,GAA7Z;AAAia,gBAAK,GAAta;AAA0a,gBAAK,EAA/a;AAAkb,gBAAK,EAAvb;AAA0b,gBAAK,GAA/b;AAAmc,gBAAK,GAAxc;AAA4c,gBAAK,GAAjd;AAAqd,gBAAK,EAA1d;AAA6d,gBAAK,GAAle;AAAse,gBAAK,CAA3e;AAA6e,gBAAK,GAAlf;AAAsf,gBAAK,EAA3f;AAA8f,gBAAK,EAAngB;AAAsgB,gBAAK,EAA3gB;AAA8gB,gBAAK,GAAnhB;AAAuhB,gBAAK,GAA5hB;AAAgiB,wBAAa;AAA7iB,SAAnO;AAAoxB,kBAAS,CAA7xB;AAA+xB,sBAAa,CAA5yB;AAA8yB,sBAAa;AAA3zB;AAA7B,KAAD,EAA81B;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,CAAC,mBAAN;AAA0B,aAAI,CAAC,kBAA/B;AAAkD,aAAI,mBAAtD;AAA0E,aAAI,mBAA9E;AAAkG,aAAI,kBAAtG;AAAyH,aAAI,kBAA7H;AAAgJ,aAAI,CAAC,mBAArJ;AAAyK,aAAI,oBAA7K;AAAkM,6BAAoB,CAAtN;AAAwN,kBAAS;AAAC,eAAI,GAAL;AAAS,eAAI,GAAb;AAAiB,eAAI,GAArB;AAAyB,eAAI,EAA7B;AAAgC,eAAI,GAApC;AAAwC,eAAI,EAA5C;AAA+C,eAAI,GAAnD;AAAuD,eAAI,GAA3D;AAA+D,eAAI,GAAnE;AAAuE,eAAI,EAA3E;AAA8E,gBAAK,GAAnF;AAAuF,gBAAK,GAA5F;AAAgG,gBAAK,CAArG;AAAuG,gBAAK,GAA5G;AAAgH,gBAAK,GAArH;AAAyH,gBAAK,GAA9H;AAAkI,gBAAK,EAAvI;AAA0I,gBAAK,GAA/I;AAAmJ,gBAAK,GAAxJ;AAA4J,gBAAK,GAAjK;AAAqK,gBAAK,EAA1K;AAA6K,gBAAK,GAAlL;AAAsL,gBAAK,GAA3L;AAA+L,gBAAK,EAApM;AAAuM,gBAAK,GAA5M;AAAgN,gBAAK,GAArN;AAAyN,gBAAK,EAA9N;AAAiO,gBAAK,GAAtO;AAA0O,gBAAK,EAA/O;AAAkP,gBAAK,EAAvP;AAA0P,gBAAK,GAA/P;AAAmQ,gBAAK,EAAxQ;AAA2Q,gBAAK,GAAhR;AAAoR,gBAAK,GAAzR;AAA6R,gBAAK,GAAlS;AAAsS,gBAAK,EAA3S;AAA8S,gBAAK,GAAnT;AAAuT,gBAAK,GAA5T;AAAgU,gBAAK,GAArU;AAAyU,gBAAK,EAA9U;AAAiV,gBAAK,GAAtV;AAA0V,gBAAK,EAA/V;AAAkW,gBAAK,GAAvW;AAA2W,gBAAK,GAAhX;AAAoX,gBAAK,GAAzX;AAA6X,gBAAK,GAAlY;AAAsY,gBAAK,GAA3Y;AAA+Y,gBAAK,EAApZ;AAAuZ,gBAAK,EAA5Z;AAA+Z,gBAAK,GAApa;AAAwa,gBAAK,EAA7a;AAAgb,gBAAK,EAArb;AAAwb,gBAAK,EAA7b;AAAgc,gBAAK,GAArc;AAAyc,gBAAK,GAA9c;AAAkd,gBAAK,GAAvd;AAA2d,gBAAK,GAAhe;AAAoe,gBAAK,EAAze;AAA4e,gBAAK,GAAjf;AAAqf,gBAAK,GAA1f;AAA8f,gBAAK,GAAngB;AAAugB,gBAAK,GAA5gB;AAAghB,gBAAK,GAArhB;AAAyhB,gBAAK,EAA9hB;AAAiiB,wBAAa;AAA9iB,SAAjO;AAAmxB,kBAAS,CAA5xB;AAA8xB,sBAAa,CAA3yB;AAA6yB,sBAAa;AAA1zB;AAA7B,KAA91B,EAA0rD;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,CAAC,kBAAN;AAAyB,aAAI,kBAA7B;AAAgD,aAAI,oBAApD;AAAyE,aAAI,CAAC,kBAA9E;AAAiG,aAAI,CAAC,mBAAtG;AAA0H,aAAI,CAAC,kBAA/H;AAAkJ,aAAI,CAAC,kBAAvJ;AAA0K,aAAI,CAAC,mBAA/K;AAAmM,6BAAoB,CAAvN;AAAyN,kBAAS;AAAC,eAAI,GAAL;AAAS,eAAI,EAAb;AAAgB,eAAI,CAApB;AAAsB,eAAI,EAA1B;AAA6B,eAAI,EAAjC;AAAoC,eAAI,CAAxC;AAA0C,eAAI,GAA9C;AAAkD,eAAI,GAAtD;AAA0D,eAAI,GAA9D;AAAkE,eAAI,EAAtE;AAAyE,gBAAK,EAA9E;AAAiF,gBAAK,GAAtF;AAA0F,gBAAK,EAA/F;AAAkG,gBAAK,EAAvG;AAA0G,gBAAK,GAA/G;AAAmH,gBAAK,EAAxH;AAA2H,gBAAK,GAAhI;AAAoI,gBAAK,EAAzI;AAA4I,gBAAK,GAAjJ;AAAqJ,gBAAK,GAA1J;AAA8J,gBAAK,GAAnK;AAAuK,gBAAK,EAA5K;AAA+K,gBAAK,GAApL;AAAwL,gBAAK,EAA7L;AAAgM,gBAAK,EAArM;AAAwM,gBAAK,GAA7M;AAAiN,gBAAK,EAAtN;AAAyN,gBAAK,GAA9N;AAAkO,gBAAK,GAAvO;AAA2O,gBAAK,GAAhP;AAAoP,gBAAK,GAAzP;AAA6P,gBAAK,GAAlQ;AAAsQ,gBAAK,GAA3Q;AAA+Q,gBAAK,GAApR;AAAwR,gBAAK,GAA7R;AAAiS,gBAAK,CAAtS;AAAwS,gBAAK,EAA7S;AAAgT,gBAAK,GAArT;AAAyT,gBAAK,GAA9T;AAAkU,gBAAK,GAAvU;AAA2U,gBAAK,GAAhV;AAAoV,gBAAK,GAAzV;AAA6V,gBAAK,GAAlW;AAAsW,gBAAK,CAA3W;AAA6W,gBAAK,EAAlX;AAAqX,gBAAK,GAA1X;AAA8X,gBAAK,GAAnY;AAAuY,gBAAK,GAA5Y;AAAgZ,gBAAK,GAArZ;AAAyZ,gBAAK,GAA9Z;AAAka,gBAAK,EAAva;AAA0a,gBAAK,GAA/a;AAAmb,gBAAK,EAAxb;AAA2b,gBAAK,EAAhc;AAAmc,gBAAK,GAAxc;AAA4c,gBAAK,GAAjd;AAAqd,gBAAK,GAA1d;AAA8d,gBAAK,EAAne;AAAse,gBAAK,GAA3e;AAA+e,gBAAK,EAApf;AAAuf,gBAAK,GAA5f;AAAggB,gBAAK,EAArgB;AAAwgB,gBAAK,GAA7gB;AAAihB,gBAAK,GAAthB;AAA0hB,wBAAa;AAAviB,SAAlO;AAA6wB,kBAAS,CAAtxB;AAAwxB,sBAAa,CAAryB;AAAuyB,sBAAa;AAApzB;AAA7B,KAA1rD,EAAghF;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,kBAAL;AAAwB,aAAI,CAAC,eAA7B;AAA6C,aAAI,mBAAjD;AAAqE,aAAI,CAAC,iBAA1E;AAA4F,aAAI,kBAAhG;AAAmH,aAAI,kBAAvH;AAA0I,aAAI,CAAC,kBAA/I;AAAkK,aAAI,mBAAtK;AAA0L,6BAAoB,CAA9M;AAAgN,kBAAS;AAAC,eAAI,GAAL;AAAS,eAAI,GAAb;AAAiB,eAAI,GAArB;AAAyB,eAAI,GAA7B;AAAiC,eAAI,EAArC;AAAwC,eAAI,GAA5C;AAAgD,eAAI,GAApD;AAAwD,eAAI,EAA5D;AAA+D,eAAI,EAAnE;AAAsE,eAAI,EAA1E;AAA6E,gBAAK,EAAlF;AAAqF,gBAAK,GAA1F;AAA8F,gBAAK,GAAnG;AAAuG,gBAAK,GAA5G;AAAgH,gBAAK,GAArH;AAAyH,gBAAK,GAA9H;AAAkI,gBAAK,GAAvI;AAA2I,gBAAK,EAAhJ;AAAmJ,gBAAK,GAAxJ;AAA4J,gBAAK,GAAjK;AAAqK,gBAAK,EAA1K;AAA6K,gBAAK,EAAlL;AAAqL,gBAAK,GAA1L;AAA8L,gBAAK,EAAnM;AAAsM,gBAAK,EAA3M;AAA8M,gBAAK,GAAnN;AAAuN,gBAAK,EAA5N;AAA+N,gBAAK,GAApO;AAAwO,gBAAK,EAA7O;AAAgP,gBAAK,GAArP;AAAyP,gBAAK,GAA9P;AAAkQ,gBAAK,GAAvQ;AAA2Q,gBAAK,GAAhR;AAAoR,gBAAK,GAAzR;AAA6R,gBAAK,GAAlS;AAAsS,gBAAK,CAA3S;AAA6S,gBAAK,CAAlT;AAAoT,gBAAK,GAAzT;AAA6T,gBAAK,GAAlU;AAAsU,gBAAK,EAA3U;AAA8U,gBAAK,EAAnV;AAAsV,gBAAK,EAA3V;AAA8V,gBAAK,GAAnW;AAAuW,gBAAK,EAA5W;AAA+W,gBAAK,GAApX;AAAwX,gBAAK,GAA7X;AAAiY,gBAAK,GAAtY;AAA0Y,gBAAK,EAA/Y;AAAkZ,gBAAK,GAAvZ;AAA2Z,gBAAK,GAAha;AAAoa,gBAAK,EAAza;AAA4a,gBAAK,GAAjb;AAAqb,gBAAK,GAA1b;AAA8b,gBAAK,EAAnc;AAAsc,gBAAK,GAA3c;AAA+c,gBAAK,GAApd;AAAwd,gBAAK,GAA7d;AAAie,gBAAK,GAAte;AAA0e,gBAAK,GAA/e;AAAmf,gBAAK,GAAxf;AAA4f,gBAAK,EAAjgB;AAAogB,gBAAK,GAAzgB;AAA6gB,gBAAK,GAAlhB;AAAshB,gBAAK,EAA3hB;AAA8hB,wBAAa;AAA3iB,SAAzN;AAAwwB,kBAAS,CAAjxB;AAAmxB,sBAAa,CAAhyB;AAAkyB,sBAAa;AAA/yB;AAA7B,KAAhhF,EAAi2G;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,kBAAL;AAAwB,aAAI,CAAC,kBAA7B;AAAgD,aAAI,mBAApD;AAAwE,aAAI,CAAC,mBAA7E;AAAiG,aAAI,kBAArG;AAAwH,aAAI,kBAA5H;AAA+I,aAAI,CAAC,mBAApJ;AAAwK,aAAI,mBAA5K;AAAgM,6BAAoB,CAApN;AAAsN,kBAAS;AAAC,eAAI,GAAL;AAAS,eAAI,GAAb;AAAiB,eAAI,EAArB;AAAwB,eAAI,EAA5B;AAA+B,eAAI,EAAnC;AAAsC,eAAI,GAA1C;AAA8C,eAAI,GAAlD;AAAsD,eAAI,EAA1D;AAA6D,eAAI,GAAjE;AAAqE,eAAI,EAAzE;AAA4E,gBAAK,GAAjF;AAAqF,gBAAK,CAA1F;AAA4F,gBAAK,EAAjG;AAAoG,gBAAK,EAAzG;AAA4G,gBAAK,GAAjH;AAAqH,gBAAK,GAA1H;AAA8H,gBAAK,EAAnI;AAAsI,gBAAK,GAA3I;AAA+I,gBAAK,EAApJ;AAAuJ,gBAAK,EAA5J;AAA+J,gBAAK,EAApK;AAAuK,gBAAK,GAA5K;AAAgL,gBAAK,GAArL;AAAyL,gBAAK,EAA9L;AAAiM,gBAAK,GAAtM;AAA0M,gBAAK,GAA/M;AAAmN,gBAAK,GAAxN;AAA4N,gBAAK,GAAjO;AAAqO,gBAAK,EAA1O;AAA6O,gBAAK,EAAlP;AAAqP,gBAAK,GAA1P;AAA8P,gBAAK,GAAnQ;AAAuQ,gBAAK,CAA5Q;AAA8Q,gBAAK,GAAnR;AAAuR,gBAAK,GAA5R;AAAgS,gBAAK,EAArS;AAAwS,gBAAK,GAA7S;AAAiT,gBAAK,GAAtT;AAA0T,gBAAK,GAA/T;AAAmU,gBAAK,EAAxU;AAA2U,gBAAK,GAAhV;AAAoV,gBAAK,GAAzV;AAA6V,gBAAK,GAAlW;AAAsW,gBAAK,EAA3W;AAA8W,gBAAK,EAAnX;AAAsX,gBAAK,GAA3X;AAA+X,gBAAK,GAApY;AAAwY,gBAAK,EAA7Y;AAAgZ,gBAAK,EAArZ;AAAwZ,gBAAK,GAA7Z;AAAia,gBAAK,GAAta;AAA0a,gBAAK,GAA/a;AAAmb,gBAAK,EAAxb;AAA2b,gBAAK,EAAhc;AAAmc,gBAAK,GAAxc;AAA4c,gBAAK,GAAjd;AAAqd,gBAAK,EAA1d;AAA6d,gBAAK,EAAle;AAAqe,gBAAK,GAA1e;AAA8e,gBAAK,EAAnf;AAAsf,gBAAK,GAA3f;AAA+f,gBAAK,GAApgB;AAAwgB,gBAAK,GAA7gB;AAAihB,gBAAK,EAAthB;AAAyhB,wBAAa;AAAtiB,SAA/N;AAAywB,kBAAS,CAAlxB;AAAoxB,sBAAa,CAAjyB;AAAmyB,sBAAa;AAAhzB;AAA7B,KAAj2G,EAAmrI;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,CAAC,kBAAN;AAAyB,aAAI,kBAA7B;AAAgD,aAAI,mBAApD;AAAwE,aAAI,kBAA5E;AAA+F,aAAI,CAAC,kBAApG;AAAuH,aAAI,CAAC,kBAA5H;AAA+I,aAAI,mBAAnJ;AAAuK,aAAI,CAAC,kBAA5K;AAA+L,6BAAoB,CAAnN;AAAqN,kBAAS;AAAC,eAAI,EAAL;AAAQ,eAAI,GAAZ;AAAgB,eAAI,GAApB;AAAwB,eAAI,GAA5B;AAAgC,eAAI,GAApC;AAAwC,eAAI,GAA5C;AAAgD,eAAI,GAApD;AAAwD,eAAI,GAA5D;AAAgE,eAAI,GAApE;AAAwE,eAAI,GAA5E;AAAgF,gBAAK,GAArF;AAAyF,gBAAK,GAA9F;AAAkG,gBAAK,GAAvG;AAA2G,gBAAK,EAAhH;AAAmH,gBAAK,GAAxH;AAA4H,gBAAK,EAAjI;AAAoI,gBAAK,GAAzI;AAA6I,gBAAK,GAAlJ;AAAsJ,gBAAK,EAA3J;AAA8J,gBAAK,GAAnK;AAAuK,gBAAK,EAA5K;AAA+K,gBAAK,GAApL;AAAwL,gBAAK,GAA7L;AAAiM,gBAAK,EAAtM;AAAyM,gBAAK,CAA9M;AAAgN,gBAAK,GAArN;AAAyN,gBAAK,CAA9N;AAAgO,gBAAK,GAArO;AAAyO,gBAAK,GAA9O;AAAkP,gBAAK,EAAvP;AAA0P,gBAAK,GAA/P;AAAmQ,gBAAK,EAAxQ;AAA2Q,gBAAK,GAAhR;AAAoR,gBAAK,CAAzR;AAA2R,gBAAK,GAAhS;AAAoS,gBAAK,GAAzS;AAA6S,gBAAK,EAAlT;AAAqT,gBAAK,GAA1T;AAA8T,gBAAK,GAAnU;AAAuU,gBAAK,GAA5U;AAAgV,gBAAK,GAArV;AAAyV,gBAAK,GAA9V;AAAkW,gBAAK,EAAvW;AAA0W,gBAAK,GAA/W;AAAmX,gBAAK,GAAxX;AAA4X,gBAAK,GAAjY;AAAqY,gBAAK,GAA1Y;AAA8Y,gBAAK,GAAnZ;AAAuZ,gBAAK,GAA5Z;AAAga,gBAAK,EAAra;AAAwa,gBAAK,EAA7a;AAAgb,gBAAK,GAArb;AAAyb,gBAAK,GAA9b;AAAkc,gBAAK,EAAvc;AAA0c,gBAAK,GAA/c;AAAmd,gBAAK,EAAxd;AAA2d,gBAAK,EAAhe;AAAme,gBAAK,GAAxe;AAA4e,gBAAK,GAAjf;AAAqf,gBAAK,EAA1f;AAA6f,gBAAK,EAAlgB;AAAqgB,gBAAK,GAA1gB;AAA8gB,gBAAK,GAAnhB;AAAuhB,gBAAK,GAA5hB;AAAgiB,wBAAa;AAA7iB,SAA9N;AAA+wB,kBAAS,CAAxxB;AAA0xB,sBAAa,CAAvyB;AAAyyB,sBAAa;AAAtzB;AAA7B,KAAnrI,EAA2gK;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,CAAC,oBAAN;AAA2B,aAAI,kBAA/B;AAAkD,aAAI,mBAAtD;AAA0E,aAAI,mBAA9E;AAAkG,aAAI,CAAC,mBAAvG;AAA2H,aAAI,mBAA/H;AAAmJ,aAAI,kBAAvJ;AAA0K,aAAI,CAAC,kBAA/K;AAAkM,6BAAoB,CAAtN;AAAwN,kBAAS;AAAC,eAAI,GAAL;AAAS,eAAI,GAAb;AAAiB,eAAI,EAArB;AAAwB,eAAI,GAA5B;AAAgC,eAAI,EAApC;AAAuC,eAAI,GAA3C;AAA+C,eAAI,GAAnD;AAAuD,eAAI,GAA3D;AAA+D,eAAI,EAAnE;AAAsE,eAAI,GAA1E;AAA8E,gBAAK,GAAnF;AAAuF,gBAAK,EAA5F;AAA+F,gBAAK,EAApG;AAAuG,gBAAK,CAA5G;AAA8G,gBAAK,GAAnH;AAAuH,gBAAK,EAA5H;AAA+H,gBAAK,GAApI;AAAwI,gBAAK,GAA7I;AAAiJ,gBAAK,EAAtJ;AAAyJ,gBAAK,GAA9J;AAAkK,gBAAK,GAAvK;AAA2K,gBAAK,GAAhL;AAAoL,gBAAK,GAAzL;AAA6L,gBAAK,EAAlM;AAAqM,gBAAK,GAA1M;AAA8M,gBAAK,GAAnN;AAAuN,gBAAK,GAA5N;AAAgO,gBAAK,GAArO;AAAyO,gBAAK,GAA9O;AAAkP,gBAAK,GAAvP;AAA2P,gBAAK,GAAhQ;AAAoQ,gBAAK,EAAzQ;AAA4Q,gBAAK,GAAjR;AAAqR,gBAAK,EAA1R;AAA6R,gBAAK,EAAlS;AAAqS,gBAAK,GAA1S;AAA8S,gBAAK,GAAnT;AAAuT,gBAAK,EAA5T;AAA+T,gBAAK,GAApU;AAAwU,gBAAK,GAA7U;AAAiV,gBAAK,EAAtV;AAAyV,gBAAK,GAA9V;AAAkW,gBAAK,GAAvW;AAA2W,gBAAK,GAAhX;AAAoX,gBAAK,EAAzX;AAA4X,gBAAK,EAAjY;AAAoY,gBAAK,GAAzY;AAA6Y,gBAAK,EAAlZ;AAAqZ,gBAAK,GAA1Z;AAA8Z,gBAAK,GAAna;AAAua,gBAAK,GAA5a;AAAgb,gBAAK,GAArb;AAAyb,gBAAK,EAA9b;AAAic,gBAAK,EAAtc;AAAyc,gBAAK,GAA9c;AAAkd,gBAAK,EAAvd;AAA0d,gBAAK,CAA/d;AAAie,gBAAK,GAAte;AAA0e,gBAAK,EAA/e;AAAkf,gBAAK,EAAvf;AAA0f,gBAAK,GAA/f;AAAmgB,gBAAK,GAAxgB;AAA4gB,gBAAK,GAAjhB;AAAqhB,gBAAK,GAA1hB;AAA8hB,wBAAa;AAA3iB,SAAjO;AAAgxB,kBAAS,CAAzxB;AAA2xB,sBAAa,CAAxyB;AAA0yB,sBAAa;AAAvzB;AAA7B,KAA3gK,EAAo2L;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,kBAAL;AAAwB,aAAI,CAAC,kBAA7B;AAAgD,aAAI,mBAApD;AAAwE,aAAI,CAAC,kBAA7E;AAAgG,aAAI,kBAApG;AAAuH,aAAI,mBAA3H;AAA+I,aAAI,CAAC,kBAApJ;AAAuK,aAAI,mBAA3K;AAA+L,6BAAoB,CAAnN;AAAqN,kBAAS;AAAC,eAAI,GAAL;AAAS,eAAI,GAAb;AAAiB,eAAI,GAArB;AAAyB,eAAI,EAA7B;AAAgC,eAAI,EAApC;AAAuC,eAAI,GAA3C;AAA+C,eAAI,GAAnD;AAAuD,eAAI,EAA3D;AAA8D,eAAI,GAAlE;AAAsE,eAAI,EAA1E;AAA6E,gBAAK,GAAlF;AAAsF,gBAAK,EAA3F;AAA8F,gBAAK,GAAnG;AAAuG,gBAAK,GAA5G;AAAgH,gBAAK,GAArH;AAAyH,gBAAK,GAA9H;AAAkI,gBAAK,EAAvI;AAA0I,gBAAK,EAA/I;AAAkJ,gBAAK,GAAvJ;AAA2J,gBAAK,GAAhK;AAAoK,gBAAK,GAAzK;AAA6K,gBAAK,GAAlL;AAAsL,gBAAK,GAA3L;AAA+L,gBAAK,EAApM;AAAuM,gBAAK,GAA5M;AAAgN,gBAAK,EAArN;AAAwN,gBAAK,GAA7N;AAAiO,gBAAK,EAAtO;AAAyO,gBAAK,GAA9O;AAAkP,gBAAK,EAAvP;AAA0P,gBAAK,GAA/P;AAAmQ,gBAAK,GAAxQ;AAA4Q,gBAAK,GAAjR;AAAqR,gBAAK,GAA1R;AAA8R,gBAAK,GAAnS;AAAuS,gBAAK,GAA5S;AAAgT,gBAAK,GAArT;AAAyT,gBAAK,GAA9T;AAAkU,gBAAK,GAAvU;AAA2U,gBAAK,EAAhV;AAAmV,gBAAK,GAAxV;AAA4V,gBAAK,GAAjW;AAAqW,gBAAK,GAA1W;AAA8W,gBAAK,EAAnX;AAAsX,gBAAK,EAA3X;AAA8X,gBAAK,GAAnY;AAAuY,gBAAK,GAA5Y;AAAgZ,gBAAK,EAArZ;AAAwZ,gBAAK,EAA7Z;AAAga,gBAAK,GAAra;AAAya,gBAAK,EAA9a;AAAib,gBAAK,GAAtb;AAA0b,gBAAK,EAA/b;AAAkc,gBAAK,GAAvc;AAA2c,gBAAK,GAAhd;AAAod,gBAAK,GAAzd;AAA6d,gBAAK,EAAle;AAAqe,gBAAK,GAA1e;AAA8e,gBAAK,GAAnf;AAAuf,gBAAK,EAA5f;AAA+f,gBAAK,EAApgB;AAAugB,gBAAK,EAA5gB;AAA+gB,gBAAK,GAAphB;AAAwhB,gBAAK,EAA7hB;AAAgiB,wBAAa;AAA7iB,SAA9N;AAA+wB,kBAAS,CAAxxB;AAA0xB,sBAAa,CAAvyB;AAAyyB,sBAAa;AAAtzB;AAA7B,KAAp2L,CAAlH;AAA+yN,cAAS;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,oBAAL;AAA0B,aAAI,CAAC,oBAA/B;AAAoD,aAAI,CAAC,mBAAzD;AAA6E,aAAI,CAAC,mBAAlF;AAAsG,aAAI,CAAC,mBAA3G;AAA+H,aAAI,mBAAnI;AAAuJ,aAAI,CAAC,mBAA5J;AAAgL,aAAI,mBAApL;AAAwM,6BAAoB,CAA5N;AAA8N,kBAAS;AAAC,eAAI,EAAL;AAAQ,eAAI,EAAZ;AAAe,eAAI,GAAnB;AAAuB,eAAI,EAA3B;AAA8B,eAAI,CAAlC;AAAoC,eAAI,CAAxC;AAA0C,eAAI,GAA9C;AAAkD,eAAI,EAAtD;AAAyD,eAAI,GAA7D;AAAiE,eAAI,GAArE;AAAyE,gBAAK,EAA9E;AAAiF,gBAAK,EAAtF;AAAyF,gBAAK,EAA9F;AAAiG,gBAAK,EAAtG;AAAyG,gBAAK,GAA9G;AAAkH,gBAAK,GAAvH;AAA2H,gBAAK,GAAhI;AAAoI,gBAAK,GAAzI;AAA6I,gBAAK,EAAlJ;AAAqJ,gBAAK,GAA1J;AAA8J,gBAAK,EAAnK;AAAsK,gBAAK,EAA3K;AAA8K,gBAAK,GAAnL;AAAuL,gBAAK,GAA5L;AAAgM,gBAAK,EAArM;AAAwM,gBAAK,GAA7M;AAAiN,gBAAK,EAAtN;AAAyN,gBAAK,GAA9N;AAAkO,gBAAK,GAAvO;AAA2O,gBAAK,GAAhP;AAAoP,gBAAK,GAAzP;AAA6P,gBAAK,GAAlQ;AAAsQ,gBAAK,EAA3Q;AAA8Q,gBAAK,GAAnR;AAAuR,gBAAK,GAA5R;AAAgS,gBAAK,EAArS;AAAwS,gBAAK,EAA7S;AAAgT,gBAAK,GAArT;AAAyT,gBAAK,GAA9T;AAAkU,gBAAK,GAAvU;AAA2U,gBAAK,GAAhV;AAAoV,gBAAK,CAAzV;AAA2V,gBAAK,GAAhW;AAAoW,gBAAK,EAAzW;AAA4W,gBAAK,GAAjX;AAAqX,gBAAK,GAA1X;AAA8X,gBAAK,GAAnY;AAAuY,gBAAK,EAA5Y;AAA+Y,gBAAK,EAApZ;AAAuZ,gBAAK,EAA5Z;AAA+Z,gBAAK,GAApa;AAAwa,gBAAK,GAA7a;AAAib,gBAAK,GAAtb;AAA0b,gBAAK,EAA/b;AAAkc,gBAAK,GAAvc;AAA2c,gBAAK,GAAhd;AAAod,gBAAK,EAAzd;AAA4d,gBAAK,EAAje;AAAoe,gBAAK,GAAze;AAA6e,gBAAK,GAAlf;AAAsf,gBAAK,GAA3f;AAA+f,gBAAK,GAApgB;AAAwgB,gBAAK,GAA7gB;AAAihB,gBAAK,EAAthB;AAAyhB,wBAAa;AAAtiB,SAAvO;AAAixB,kBAAS,CAA1xB;AAA4xB,sBAAa,CAAzyB;AAA2yB,sBAAa;AAAxzB;AAA7B;AAAxzN,GAAxyP,EAA27e;AAAC,iBAAY,CAAb;AAAe,cAAS,CAAxB;AAA0B,cAAS,CAAnC;AAAqC,kBAAa;AAAlD,GAA37e,EAAq/e;AAAC,iBAAY,CAAb;AAAe,cAAS,CAAxB;AAA0B,cAAS,CAAnC;AAAqC,kBAAa,IAAlD;AAAuD,kBAAa,CAApE;AAAsE,oBAAe,CAArF;AAAuF,oBAAe,CAAtG;AAAwG,eAAU,CAAC;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,kBAAL;AAAwB,aAAI,CAAC,mBAA7B;AAAiD,aAAI,kBAArD;AAAwE,aAAI,CAAC,kBAA7E;AAAgG,aAAI,CAAC,kBAArG;AAAwH,aAAI,kBAA5H;AAA+I,aAAI,kBAAnJ;AAAsK,aAAI,CAAC,kBAA3K;AAA8L,6BAAoB,CAAlN;AAAoN,kBAAS;AAAC,eAAI,GAAL;AAAS,eAAI,GAAb;AAAiB,eAAI,EAArB;AAAwB,eAAI,EAA5B;AAA+B,eAAI,GAAnC;AAAuC,eAAI,EAA3C;AAA8C,eAAI,GAAlD;AAAsD,eAAI,EAA1D;AAA6D,eAAI,EAAjE;AAAoE,eAAI,GAAxE;AAA4E,gBAAK,GAAjF;AAAqF,gBAAK,GAA1F;AAA8F,gBAAK,EAAnG;AAAsG,gBAAK,GAA3G;AAA+G,gBAAK,GAApH;AAAwH,gBAAK,GAA7H;AAAiI,gBAAK,EAAtI;AAAyI,gBAAK,GAA9I;AAAkJ,gBAAK,GAAvJ;AAA2J,gBAAK,EAAhK;AAAmK,gBAAK,GAAxK;AAA4K,gBAAK,EAAjL;AAAoL,gBAAK,GAAzL;AAA6L,gBAAK,EAAlM;AAAqM,gBAAK,GAA1M;AAA8M,gBAAK,GAAnN;AAAuN,gBAAK,GAA5N;AAAgO,gBAAK,EAArO;AAAwO,gBAAK,GAA7O;AAAiP,gBAAK,CAAtP;AAAwP,gBAAK,GAA7P;AAAiQ,gBAAK,GAAtQ;AAA0Q,gBAAK,GAA/Q;AAAmR,gBAAK,GAAxR;AAA4R,gBAAK,EAAjS;AAAoS,gBAAK,EAAzS;AAA4S,gBAAK,EAAjT;AAAoT,gBAAK,GAAzT;AAA6T,gBAAK,GAAlU;AAAsU,gBAAK,GAA3U;AAA+U,gBAAK,EAApV;AAAuV,gBAAK,GAA5V;AAAgW,gBAAK,GAArW;AAAyW,gBAAK,GAA9W;AAAkX,gBAAK,GAAvX;AAA2X,gBAAK,EAAhY;AAAmY,gBAAK,GAAxY;AAA4Y,gBAAK,EAAjZ;AAAoZ,gBAAK,EAAzZ;AAA4Z,gBAAK,EAAja;AAAoa,gBAAK,EAAza;AAA4a,gBAAK,GAAjb;AAAqb,gBAAK,EAA1b;AAA6b,gBAAK,GAAlc;AAAsc,gBAAK,GAA3c;AAA+c,gBAAK,EAApd;AAAud,gBAAK,GAA5d;AAAge,gBAAK,GAAre;AAAye,gBAAK,GAA9e;AAAkf,gBAAK,GAAvf;AAA2f,gBAAK,GAAhgB;AAAogB,gBAAK,GAAzgB;AAA6gB,gBAAK,GAAlhB;AAAshB,gBAAK,GAA3hB;AAA+hB,wBAAa;AAA5iB,SAA7N;AAA6wB,kBAAS,CAAtxB;AAAwxB,sBAAa,CAAryB;AAAuyB,sBAAa;AAApzB;AAA7B,KAAD,EAAu1B;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,CAAC,iBAAN;AAAwB,aAAI,kBAA5B;AAA+C,aAAI,oBAAnD;AAAwE,aAAI,iBAA5E;AAA8F,aAAI,iBAAlG;AAAoH,aAAI,CAAC,kBAAzH;AAA4I,aAAI,CAAC,kBAAjJ;AAAoK,aAAI,kBAAxK;AAA2L,6BAAoB,CAA/M;AAAiN,kBAAS;AAAC,eAAI,EAAL;AAAQ,eAAI,GAAZ;AAAgB,eAAI,GAApB;AAAwB,eAAI,GAA5B;AAAgC,eAAI,EAApC;AAAuC,eAAI,CAA3C;AAA6C,eAAI,GAAjD;AAAqD,eAAI,GAAzD;AAA6D,eAAI,GAAjE;AAAqE,eAAI,GAAzE;AAA6E,gBAAK,GAAlF;AAAsF,gBAAK,EAA3F;AAA8F,gBAAK,EAAnG;AAAsG,gBAAK,EAA3G;AAA8G,gBAAK,GAAnH;AAAuH,gBAAK,EAA5H;AAA+H,gBAAK,GAApI;AAAwI,gBAAK,EAA7I;AAAgJ,gBAAK,GAArJ;AAAyJ,gBAAK,GAA9J;AAAkK,gBAAK,GAAvK;AAA2K,gBAAK,EAAhL;AAAmL,gBAAK,GAAxL;AAA4L,gBAAK,EAAjM;AAAoM,gBAAK,GAAzM;AAA6M,gBAAK,GAAlN;AAAsN,gBAAK,EAA3N;AAA8N,gBAAK,GAAnO;AAAuO,gBAAK,EAA5O;AAA+O,gBAAK,CAApP;AAAsP,gBAAK,GAA3P;AAA+P,gBAAK,EAApQ;AAAuQ,gBAAK,GAA5Q;AAAgR,gBAAK,EAArR;AAAwR,gBAAK,GAA7R;AAAiS,gBAAK,EAAtS;AAAyS,gBAAK,EAA9S;AAAiT,gBAAK,GAAtT;AAA0T,gBAAK,GAA/T;AAAmU,gBAAK,EAAxU;AAA2U,gBAAK,EAAhV;AAAmV,gBAAK,EAAxV;AAA2V,gBAAK,EAAhW;AAAmW,gBAAK,GAAxW;AAA4W,gBAAK,GAAjX;AAAqX,gBAAK,GAA1X;AAA8X,gBAAK,GAAnY;AAAuY,gBAAK,GAA5Y;AAAgZ,gBAAK,GAArZ;AAAyZ,gBAAK,GAA9Z;AAAka,gBAAK,GAAva;AAA2a,gBAAK,GAAhb;AAAob,gBAAK,GAAzb;AAA6b,gBAAK,GAAlc;AAAsc,gBAAK,GAA3c;AAA+c,gBAAK,GAApd;AAAwd,gBAAK,GAA7d;AAAie,gBAAK,GAAte;AAA0e,gBAAK,GAA/e;AAAmf,gBAAK,GAAxf;AAA4f,gBAAK,EAAjgB;AAAogB,gBAAK,GAAzgB;AAA6gB,gBAAK,GAAlhB;AAAshB,gBAAK,EAA3hB;AAA8hB,wBAAa;AAA3iB,SAA1N;AAAywB,kBAAS,CAAlxB;AAAoxB,sBAAa,CAAjyB;AAAmyB,sBAAa;AAAhzB;AAA7B,KAAv1B,CAAlH;AAA4xD,cAAS;AAAC,YAAK,CAAN;AAAQ,YAAK,CAAb;AAAe,eAAQ,CAAvB;AAAyB,WAAI;AAAC,aAAI,CAAC,oBAAN;AAA2B,aAAI,mBAA/B;AAAmD,6BAAoB,CAAvE;AAAyE,kBAAS;AAAC,eAAI,EAAL;AAAQ,eAAI,GAAZ;AAAgB,eAAI,GAApB;AAAwB,eAAI,GAA5B;AAAgC,eAAI,EAApC;AAAuC,eAAI,GAA3C;AAA+C,eAAI,GAAnD;AAAuD,eAAI,GAA3D;AAA+D,eAAI,GAAnE;AAAuE,eAAI,GAA3E;AAA+E,gBAAK,GAApF;AAAwF,gBAAK,GAA7F;AAAiG,gBAAK,EAAtG;AAAyG,gBAAK,GAA9G;AAAkH,gBAAK,GAAvH;AAA2H,gBAAK,EAAhI;AAAmI,wBAAa;AAAhJ,SAAlF;AAAsO,kBAAS,CAA/O;AAAiP,sBAAa,CAA9P;AAAgQ,sBAAa;AAA7Q;AAA7B;AAAryD,GAAr/e,EAA0kjB;AAAC,iBAAY,CAAb;AAAe,cAAS,CAAxB;AAA0B,cAAS,CAAnC;AAAqC,kBAAa,SAAlD;AAA4D,kBAAa;AAAzE,GAA1kjB;AAAV,CAAjD,C;;;;;;;;;;;ACAA7b,MAAM,CAAC4S,MAAP,CAAc;AAACoS,aAAW,EAAC,MAAIA;AAAjB,CAAd;AAA6C,IAAIxQ,MAAJ;AAAWxU,MAAM,CAAC2W,IAAP,CAAY,WAAZ,EAAwB;AAACnC,QAAM,CAACtqB,CAAD,EAAG;AAACsqB,UAAM,GAACtqB,CAAP;AAAS;;AAApB,CAAxB,EAA8C,CAA9C;AAExD,MAAM+6B,aAAa,GACf;AAAC,KAAG,QAAJ;AAAc,KAAG,QAAjB;AAA2B,KAAG,QAA9B;AAAwC,KAAG,QAA3C;AAAqD,KAAG;AAAxD,CADJ;;AAGA,MAAMC,QAAQ,GAAIC,MAAD,IAAY;AAC3B,QAAM7R,MAAM,GAAG,EAAf;AACA6R,QAAM,CAAC3W,KAAP,CAAa,GAAb,EAAkBjC,GAAlB,CAAuB1e,CAAD,IAAOylB,MAAM,CAACzlB,CAAD,CAAN,GAAY,IAAzC;AACA,SAAOylB,MAAP;AACD,CAJD;;AAMA,MAAM8R,UAAU,GAAGF,QAAQ,CAAC,kDAAD,CAA3B;AACA,MAAMG,MAAM,GAAGH,QAAQ,CAAC,wDACA,qDADA,GAEA,gBAFD,CAAvB;AAGA,MAAMI,aAAa,GAAGJ,QAAQ,CAAC,8CACA,mBADD,CAA9B;AAGA,MAAMF,WAAW,GAAG,EAApB;;AAEAA,WAAW,CAACO,SAAZ,GAAwB,CAAC5J,MAAD,EAAS6J,aAAT,KAA2B;AACjD,OAAK,IAAIn6B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGswB,MAAM,CAAClwB,MAA3B,EAAmCJ,CAAC,EAApC,EAAwC;AACtC,SAAK,IAAIo6B,MAAM,GAAG,CAAlB,EAAqBA,MAAM,IAAI,CAA/B,EAAkCA,MAAM,EAAxC,EAA4C;AAC1C,YAAMjmB,KAAK,GAAGylB,aAAa,CAACQ,MAAD,CAAb,CAAsB5T,OAAtB,CAA8B8J,MAAM,CAACtwB,CAAD,CAApC,CAAd;;AACA,UAAImU,KAAK,IAAI,CAAb,EAAgB;AACd,cAAMkmB,QAAQ,GAAG,SAASlmB,KAAT,CAAjB;AACAmc,cAAM,GAAGA,MAAM,CAACxD,MAAP,CAAc,CAAd,EAAiB9sB,CAAjB,IAAsBq6B,QAAtB,GAAiC/J,MAAM,CAACxD,MAAP,CAAc9sB,CAAC,GAAG,CAAlB,CAA1C;;AACA,YAAIm6B,aAAJ,EAAmB;AACjB,2BAAU7J,MAAV,SAAmB8J,MAAnB;AACD;AACF;AACF;AACF;;AACD,SAAO9J,MAAP;AACD,CAdD;;AAgBAqJ,WAAW,CAACW,0BAAZ,GAA0CC,QAAD,IAAc;AACrDpR,QAAM,CAACoR,QAAQ,IAAIA,QAAQ,KAAKA,QAAQ,CAACC,WAAT,EAA1B,CAAN;AACA,MAAIC,IAAI,GAAG,CAAX;;AACA,MAAI,QAAQjU,OAAR,CAAgB+T,QAAQ,CAACA,QAAQ,CAACn6B,MAAT,GAAkB,CAAnB,CAAxB,KAAkD,CAAtD,EAAyD;AACvDq6B,QAAI,GAAG5N,QAAQ,CAAC0N,QAAQ,CAACA,QAAQ,CAACn6B,MAAT,GAAkB,CAAnB,CAAT,EAAgC,EAAhC,CAAf;AACAm6B,YAAQ,GAAGA,QAAQ,CAACzN,MAAT,CAAgB,CAAhB,EAAmByN,QAAQ,CAACn6B,MAAT,GAAkB,CAArC,CAAX;AACD;;AACD,OAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGu6B,QAAQ,CAACn6B,MAA7B,EAAqCJ,CAAC,EAAtC,EAA0C;AACxC,SAAK,IAAIo6B,MAAM,GAAG,CAAlB,EAAqBA,MAAM,IAAI,CAA/B,EAAkCA,MAAM,EAAxC,EAA4C;AAC1C,YAAMjmB,KAAK,GAAGylB,aAAa,CAACQ,MAAD,CAAb,CAAsB5T,OAAtB,CAA8B+T,QAAQ,CAACv6B,CAAD,CAAtC,CAAd;;AACA,UAAImU,KAAK,IAAI,CAAb,EAAgB;AACdsmB,YAAI,GAAGL,MAAP;AACA,cAAMC,QAAQ,GAAG,SAASlmB,KAAT,CAAjB;AACAomB,gBAAQ,GAAGA,QAAQ,CAACzN,MAAT,CAAgB,CAAhB,EAAmB9sB,CAAnB,IAAwBq6B,QAAxB,GAAmCE,QAAQ,CAACzN,MAAT,CAAgB9sB,CAAC,GAAG,CAApB,CAA9C;AACD;AACF;AACF;;AACD,MAAI06B,SAAS,GAAG,EAAhB;;AACA,OAAK,IAAI16B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGu6B,QAAQ,CAACn6B,MAA7B,EAAqCJ,CAAC,EAAtC,EAA0C;AACxC,UAAMg5B,SAAS,GAAGuB,QAAQ,CAACzN,MAAT,CAAgB,CAAhB,EAAmB9sB,CAAnB,CAAlB;;AACA,QAAI+5B,UAAU,CAACf,SAAD,CAAd,EAA2B;AACzB0B,eAAS,GAAG1B,SAAZ;AACD,KAFD,MAEO;AACL;AACD;AACF;;AACD,MAAI2B,KAAK,GAAGJ,QAAQ,CAACzN,MAAT,CAAgB4N,SAAS,CAACt6B,MAA1B,CAAZ;AACA+oB,QAAM,CAAC,CAAC,CAACuR,SAAD,IAAcX,UAAU,CAACW,SAAD,CAAzB,KAAyCV,MAAM,CAACW,KAAD,CAAhD,CAAN;;AACA,MAAIV,aAAa,CAACU,KAAD,CAAjB,EAA0B;AACxB,UAAMxmB,KAAK,GAAG,SAASqS,OAAT,CAAiBmU,KAAK,CAAC,CAAD,CAAtB,CAAd;AACAA,SAAK,GAAGA,KAAK,CAAC,CAAD,CAAL,GAAWf,aAAa,CAACa,IAAD,CAAb,CAAoBtmB,KAApB,CAAX,GAAwCwmB,KAAK,CAAC7N,MAAN,CAAa,CAAb,CAAhD;AACD,GAHD,MAGO;AACL,UAAM3Y,KAAK,GAAG,SAASqS,OAAT,CAAiBmU,KAAK,CAAC,CAAD,CAAtB,CAAd;AACAxR,UAAM,CAAChV,KAAK,IAAI,CAAV,CAAN;AACAwmB,SAAK,GAAGf,aAAa,CAACa,IAAD,CAAb,CAAoBtmB,KAApB,IAA6BwmB,KAAK,CAAC7N,MAAN,CAAa,CAAb,CAArC;AACD;;AACD,SAAO4N,SAAS,GAAGC,KAAK,CAAC/Y,OAAN,CAAc,GAAd,EAAmB,GAAnB,CAAnB;AACD,CArCD;;AAuCA+X,WAAW,CAACiB,0BAAZ,GAA0CH,IAAD,IAAU;AACjD,SAAOd,WAAW,CAACO,SAAZ,CAAsBO,IAAtB,EAA4B;AAAK;AAAjC,GAAP;AACD,CAFD,C;;;;;;;;;;;AC3EA9lB,MAAM,CAAC4S,MAAP,CAAc;AAACkJ,kBAAgB,EAAC,MAAIA;AAAtB,CAAd;AAAuD,IAAItH,MAAJ,EAAWG,KAAX,EAAiBC,KAAjB;AAAuB5U,MAAM,CAAC2W,IAAP,CAAY,WAAZ,EAAwB;AAACnC,QAAM,CAACtqB,CAAD,EAAG;AAACsqB,UAAM,GAACtqB,CAAP;AAAS,GAApB;;AAAqByqB,OAAK,CAACzqB,CAAD,EAAG;AAACyqB,SAAK,GAACzqB,CAAN;AAAQ,GAAtC;;AAAuC0qB,OAAK,CAAC1qB,CAAD,EAAG;AAAC0qB,SAAK,GAAC1qB,CAAN;AAAQ;;AAAxD,CAAxB,EAAkF,CAAlF;AAAqF,IAAI02B,SAAJ;AAAc5gB,MAAM,CAAC2W,IAAP,CAAY,gBAAZ,EAA6B;AAACiK,WAAS,CAAC12B,CAAD,EAAG;AAAC02B,aAAS,GAAC12B,CAAV;AAAY;;AAA1B,CAA7B,EAAyD,CAAzD;AAA4D,IAAIs5B,GAAJ;AAAQxjB,MAAM,CAAC2W,IAAP,CAAY,UAAZ,EAAuB;AAAC6M,KAAG,CAACt5B,CAAD,EAAG;AAACs5B,OAAG,GAACt5B,CAAJ;AAAM;;AAAd,CAAvB,EAAuC,CAAvC;AAIrP,MAAMg8B,mBAAmB,GAAG,EAA5B;AACA,MAAMC,gBAAgB,GAAG,MAAIn8B,IAAI,CAACmsB,EAAlC;AACA,MAAMiQ,2BAA2B,GAAG,CAApC;AACA,MAAMC,gBAAgB,GAAG,GAAzB,C,CAEA;;AACA,MAAMC,WAAW,GAAI5Z,MAAD,IAAY;AAC9B8H,QAAM,CAACI,KAAK,CAAC6B,KAAN,CAAY/J,MAAM,CAAC,CAAD,CAAlB,KAA0BkI,KAAK,CAAC6B,KAAN,CAAY/J,MAAM,CAAC,CAAD,CAAlB,CAA3B,CAAN;AACA8H,QAAM,CAAC,CAACI,KAAK,CAAC0B,KAAN,CAAY5J,MAAM,CAAC,CAAD,CAAlB,EAAuBA,MAAM,CAAC,CAAD,CAA7B,CAAF,CAAN;AACD,CAHD,C,CAKA;AACA;AACA;;;AACA,MAAMuB,UAAU,GAAG,CAACsY,SAAD,EAAYC,UAAZ,KAA2B;AAC5C,QAAMlT,MAAM,GAAG,EAAf;AACA,QAAMmT,OAAO,GAAGF,SAAS,CAACna,MAAV,CAAkBve,CAAD,IAAOA,CAAC,CAAC64B,MAA1B,CAAhB;AACA,QAAMC,QAAQ,GAAGC,YAAY,CAACH,OAAD,EAAUD,UAAV,CAA7B;;AACA,OAAK,IAAIn7B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGo7B,OAAO,CAACh7B,MAA5B,EAAoCJ,CAAC,EAArC,EAAyC;AACvC,UAAMe,CAAC,GAAGu6B,QAAQ,CAACt7B,CAAD,CAAlB;;AACA,QAAIe,CAAC,IAAIf,CAAL,IAAUs7B,QAAQ,CAACv6B,CAAD,CAAR,KAAgBf,CAA9B,EAAiC;AAC/B;AACD;;AACDioB,UAAM,CAAC3nB,IAAP,CAAY,CAACipB,KAAK,CAACrmB,KAAN,CAAYk4B,OAAO,CAACp7B,CAAD,CAAP,CAAW4T,KAAvB,CAAD,EAAgC2V,KAAK,CAACrmB,KAAN,CAAYk4B,OAAO,CAACr6B,CAAD,CAAP,CAAW6S,KAAvB,CAAhC,CAAZ;AACD;;AACDqU,QAAM,CAAC/G,GAAP,CAAW+Z,WAAX;AACA,SAAOhT,MAAP;AACD,CAbD,C,CAeA;;;AACA,MAAMuT,WAAW,GAAG,CAACC,GAAD,EAAMC,GAAN,KAAc;AAChC,QAAM5T,IAAI,GAAGyB,KAAK,CAACtE,QAAN,CAAeyW,GAAG,CAAC9nB,KAAnB,EAA0B6nB,GAAG,CAAC7nB,KAA9B,CAAb;AACA,QAAM+nB,OAAO,GAAGpS,KAAK,CAAC0B,KAAN,CAAYnD,IAAZ,EAAkB,CAAC,CAAD,EAAI,CAAJ,CAAlB,CAAhB;AACA,QAAMpP,KAAK,GAAG/Z,IAAI,CAACqb,KAAL,CAAW8N,IAAI,CAAC,CAAD,CAAf,EAAoBA,IAAI,CAAC,CAAD,CAAxB,CAAd;AACA,QAAMf,QAAQ,GAAGpoB,IAAI,CAACK,IAAL,CAAUuqB,KAAK,CAAC5B,SAAN,CAAgB+T,GAAG,CAAC9nB,KAApB,EAA2B6nB,GAAG,CAAC7nB,KAA/B,CAAV,CAAjB;AACA,SAAO,CACL0V,KAAK,CAACrE,QAAN,CAAevM,KAAf,EAAsB+iB,GAAG,CAACG,MAAJ,CAAW,CAAX,CAAtB,CADK,EAELtS,KAAK,CAACrE,QAAN,CAAeyW,GAAG,CAACE,MAAJ,CAAW,CAAX,CAAf,EAA8BljB,KAA9B,CAFK,EAGL4Q,KAAK,CAACrE,QAAN,CAAewW,GAAG,CAACG,MAAJ,CAAW,CAAX,CAAf,EAA8BljB,KAA9B,CAHK,EAIL4Q,KAAK,CAACrE,QAAN,CAAevM,KAAf,EAAsBgjB,GAAG,CAACE,MAAJ,CAAW,CAAX,CAAtB,CAJK,EAKLtS,KAAK,CAACrE,QAAN,CAAewW,GAAG,CAACG,MAAJ,CAAW,CAAX,CAAf,EAA8BH,GAAG,CAACG,MAAJ,CAAW,CAAX,CAA9B,CALK,EAMLtS,KAAK,CAACrE,QAAN,CAAeyW,GAAG,CAACE,MAAJ,CAAW,CAAX,CAAf,EAA8BF,GAAG,CAACE,MAAJ,CAAW,CAAX,CAA9B,CANK,EAOJD,OAAO,GAAG,CAAH,GAAO,CAPV,EAQL5U,QAAQ,GAAC8T,mBARJ,CAAP;AAUD,CAfD,C,CAiBA;AACA;;;AACA,MAAM7J,mBAAmB,GAAIH,QAAD,IAAc;AACxC,MAAIA,QAAQ,CAAC,CAAD,CAAR,GAAc,CAAlB,EAAqB;AACnB,WAAO,CAACvH,KAAK,CAACyB,OAAN,CAAc8F,QAAQ,CAAC,CAAD,CAAtB,CAAR;AACD;;AACD,MAAIgL,aAAa,GAAGvS,KAAK,CAACyB,OAAN,CAAc8F,QAAQ,CAAC,CAAD,CAAtB,IAA6BvH,KAAK,CAACyB,OAAN,CAAc8F,QAAQ,CAAC,CAAD,CAAtB,CAAjD;AACA,QAAMiL,gBAAgB,GAAGjL,QAAQ,CAAC,CAAD,CAAjC;;AACA,MAAIA,QAAQ,CAAC,CAAD,CAAR,GAAc,CAAd,IAAmBA,QAAQ,CAAC,CAAD,CAAR,GAAc,CAAjC,IACAA,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAtB,GAA4B,CAAC,GAAD,GAAKlyB,IAAI,CAACmsB,EAD1C,EAC8C;AAC5C+Q,iBAAa,GAAGA,aAAa,GAAC,EAA9B;AACD;;AACD,SAAO,EAAEA,aAAa,GAAGC,gBAAlB,CAAP;AACD,CAXD,C,CAaA;AACA;AACA;;;AACA,MAAMP,YAAY,GAAG,CAACH,OAAD,EAAUD,UAAV,KAAyB;AAC5C,QAAMY,MAAM,GAAG,EAAf;;AACA,OAAK,IAAI/7B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGo7B,OAAO,CAACh7B,MAA5B,EAAoCJ,CAAC,EAArC,EAAyC;AACvC+7B,UAAM,CAACz7B,IAAP,CAAY,EAAZ;;AACA,SAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGq6B,OAAO,CAACh7B,MAA5B,EAAoCW,CAAC,EAArC,EAAyC;AACvCg7B,YAAM,CAAC/7B,CAAD,CAAN,CAAUM,IAAV,CAAe07B,YAAY,CAACZ,OAAO,CAACp7B,CAAD,CAAR,EAAao7B,OAAO,CAACr6B,CAAD,CAApB,EAAyBo6B,UAAzB,CAA3B;AACD;AACF;;AACD,OAAK,IAAIn7B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGo7B,OAAO,CAACh7B,MAA5B,EAAoCJ,CAAC,EAArC,EAAyC;AACvC,SAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGq6B,OAAO,CAACh7B,MAA5B,EAAoCW,CAAC,EAArC,EAAyC;AACvC,YAAMk7B,cAAc,GAAGF,MAAM,CAACh7B,CAAD,CAAN,CAAUf,CAAV,IAAeg7B,gBAAtC;;AACA,UAAIiB,cAAc,GAAGF,MAAM,CAAC/7B,CAAD,CAAN,CAAUe,CAAV,CAArB,EAAmC;AACjCg7B,cAAM,CAAC/7B,CAAD,CAAN,CAAUe,CAAV,IAAek7B,cAAf;AACD;AACF;AACF;;AACD,SAAQ,IAAI1G,SAAJ,CAAcwG,MAAd,CAAD,CAAwBjF,OAA/B;AACD,CAjBD,C,CAmBA;AACA;AACA;;;AACA,MAAMkF,YAAY,GAAG,CAACP,GAAD,EAAMC,GAAN,EAAWP,UAAX,KAA0B;AAC7C,SAAOA,UAAU,CAACK,WAAW,CAACC,GAAD,EAAMC,GAAN,CAAZ,CAAjB;AACD,CAFD,C,CAIA;AACA;AACA;;;AACA,SAASQ,QAAT,CAAkB1T,KAAlB,EAAyBrU,KAAzB,EAAgC;AAC9B,OAAKA,KAAL,GAAaA,KAAb;AACA,QAAMgQ,IAAI,GAAGqE,KAAK,CAACrU,KAAK,CAAC,CAAD,CAAN,CAAlB;AACA,QAAMxU,CAAC,GAAGwkB,IAAI,CAAC/jB,MAAf;AACA,OAAK+7B,OAAL,GAAe,CAAC,CAAChoB,KAAK,CAAC,CAAD,CAAN,EAAW,CAACA,KAAK,CAAC,CAAD,CAAL,GAAWxU,CAAX,GAAe,CAAhB,IAAqBA,CAAhC,CAAD,EAAqCwU,KAArC,CAAf;AACA,OAAKioB,QAAL,GAAgB,CAACjY,IAAI,CAAC,CAAChQ,KAAK,CAAC,CAAD,CAAL,GAAWxU,CAAX,GAAe,CAAhB,IAAqBA,CAAtB,CAAL,EAA+BwkB,IAAI,CAAChQ,KAAK,CAAC,CAAD,CAAN,CAAnC,CAAhB;AACA,OAAKP,KAAL,GAAa,KAAKwoB,QAAL,CAAc,CAAd,EAAiBtuB,GAA9B;AACAqb,QAAM,CAACI,KAAK,CAAC6B,KAAN,CAAY,KAAKxX,KAAjB,CAAD,EAA0B,KAAKA,KAA/B,CAAN;AACAuV,QAAM,CAACI,KAAK,CAAC0B,KAAN,CAAY,KAAKrX,KAAjB,EAAwB,KAAKwoB,QAAL,CAAc,CAAd,EAAiBzuB,KAAzC,CAAD,EAAkDwW,IAAlD,CAAN;AACA,OAAKkY,QAAL,GAAgB,CACd9S,KAAK,CAACtE,QAAN,CAAe,KAAKmX,QAAL,CAAc,CAAd,EAAiBtuB,GAAhC,EAAqC,KAAKsuB,QAAL,CAAc,CAAd,EAAiBzuB,KAAtD,CADc,EAEd4b,KAAK,CAACtE,QAAN,CAAe,KAAKmX,QAAL,CAAc,CAAd,EAAiBtuB,GAAhC,EAAqC,KAAKsuB,QAAL,CAAc,CAAd,EAAiBzuB,KAAtD,CAFc,CAAhB;AAIA,QAAM2uB,SAAS,GAAG39B,IAAI,CAACuM,GAAL,CAAS6vB,2BAAT,EAAsC,CAAtC,CAAlB;;AACA,MAAI,KAAKqB,QAAL,CAAc,CAAd,EAAiBG,OAAjB,KAA6B/nB,SAA7B,IACA+U,KAAK,CAAC5B,SAAN,CAAgB,KAAK/T,KAArB,EAA4B,KAAKwoB,QAAL,CAAc,CAAd,EAAiBG,OAA7C,IAAwDD,SAD5D,EACuE;AACrE,SAAKD,QAAL,CAAc,CAAd,IAAmB9S,KAAK,CAACtE,QAAN,CAAe,KAAKrR,KAApB,EAA2B,KAAKwoB,QAAL,CAAc,CAAd,EAAiBG,OAA5C,CAAnB;AACD;;AACD,MAAI,KAAKH,QAAL,CAAc,CAAd,EAAiBG,OAAjB,KAA6B/nB,SAA7B,IACA+U,KAAK,CAAC5B,SAAN,CAAgB,KAAK/T,KAArB,EAA4B,KAAKwoB,QAAL,CAAc,CAAd,EAAiBG,OAA7C,IAAwDD,SAD5D,EACuE;AACrE,SAAKD,QAAL,CAAc,CAAd,IAAmB9S,KAAK,CAACtE,QAAN,CAAe,KAAKmX,QAAL,CAAc,CAAd,EAAiBG,OAAhC,EAAyC,KAAK3oB,KAA9C,CAAnB;AACD;;AACD,OAAKgoB,MAAL,GAAc,KAAKS,QAAL,CAAcnb,GAAd,CAAkBqI,KAAK,CAAC7Q,KAAxB,CAAd;AACA,QAAMoP,IAAI,GAAGwB,KAAK,CAACrE,QAAN,CAAe,KAAK2W,MAAL,CAAY,CAAZ,CAAf,EAA+B,KAAKA,MAAL,CAAY,CAAZ,CAA/B,CAAb;AACA,OAAKP,MAAL,GAAcvT,IAAI,GAAG,CAACgT,gBAAtB;AACA,SAAO,IAAP;AACD,C,CAED;;;AAEA,MAAM0B,kBAAkB,GAAG,CAAClkB,IAAD,EAAOugB,SAAP,KAAqB;AAC9C1P,QAAM,CAAC7Q,IAAI,CAAClY,MAAL,KAAgB,CAAjB,CAAN;AACAy4B,WAAS,CAACvgB,IAAI,CAAC,CAAD,CAAL,CAAT,GAAqBugB,SAAS,CAACvgB,IAAI,CAAC,CAAD,CAAL,CAAT,IAAsB,EAA3C;;AACA,MAAIugB,SAAS,CAACvgB,IAAI,CAAC,CAAD,CAAL,CAAT,CAAmBkO,OAAnB,CAA2BlO,IAAI,CAAC,CAAD,CAA/B,IAAsC,CAA1C,EAA6C;AAC3CugB,aAAS,CAACvgB,IAAI,CAAC,CAAD,CAAL,CAAT,CAAmBhY,IAAnB,CAAwBgY,IAAI,CAAC,CAAD,CAA5B;AACD;AACF,CAND;;AAQA,MAAMmkB,aAAa,GAAG,CAACjU,KAAD,EAAQkU,YAAR,EAAsBC,gBAAtB,EAAwC19B,GAAxC,EACC29B,iBADD,EACoBjvB,KADpB,EAC2BkvB,WAD3B,KAC2C;AAC/D,QAAM5U,MAAM,GAAG,EAAf;AACA,QAAM+K,OAAO,GAAG,EAAhB;AACA,MAAIrB,OAAO,GAAGhkB,KAAd,CAH+D,CAK/D;AACA;;AACA,QAAMmvB,aAAa,GAAG,EAAtB;AACA,MAAIC,iBAAiB,GAAG,KAAxB;;AAEA,QAAMC,OAAO,GAAI7oB,KAAD,IACZ,CAACA,KAAK,CAAC,CAAD,CAAN,EAAW,CAACA,KAAK,CAAC,CAAD,CAAL,GAAW,CAAZ,IAAiBqU,KAAK,CAACrU,KAAK,CAAC,CAAD,CAAN,CAAL,CAAgB/T,MAA5C,CADJ;;AAGA,QAAMsY,KAAK,GAAG,CAACukB,MAAD,EAASC,MAAT,KAAoB;AAChC,UAAMpV,IAAI,GAAGyB,KAAK,CAACtE,QAAN,CAAeyX,YAAY,CAACnT,KAAK,CAAC2B,GAAN,CAAUgS,MAAV,CAAD,CAAZ,CAAgCtpB,KAA/C,EACe8oB,YAAY,CAACnT,KAAK,CAAC2B,GAAN,CAAU+R,MAAV,CAAD,CAAZ,CAAgCrpB,KAD/C,CAAb;AAEAuV,UAAM,CAACrB,IAAI,CAAC,CAAD,CAAJ,KAAY,CAAZ,IAAiBA,IAAI,CAAC,CAAD,CAAJ,KAAY,CAA9B,CAAN;AACA,UAAMpP,KAAK,GAAG/Z,IAAI,CAACqb,KAAL,CAAW8N,IAAI,CAAC,CAAD,CAAf,EAAoBA,IAAI,CAAC,CAAD,CAAxB,CAAd;AACA,WAAOwB,KAAK,CAACrE,QAAN,CAAevM,KAAf,EAAuBykB,QAAQ,CAACvB,MAAT,CAAgB,CAAhB,CAAvB,CAAP;AACD,GAND;;AAQA,QAAMwB,eAAe,GAAG,CAACC,QAAD,EAAWC,QAAX,KAAwB;AAC9C,UAAMC,KAAK,GAAGhU,KAAK,CAACtE,QAAN,CAAeoY,QAAQ,CAAC,CAAD,CAAvB,EAA4BA,QAAQ,CAAC,CAAD,CAApC,CAAd;AACA,UAAMG,KAAK,GAAGjU,KAAK,CAACtE,QAAN,CAAeqY,QAAQ,CAAC,CAAD,CAAvB,EAA4BA,QAAQ,CAAC,CAAD,CAApC,CAAd;AACA,UAAMG,KAAK,GAAGF,KAAK,CAAC,CAAD,CAAL,GAASC,KAAK,CAAC,CAAD,CAAd,GAAoBD,KAAK,CAAC,CAAD,CAAL,GAASC,KAAK,CAAC,CAAD,CAAhD;;AACA,QAAIC,KAAK,KAAK,CAAd,EAAiB;AACf,aAAOjpB,SAAP;AACD;;AACD,UAAM3V,CAAC,GAAG0qB,KAAK,CAACtE,QAAN,CAAeoY,QAAQ,CAAC,CAAD,CAAvB,EAA4BC,QAAQ,CAAC,CAAD,CAApC,CAAV;AACA,UAAMI,CAAC,GAAG,CAACH,KAAK,CAAC,CAAD,CAAL,GAAS1+B,CAAC,CAAC,CAAD,CAAV,GAAgB0+B,KAAK,CAAC,CAAD,CAAL,GAAS1+B,CAAC,CAAC,CAAD,CAA3B,IAAgC4+B,KAA1C;AACA,UAAM7wB,CAAC,GAAG,CAAC4wB,KAAK,CAAC,CAAD,CAAL,GAAS3+B,CAAC,CAAC,CAAD,CAAV,GAAgB2+B,KAAK,CAAC,CAAD,CAAL,GAAS3+B,CAAC,CAAC,CAAD,CAA3B,IAAgC4+B,KAA1C;;AACA,QAAI,IAAIC,CAAJ,IAASA,CAAC,GAAG,CAAb,IAAkB,IAAI9wB,CAAtB,IAA2BA,CAAC,GAAG,CAAnC,EAAsC;AACpC,aAAO,CAACywB,QAAQ,CAAC,CAAD,CAAR,CAAY,CAAZ,IAAiBzwB,CAAC,GAAC2wB,KAAK,CAAC,CAAD,CAAzB,EAA8BF,QAAQ,CAAC,CAAD,CAAR,CAAY,CAAZ,IAAiBzwB,CAAC,GAAC2wB,KAAK,CAAC,CAAD,CAAtD,CAAP;AACD;;AACD,WAAO/oB,SAAP;AACD,GAdD;;AAgBA,QAAMmpB,YAAY,GAAIxpB,KAAD,IAAWuoB,YAAY,CAACnT,KAAK,CAAC2B,GAAN,CAAU/W,KAAV,CAAD,CAAZ,CAA+BP,KAA/D;;AAEA,QAAMgqB,gBAAgB,GAAIpqB,MAAD,IAAY;AACnC,UAAMqqB,SAAS,GAAGf,aAAa,CAAC18B,MAAhC;;AACA,SAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwT,MAAM,CAACpT,MAAP,GAAgB,CAApC,EAAuCJ,CAAC,EAAxC,EAA4C;AAC1C88B,mBAAa,CAACx8B,IAAd,CAAmB,CAACkT,MAAM,CAACxT,CAAD,CAAP,EAAYwT,MAAM,CAACxT,CAAC,GAAG,CAAL,CAAlB,CAAnB;AACAioB,YAAM,CAAC3nB,IAAP,CAAY;AACVqN,aAAK,EAAE4b,KAAK,CAACrmB,KAAN,CAAYsQ,MAAM,CAACxT,CAAD,CAAlB,CADG;AAEV8N,WAAG,EAAEyb,KAAK,CAACrmB,KAAN,CAAYsQ,MAAM,CAACxT,CAAC,GAAG,CAAL,CAAlB,CAFK;AAGVu8B,eAAO,EAAE/nB;AAHC,OAAZ;AAKD,KATkC,CAUnC;;;AACA,QAAI,CAACuoB,iBAAL,EAAwB;AACtB,WAAK,IAAI/8B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG69B,SAApB,EAA+B79B,CAAC,EAAhC,EAAoC;AAClC,aAAK,IAAIe,CAAC,GAAG88B,SAAb,EAAwB98B,CAAC,GAAG+7B,aAAa,CAAC18B,MAA1C,EAAkDW,CAAC,EAAnD,EAAuD;AACrD,cAAIq8B,eAAe,CAACN,aAAa,CAAC98B,CAAD,CAAd,EAAmB88B,aAAa,CAAC/7B,CAAD,CAAhC,CAAnB,EAAyD;AACvDg8B,6BAAiB,GAAG,IAApB;AACA;AACD;AACF;AACF;AACF;AACF,GArBD,CAvC+D,CA8D/D;AACA;;;AACA,QAAMe,YAAY,GAAG,CAACX,QAAD,EAAW1xB,OAAX,KAAuB;AAC1C,QAAIA,OAAO,CAACrL,MAAR,KAAmB,CAAnB,IAAwBw8B,iBAAiB,CAACrT,KAAK,CAAC2B,GAAN,CAAUzf,OAAO,CAAC,CAAD,CAAjB,CAAD,CAA7C,EAAsE;AACpE;AACA;AACA,YAAMsyB,QAAQ,GAAG,CAACZ,QAAQ,CAAChpB,KAAV,EAAiB1I,OAAO,CAAC,CAAD,CAAxB,CAAjB;AACA,YAAM4xB,QAAQ,GAAGU,QAAQ,CAAC7c,GAAT,CAAayc,YAAb,CAAjB;;AACA,WAAK,IAAIzS,GAAT,IAAgByR,gBAAhB,EAAkC;AAChC,YAAIpT,KAAK,CAAC0B,KAAN,CAAYyR,YAAY,CAACxR,GAAD,CAAZ,CAAkB/W,KAA9B,EAAqC4pB,QAAQ,CAAC,CAAD,CAA7C,CAAJ,EAAuD;AACrD;AACD;;AACD,aAAK,IAAI/9B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG28B,gBAAgB,CAACzR,GAAD,CAAhB,CAAsB9qB,MAA1C,EAAkDJ,CAAC,EAAnD,EAAuD;AACrD,cAAIupB,KAAK,CAAC0B,KAAN,CAAY0R,gBAAgB,CAACzR,GAAD,CAAhB,CAAsBlrB,CAAtB,CAAZ,EAAsCq9B,QAAQ,CAAC,CAAD,CAA9C,CAAJ,EAAwD;AACtD;AACD,WAHoD,CAIrD;;;AACA,gBAAMW,QAAQ,GAAG,CAACtB,YAAY,CAACxR,GAAD,CAAZ,CAAkB/W,KAAnB,EAA0BwoB,gBAAgB,CAACzR,GAAD,CAAhB,CAAsBlrB,CAAtB,CAA1B,CAAjB;AACA,gBAAMs9B,QAAQ,GAAGU,QAAQ,CAAC9c,GAAT,CAAayc,YAAb,CAAjB;;AACA,cAAIpU,KAAK,CAAC0B,KAAN,CAAY+S,QAAQ,CAAC,CAAD,CAApB,EAAyBD,QAAQ,CAAC,CAAD,CAAjC,KACA,CAACnB,iBAAiB,CAACrT,KAAK,CAAC2B,GAAN,CAAU8S,QAAQ,CAAC,CAAD,CAAlB,CAAD,CADtB,EACgD;AAC9CJ,4BAAgB,CAAC,CAACP,QAAQ,CAAC,CAAD,CAAT,EAAcA,QAAQ,CAAC,CAAD,CAAtB,EAA2BC,QAAQ,CAAC,CAAD,CAAnC,CAAD,CAAhB;AACA,mBAAOU,QAAQ,CAAC,CAAD,CAAf;AACD,WAJD,MAIO,IAAIzU,KAAK,CAAC0B,KAAN,CAAY+S,QAAQ,CAAC,CAAD,CAApB,EAAyBD,QAAQ,CAAC,CAAD,CAAjC,KACA,CAACnB,iBAAiB,CAACrT,KAAK,CAAC2B,GAAN,CAAU8S,QAAQ,CAAC,CAAD,CAAlB,CAAD,CADtB,EACgD;AACrDJ,4BAAgB,CAAC,CAACP,QAAQ,CAAC,CAAD,CAAT,EAAcA,QAAQ,CAAC,CAAD,CAAtB,EAA2BC,QAAQ,CAAC,CAAD,CAAnC,CAAD,CAAhB;AACA,mBAAOU,QAAQ,CAAC,CAAD,CAAf;AACD;;AACD,gBAAMC,YAAY,GAAGb,eAAe,CAACC,QAAD,EAAWC,QAAX,CAApC;;AACA,cAAIW,YAAY,KAAKzpB,SAArB,EAAgC;AAC9B,kBAAMoW,MAAM,GAAGlS,KAAK,CAACqlB,QAAQ,CAAC,CAAD,CAAT,EAAcA,QAAQ,CAAC,CAAD,CAAtB,CAApB;AACA,kBAAMlT,MAAM,GAAGnS,KAAK,CAACslB,QAAQ,CAAC,CAAD,CAAT,EAAcA,QAAQ,CAAC,CAAD,CAAtB,CAApB;;AACA,gBAAI1U,KAAK,CAACrE,QAAN,CAAe4F,MAAf,EAAuBD,MAAvB,IAAiC,CAArC,EAAwC;AACtCoT,sBAAQ,CAACE,OAAT;AACAZ,sBAAQ,CAACY,OAAT;AACD;;AACDN,4BAAgB,CAAC,CAACP,QAAQ,CAAC,CAAD,CAAT,EAAcY,YAAd,EAA4BX,QAAQ,CAAC,CAAD,CAApC,CAAD,CAAhB;AACA,mBAAOU,QAAQ,CAAC,CAAD,CAAf;AACD;AACF;AACF;AACF,KAtCD,MAsCO;AACL;AACA;AACA,WAAK,IAAIh+B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyL,OAAO,CAACrL,MAA5B,EAAoCJ,CAAC,EAArC,EAAyC;AACvC,cAAMkrB,GAAG,GAAG3B,KAAK,CAAC2B,GAAN,CAAUzf,OAAO,CAACzL,CAAD,CAAjB,CAAZ;;AACA,YAAI,CAAC48B,iBAAiB,CAAC1R,GAAD,CAAtB,EAA6B;AAC3B,iBAAOzf,OAAO,CAACzL,CAAD,CAAd;AACD;AACF;AACF;;AACD,WAAOyL,OAAO,CAAC,CAAD,CAAd;AACD,GAlDD;;AAoDA,SAAO,IAAP,EAAa;AACX;AACAwc,UAAM,CAAC3nB,IAAP,CAAYkoB,KAAK,CAACmJ,OAAO,CAAC,CAAD,CAAR,CAAL,CAAkBA,OAAO,CAAC,CAAD,CAAzB,CAAZ;AACAqB,WAAO,CAACzJ,KAAK,CAAC2B,GAAN,CAAUyG,OAAV,CAAD,CAAP,GAA8B,IAA9B;AACAA,WAAO,GAAGqL,OAAO,CAACrL,OAAD,CAAjB,CAJW,CAKX;AACA;AACA;;AACA,UAAMzG,GAAG,GAAG3B,KAAK,CAAC2B,GAAN,CAAUyG,OAAV,CAAZ;;AACA,QAAIgL,gBAAgB,CAAClO,cAAjB,CAAgCvD,GAAhC,CAAJ,EAA0C;AACxC,UAAIiS,QAAQ,GAAGT,YAAY,CAACxR,GAAD,CAA3B;AACA,YAAMzf,OAAO,GAAGkxB,gBAAgB,CAACzR,GAAD,CAAhB,CAAsB7Y,IAAtB,CACZ,CAAClT,CAAD,EAAIC,CAAJ,KAAUsZ,KAAK,CAACykB,QAAQ,CAAChpB,KAAV,EAAiBhV,CAAjB,CAAL,GAA2BuZ,KAAK,CAACykB,QAAQ,CAAChpB,KAAV,EAAiB/U,CAAjB,CAD9B,CAAhB,CAFwC,CAIxC;AACA;AACA;;AACA,YAAM++B,aAAa,GAAGlW,MAAM,CAAC7nB,MAA7B;AACA,YAAMmX,IAAI,GAAIslB,WAAW,GAAGpxB,OAAO,CAAC,CAAD,CAAV,GAAgBqyB,YAAY,CAACX,QAAD,EAAW1xB,OAAX,CAArD;;AACA,UAAIwc,MAAM,CAAC7nB,MAAP,KAAkB+9B,aAAtB,EAAqC;AACnCP,wBAAgB,CAAC,CAACT,QAAQ,CAACvpB,KAAV,EAAiB8oB,YAAY,CAACnT,KAAK,CAAC2B,GAAN,CAAU3T,IAAV,CAAD,CAAZ,CAA8B3D,KAA/C,CAAD,CAAhB;AACD;;AACD+d,aAAO,GAAGpa,IAAV;AACD,KAtBU,CAuBX;;;AACA,UAAM6mB,OAAO,GAAG7U,KAAK,CAAC2B,GAAN,CAAUyG,OAAV,CAAhB;;AACA,QAAIpI,KAAK,CAAC0B,KAAN,CAAY0G,OAAZ,EAAqBhkB,KAArB,CAAJ,EAAiC;AAC/B,UAAIovB,iBAAJ,EAAuB;AACrB99B,WAAG,CAACqB,IAAJ,CAAS;AAAC+9B,aAAG,EAAE,OAAN;AACC5U,iBAAO,EAAE;AADV,SAAT;AAED;;AACD,UAAI6U,oBAAoB,GAAG,CAA3B;;AACA,WAAK,IAAInqB,KAAT,IAAkB6e,OAAlB,EAA2B;AACzB4J,yBAAiB,CAACzoB,KAAD,CAAjB,GAA2B,IAA3B;AACAmqB,4BAAoB,IAAI,CAAxB;AACD,OAT8B,CAU/B;AACA;;;AACA,UAAIA,oBAAoB,KAAK,CAA7B,EAAgC;AAC9Br/B,WAAG,CAACqB,IAAJ,CAAS;AAAC+9B,aAAG,EAAE,SAAN;AAAiB5U,iBAAO,EAAE;AAA1B,SAAT;AACA,eAAOjV,SAAP;AACD;;AACD,aAAOyT,MAAP;AACD,KAjBD,MAiBO,IAAI2U,iBAAiB,CAACwB,OAAD,CAAjB,IAA8BpL,OAAO,CAACoL,OAAD,CAAzC,EAAoD;AACzD,aAAO5pB,SAAP;AACD;AACF;AACF,CAnKD;;AAqKA,MAAM+pB,cAAc,GAAG,CAAC/V,KAAD,EAAQ0S,SAAR,EAAmB3X,OAAnB,EAA4BtkB,GAA5B,KAAoC;AACzD;AACA;AACA,QAAMy9B,YAAY,GAAG,EAArB;AACA,QAAM8B,qBAAqB,GAAG,EAA9B;;AACA,OAAK,IAAIrB,QAAT,IAAqBjC,SAArB,EAAgC;AAC9BwB,gBAAY,CAACnT,KAAK,CAAC2B,GAAN,CAAUiS,QAAQ,CAAChpB,KAAnB,CAAD,CAAZ,GAA0CgpB,QAA1C;AACAqB,yBAAqB,CAACjV,KAAK,CAAC2B,GAAN,CAAUiS,QAAQ,CAACvpB,KAAnB,CAAD,CAArB,GAAmDupB,QAAnD;AACD;;AACD5Z,SAAO,CAACrC,GAAR,CAAY+Z,WAAZ;AACA,QAAM0B,gBAAgB,GAAG,EAAzB;;AACA,OAAK,IAAItb,MAAT,IAAmBkC,OAAnB,EAA4B;AAC1B,UAAM+L,IAAI,GAAGjO,MAAM,CAACH,GAAP,CAAWqI,KAAK,CAAC2B,GAAjB,CAAb;AACA/B,UAAM,CAACqV,qBAAqB,CAAC/P,cAAtB,CAAqCa,IAAI,CAAC,CAAD,CAAzC,CAAD,CAAN;AACAnG,UAAM,CAACqV,qBAAqB,CAAC/P,cAAtB,CAAqCa,IAAI,CAAC,CAAD,CAAzC,CAAD,CAAN;AACA,UAAMmP,EAAE,GAAGnP,IAAI,CAACpO,GAAL,CAAU1e,CAAD,IAAOg8B,qBAAqB,CAACh8B,CAAD,CAArB,CAAyB2R,KAAzC,CAAX;AACAqoB,sBAAkB,CAAC,CAACjT,KAAK,CAAC2B,GAAN,CAAUuT,EAAE,CAAC,CAAD,CAAZ,CAAD,EAAmBA,EAAE,CAAC,CAAD,CAArB,CAAD,EAA4B9B,gBAA5B,CAAlB;AACAH,sBAAkB,CAAC,CAACjT,KAAK,CAAC2B,GAAN,CAAUuT,EAAE,CAAC,CAAD,CAAZ,CAAD,EAAmBA,EAAE,CAAC,CAAD,CAArB,CAAD,EAA4B9B,gBAA5B,CAAlB;AACD,GAlBwD,CAmBzD;AACA;;;AACA,QAAMC,iBAAiB,GAAG,EAA1B;AACA,QAAM9b,OAAO,GAAG,EAAhB;;AACA,OAAK,IAAI4d,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAG,CAAhC,EAAmCA,OAAO,EAA1C,EAA8C;AAC5C,QAAIC,MAAM,GAAG,KAAb;;AACA,SAAK,IAAI3+B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwoB,KAAK,CAACpoB,MAA1B,EAAkCJ,CAAC,EAAnC,EAAuC;AACrC,WAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGynB,KAAK,CAACxoB,CAAD,CAAL,CAASI,MAA7B,EAAqCW,CAAC,EAAtC,EAA0C;AACxC,cAAMoT,KAAK,GAAG,CAACnU,CAAD,EAAIe,CAAJ,CAAd;;AACA,YAAI67B,iBAAiB,CAACrT,KAAK,CAAC2B,GAAN,CAAU/W,KAAV,CAAD,CAArB,EAAyC;AACvC;AACD;;AACD,cAAM0oB,WAAW,GAAG6B,OAAO,KAAK,CAAhC;AACA,cAAMne,MAAM,GAAGkc,aAAa,CAACjU,KAAD,EAAQkU,YAAR,EAAsBC,gBAAtB,EAAwC19B,GAAxC,EACC29B,iBADD,EACoBzoB,KADpB,EAC2B0oB,WAD3B,CAA5B;;AAEA,YAAItc,MAAM,KAAK/L,SAAf,EAA0B;AACxBmqB,gBAAM,GAAG,IAAT;AACA;AACD;;AACD7d,eAAO,CAACxgB,IAAR,CAAaigB,MAAb;AACD;AACF;;AACD,QAAI,CAACoe,MAAL,EAAa;AACX,aAAO7d,OAAP;AACD;AACF;;AACD7hB,KAAG,CAACqB,IAAJ,CAAS;AAAC+9B,OAAG,EAAE,OAAN;AACC5U,WAAO,EAAE;AADV,GAAT;AAEA,SAAO3I,OAAP;AACD,CAhDD,C,CAkDA;;;AAEA,MAAM2P,gBAAgB,GAAG,EAAzB;;AAEAA,gBAAgB,CAAC7N,UAAjB,GAA8B,CAACuB,IAAD,EAAOgX,UAAP,KAAsB;AAClD,QAAM3S,KAAK,GAAG2P,GAAG,CAACe,qBAAJ,CAA0B/U,IAA1B,CAAd;AACA,QAAM+W,SAAS,GAAG,EAAlB;;AACA,OAAK,IAAIl7B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwoB,KAAK,CAACpoB,MAA1B,EAAkCJ,CAAC,EAAnC,EAAuC;AACrC,SAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGynB,KAAK,CAACxoB,CAAD,CAAL,CAASI,MAA7B,EAAqCW,CAAC,EAAtC,EAA0C;AACxCm6B,eAAS,CAAC56B,IAAV,CAAe,IAAI47B,QAAJ,CAAa1T,KAAb,EAAoB,CAACxoB,CAAD,EAAIe,CAAJ,CAApB,CAAf;AACD;AACF;;AACDo6B,YAAU,GAAGA,UAAU,IAAI1K,gBAAgB,CAACM,kBAA5C;AACA,QAAMxN,OAAO,GAAGX,UAAU,CAACsY,SAAD,EAAYC,UAAZ,CAA1B;AACA,SAAO;AAACD,aAAS,EAAEA,SAAZ;AAAuB3X,WAAO,EAAEA;AAAhC,GAAP;AACD,CAXD;;AAaAkN,gBAAgB,CAACmO,UAAjB,GAA8B,CAACza,IAAD,EAAOZ,OAAP,KAAmB;AAC/C,QAAMiF,KAAK,GAAG2P,GAAG,CAACe,qBAAJ,CAA0B/U,IAA1B,CAAd;AACA,QAAM+W,SAAS,GAAG,EAAlB;;AACA,OAAK,IAAIl7B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwoB,KAAK,CAACpoB,MAA1B,EAAkCJ,CAAC,EAAnC,EAAuC;AACrC,SAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGynB,KAAK,CAACxoB,CAAD,CAAL,CAASI,MAA7B,EAAqCW,CAAC,EAAtC,EAA0C;AACxCm6B,eAAS,CAAC56B,IAAV,CAAe,IAAI47B,QAAJ,CAAa1T,KAAb,EAAoB,CAACxoB,CAAD,EAAIe,CAAJ,CAApB,CAAf;AACD;AACF;;AACD,QAAM9B,GAAG,GAAG,EAAZ;AACA,QAAM4/B,YAAY,GAAGN,cAAc,CAAC/V,KAAD,EAAQ0S,SAAR,EAAmB3X,OAAnB,EAA4BtkB,GAA5B,CAAnC;AACA,QAAM6hB,OAAO,GAAG+d,YAAY,CAAC3d,GAAb,CAAkB1e,CAAD,IAAO21B,GAAG,CAAC2G,qBAAJ,CAA0B,CAACt8B,CAAD,CAA1B,CAAxB,CAAhB;AACA,SAAO;AAACvD,OAAG,EAAEA,GAAN;AAAW6hB,WAAO,EAAEA;AAApB,GAAP;AACD,CAZD;;AAcA2P,gBAAgB,CAACO,mBAAjB,GAAuCA,mBAAvC,C;;;;;;;;;;;AC9XArc,MAAM,CAAC4S,MAAP,CAAc;AAAC4Q,KAAG,EAAC,MAAIA;AAAT,CAAd;AAA6B,IAAIhP,MAAJ,EAAWI,KAAX;AAAiB5U,MAAM,CAAC2W,IAAP,CAAY,WAAZ,EAAwB;AAACnC,QAAM,CAACtqB,CAAD,EAAG;AAACsqB,UAAM,GAACtqB,CAAP;AAAS,GAApB;;AAAqB0qB,OAAK,CAAC1qB,CAAD,EAAG;AAAC0qB,SAAK,GAAC1qB,CAAN;AAAQ;;AAAtC,CAAxB,EAAgE,CAAhE;AAE9C,MAAMs5B,GAAG,GAAG,EAAZ,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA,MAAM4G,SAAS,GAAI5F,OAAD,IAAa;AAC7B,MAAI6F,IAAI,GAAG,CAAX;;AACA,OAAK,IAAIh/B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGm5B,OAAO,CAAC/4B,MAA5B,EAAoCJ,CAAC,EAArC,EAAyC;AACvC,UAAMoT,EAAE,GAAG+lB,OAAO,CAACn5B,CAAD,CAAlB;AACA,UAAMqT,EAAE,GAAG8lB,OAAO,CAAC,CAACn5B,CAAC,GAAG,CAAL,IAAUm5B,OAAO,CAAC/4B,MAAnB,CAAlB;AACA4+B,QAAI,IAAI,CAAC3rB,EAAE,CAAC,CAAD,CAAF,GAAQD,EAAE,CAAC,CAAD,CAAX,KAAiBC,EAAE,CAAC,CAAD,CAAF,GAAQD,EAAE,CAAC,CAAD,CAA3B,CAAR;AACD;;AACD,SAAO4rB,IAAP;AACD,CARD,C,CAUA;AACA;;;AACA,MAAMC,WAAW,GAAG,CAACzW,KAAD,EAAQ0W,mBAAR,KAAgC;AAClD,QAAMC,QAAQ,GAAG3W,KAAK,CAACtH,GAAN,CAAUiX,GAAG,CAACkB,uBAAd,CAAjB;;AACA,OAAK,IAAIr5B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwoB,KAAK,CAACpoB,MAA1B,EAAkCJ,CAAC,EAAnC,EAAuC;AACrC,UAAMmkB,IAAI,GAAGqE,KAAK,CAACxoB,CAAD,CAAlB;AACA,QAAIo/B,QAAQ,GAAG,CAAf;;AACA,SAAK,IAAIr+B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGynB,KAAK,CAACpoB,MAA1B,EAAkCW,CAAC,EAAnC,EAAuC;AACrC,UAAIA,CAAC,KAAKf,CAAV,EAAa;AACX;AACD,OAFD,MAEO,IAAIm4B,GAAG,CAACqB,oBAAJ,CAAyB2F,QAAQ,CAACp+B,CAAD,CAAjC,EAAsCojB,IAAI,CAAC,CAAD,CAAJ,CAAQxW,KAA9C,CAAJ,EAA0D;AAC/DyxB,gBAAQ,IAAI,CAAZ;AACD;AACF;;AACD,UAAMJ,IAAI,GAAGD,SAAS,CAACI,QAAQ,CAACn/B,CAAD,CAAT,CAAtB,CAVqC,CAWrC;AACA;AACA;;AACA,UAAMq/B,cAAc,GAAIL,IAAI,GAAG,CAAR,MAAgBI,QAAQ,GAAG,CAAX,KAAiB,CAAjC,CAAvB;;AACA,QAAIC,cAAJ,EAAoB;AAClB,WAAK,IAAIC,OAAT,IAAoBnb,IAApB,EAA0B;AACxB,SAACmb,OAAO,CAAC3xB,KAAT,EAAgB2xB,OAAO,CAACxxB,GAAxB,IAA+B,CAACwxB,OAAO,CAACxxB,GAAT,EAAcwxB,OAAO,CAAC3xB,KAAtB,CAA/B;AACD;;AACDwW,UAAI,CAAC+Z,OAAL;AACD;AACF;;AACD,SAAO1V,KAAP;AACD,CAzBD,C,CA2BA;;;AACA,MAAM+W,SAAS,GAAIpb,IAAD,IAAU;AAC1BgF,QAAM,CAAChF,IAAI,CAAC/jB,MAAL,GAAc,CAAf,CAAN;AACA+oB,QAAM,CAAChF,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAb,uCAAgDA,IAAhD,EAAN;AACAgF,QAAM,CAAChF,IAAI,CAACA,IAAI,CAAC/jB,MAAL,GAAc,CAAf,CAAJ,KAA0B,GAA3B,qCAA4D+jB,IAA5D,EAAN;AACA,QAAMqb,KAAK,GAAGrb,IAAI,CAAChB,KAAL,CAAW,GAAX,CAAd;AACA,QAAM8E,MAAM,GAAG,EAAf;AACA,MAAIta,KAAK,GAAG6G,SAAZ;AACA,MAAImd,OAAO,GAAGnd,SAAd;;AACA,OAAK,IAAIxU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGw/B,KAAK,CAACp/B,MAA1B,EAAkCJ,CAAC,EAAnC,EAAuC;AACrC,UAAMy/B,OAAO,GAAGD,KAAK,CAACx/B,CAAD,CAArB;AACAmpB,UAAM,CAACsW,OAAO,CAACr/B,MAAR,GAAiB,CAAlB,yCAAqD+jB,IAArD,EAAN;AACAgF,UAAM,CAAC,OAAO3C,OAAP,CAAeiZ,OAAf,KAA2B,CAA5B,EAA+BA,OAA/B,CAAN;;AACA,QAAIA,OAAO,KAAK,GAAZ,IAAmBA,OAAO,KAAK,GAAnC,EAAwC;AACtC,UAAI9N,OAAO,KAAKnd,SAAhB,EAA2B;AACzB2U,cAAM,CAACI,KAAK,CAAC0B,KAAN,CAAY0G,OAAZ,EAAqBhkB,KAArB,CAAD,mCAAwDwW,IAAxD,EAAN;AACAgF,cAAM,CAAClB,MAAM,CAACA,MAAM,CAAC7nB,MAAP,GAAgB,CAAjB,CAAN,CAA0BA,MAA1B,GAAmC,CAApC,oCAC4B+jB,IAD5B,EAAN;;AAEA,YAAIsb,OAAO,KAAK,GAAhB,EAAqB;AACnBtW,gBAAM,CAACnpB,CAAC,KAAKw/B,KAAK,CAACp/B,MAAN,GAAe,CAAtB,8BAA8C+jB,IAA9C,EAAN;AACA,iBAAO8D,MAAP;AACD;AACF;;AACDA,YAAM,CAAC3nB,IAAP,CAAY,EAAZ;AACA6oB,YAAM,CAACnpB,CAAC,GAAGw/B,KAAK,CAACp/B,MAAN,GAAe,CAApB,mCAAiD+jB,IAAjD,EAAN;AACAxW,WAAK,GAAG,CAAC0V,UAAU,CAACmc,KAAK,CAACx/B,CAAC,GAAG,CAAL,CAAN,EAAe,EAAf,CAAX,EAA+BqjB,UAAU,CAACmc,KAAK,CAACx/B,CAAC,GAAG,CAAL,CAAN,EAAe,EAAf,CAAzC,CAAR;AACAmpB,YAAM,CAACI,KAAK,CAAC6B,KAAN,CAAYzd,KAAZ,CAAD,CAAN;AACA3N,OAAC,IAAI,CAAL;AACA2xB,aAAO,GAAGpI,KAAK,CAACrmB,KAAN,CAAYyK,KAAZ,CAAV;AACA;AACD;;AACD,QAAI4uB,OAAO,GAAG/nB,SAAd;;AACA,QAAIirB,OAAO,KAAK,GAAhB,EAAqB;AACnBtW,YAAM,CAACnpB,CAAC,GAAGw/B,KAAK,CAACp/B,MAAN,GAAe,CAApB,mCAAiD+jB,IAAjD,EAAN;AACAoY,aAAO,GAAG,CAAClZ,UAAU,CAACmc,KAAK,CAACx/B,CAAC,GAAG,CAAL,CAAN,EAAe,EAAf,CAAX,EAA+BqjB,UAAU,CAACmc,KAAK,CAACx/B,CAAC,GAAG,CAAL,CAAN,EAAe,EAAf,CAAzC,CAAV;AACAmpB,YAAM,CAACI,KAAK,CAAC6B,KAAN,CAAYmR,OAAZ,CAAD,CAAN;AACAv8B,OAAC,IAAI,CAAL;AACD;;AACDmpB,UAAM,CAACnpB,CAAC,GAAGw/B,KAAK,CAACp/B,MAAN,GAAe,CAApB,mCAAiD+jB,IAAjD,EAAN;AACA,UAAMrW,GAAG,GAAG,CAACuV,UAAU,CAACmc,KAAK,CAACx/B,CAAC,GAAG,CAAL,CAAN,EAAe,EAAf,CAAX,EAA+BqjB,UAAU,CAACmc,KAAK,CAACx/B,CAAC,GAAG,CAAL,CAAN,EAAe,EAAf,CAAzC,CAAZ;AACAmpB,UAAM,CAACI,KAAK,CAAC6B,KAAN,CAAYtd,GAAZ,CAAD,CAAN;AACA9N,KAAC,IAAI,CAAL;;AACA,QAAIupB,KAAK,CAAC0B,KAAN,CAAY0G,OAAZ,EAAqB7jB,GAArB,CAAJ,EAA+B;AAC7B;AACD;;AACD,QAAIyuB,OAAO,KAAK/nB,SAAZ,KACC+U,KAAK,CAAC0B,KAAN,CAAYsR,OAAZ,EAAqB5K,OAArB,KAAiCpI,KAAK,CAAC0B,KAAN,CAAYsR,OAAZ,EAAqBzuB,GAArB,CADlC,CAAJ,EACkE;AAChEyuB,aAAO,GAAG/nB,SAAV;AACD;;AACDyT,UAAM,CAACA,MAAM,CAAC7nB,MAAP,GAAgB,CAAjB,CAAN,CAA0BE,IAA1B,CAA+B;AAC7BqN,WAAK,EAAE4b,KAAK,CAACrmB,KAAN,CAAYyuB,OAAZ,CADsB;AAE7B4K,aAAO,EAAEA,OAFoB;AAG7BzuB,SAAG,EAAEA;AAHwB,KAA/B;AAKA6jB,WAAO,GAAGpI,KAAK,CAACrmB,KAAN,CAAY4K,GAAZ,CAAV;AACD;AACF,CAvDD,C,CAyDA;AACA;;;AACAqqB,GAAG,CAACuH,qBAAJ,GAA6BC,QAAD,IAAc;AACxC,QAAMH,KAAK,GAAG,EAAd;;AACA,OAAK,IAAIx/B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2/B,QAAQ,CAACv/B,MAA7B,EAAqCJ,CAAC,EAAtC,EAA0C;AACxC,UAAMy/B,OAAO,GAAGE,QAAQ,CAAC3/B,CAAD,CAAxB;AACAmpB,UAAM,CAAC,OAAO3C,OAAP,CAAeiZ,OAAO,CAAC5zB,IAAvB,KAAgC,CAAjC,EAAoC4zB,OAAO,CAAC5zB,IAA5C,CAAN;;AACA,QAAI4zB,OAAO,CAAC5zB,IAAR,KAAiB,GAArB,EAA0B;AACxBsd,YAAM,CAACnpB,CAAC,KAAK2/B,QAAQ,CAACv/B,MAAT,GAAkB,CAAzB,CAAN;AACA;AACD;;AACDo/B,SAAK,CAACl/B,IAAN,CAAWm/B,OAAO,CAAC5zB,IAAnB;AACAsd,UAAM,CAAEsW,OAAO,CAACt6B,EAAR,KAAeqP,SAAhB,MAAgCirB,OAAO,CAAC5zB,IAAR,KAAiB,GAAjD,CAAD,CAAN;;AACA,QAAI4zB,OAAO,CAACt6B,EAAR,KAAeqP,SAAnB,EAA8B;AAC5BgrB,WAAK,CAACl/B,IAAN,CAAWm/B,OAAO,CAACt6B,EAAnB;AACAq6B,WAAK,CAACl/B,IAAN,CAAWm/B,OAAO,CAAC5Z,EAAnB;AACD;;AACDsD,UAAM,CAACsW,OAAO,CAACj9B,CAAR,KAAcgS,SAAf,CAAN;AACAgrB,SAAK,CAACl/B,IAAN,CAAWm/B,OAAO,CAACj9B,CAAnB;AACAg9B,SAAK,CAACl/B,IAAN,CAAWm/B,OAAO,CAACh9B,CAAnB;AACD;;AACD+8B,OAAK,CAACl/B,IAAN,CAAW,GAAX;AACA,SAAOk/B,KAAK,CAACrX,IAAN,CAAW,GAAX,CAAP;AACD,CArBD,C,CAuBA;AACA;AACA;;;AACAgQ,GAAG,CAACe,qBAAJ,GAA6B/U,IAAD,IAAU;AACpC,SAAO8a,WAAW,CAACM,SAAS,CAACpb,IAAD,CAAV,CAAlB;AACD,CAFD,C,CAIA;;;AACAgU,GAAG,CAAC2G,qBAAJ,GAA6BtW,KAAD,IAAW;AACrC,QAAMgX,KAAK,GAAG,EAAd;;AACA,OAAK,IAAIrb,IAAT,IAAiBqE,KAAjB,EAAwB;AACtBW,UAAM,CAAChF,IAAI,CAAC/jB,MAAL,GAAc,CAAf,CAAN;AACAo/B,SAAK,CAACl/B,IAAN,CAAW,GAAX;AACAk/B,SAAK,CAACl/B,IAAN,CAAW6jB,IAAI,CAAC,CAAD,CAAJ,CAAQxW,KAAR,CAAc,CAAd,CAAX;AACA6xB,SAAK,CAACl/B,IAAN,CAAW6jB,IAAI,CAAC,CAAD,CAAJ,CAAQxW,KAAR,CAAc,CAAd,CAAX;;AACA,SAAK,IAAI2xB,OAAT,IAAoBnb,IAApB,EAA0B;AACxB,UAAImb,OAAO,CAAC/C,OAAR,KAAoB/nB,SAAxB,EAAmC;AACjCgrB,aAAK,CAACl/B,IAAN,CAAW,GAAX;AACD,OAFD,MAEO;AACLk/B,aAAK,CAACl/B,IAAN,CAAW,GAAX;AACAk/B,aAAK,CAACl/B,IAAN,CAAWg/B,OAAO,CAAC/C,OAAR,CAAgB,CAAhB,CAAX;AACAiD,aAAK,CAACl/B,IAAN,CAAWg/B,OAAO,CAAC/C,OAAR,CAAgB,CAAhB,CAAX;AACD;;AACDiD,WAAK,CAACl/B,IAAN,CAAWg/B,OAAO,CAACxxB,GAAR,CAAY,CAAZ,CAAX;AACA0xB,WAAK,CAACl/B,IAAN,CAAWg/B,OAAO,CAACxxB,GAAR,CAAY,CAAZ,CAAX;AACD;AACF;;AACD0xB,OAAK,CAACl/B,IAAN,CAAW,GAAX;AACA,SAAOk/B,KAAK,CAACrX,IAAN,CAAW,GAAX,CAAP;AACD,CArBD,C,CAuBA;AACA;AACA;AACA;AACA;AACA;;;AACAgQ,GAAG,CAACkB,uBAAJ,GAA8B,CAAClV,IAAD,EAAO+a,mBAAP,KAA+B;AAC3D,QAAMjX,MAAM,GAAG,EAAf;AACAiX,qBAAmB,GAAGA,mBAAmB,IAAI,EAA7C;;AACA,OAAK,IAAI18B,CAAT,IAAc2hB,IAAd,EAAoB;AAClB,UAAMoY,OAAO,GAAG/5B,CAAC,CAAC+5B,OAAF,IAAahT,KAAK,CAAC4B,QAAN,CAAe3oB,CAAC,CAACmL,KAAjB,EAAwBnL,CAAC,CAACsL,GAA1B,CAA7B;AACA,UAAMiZ,QAAQ,GAAGpoB,IAAI,CAACK,IAAL,CAAUuqB,KAAK,CAAC5B,SAAN,CAAgBnlB,CAAC,CAACmL,KAAlB,EAAyBnL,CAAC,CAACsL,GAA3B,CAAV,CAAjB;AACA,UAAM8xB,UAAU,GAAGjhC,IAAI,CAACW,KAAL,CAAWynB,QAAQ,GAACmY,mBAApB,CAAnB;;AACA,SAAK,IAAIl/B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4/B,UAApB,EAAgC5/B,CAAC,EAAjC,EAAqC;AACnC,YAAM4M,CAAC,GAAG,CAAC5M,CAAC,GAAG,CAAL,KAAS4/B,UAAU,GAAG,CAAtB,CAAV;AACA,YAAMlC,CAAC,GAAG,IAAI9wB,CAAd;AACAqb,YAAM,CAAC3nB,IAAP,CAAY,CAACo9B,CAAC,GAACA,CAAF,GAAIl7B,CAAC,CAACmL,KAAF,CAAQ,CAAR,CAAJ,GAAiB,IAAE+vB,CAAF,GAAI9wB,CAAJ,GAAM2vB,OAAO,CAAC,CAAD,CAA9B,GAAoC3vB,CAAC,GAACA,CAAF,GAAIpK,CAAC,CAACsL,GAAF,CAAM,CAAN,CAAzC,EACC4vB,CAAC,GAACA,CAAF,GAAIl7B,CAAC,CAACmL,KAAF,CAAQ,CAAR,CAAJ,GAAiB,IAAE+vB,CAAF,GAAI9wB,CAAJ,GAAM2vB,OAAO,CAAC,CAAD,CAA9B,GAAoC3vB,CAAC,GAACA,CAAF,GAAIpK,CAAC,CAACsL,GAAF,CAAM,CAAN,CADzC,CAAZ;AAED;;AACDma,UAAM,CAAC3nB,IAAP,CAAYkC,CAAC,CAACsL,GAAd;AACD;;AACD,SAAOma,MAAP;AACD,CAhBD,C,CAkBA;;;AACAkQ,GAAG,CAACqB,oBAAJ,GAA2B,CAACL,OAAD,EAAUvlB,KAAV,KAAoB;AAC7C,QAAMpR,CAAC,GAAGoR,KAAK,CAAC,CAAD,CAAf;AACA,QAAMnR,CAAC,GAAGmR,KAAK,CAAC,CAAD,CAAf;AACA,MAAIisB,SAAS,GAAG,CAAhB;;AACA,OAAK,IAAI7/B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGm5B,OAAO,CAAC/4B,MAA5B,EAAoCJ,CAAC,EAArC,EAAyC;AACvC,UAAMs/B,OAAO,GAAG;AAAC3xB,WAAK,EAAEwrB,OAAO,CAACn5B,CAAD,CAAf;AAAoB8N,SAAG,EAAEqrB,OAAO,CAAC,CAACn5B,CAAC,GAAG,CAAL,IAAUm5B,OAAO,CAAC/4B,MAAnB;AAAhC,KAAhB;;AACA,QAAKk/B,OAAO,CAAC3xB,KAAR,CAAc,CAAd,IAAmBnL,CAAnB,IAAwBA,CAAC,GAAG88B,OAAO,CAACxxB,GAAR,CAAY,CAAZ,CAA7B,IACCwxB,OAAO,CAAC3xB,KAAR,CAAc,CAAd,IAAmBnL,CAAnB,IAAwBA,CAAC,GAAG88B,OAAO,CAACxxB,GAAR,CAAY,CAAZ,CADjC,EACkD;AAChD,YAAMlB,CAAC,GAAG,CAACpK,CAAC,GAAG88B,OAAO,CAACxxB,GAAR,CAAY,CAAZ,CAAL,KAAsBwxB,OAAO,CAAC3xB,KAAR,CAAc,CAAd,IAAmB2xB,OAAO,CAACxxB,GAAR,CAAY,CAAZ,CAAzC,CAAV;AACA,YAAM8O,EAAE,GAAGhQ,CAAC,GAAC0yB,OAAO,CAAC3xB,KAAR,CAAc,CAAd,CAAF,GAAqB,CAAC,IAAIf,CAAL,IAAQ0yB,OAAO,CAACxxB,GAAR,CAAY,CAAZ,CAAxC;;AACA,UAAIrL,CAAC,GAAGma,EAAR,EAAY;AACVijB,iBAAS,IAAI,CAAb;AACD;AACF,KAPD,MAOO,IAAIP,OAAO,CAAC3xB,KAAR,CAAc,CAAd,MAAqBnL,CAArB,IAA0B88B,OAAO,CAAC3xB,KAAR,CAAc,CAAd,KAAoBlL,CAAlD,EAAqD;AAC1D,UAAI68B,OAAO,CAACxxB,GAAR,CAAY,CAAZ,IAAiBtL,CAArB,EAAwB;AACtBq9B,iBAAS,IAAI,CAAb;AACD;;AACD,YAAM7rB,IAAI,GAAGmlB,OAAO,CAAC,CAACn5B,CAAC,GAAGm5B,OAAO,CAAC/4B,MAAZ,GAAqB,CAAtB,IAA4B+4B,OAAO,CAAC/4B,MAArC,CAApB;;AACA,UAAI4T,IAAI,CAAC,CAAD,CAAJ,GAAUxR,CAAd,EAAiB;AACfq9B,iBAAS,IAAI,CAAb;AACD;AACF;AACF;;AACD,SAAOA,SAAS,GAAG,CAAZ,KAAkB,CAAzB;AACD,CAxBD,C;;;;;;;;;;;ACpMA,IAAIzN,MAAJ;AAAWzd,MAAM,CAAC2W,IAAP,CAAY,aAAZ,EAA0B;AAAC8G,QAAM,CAACvzB,CAAD,EAAG;AAACuzB,UAAM,GAACvzB,CAAP;AAAS;;AAApB,CAA1B,EAAgD,CAAhD;AAEXkrB,MAAM,CAACuL,OAAP,CAAe,OAAf,EAAwBlD,MAAM,CAAC0N,oBAA/B,E;;;;;;;;;;;ACFA,IAAItY,gBAAJ;AAAqB7S,MAAM,CAAC2W,IAAP,CAAY,gBAAZ,EAA6B;AAAC9D,kBAAgB,CAAC3oB,CAAD,EAAG;AAAC2oB,oBAAgB,GAAC3oB,CAAjB;AAAmB;;AAAxC,CAA7B,EAAuE,CAAvE;AAA0E,IAAIsqB,MAAJ,EAAWC,MAAX,EAAkBG,KAAlB;AAAwB5U,MAAM,CAAC2W,IAAP,CAAY,WAAZ,EAAwB;AAACnC,QAAM,CAACtqB,CAAD,EAAG;AAACsqB,UAAM,GAACtqB,CAAP;AAAS,GAApB;;AAAqBuqB,QAAM,CAACvqB,CAAD,EAAG;AAACuqB,UAAM,GAACvqB,CAAP;AAAS,GAAxC;;AAAyC0qB,OAAK,CAAC1qB,CAAD,EAAG;AAAC0qB,SAAK,GAAC1qB,CAAN;AAAQ;;AAA1D,CAAxB,EAAoF,CAApF;AAAuF,IAAIwsB,MAAJ;AAAW1W,MAAM,CAAC2W,IAAP,CAAY,aAAZ,EAA0B;AAACD,QAAM,CAACxsB,CAAD,EAAG;AAACwsB,UAAM,GAACxsB,CAAP;AAAS;;AAApB,CAA1B,EAAgD,CAAhD;AAAmD,IAAIuzB,MAAJ;AAAWzd,MAAM,CAAC2W,IAAP,CAAY,aAAZ,EAA0B;AAAC8G,QAAM,CAACvzB,CAAD,EAAG;AAACuzB,UAAM,GAACvzB,CAAP;AAAS;;AAApB,CAA1B,EAAgD,CAAhD;AAAmD,IAAIgmB,UAAJ;AAAelQ,MAAM,CAAC2W,IAAP,CAAY,6BAAZ,EAA0C;AAACzG,YAAU,CAAChmB,CAAD,EAAG;AAACgmB,cAAU,GAAChmB,CAAX;AAAa;;AAA5B,CAA1C,EAAwE,CAAxE;AAA2E,IAAI4xB,gBAAJ;AAAqB9b,MAAM,CAAC2W,IAAP,CAAY,uBAAZ,EAAoC;AAACmF,kBAAgB,CAAC5xB,CAAD,EAAG;AAAC4xB,oBAAgB,GAAC5xB,CAAjB;AAAmB;;AAAxC,CAApC,EAA8E,CAA9E;AAAiF,IAAIs5B,GAAJ;AAAQxjB,MAAM,CAAC2W,IAAP,CAAY,UAAZ,EAAuB;AAAC6M,KAAG,CAACt5B,CAAD,EAAG;AAACs5B,OAAG,GAACt5B,CAAJ;AAAM;;AAAd,CAAvB,EAAuC,CAAvC;;AAQlhB,MAAMkhC,iBAAiB,GAAItN,KAAD,IAAW;AACnC,QAAMztB,IAAI,GAAGqmB,MAAM,CAACY,gBAAP,CAAwBwG,KAAK,CAAC5R,SAA9B,CAAb;AACA4R,OAAK,CAACF,QAAN,CAAenC,SAAf,GAA2BprB,IAAI,CAACorB,SAAhC;AACAgC,QAAM,CAACoC,IAAP,CAAY/B,KAAZ;AACD,CAJD;;AAMA,MAAMuN,iCAAiC,GAAIvN,KAAD,IAAW;AACnD,QAAMztB,IAAI,GAAGqmB,MAAM,CAACY,gBAAP,CAAwBwG,KAAK,CAAC5R,SAA9B,CAAb;AACA4R,OAAK,CAACxe,UAAN,GAAmBjP,IAAI,CAACiP,UAAxB;AACAwe,OAAK,CAACtG,WAAN,GAAoBnnB,IAAI,CAACmnB,WAAzB;AACAiG,QAAM,CAACoC,IAAP,CAAY/B,KAAZ;AACD,CALD;;AAOA,MAAMwN,aAAa,GAAIxN,KAAD,IAAW;AAC/B,QAAMyN,GAAG,GAAGzN,KAAK,CAACD,MAAN,CAAa1R,OAAzB;AACA,MAAIof,GAAG,CAACA,GAAJ,IAAWA,GAAG,CAACtb,SAAnB,EAA8B;AAC9B6N,OAAK,CAACD,MAAN,CAAa1R,OAAb,GAAuB;AAAC8D,aAAS,EAAEC,UAAU,CAACqb,GAAD,CAAtB;AAA6BA;AAA7B,GAAvB;AACA9N,QAAM,CAACoC,IAAP,CAAY/B,KAAZ;AACD,CALD;;AAOA,MAAM0N,6BAA6B,GAAI1N,KAAD,IAAW;AAC/C,QAAM3R,OAAO,GAAG2P,gBAAgB,CAACmO,UAAjB,CACZnM,KAAK,CAACD,MAAN,CAAarO,IADD,EACOsO,KAAK,CAACD,MAAN,CAAajP,OADpB,CAAhB;;AAEA,MAAI,CAAC0L,CAAC,CAACmR,OAAF,CAAUtf,OAAO,CAACA,OAAR,CAAgBzO,IAAhB,EAAV,EAAkCogB,KAAK,CAACD,MAAN,CAAa1R,OAAb,CAAqBzO,IAArB,EAAlC,CAAL,EAAqE;AACnE1H,WAAO,CAAC1L,GAAR,iCAAqCwzB,KAAK,CAAC5R,SAA3C;AACD;AACF,CAND;;AAQA,MAAMwf,6BAA6B,GAAIlc,IAAD,IAAU;AAC9C,QAAMqb,KAAK,GAAG,EAAd;;AACA,OAAK,IAAIF,OAAT,IAAoBnb,IAApB,EAA0B;AACxBgF,UAAM,CAAC,OAAO3C,OAAP,CAAe8Y,OAAO,CAACzzB,IAAvB,KAAgC,CAAjC,EAAoCyzB,OAAO,CAACzzB,IAA5C,CAAN;AACA2zB,SAAK,CAACl/B,IAAN,CAAWg/B,OAAO,CAACzzB,IAAnB;;AACA,QAAIyzB,OAAO,CAACn6B,EAAR,KAAeqP,SAAnB,EAA8B;AAC5BgrB,WAAK,CAACl/B,IAAN,CAAWg/B,OAAO,CAACn6B,EAAnB;AACAq6B,WAAK,CAACl/B,IAAN,CAAWg/B,OAAO,CAACzZ,EAAnB;AACD;;AACD,QAAIyZ,OAAO,CAAC98B,CAAR,KAAcgS,SAAlB,EAA6B;AAC3BgrB,WAAK,CAACl/B,IAAN,CAAWg/B,OAAO,CAAC98B,CAAnB;AACAg9B,WAAK,CAACl/B,IAAN,CAAWg/B,OAAO,CAAC78B,CAAnB;AACD;AACF;;AACD,SAAO+8B,KAAK,CAACrX,IAAN,CAAW,GAAX,CAAP;AACD,CAfD;;AAiBA,MAAMmY,SAAS,GAAG,CAACC,UAAD,EAAaC,QAAb,KAA2B/N,KAAD,IAAW;AACrD,MAAI,CAACA,KAAK,CAACD,MAAN,CAAaG,QAAlB,EAA4B;AAC1B;AACD;;AACD,QAAM8N,QAAQ,GAAGhO,KAAK,CAACD,MAAN,CAAaiO,QAA9B;AACA,QAAMC,KAAK,GAAGjO,KAAK,CAACD,MAAN,CAAakO,KAA3B;AACA,QAAM17B,IAAI,GAAGqmB,MAAM,CAACY,gBAAP,CAAwBwG,KAAK,CAAC5R,SAA9B,CAAb;AACA,QAAMyP,MAAM,GAAG,CAACmC,KAAK,CAACF,QAAN,CAAejC,MAAf,IAAyBtrB,IAAI,CAACsrB,MAA9B,IAAwC,EAAzC,EACKnN,KADL,CACW,GADX,EACgBjC,GADhB,CACqB1e,CAAD,IAAOA,CAAC,CAACm+B,IAAF,EAD3B,EACqC5f,MADrC,CAC6Cve,CAAD,IAAOA,CADnD,CAAf;AAEA,QAAMse,OAAO,GAAG4f,KAAK,CAACxf,GAAN,CAAW1e,CAAD,IAAOiwB,KAAK,CAACD,MAAN,CAAa1R,OAAb,CAAqB8D,SAArB,CAA+BpiB,CAAC,CAAC+d,MAAjC,CAAjB,CAAhB;AACA,QAAM6H,OAAO,GAAGsY,KAAK,CAACxf,GAAN,CAAW1e,CAAD,IAAOA,CAAC,CAACwlB,MAAnB,CAAhB;AACAlH,SAAO,CAACI,GAAR,CAAa1e,CAAD,IAAO2mB,MAAM,CAAC3mB,CAAD,CAAzB;AACA4lB,SAAO,CAAClH,GAAR,CAAa1e,CAAD,IAAO2mB,MAAM,CAAC3mB,CAAD,CAAzB;AACA,QAAMo+B,aAAa,GACfH,QAAQ,CAACI,SAAT,CAAmBC,IAAnB,IAA4BL,QAAQ,CAACI,SAAT,CAAmBh1B,IAAnB,KAA4B,eAD5D;AAGA00B,YAAU,CAACQ,KAAX,CAAiBC,IAAI,CAACC,SAAL,CAAe;AAC9BpgB,aAAS,EAAE4R,KAAK,CAAC5R,SADa;AAE9BsP,cAAU,EAAEsC,KAAK,CAACF,QAAN,CAAepC,UAAf,IAA6BnrB,IAAI,CAACmrB,UAFhB;AAG9BG,UAAM,EAAEA,MAHsB;AAI9BX,iBAAa,EAAE8Q,QAAQ,CAAC9Q,aAAT,IAA0B,GAJX;AAK9BkR,aAAS,EAAED,aAAa,GAAGH,QAAQ,CAACI,SAAZ,GAAwBrsB,SALlB;AAM9Bqb,WAAO,EAAE4Q,QAAQ,CAAC5Q,OANY;AAO9BqR,WAAO,EAAER,KAAK,CAACxf,GAAN,CAAW1e,CAAD,IAAOA,CAAC,CAACsgB,KAAnB;AAPqB,GAAf,IAQZ,IARL;AASA0d,UAAQ,CAACO,KAAT,CAAeC,IAAI,CAACC,SAAL,CAAe;AAC5BpgB,aAAS,EAAE4R,KAAK,CAAC5R,SADW;AAE5BC,WAAO,EAAEA,OAFmB;AAG5BsH,WAAO,EAAEA;AAHmB,GAAf,IAIV,IAJL;AAKD,CA9BD;;AAgCA,MAAM+Y,gBAAgB,GAAG,CAAC1O,KAAD,EAAQ6J,SAAR,KAAsB;AAC7CA,WAAS,GAAGA,SAAS,IAAI,EAAzB;;AACA,OAAK,IAAI/b,MAAT,IAAmBkS,KAAK,CAACD,MAAN,CAAakO,KAAhC,EAAuC;AACrC,UAAM3Z,QAAQ,GAAGpoB,IAAI,CAACK,IAAL,CAAUuqB,KAAK,CAAC5B,SAAN,CACvBpH,MAAM,CAACyH,MAAP,CAAc,CAAd,CADuB,EACLzH,MAAM,CAACyH,MAAP,CAAczH,MAAM,CAACyH,MAAP,CAAc5nB,MAAd,GAAuB,CAArC,CADK,CAAV,CAAjB;;AAEA,QAAI2mB,QAAQ,GAAGuV,SAAf,EAA0B;AACxB3xB,aAAO,CAAC1L,GAAR,kCAAsCwzB,KAAK,CAAC5R,SAA5C;AACA,YAAM2H,KAAK,GAAG2P,GAAG,CAACe,qBAAJ,CACVzG,KAAK,CAACD,MAAN,CAAa1R,OAAb,CAAqBP,MAAM,CAACA,MAA5B,CADU,CAAd;AAEA4I,YAAM,CAACX,KAAK,CAACpoB,MAAN,KAAiB,CAAlB,CAAN;AACA,YAAM+4B,OAAO,GAAGhB,GAAG,CAACkB,uBAAJ,CAA4B7Q,KAAK,CAAC,CAAD,CAAjC,EAAsC8T,SAAtC,CAAhB;AACA,UAAI8E,UAAU,GAAG,IAAjB;AACA,UAAIC,UAAU,GAAG,CAACnoB,QAAlB;;AACA,WAAK,IAAItF,KAAT,IAAkBulB,OAAlB,EAA2B;AACzB,cAAMvH,KAAK,GAAGrI,KAAK,CAAC5B,SAAN,CAAgB/T,KAAhB,EAAuB2M,MAAM,CAACyH,MAAP,CAAc,CAAd,CAAvB,CAAd;;AACA,YAAI4J,KAAK,GAAGyP,UAAZ,EAAwB;AACtBD,oBAAU,GAAGxtB,KAAb;AACAytB,oBAAU,GAAGzP,KAAb;AACD;AACF;;AACDzI,YAAM,CAACiY,UAAU,KAAK,IAAhB,CAAN;AACA7gB,YAAM,CAACyH,MAAP,GAAgB,CAACoZ,UAAD,EAAa7gB,MAAM,CAACyH,MAAP,CAAc,CAAd,CAAb,CAAhB;AACAoK,YAAM,CAACoC,IAAP,CAAY/B,KAAZ;AACD;AACF;AACF,CAzBD;;AA2BA,MAAM6O,0BAA0B,GAAI7O,KAAD,IAAW;AAC5C,QAAMrD,SAAS,GAAGvC,QAAQ,CAAC4F,KAAK,CAAC5tB,IAAN,CAAWioB,MAAX,CAAkB,CAAlB,CAAD,EAAuB,EAAvB,CAA1B;AACA,QAAMjM,SAAS,GAAG4J,MAAM,CAACmC,aAAP,CAAqBwC,SAArB,CAAlB;AACA,QAAMpqB,IAAI,GAAGqmB,MAAM,CAACY,gBAAP,CAAwBpL,SAAxB,CAAb;AACAsI,QAAM,CAACsJ,KAAK,CAAC8O,MAAN,IAAgB9O,KAAK,CAAC8O,MAAN,CAAa5O,QAAb,KAA0Bne,SAA3C,kBACUqM,SADV,wBAAN,CAJ4C,CAM5C;;AACA,MAAIsP,UAAU,GAAG3b,SAAjB;AACA,MAAI8b,MAAM,GAAG9b,SAAb;;AACA,MAAIxP,IAAI,CAACiP,UAAT,EAAqB;AACnB,UAAMA,UAAU,GAAGme,MAAM,CAAC7vB,GAAP,CAAWyC,IAAI,CAACiP,UAAhB,CAAnB;AACA,UAAMse,QAAQ,GAAG,CAACte,UAAU,IAAI;AAACse,cAAQ,EAAE;AAAX,KAAf,EAA+BA,QAAhD;AACA,UAAMG,IAAI,GAAGrH,MAAM,CAACY,gBAAP,CAAwBjnB,IAAI,CAACiP,UAA7B,CAAb;AACAkc,cAAU,GAAGoC,QAAQ,CAACpC,UAAT,IAAuBuC,IAAI,CAACvC,UAAzC;AACAG,UAAM,GAAGiC,QAAQ,CAACjC,MAAT,IAAmBoC,IAAI,CAACpC,MAAjC;AACD;;AACD,QAAMrI,MAAM,GAAG;AACbpH,aAAS,EAAEA,SADE;AAEbuO,aAAS,EAAEA,SAFE;AAGbmD,YAAQ,EAAE;AACRpC,gBAAU,EAAEA,UADJ;AAERC,eAAS,EAAEprB,IAAI,CAACorB,SAFR;AAGRC,kBAAY,EAAErrB,IAAI,CAACqrB,YAHX;AAIRC,YAAM,EAAEA,MAJA;AAKRxP,aAAO,EAAEtM;AALD,KAHG;AAUbge,UAAM,EAAE;AACNrO,UAAI,EAAEkc,6BAA6B,CAAC5N,KAAK,CAACtO,IAAP,CAD7B;AAENZ,aAAO,EAAEkP,KAAK,CAAC8O,MAAN,CAAahe,OAFhB;AAGNzC,aAAO,EAAE2R,KAAK,CAAC+O,OAAN,CAAc1gB,OAHjB;AAIN2f,cAAQ,EAAEjsB,SAJJ;AAKNksB,WAAK,EAAElsB,SALD;AAMNme,cAAQ,EAAEne;AANJ,KAVK;AAkBbP,cAAU,EAAEjP,IAAI,CAACiP,UAlBJ;AAmBbkY,eAAW,EAAEnnB,IAAI,CAACmnB;AAnBL,GAAf;AAqBAhD,QAAM,CAAClB,MAAM,CAACuK,MAAP,CAAcrO,IAAd,KAAuB3P,SAAxB,CAAN;AACA2U,QAAM,CAAClB,MAAM,CAACuK,MAAP,CAAcjP,OAAd,KAA0B/O,SAA3B,CAAN;AACA2U,QAAM,CAAClB,MAAM,CAACuK,MAAP,CAAc1R,OAAd,KAA0BtM,SAA3B,CAAN;AACA,SAAOyT,MAAP;AACD,CAzCD,C,CA2CA;;;AAEA,MAAMwZ,mBAAmB,GAAG,MAAM;AAChC,QAAMlW,EAAE,GAAGtB,GAAG,CAACjK,OAAJ,CAAY,IAAZ,CAAX;;AACA,QAAMmE,IAAI,GAAG8F,GAAG,CAACjK,OAAJ,CAAY,MAAZ,CAAb;;AACA,QAAM0hB,GAAG,GAAGtY,MAAM,EAAlB;AACA,QAAMmX,UAAU,GAAGhV,EAAE,CAACoW,iBAAH,CAAqBxd,IAAI,CAACgE,IAAL,CAAUuZ,GAAV,EAAe,gBAAf,CAArB,CAAnB;AACA,QAAMlB,QAAQ,GAAGjV,EAAE,CAACoW,iBAAH,CAAqBxd,IAAI,CAACgE,IAAL,CAAUuZ,GAAV,EAAe,cAAf,CAArB,CAAjB;AACAE,cAAY,CAACtB,SAAS,CAACC,UAAD,EAAaC,QAAb,CAAV,EAAmC,MAAM;AACnDD,cAAU,CAACzyB,GAAX;AACA0yB,YAAQ,CAAC1yB,GAAT;AACD,GAHW,CAAZ;AAID,CAVD;;AAYA,MAAM+zB,UAAU,GAAG,MAAM;AACvB,QAAMtW,EAAE,GAAGtB,GAAG,CAACjK,OAAJ,CAAY,IAAZ,CAAX;;AACA,QAAMmE,IAAI,GAAG8F,GAAG,CAACjK,OAAJ,CAAY,MAAZ,CAAb;;AACA,QAAM0hB,GAAG,GAAGtY,MAAM,EAAlB;AACA,QAAM0Y,SAAS,GAAG3d,IAAI,CAACgE,IAAL,CAAUuZ,GAAV,EAAe,OAAf,CAAlB;AACAnW,IAAE,CAACwW,SAAH,CAAaD,SAAb;AACAF,cAAY,CAAEnP,KAAD,IAAW;AACtB,UAAMrD,SAAS,GAAGqD,KAAK,CAAC5R,SAAN,CAAgBwO,WAAhB,CAA4B,CAA5B,CAAlB;AACA,UAAMjH,OAAO,GAAGqK,KAAK,CAACD,MAAN,CAAakO,KAAb,CAAmBxf,GAAnB,CAAwB1e,CAAD,IAAOA,CAAC,CAACwlB,MAAhC,CAAhB;AACA,UAAMlH,OAAO,GAAG2R,KAAK,CAACD,MAAN,CAAakO,KAAb,CAAmBxf,GAAnB,CACX1e,CAAD,IAAOiwB,KAAK,CAACD,MAAN,CAAa1R,OAAb,CAAqB8D,SAArB,CAA+BpiB,CAAC,CAAC+d,MAAjC,CADK,CAAhB;AAEA,UAAM2f,GAAG,GAAG8B,GAAG,CAACC,MAAJ,CAAW,WAAX,EAAwBza,gBAAgB,CAAC1G,OAAD,EAAUsH,OAAV,CAAxC,CAAZ;AACA,UAAM+P,GAAG,GAAG+H,GAAG,CAACte,OAAJ,CAAY,OAAZ,EAAqB,IAArB,EAA2BuB,KAA3B,CAAiC,IAAjC,EAAuCvS,KAAvC,CAA6C,CAA7C,EAAgD,CAAC,CAAjD,EAAoDuX,IAApD,CAAyD,IAAzD,CAAZ;AACAoD,MAAE,CAAC2W,aAAH,CAAiB/d,IAAI,CAACgE,IAAL,CAAU2Z,SAAV,YAAwB1S,SAAxB,UAAjB,EAA2D+I,GAA3D;AACD,GARW,EAQT,MAAM,CAAE,CARC,CAAZ;AASD,CAfD;;AAiBA,MAAMgK,qBAAqB,GAAInV,QAAD,IAAc;AAC1C,QAAMzB,EAAE,GAAGtB,GAAG,CAACjK,OAAJ,CAAY,IAAZ,CAAX;;AACA,QAAMmE,IAAI,GAAG8F,GAAG,CAACjK,OAAJ,CAAY,MAAZ,CAAb;;AACA,QAAMoN,QAAQ,GAAGjJ,IAAI,CAACgE,IAAL,CAAUiB,MAAM,EAAhB,EAAoB,QAApB,EAA8B4D,QAA9B,CAAjB;AACAzB,IAAE,CAACwB,QAAH,CAAYK,QAAZ,EAAsB,MAAtB,EAA8BrD,MAAM,CAACqY,eAAP,CAAuB,CAAC1Y,KAAD,EAAQ1kB,IAAR,KAAiB;AACpE,QAAI0kB,KAAJ,EAAW,MAAMA,KAAN;AACX,UAAM2C,KAAK,GAAGrnB,IAAI,CAACme,KAAL,CAAW,IAAX,EAAiBpC,MAAjB,CAAyBve,CAAD,IAAOA,CAAC,CAACpC,MAAF,GAAW,CAA1C,CAAd;AACAuK,WAAO,CAAC1L,GAAR,kBAAsBotB,KAAK,CAACjsB,MAA5B;AACA,QAAIiiC,QAAQ,GAAG,CAAf;AACA,QAAIlS,UAAU,GAAG,CAAjB;AACA,QAAIG,MAAM,GAAG,CAAb;;AACA,SAAK,IAAIhE,IAAT,IAAiBD,KAAjB,EAAwB;AACtB,UAAI;AACF,cAAMiW,SAAS,GAAGtB,IAAI,CAACuB,KAAL,CAAWjW,IAAX,CAAlB;AACA,cAAMkW,SAAS,GAAGlB,0BAA0B,CAACgB,SAAD,CAA5C;AACA,cAAM7P,KAAK,GAAGL,MAAM,CAAC7vB,GAAP,CAAWigC,SAAS,CAAC3hB,SAArB,CAAd;;AACA,YAAI4R,KAAK,IAAIA,KAAK,CAACD,MAAN,CAAaG,QAA1B,EAAoC;AAClChoB,iBAAO,CAAC1L,GAAR,mCAAuCwzB,KAAK,CAAC5R,SAA7C;AACA;AACD;;AACDuR,cAAM,CAACoC,IAAP,CAAYgO,SAAZ;AACAH,gBAAQ,IAAI,CAAZ;AACAlS,kBAAU,IAAIqS,SAAS,CAACjQ,QAAV,CAAmBpC,UAAnB,GAAgC,CAAhC,GAAoC,CAAlD;AACAG,cAAM,IAAIkS,SAAS,CAACjQ,QAAV,CAAmBjC,MAAnB,GAA4B,CAA5B,GAAgC,CAA1C;AACD,OAZD,CAYE,OAAO5G,KAAP,EAAc;AACd/e,eAAO,CAAC+e,KAAR,CAAcA,KAAd;AACD;AACF;;AACD/e,WAAO,CAAC1L,GAAR,iCAAqCojC,QAArC;AACA13B,WAAO,CAAC1L,GAAR,kCAAsCkxB,UAAtC;AACAxlB,WAAO,CAAC1L,GAAR,6BAAiCqxB,MAAjC;AACD,GA3B6B,CAA9B;AA4BD,CAhCD,C,CAkCA;AACA;;;AACA,MAAMsR,YAAY,GAAG,CAACa,kBAAD,EAAqBC,mBAArB,KAA6C;AAChE/3B,SAAO,CAAC1L,GAAR,CAAY,sBAAZ;;AACA,MAAIwjC,kBAAJ,EAAwB;AACtB,UAAME,UAAU,GACZvQ,MAAM,CAACpO,IAAP,CAAY,EAAZ,EAAgB;AAAC4e,YAAM,EAAE;AAACxT,iBAAS,EAAE;AAAZ,OAAT;AAAyB/c,UAAI,EAAE;AAAC+c,iBAAS,EAAE;AAAZ;AAA/B,KAAhB,EAAgEgE,KAAhE,EADJ;;AAEA,SAAK,IAAIpzB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2iC,UAAU,CAACviC,MAA/B,EAAuCJ,CAAC,EAAxC,EAA4C;AAC1C,YAAMyyB,KAAK,GAAGL,MAAM,CAACqB,OAAP,CAAe;AAACrE,iBAAS,EAAEuT,UAAU,CAAC3iC,CAAD,CAAV,CAAcovB;AAA1B,OAAf,CAAd;AACAjG,YAAM,CAACsJ,KAAD,EAAQ,kCAAR,CAAN;AACAgQ,wBAAkB,CAAChQ,KAAD,CAAlB;;AACA,UAAI,CAACzyB,CAAC,GAAG,CAAL,IAAU,IAAV,KAAmB,CAAvB,EAA0B;AACxB2K,eAAO,CAAC1L,GAAR,oBAAwBe,CAAC,GAAG,CAA5B;AACD;AACF;AACF;;AACD,MAAI0iC,mBAAJ,EAAyB;AACvBA,uBAAmB;AACpB;;AACD/3B,SAAO,CAAC1L,GAAR,CAAY,qBAAZ;AACD,CAlBD;;AAoBA8qB,MAAM,CAACmL,OAAP,CAAe;AACb,YAAU,MAAM;AACd7J,UAAM,CAACM,OAAP,CAAegC,IAAf,CAAoB5D,MAAM,CAACqY,eAAP,CAAuBX,mBAAvB,CAApB,EACelR,KADf,CACqB5lB,OAAO,CAAC+e,KAAR,CAAcqG,IAAd,CAAmBplB,OAAnB,CADrB;AAED,GAJY;AAKb,gBAAck3B,UALD;AAMb,2BAA0B7U,QAAD,IAAc;AACrC3B,UAAM,CAACM,OAAP,CAAegC,IAAf,CACI5D,MAAM,CAACqY,eAAP,CAAuB,MAAMD,qBAAqB,CAACnV,QAAD,CAAlD,CADJ,EAEeuD,KAFf,CAEqB5lB,OAAO,CAAC+e,KAAR,CAAcqG,IAAd,CAAmBplB,OAAnB,CAFrB;AAGD;AAVY,CAAf;AAaAof,MAAM,CAAC+F,OAAP,CAAe,MAAM;AACnBkS,KAAG,CAACa,eAAJ,CAAoB,WAApB,EAAiCC,MAAM,CAACC,OAAP,CAAe,gBAAf,CAAjC;AACA,QAAML,mBAAmB,GAAGluB,SAA5B;AACA,QAAMiuB,kBAAkB,GAAGjuB,SAA3B;;AACA,MAAI,CAACiuB,kBAAD,IAAuB,CAACC,mBAA5B,EAAiD;AAC/C;AACD;;AACD/3B,SAAO,CAAC1L,GAAR,CAAY,4BAAZ;;AACA,QAAM+jC,SAAS,GAAG,MAAMpB,YAAY,CAACa,kBAAD,EAAqBC,mBAArB,CAApC;;AACArX,QAAM,CAACM,OAAP,CAAegC,IAAf,CAAoB5D,MAAM,CAACqY,eAAP,CAAuBY,SAAvB,CAApB,EACezS,KADf,CACqB5lB,OAAO,CAAC+e,KAAR,CAAcqG,IAAd,CAAmBplB,OAAnB,CADrB;AAED,CAXD,E;;;;;;;;;;;AC/PA,IAAIye,MAAJ;AAAWzU,MAAM,CAAC2W,IAAP,CAAY,WAAZ,EAAwB;AAAClC,QAAM,CAACvqB,CAAD,EAAG;AAACuqB,UAAM,GAACvqB,CAAP;AAAS;;AAApB,CAAxB,EAA8C,CAA9C;AAAiD,IAAIwzB,QAAJ;AAAa1d,MAAM,CAAC2W,IAAP,CAAY,aAAZ,EAA0B;AAAC+G,UAAQ,CAACxzB,CAAD,EAAG;AAACwzB,YAAQ,GAACxzB,CAAT;AAAW;;AAAxB,CAA1B,EAAoD,CAApD;;AAGzE,MAAMokC,aAAa,GAAGhZ,GAAG,CAACjK,OAAJ,CAAY,eAAZ,CAAtB;;AACA,MAAMmE,IAAI,GAAG8F,GAAG,CAACjK,OAAJ,CAAY,MAAZ,CAAb;;AAEA,MAAMkjB,aAAa,GAAG,MAAM;AAC1B,SAAO/e,IAAI,CAACgE,IAAL,CAAUiB,MAAM,EAAhB,EAAoB,QAApB,EAA8B,QAA9B,CAAP;AACD,CAFD;;AAIAW,MAAM,CAACmL,OAAP,CAAe;AACbF,QAAM,GAAG;AACP,UAAM7Q,IAAI,GAAG+e,aAAa,EAA1B;AACAD,iBAAa,CAACE,KAAd,CAAoB,WAApB,EAAiC,CAAC,QAAD,EAAW,MAAX,EAAmB,OAAnB,EAA4Bhf,IAA5B,CAAjC;AACAkO,YAAQ,CAACgB,MAAT,CAAgB,EAAhB,EAAoB;AAACE,UAAI,EAAE;AAACyB,cAAM,EAAE;AAAT;AAAP,KAApB;AACD,GALY;;AAMboO,SAAO,GAAG;AACR,UAAMjf,IAAI,GAAG+e,aAAa,EAA1B;AACAv4B,WAAO,CAAC1L,GAAR,CAAYklB,IAAZ;AACA8e,iBAAa,CAACE,KAAd,CAAoB,cAApB,EAAoC,CAAC,QAAD,EAAW,MAAX,EAAmB,QAAnB,EAA6Bhf,IAA7B,CAApC;AACD;;AAVY,CAAf,E;;;;;;;;;;;ACVA,IAAIgF,MAAJ;AAAWxU,MAAM,CAAC2W,IAAP,CAAY,WAAZ,EAAwB;AAACnC,QAAM,CAACtqB,CAAD,EAAG;AAACsqB,UAAM,GAACtqB,CAAP;AAAS;;AAApB,CAAxB,EAA8C,CAA9C;AAAiD,IAAIuzB,MAAJ;AAAWzd,MAAM,CAAC2W,IAAP,CAAY,aAAZ,EAA0B;AAAC8G,QAAM,CAACvzB,CAAD,EAAG;AAACuzB,UAAM,GAACvzB,CAAP;AAAS;;AAApB,CAA1B,EAAgD,CAAhD;;AAGvE,SAASwkC,QAAT,CAAkB5V,MAAlB,EAA0B0N,UAA1B,EAAsC;AACpC,MAAImI,WAAW,GAAG,CAAlB;;AACA,OAAK,IAAItjC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGytB,MAAM,CAACrtB,MAA3B,EAAmCJ,CAAC,EAApC,EAAwC;AACtC,QAAIujC,yBAAyB,CAAC9V,MAAM,CAACztB,CAAD,CAAP,EAAYm7B,UAAZ,CAA7B,EAAsD;AACpDmI,iBAAW,IAAI,CAAf;AACD;AACF;;AACD,SAAOA,WAAW,GAAC7V,MAAM,CAACrtB,MAA1B;AACD;;AAED,SAASojC,gBAAT,GAA4B;AAC1B,MAAI/V,MAAM,GAAG2E,MAAM,CAACpO,IAAP,CAAY;AAAC,uBAAmB;AAApB,GAAZ,EAAuCoP,KAAvC,EAAb;;AACA,MAAIqQ,MAAM,GAAGxU,CAAC,CAACwU,MAAF,CAAShW,MAAT,EAAiB,GAAjB,CAAb;;AACA9iB,SAAO,CAAC1L,GAAR,CAAY,sBAAZ,EAAoCokC,QAAQ,CAACI,MAAD,EAASC,qBAAT,CAA5C;AAEA,MAAIC,aAAa,GAAG,EAApB;;AACA,OAAK,IAAI3jC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGytB,MAAM,CAACrtB,MAA3B,EAAmCJ,CAAC,EAApC,EAAwC;AACtC,QAAI4jC,UAAU,GAAGC,uBAAuB,CAACpW,MAAM,CAACztB,CAAD,CAAP,CAAxC;AACA,QAAI8jC,aAAa,GAAGF,UAAU,CAAC7iB,MAAX,CAAkB,UAASve,CAAT,EAAY;AAAE,aAAOA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAd;AAAkB,KAAlD,CAApB;AACA,QAAIuhC,aAAa,GAAGH,UAAU,CAAC7iB,MAAX,CAAkB,UAASve,CAAT,EAAY;AAAE,aAAOA,CAAC,CAAC,CAAD,CAAD,KAAS,CAAhB;AAAoB,KAApD,CAApB;;AACA,QAAIshC,aAAa,CAAC1jC,MAAd,GAAuB2jC,aAAa,CAAC3jC,MAAzC,EAAiD;AAC/C0jC,mBAAa,GAAG7U,CAAC,CAACwU,MAAF,CAASK,aAAT,EAAwBC,aAAa,CAAC3jC,MAAtC,CAAhB;AACD,KAFD,MAEO;AACL2jC,mBAAa,GAAG9U,CAAC,CAACwU,MAAF,CAASM,aAAT,EAAwBD,aAAa,CAAC1jC,MAAtC,CAAhB;AACD;;AACDwjC,cAAU,GAAGG,aAAa,CAAC/kB,MAAd,CAAqB8kB,aAArB,CAAb;;AACA,SAAK,IAAI/iC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6iC,UAAU,CAACxjC,MAA/B,EAAuCW,CAAC,EAAxC,EAA4C;AAC1C4iC,mBAAa,CAACrjC,IAAd,CAAmBsjC,UAAU,CAAC7iC,CAAD,CAA7B;AACD;AACF;;AACD4J,SAAO,CAAC1L,GAAR,CAAY,SAAS0kC,aAAa,CAACvjC,MAAvB,GAAgC,yBAA5C;AAEA,MAAI2M,GAAG,GAAG,IAAI3O,SAAS,CAACoN,GAAd,EAAV;AACAuB,KAAG,CAACpB,UAAJ,CAAe,CACb;AAACE,QAAI,EAAE,OAAP;AAAgB/F,UAAM,EAAE,CAAxB;AAA2BC,UAAM,EAAE,CAAnC;AAAsCV,aAAS,EAAE;AAAjD,GADa,EAEb;AAACwG,QAAI,EAAE,IAAP;AAAahE,eAAW,EAAE,CAA1B;AAA6BqE,cAAU,EAAE;AAAzC,GAFa,EAGb;AAACL,QAAI,EAAE,IAAP;AAAahE,eAAW,EAAE,CAA1B;AAA6BqE,cAAU,EAAE;AAAzC,GAHa,EAIb;AAACL,QAAI,EAAE,SAAP;AAAkBI,eAAW,EAAE;AAA/B,GAJa,CAAf;AAMA,MAAIyF,OAAO,GAAG,IAAItT,SAAS,CAAC0O,OAAd,CACVC,GADU,EACL;AAACK,UAAM,EAAE,UAAT;AAAqBF,YAAQ,EAAE,KAA/B;AAAsCC,cAAU,EAAE;AAAlD,GADK,CAAd;AAEA,MAAIujB,KAAK,GAAG,IAAItyB,SAAS,CAACyD,GAAd,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAAZ;;AACA,OAAK,IAAImiC,SAAS,GAAG,CAArB,EAAwBA,SAAS,GAAG,EAApC,EAAwCA,SAAS,EAAjD,EAAqD;AACnD,QAAI/6B,IAAI,GAAG,CAAX;;AACA,QAAIg7B,UAAU,GAAGhV,CAAC,CAACwU,MAAF,CAASE,aAAT,EAAwB,IAAxB,CAAjB;;AACA,SAAK,IAAI3jC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGikC,UAAU,CAAC7jC,MAA/B,EAAuCJ,CAAC,EAAxC,EAA4C;AAC1CmpB,YAAM,CAACuH,KAAK,CAAClwB,CAAN,CAAQJ,MAAR,KAAmB6jC,UAAU,CAACjkC,CAAD,CAAV,CAAc,CAAd,EAAiBI,MAArC,CAAN;AACAswB,WAAK,CAAClwB,CAAN,GAAUyjC,UAAU,CAACjkC,CAAD,CAAV,CAAc,CAAd,CAAV;AACA,UAAI4S,KAAK,GAAGlB,OAAO,CAAChE,KAAR,CAAcgjB,KAAd,EAAqBuT,UAAU,CAACjkC,CAAD,CAAV,CAAc,CAAd,CAArB,CAAZ;AACAmpB,YAAM,CAAC,CAACvpB,KAAK,CAACgT,KAAK,CAAC3J,IAAP,CAAP,CAAN;AACAA,UAAI,IAAI2J,KAAK,CAAC3J,IAAd;AACD;;AACD0B,WAAO,CAAC1L,GAAR,CAAY,WAAZ,EAAyB+kC,SAAzB,EAAoC,YAApC,EAAkD/6B,IAAI,GAACg7B,UAAU,CAAC7jC,MAAlE;AACD;;AACDuK,SAAO,CAAC1L,GAAR,CAAY,yBAAZ,EAAuC+hC,IAAI,CAACC,SAAL,CAAel0B,GAAG,CAACxJ,MAAJ,EAAf,CAAvC;;AAEA,WAAS2gC,cAAT,CAAwBrT,QAAxB,EAAkC;AAChC1H,UAAM,CAACuH,KAAK,CAAClwB,CAAN,CAAQJ,MAAR,KAAmBywB,QAAQ,CAACzwB,MAA7B,CAAN;AACAswB,SAAK,CAAClwB,CAAN,GAAUqwB,QAAV;AACA,QAAIC,OAAO,GAAG/jB,GAAG,CAAC3G,OAAJ,CAAYsqB,KAAZ,EAAmBlwB,CAAjC;AACA2oB,UAAM,CAAC2H,OAAO,CAAC1wB,MAAR,KAAmB,CAApB,CAAN;AACA,WAAO0wB,OAAO,CAAC,CAAD,CAAP,GAAaA,OAAO,CAAC,CAAD,CAA3B;AACD;;AACDnmB,SAAO,CAAC1L,GAAR,CAAY,sBAAZ,EAAoCokC,QAAQ,CAACI,MAAD,EAASS,cAAT,CAA5C;;AAEA,WAASC,mBAAT,CAA6BxT,MAA7B,EAAqC;AACnC,WAAO,UAASE,QAAT,EAAmB;AACxB,aAAO6S,qBAAqB,CAAC7S,QAAD,CAArB,GAAkCF,MAAM,GAACuT,cAAc,CAACrT,QAAD,CAA9D;AACD,KAFD;AAGD;;AACD,MAAIuT,OAAO,GAAG,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,EAAc,GAAd,EAAmB,GAAnB,EAAwB,GAAxB,EAA6B,GAA7B,EAAkC,GAAlC,EAAuC,GAAvC,EAA4C,GAA5C,EAAiD,CAAjD,CAAd;;AACA,OAAK,IAAIpkC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGokC,OAAO,CAAChkC,MAA5B,EAAoCJ,CAAC,EAArC,EAAyC;AACvC2K,WAAO,CAAC1L,GAAR,CAAY,QAAZ,EAAuBmlC,OAAO,CAACpkC,CAAD,CAA9B,EAAmC,oBAAnC,EACYqjC,QAAQ,CAACI,MAAD,EAASU,mBAAmB,CAACC,OAAO,CAACpkC,CAAD,CAAR,CAA5B,CADpB;AAED;AACF,C","file":"/app.js","sourcesContent":["var convnetjs = convnetjs || { REVISION: 'ALPHA' };\n(function(global) {\n  \"use strict\";\n\n  // Random number utilities\n  var return_v = false;\n  var v_val = 0.0;\n  var gaussRandom = function() {\n    if(return_v) { \n      return_v = false;\n      return v_val; \n    }\n    var u = 2*Math.random()-1;\n    var v = 2*Math.random()-1;\n    var r = u*u + v*v;\n    if(r == 0 || r > 1) return gaussRandom();\n    var c = Math.sqrt(-2*Math.log(r)/r);\n    v_val = v*c; // cache this\n    return_v = true;\n    return u*c;\n  }\n  var randf = function(a, b) { return Math.random()*(b-a)+a; }\n  var randi = function(a, b) { return Math.floor(Math.random()*(b-a)+a); }\n  var randn = function(mu, std){ return mu+gaussRandom()*std; }\n\n  // Array utilities\n  var zeros = function(n) {\n    if(typeof(n)==='undefined' || isNaN(n)) { return []; }\n    if(typeof ArrayBuffer === 'undefined') {\n      // lacking browser support\n      var arr = new Array(n);\n      for(var i=0;i<n;i++) { arr[i]= 0; }\n      return arr;\n    } else {\n      return new Float64Array(n);\n    }\n  }\n\n  var arrContains = function(arr, elt) {\n    for(var i=0,n=arr.length;i<n;i++) {\n      if(arr[i]===elt) return true;\n    }\n    return false;\n  }\n\n  var arrUnique = function(arr) {\n    var b = [];\n    for(var i=0,n=arr.length;i<n;i++) {\n      if(!arrContains(b, arr[i])) {\n        b.push(arr[i]);\n      }\n    }\n    return b;\n  }\n\n  // return max and min of a given non-empty array.\n  var maxmin = function(w) {\n    if(w.length === 0) { return {}; } // ... ;s\n    var maxv = w[0];\n    var minv = w[0];\n    var maxi = 0;\n    var mini = 0;\n    var n = w.length;\n    for(var i=1;i<n;i++) {\n      if(w[i] > maxv) { maxv = w[i]; maxi = i; } \n      if(w[i] < minv) { minv = w[i]; mini = i; } \n    }\n    return {maxi: maxi, maxv: maxv, mini: mini, minv: minv, dv:maxv-minv};\n  }\n\n  // create random permutation of numbers, in range [0...n-1]\n  var randperm = function(n) {\n    var i = n,\n        j = 0,\n        temp;\n    var array = [];\n    for(var q=0;q<n;q++)array[q]=q;\n    while (i--) {\n        j = Math.floor(Math.random() * (i+1));\n        temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    return array;\n  }\n\n  // sample from list lst according to probabilities in list probs\n  // the two lists are of same size, and probs adds up to 1\n  var weightedSample = function(lst, probs) {\n    var p = randf(0, 1.0);\n    var cumprob = 0.0;\n    for(var k=0,n=lst.length;k<n;k++) {\n      cumprob += probs[k];\n      if(p < cumprob) { return lst[k]; }\n    }\n  }\n\n  // syntactic sugar function for getting default parameter values\n  var getopt = function(opt, field_name, default_value) {\n    return typeof opt[field_name] !== 'undefined' ? opt[field_name] : default_value;\n  }\n\n  global.randf = randf;\n  global.randi = randi;\n  global.randn = randn;\n  global.zeros = zeros;\n  global.maxmin = maxmin;\n  global.randperm = randperm;\n  global.weightedSample = weightedSample;\n  global.arrUnique = arrUnique;\n  global.arrContains = arrContains;\n  global.getopt = getopt;\n  \n})(convnetjs);\n(function(global) {\n  \"use strict\";\n\n  // Vol is the basic building block of all data in a net.\n  // it is essentially just a 3D volume of numbers, with a\n  // width (sx), height (sy), and depth (depth).\n  // it is used to hold data for all filters, all volumes,\n  // all weights, and also stores all gradients w.r.t. \n  // the data. c is optionally a value to initialize the volume\n  // with. If c is missing, fills the Vol with random numbers.\n  var Vol = function(sx, sy, depth, c) {\n    // this is how you check if a variable is an array. Oh, Javascript :)\n    if(Object.prototype.toString.call(sx) === '[object Array]') {\n      // we were given a list in sx, assume 1D volume and fill it up\n      this.sx = 1;\n      this.sy = 1;\n      this.depth = sx.length;\n      // we have to do the following copy because we want to use\n      // fast typed arrays, not an ordinary javascript array\n      this.w = global.zeros(this.depth);\n      this.dw = global.zeros(this.depth);\n      for(var i=0;i<this.depth;i++) {\n        this.w[i] = sx[i];\n      }\n    } else {\n      // we were given dimensions of the vol\n      this.sx = sx;\n      this.sy = sy;\n      this.depth = depth;\n      var n = sx*sy*depth;\n      this.w = global.zeros(n);\n      this.dw = global.zeros(n);\n      if(typeof c === 'undefined') {\n        // weight normalization is done to equalize the output\n        // variance of every neuron, otherwise neurons with a lot\n        // of incoming connections have outputs of larger variance\n        var scale = Math.sqrt(1.0/(sx*sy*depth));\n        for(var i=0;i<n;i++) { \n          this.w[i] = global.randn(0.0, scale);\n        }\n      } else {\n        for(var i=0;i<n;i++) { \n          this.w[i] = c;\n        }\n      }\n    }\n  }\n\n  Vol.prototype = {\n    get: function(x, y, d) { \n      var ix=((this.sx * y)+x)*this.depth+d;\n      return this.w[ix];\n    },\n    set: function(x, y, d, v) { \n      var ix=((this.sx * y)+x)*this.depth+d;\n      this.w[ix] = v; \n    },\n    add: function(x, y, d, v) { \n      var ix=((this.sx * y)+x)*this.depth+d;\n      this.w[ix] += v; \n    },\n    get_grad: function(x, y, d) { \n      var ix = ((this.sx * y)+x)*this.depth+d;\n      return this.dw[ix]; \n    },\n    set_grad: function(x, y, d, v) { \n      var ix = ((this.sx * y)+x)*this.depth+d;\n      this.dw[ix] = v; \n    },\n    add_grad: function(x, y, d, v) { \n      var ix = ((this.sx * y)+x)*this.depth+d;\n      this.dw[ix] += v; \n    },\n    cloneAndZero: function() { return new Vol(this.sx, this.sy, this.depth, 0.0)},\n    clone: function() {\n      var V = new Vol(this.sx, this.sy, this.depth, 0.0);\n      var n = this.w.length;\n      for(var i=0;i<n;i++) { V.w[i] = this.w[i]; }\n      return V;\n    },\n    addFrom: function(V) { for(var k=0;k<this.w.length;k++) { this.w[k] += V.w[k]; }},\n    addFromScaled: function(V, a) { for(var k=0;k<this.w.length;k++) { this.w[k] += a*V.w[k]; }},\n    setConst: function(a) { for(var k=0;k<this.w.length;k++) { this.w[k] = a; }},\n\n    toJSON: function() {\n      // todo: we may want to only save d most significant digits to save space\n      var json = {}\n      json.sx = this.sx; \n      json.sy = this.sy;\n      json.depth = this.depth;\n      json.w = this.w;\n      return json;\n      // we wont back up gradients to save space\n    },\n    fromJSON: function(json) {\n      this.sx = json.sx;\n      this.sy = json.sy;\n      this.depth = json.depth;\n\n      var n = this.sx*this.sy*this.depth;\n      this.w = global.zeros(n);\n      this.dw = global.zeros(n);\n      // copy over the elements.\n      for(var i=0;i<n;i++) {\n        this.w[i] = json.w[i];\n      }\n    }\n  }\n\n  global.Vol = Vol;\n})(convnetjs);\n(function(global) {\n  \"use strict\";\n  var Vol = global.Vol; // convenience\n\n  // Volume utilities\n  // intended for use with data augmentation\n  // crop is the size of output\n  // dx,dy are offset wrt incoming volume, of the shift\n  // fliplr is boolean on whether we also want to flip left<->right\n  var augment = function(V, crop, dx, dy, fliplr) {\n    // note assumes square outputs of size crop x crop\n    if(typeof(fliplr)==='undefined') var fliplr = false;\n    if(typeof(dx)==='undefined') var dx = global.randi(0, V.sx - crop);\n    if(typeof(dy)==='undefined') var dy = global.randi(0, V.sy - crop);\n    \n    // randomly sample a crop in the input volume\n    var W;\n    if(crop !== V.sx || dx!==0 || dy!==0) {\n      W = new Vol(crop, crop, V.depth, 0.0);\n      for(var x=0;x<crop;x++) {\n        for(var y=0;y<crop;y++) {\n          if(x+dx<0 || x+dx>=V.sx || y+dy<0 || y+dy>=V.sy) continue; // oob\n          for(var d=0;d<V.depth;d++) {\n           W.set(x,y,d,V.get(x+dx,y+dy,d)); // copy data over\n          }\n        }\n      }\n    } else {\n      W = V;\n    }\n\n    if(fliplr) {\n      // flip volume horziontally\n      var W2 = W.cloneAndZero();\n      for(var x=0;x<W.sx;x++) {\n        for(var y=0;y<W.sy;y++) {\n          for(var d=0;d<W.depth;d++) {\n           W2.set(x,y,d,W.get(W.sx - x - 1,y,d)); // copy data over\n          }\n        }\n      }\n      W = W2; //swap\n    }\n    return W;\n  }\n\n  // img is a DOM element that contains a loaded image\n  // returns a Vol of size (W, H, 4). 4 is for RGBA\n  var img_to_vol = function(img, convert_grayscale) {\n\n    if(typeof(convert_grayscale)==='undefined') var convert_grayscale = false;\n\n    var canvas = document.createElement('canvas');\n    canvas.width = img.width;\n    canvas.height = img.height;\n    var ctx = canvas.getContext(\"2d\");\n\n    // due to a Firefox bug\n    try {\n      ctx.drawImage(img, 0, 0);\n    } catch (e) {\n      if (e.name === \"NS_ERROR_NOT_AVAILABLE\") {\n        // sometimes happens, lets just abort\n        return false;\n      } else {\n        throw e;\n      }\n    }\n\n    try {\n      var img_data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    } catch (e) {\n      if(e.name === 'IndexSizeError') {\n        return false; // not sure what causes this sometimes but okay abort\n      } else {\n        throw e;\n      }\n    }\n\n    // prepare the input: get pixels and normalize them\n    var p = img_data.data;\n    var W = img.width;\n    var H = img.height;\n    var pv = []\n    for(var i=0;i<p.length;i++) {\n      pv.push(p[i]/255.0-0.5); // normalize image pixels to [-0.5, 0.5]\n    }\n    var x = new Vol(W, H, 4, 0.0); //input volume (image)\n    x.w = pv;\n\n    if(convert_grayscale) {\n      // flatten into depth=1 array\n      var x1 = new Vol(W, H, 1, 0.0);\n      for(var i=0;i<W;i++) {\n        for(var j=0;j<H;j++) {\n          x1.set(i,j,0,x.get(i,j,0));\n        }\n      }\n      x = x1;\n    }\n\n    return x;\n  }\n  \n  global.augment = augment;\n  global.img_to_vol = img_to_vol;\n\n})(convnetjs);\n(function(global) {\n  \"use strict\";\n  var Vol = global.Vol; // convenience\n\n  // This file contains all layers that do dot products with input,\n  // but usually in a different connectivity pattern and weight sharing\n  // schemes: \n  // - FullyConn is fully connected dot products \n  // - ConvLayer does convolutions (so weight sharing spatially)\n  // putting them together in one file because they are very similar\n  var ConvLayer = function(opt) {\n    var opt = opt || {};\n\n    // required\n    this.out_depth = opt.filters;\n    this.sx = opt.sx; // filter size. Should be odd if possible, it's cleaner.\n    this.in_depth = opt.in_depth;\n    this.in_sx = opt.in_sx;\n    this.in_sy = opt.in_sy;\n    \n    // optional\n    this.sy = typeof opt.sy !== 'undefined' ? opt.sy : this.sx;\n    this.stride = typeof opt.stride !== 'undefined' ? opt.stride : 1; // stride at which we apply filters to input volume\n    this.pad = typeof opt.pad !== 'undefined' ? opt.pad : 0; // amount of 0 padding to add around borders of input volume\n    this.l1_decay_mul = typeof opt.l1_decay_mul !== 'undefined' ? opt.l1_decay_mul : 0.0;\n    this.l2_decay_mul = typeof opt.l2_decay_mul !== 'undefined' ? opt.l2_decay_mul : 1.0;\n\n    // computed\n    // note we are doing floor, so if the strided convolution of the filter doesnt fit into the input\n    // volume exactly, the output volume will be trimmed and not contain the (incomplete) computed\n    // final application.\n    this.out_sx = Math.floor((this.in_sx + this.pad * 2 - this.sx) / this.stride + 1);\n    this.out_sy = Math.floor((this.in_sy + this.pad * 2 - this.sy) / this.stride + 1);\n    this.layer_type = 'conv';\n\n    // initializations\n    var bias = typeof opt.bias_pref !== 'undefined' ? opt.bias_pref : 0.0;\n    this.filters = [];\n    for(var i=0;i<this.out_depth;i++) { this.filters.push(new Vol(this.sx, this.sy, this.in_depth)); }\n    this.biases = new Vol(1, 1, this.out_depth, bias);\n  }\n  ConvLayer.prototype = {\n    forward: function(V, is_training) {\n      // optimized code by @mdda that achieves 2x speedup over previous version\n\n      this.in_act = V;\n      var A = new Vol(this.out_sx |0, this.out_sy |0, this.out_depth |0, 0.0);\n      \n      var V_sx = V.sx |0;\n      var V_sy = V.sy |0;\n      var xy_stride = this.stride |0;\n\n      for(var d=0;d<this.out_depth;d++) {\n        var f = this.filters[d];\n        var x = -this.pad |0;\n        var y = -this.pad |0;\n        for(var ay=0; ay<this.out_sy; y+=xy_stride,ay++) {  // xy_stride\n          x = -this.pad |0;\n          for(var ax=0; ax<this.out_sx; x+=xy_stride,ax++) {  // xy_stride\n\n            // convolve centered at this particular location\n            var a = 0.0;\n            for(var fy=0;fy<f.sy;fy++) {\n              var oy = y+fy; // coordinates in the original input array coordinates\n              for(var fx=0;fx<f.sx;fx++) {\n                var ox = x+fx;\n                if(oy>=0 && oy<V_sy && ox>=0 && ox<V_sx) {\n                  for(var fd=0;fd<f.depth;fd++) {\n                    // avoid function call overhead (x2) for efficiency, compromise modularity :(\n                    a += f.w[((f.sx * fy)+fx)*f.depth+fd] * V.w[((V_sx * oy)+ox)*V.depth+fd];\n                  }\n                }\n              }\n            }\n            a += this.biases.w[d];\n            A.set(ax, ay, d, a);\n          }\n        }\n      }\n      this.out_act = A;\n      return this.out_act;\n    },\n    backward: function() {\n\n      var V = this.in_act;\n      V.dw = global.zeros(V.w.length); // zero out gradient wrt bottom data, we're about to fill it\n\n      var V_sx = V.sx |0;\n      var V_sy = V.sy |0;\n      var xy_stride = this.stride |0;\n\n      for(var d=0;d<this.out_depth;d++) {\n        var f = this.filters[d];\n        var x = -this.pad |0;\n        var y = -this.pad |0;\n        for(var ay=0; ay<this.out_sy; y+=xy_stride,ay++) {  // xy_stride\n          x = -this.pad |0;\n          for(var ax=0; ax<this.out_sx; x+=xy_stride,ax++) {  // xy_stride\n\n            // convolve centered at this particular location\n            var chain_grad = this.out_act.get_grad(ax,ay,d); // gradient from above, from chain rule\n            for(var fy=0;fy<f.sy;fy++) {\n              var oy = y+fy; // coordinates in the original input array coordinates\n              for(var fx=0;fx<f.sx;fx++) {\n                var ox = x+fx;\n                if(oy>=0 && oy<V_sy && ox>=0 && ox<V_sx) {\n                  for(var fd=0;fd<f.depth;fd++) {\n                    // avoid function call overhead (x2) for efficiency, compromise modularity :(\n                    var ix1 = ((V_sx * oy)+ox)*V.depth+fd;\n                    var ix2 = ((f.sx * fy)+fx)*f.depth+fd;\n                    f.dw[ix2] += V.w[ix1]*chain_grad;\n                    V.dw[ix1] += f.w[ix2]*chain_grad;\n                  }\n                }\n              }\n            }\n            this.biases.dw[d] += chain_grad;\n          }\n        }\n      }\n    },\n    getParamsAndGrads: function() {\n      var response = [];\n      for(var i=0;i<this.out_depth;i++) {\n        response.push({params: this.filters[i].w, grads: this.filters[i].dw, l2_decay_mul: this.l2_decay_mul, l1_decay_mul: this.l1_decay_mul});\n      }\n      response.push({params: this.biases.w, grads: this.biases.dw, l1_decay_mul: 0.0, l2_decay_mul: 0.0});\n      return response;\n    },\n    toJSON: function() {\n      var json = {};\n      json.sx = this.sx; // filter size in x, y dims\n      json.sy = this.sy;\n      json.stride = this.stride;\n      json.in_depth = this.in_depth;\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      json.l1_decay_mul = this.l1_decay_mul;\n      json.l2_decay_mul = this.l2_decay_mul;\n      json.pad = this.pad;\n      json.filters = [];\n      for(var i=0;i<this.filters.length;i++) {\n        json.filters.push(this.filters[i].toJSON());\n      }\n      json.biases = this.biases.toJSON();\n      return json;\n    },\n    fromJSON: function(json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n      this.sx = json.sx; // filter size in x, y dims\n      this.sy = json.sy;\n      this.stride = json.stride;\n      this.in_depth = json.in_depth; // depth of input volume\n      this.filters = [];\n      this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;\n      this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;\n      this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;\n      for(var i=0;i<json.filters.length;i++) {\n        var v = new Vol(0,0,0,0);\n        v.fromJSON(json.filters[i]);\n        this.filters.push(v);\n      }\n      this.biases = new Vol(0,0,0,0);\n      this.biases.fromJSON(json.biases);\n    }\n  }\n\n  var FullyConnLayer = function(opt) {\n    var opt = opt || {};\n\n    // required\n    // ok fine we will allow 'filters' as the word as well\n    this.out_depth = typeof opt.num_neurons !== 'undefined' ? opt.num_neurons : opt.filters;\n\n    // optional \n    this.l1_decay_mul = typeof opt.l1_decay_mul !== 'undefined' ? opt.l1_decay_mul : 0.0;\n    this.l2_decay_mul = typeof opt.l2_decay_mul !== 'undefined' ? opt.l2_decay_mul : 1.0;\n\n    // computed\n    this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;\n    this.out_sx = 1;\n    this.out_sy = 1;\n    this.layer_type = 'fc';\n\n    // initializations\n    var bias = typeof opt.bias_pref !== 'undefined' ? opt.bias_pref : 0.0;\n    this.filters = [];\n    for(var i=0;i<this.out_depth ;i++) { this.filters.push(new Vol(1, 1, this.num_inputs)); }\n    this.biases = new Vol(1, 1, this.out_depth, bias);\n  }\n\n  FullyConnLayer.prototype = {\n    forward: function(V, is_training) {\n      this.in_act = V;\n      var A = new Vol(1, 1, this.out_depth, 0.0);\n      var Vw = V.w;\n      for(var i=0;i<this.out_depth;i++) {\n        var a = 0.0;\n        var wi = this.filters[i].w;\n        for(var d=0;d<this.num_inputs;d++) {\n          a += Vw[d] * wi[d]; // for efficiency use Vols directly for now\n        }\n        a += this.biases.w[i];\n        A.w[i] = a;\n      }\n      this.out_act = A;\n      return this.out_act;\n    },\n    backward: function() {\n      var V = this.in_act;\n      V.dw = global.zeros(V.w.length); // zero out the gradient in input Vol\n      \n      // compute gradient wrt weights and data\n      for(var i=0;i<this.out_depth;i++) {\n        var tfi = this.filters[i];\n        var chain_grad = this.out_act.dw[i];\n        for(var d=0;d<this.num_inputs;d++) {\n          V.dw[d] += tfi.w[d]*chain_grad; // grad wrt input data\n          tfi.dw[d] += V.w[d]*chain_grad; // grad wrt params\n        }\n        this.biases.dw[i] += chain_grad;\n      }\n    },\n    getParamsAndGrads: function() {\n      var response = [];\n      for(var i=0;i<this.out_depth;i++) {\n        response.push({params: this.filters[i].w, grads: this.filters[i].dw, l1_decay_mul: this.l1_decay_mul, l2_decay_mul: this.l2_decay_mul});\n      }\n      response.push({params: this.biases.w, grads: this.biases.dw, l1_decay_mul: 0.0, l2_decay_mul: 0.0});\n      return response;\n    },\n    toJSON: function() {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      json.num_inputs = this.num_inputs;\n      json.l1_decay_mul = this.l1_decay_mul;\n      json.l2_decay_mul = this.l2_decay_mul;\n      json.filters = [];\n      for(var i=0;i<this.filters.length;i++) {\n        json.filters.push(this.filters[i].toJSON());\n      }\n      json.biases = this.biases.toJSON();\n      return json;\n    },\n    fromJSON: function(json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n      this.num_inputs = json.num_inputs;\n      this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;\n      this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;\n      this.filters = [];\n      for(var i=0;i<json.filters.length;i++) {\n        var v = new Vol(0,0,0,0);\n        v.fromJSON(json.filters[i]);\n        this.filters.push(v);\n      }\n      this.biases = new Vol(0,0,0,0);\n      this.biases.fromJSON(json.biases);\n    }\n  }\n\n  global.ConvLayer = ConvLayer;\n  global.FullyConnLayer = FullyConnLayer;\n  \n})(convnetjs);\n(function(global) {\n  \"use strict\";\n  var Vol = global.Vol; // convenience\n  \n  var PoolLayer = function(opt) {\n\n    var opt = opt || {};\n\n    // required\n    this.sx = opt.sx; // filter size\n    this.in_depth = opt.in_depth;\n    this.in_sx = opt.in_sx;\n    this.in_sy = opt.in_sy;\n\n    // optional\n    this.sy = typeof opt.sy !== 'undefined' ? opt.sy : this.sx;\n    this.stride = typeof opt.stride !== 'undefined' ? opt.stride : 2;\n    this.pad = typeof opt.pad !== 'undefined' ? opt.pad : 0; // amount of 0 padding to add around borders of input volume\n\n    // computed\n    this.out_depth = this.in_depth;\n    this.out_sx = Math.floor((this.in_sx + this.pad * 2 - this.sx) / this.stride + 1);\n    this.out_sy = Math.floor((this.in_sy + this.pad * 2 - this.sy) / this.stride + 1);\n    this.layer_type = 'pool';\n    // store switches for x,y coordinates for where the max comes from, for each output neuron\n    this.switchx = global.zeros(this.out_sx*this.out_sy*this.out_depth);\n    this.switchy = global.zeros(this.out_sx*this.out_sy*this.out_depth);\n  }\n\n  PoolLayer.prototype = {\n    forward: function(V, is_training) {\n      this.in_act = V;\n\n      var A = new Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);\n      \n      var n=0; // a counter for switches\n      for(var d=0;d<this.out_depth;d++) {\n        var x = -this.pad;\n        var y = -this.pad;\n        for(var ax=0; ax<this.out_sx; x+=this.stride,ax++) {\n          y = -this.pad;\n          for(var ay=0; ay<this.out_sy; y+=this.stride,ay++) {\n\n            // convolve centered at this particular location\n            var a = -99999; // hopefully small enough ;\\\n            var winx=-1,winy=-1;\n            for(var fx=0;fx<this.sx;fx++) {\n              for(var fy=0;fy<this.sy;fy++) {\n                var oy = y+fy;\n                var ox = x+fx;\n                if(oy>=0 && oy<V.sy && ox>=0 && ox<V.sx) {\n                  var v = V.get(ox, oy, d);\n                  // perform max pooling and store pointers to where\n                  // the max came from. This will speed up backprop \n                  // and can help make nice visualizations in future\n                  if(v > a) { a = v; winx=ox; winy=oy;}\n                }\n              }\n            }\n            this.switchx[n] = winx;\n            this.switchy[n] = winy;\n            n++;\n            A.set(ax, ay, d, a);\n          }\n        }\n      }\n      this.out_act = A;\n      return this.out_act;\n    },\n    backward: function() { \n      // pooling layers have no parameters, so simply compute \n      // gradient wrt data here\n      var V = this.in_act;\n      V.dw = global.zeros(V.w.length); // zero out gradient wrt data\n      var A = this.out_act; // computed in forward pass \n\n      var n = 0;\n      for(var d=0;d<this.out_depth;d++) {\n        var x = -this.pad;\n        var y = -this.pad;\n        for(var ax=0; ax<this.out_sx; x+=this.stride,ax++) {\n          y = -this.pad;\n          for(var ay=0; ay<this.out_sy; y+=this.stride,ay++) {\n\n            var chain_grad = this.out_act.get_grad(ax,ay,d);\n            V.add_grad(this.switchx[n], this.switchy[n], d, chain_grad);\n            n++;\n\n          }\n        }\n      }\n    },\n    getParamsAndGrads: function() {\n      return [];\n    },\n    toJSON: function() {\n      var json = {};\n      json.sx = this.sx;\n      json.sy = this.sy;\n      json.stride = this.stride;\n      json.in_depth = this.in_depth;\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      json.pad = this.pad;\n      return json;\n    },\n    fromJSON: function(json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n      this.sx = json.sx;\n      this.sy = json.sy;\n      this.stride = json.stride;\n      this.in_depth = json.in_depth;\n      this.pad = typeof json.pad !== 'undefined' ? json.pad : 0; // backwards compatibility\n      this.switchx = global.zeros(this.out_sx*this.out_sy*this.out_depth); // need to re-init these appropriately\n      this.switchy = global.zeros(this.out_sx*this.out_sy*this.out_depth);\n    }\n  }\n\n  global.PoolLayer = PoolLayer;\n\n})(convnetjs);\n\n(function(global) {\n  \"use strict\";\n  var Vol = global.Vol; // convenience\n  \n  var InputLayer = function(opt) {\n    var opt = opt || {};\n\n    // this is a bit silly but lets allow people to specify either ins or outs\n    this.out_sx = typeof opt.out_sx !== 'undefined' ? opt.out_sx : opt.in_sx;\n    this.out_sy = typeof opt.out_sy !== 'undefined' ? opt.out_sy : opt.in_sy;\n    this.out_depth = typeof opt.out_depth !== 'undefined' ? opt.out_depth : opt.in_depth;\n    this.layer_type = 'input';\n  }\n  InputLayer.prototype = {\n    forward: function(V, is_training) {\n      this.in_act = V;\n      this.out_act = V;\n      return this.out_act; // dummy identity function for now\n    },\n    backward: function() { },\n    getParamsAndGrads: function() {\n      return [];\n    },\n    toJSON: function() {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      return json;\n    },\n    fromJSON: function(json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type; \n    }\n  }\n\n  global.InputLayer = InputLayer;\n})(convnetjs);\n(function(global) {\n  \"use strict\";\n  var Vol = global.Vol; // convenience\n  \n  // Layers that implement a loss. Currently these are the layers that \n  // can initiate a backward() pass. In future we probably want a more \n  // flexible system that can accomodate multiple losses to do multi-task\n  // learning, and stuff like that. But for now, one of the layers in this\n  // file must be the final layer in a Net.\n\n  // This is a classifier, with N discrete classes from 0 to N-1\n  // it gets a stream of N incoming numbers and computes the softmax\n  // function (exponentiate and normalize to sum to 1 as probabilities should)\n  var SoftmaxLayer = function(opt) {\n    var opt = opt || {};\n\n    // computed\n    this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;\n    this.out_depth = this.num_inputs;\n    this.out_sx = 1;\n    this.out_sy = 1;\n    this.layer_type = 'softmax';\n  }\n\n  SoftmaxLayer.prototype = {\n    forward: function(V, is_training) {\n      this.in_act = V;\n\n      var A = new Vol(1, 1, this.out_depth, 0.0);\n\n      // compute max activation\n      var as = V.w;\n      var amax = V.w[0];\n      for(var i=1;i<this.out_depth;i++) {\n        if(as[i] > amax) amax = as[i];\n      }\n\n      // compute exponentials (carefully to not blow up)\n      var es = global.zeros(this.out_depth);\n      var esum = 0.0;\n      for(var i=0;i<this.out_depth;i++) {\n        var e = Math.exp(as[i] - amax);\n        esum += e;\n        es[i] = e;\n      }\n\n      // normalize and output to sum to one\n      for(var i=0;i<this.out_depth;i++) {\n        es[i] /= esum;\n        A.w[i] = es[i];\n      }\n\n      this.es = es; // save these for backprop\n      this.out_act = A;\n      return this.out_act;\n    },\n    backward: function(y) {\n\n      // compute and accumulate gradient wrt weights and bias of this layer\n      var x = this.in_act;\n      x.dw = global.zeros(x.w.length); // zero out the gradient of input Vol\n\n      for(var i=0;i<this.out_depth;i++) {\n        var indicator = i === y ? 1.0 : 0.0;\n        var mul = -(indicator - this.es[i]);\n        x.dw[i] = mul;\n      }\n\n      // loss is the class negative log likelihood\n      return -Math.log(this.es[y]);\n    },\n    getParamsAndGrads: function() { \n      return [];\n    },\n    toJSON: function() {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      json.num_inputs = this.num_inputs;\n      return json;\n    },\n    fromJSON: function(json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n      this.num_inputs = json.num_inputs;\n    }\n  }\n\n  // implements an L2 regression cost layer,\n  // so penalizes \\sum_i(||x_i - y_i||^2), where x is its input\n  // and y is the user-provided array of \"correct\" values.\n  var RegressionLayer = function(opt) {\n    var opt = opt || {};\n\n    // computed\n    this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;\n    this.out_depth = this.num_inputs;\n    this.out_sx = 1;\n    this.out_sy = 1;\n    this.layer_type = 'regression';\n  }\n\n  RegressionLayer.prototype = {\n    forward: function(V, is_training) {\n      this.in_act = V;\n      this.out_act = V;\n      return V; // identity function\n    },\n    // y is a list here of size num_inputs\n    backward: function(y) { \n\n      // compute and accumulate gradient wrt weights and bias of this layer\n      var x = this.in_act;\n      x.dw = global.zeros(x.w.length); // zero out the gradient of input Vol\n      var loss = 0.0;\n      if(y instanceof Array || y instanceof Float64Array) {\n        for(var i=0;i<this.out_depth;i++) {\n          var dy = x.w[i] - y[i];\n          x.dw[i] = dy;\n          loss += 2*dy*dy;\n        }\n      } else {\n        // assume it is a struct with entries .dim and .val\n        // and we pass gradient only along dimension dim to be equal to val\n        var i = y.dim;\n        var yi = y.val;\n        var dy = x.w[i] - yi;\n        x.dw[i] = dy;\n        loss += 2*dy*dy;\n      }\n      return loss;\n    },\n    getParamsAndGrads: function() { \n      return [];\n    },\n    toJSON: function() {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      json.num_inputs = this.num_inputs;\n      return json;\n    },\n    fromJSON: function(json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n      this.num_inputs = json.num_inputs;\n    }\n  }\n\n  var SVMLayer = function(opt) {\n    var opt = opt || {};\n\n    // computed\n    this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;\n    this.out_depth = this.num_inputs;\n    this.out_sx = 1;\n    this.out_sy = 1;\n    this.layer_type = 'svm';\n  }\n\n  SVMLayer.prototype = {\n    forward: function(V, is_training) {\n      this.in_act = V;\n      this.out_act = V; // nothing to do, output raw scores\n      return V;\n    },\n    backward: function(y) {\n\n      // compute and accumulate gradient wrt weights and bias of this layer\n      var x = this.in_act;\n      x.dw = global.zeros(x.w.length); // zero out the gradient of input Vol\n\n      var yscore = x.w[y]; // score of ground truth\n      var margin = 1.0;\n      var loss = 0.0;\n      for(var i=0;i<this.out_depth;i++) {\n        if(-yscore + x.w[i] + margin > 0) {\n          // violating example, apply loss\n          // I love hinge loss, by the way. Truly.\n          // Seriously, compare this SVM code with Softmax forward AND backprop code above\n          // it's clear which one is superior, not only in code, simplicity\n          // and beauty, but also in practice.\n          x.dw[i] += 1;\n          x.dw[y] -= 1;\n          loss += -yscore + x.w[i] + margin;\n        }\n      }\n\n      return loss;\n    },\n    getParamsAndGrads: function() { \n      return [];\n    },\n    toJSON: function() {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      json.num_inputs = this.num_inputs;\n      return json;\n    },\n    fromJSON: function(json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type;\n      this.num_inputs = json.num_inputs;\n    }\n  }\n  \n  global.RegressionLayer = RegressionLayer;\n  global.SoftmaxLayer = SoftmaxLayer;\n  global.SVMLayer = SVMLayer;\n\n})(convnetjs);\n\n(function(global) {\n  \"use strict\";\n  var Vol = global.Vol; // convenience\n  \n  // Implements ReLU nonlinearity elementwise\n  // x -> max(0, x)\n  // the output is in [0, inf)\n  var ReluLayer = function(opt) {\n    var opt = opt || {};\n\n    // computed\n    this.out_sx = opt.in_sx;\n    this.out_sy = opt.in_sy;\n    this.out_depth = opt.in_depth;\n    this.layer_type = 'relu';\n  }\n  ReluLayer.prototype = {\n    forward: function(V, is_training) {\n      this.in_act = V;\n      var V2 = V.clone();\n      var N = V.w.length;\n      var V2w = V2.w;\n      for(var i=0;i<N;i++) { \n        if(V2w[i] < 0) V2w[i] = 0; // threshold at 0\n      }\n      this.out_act = V2;\n      return this.out_act;\n    },\n    backward: function() {\n      var V = this.in_act; // we need to set dw of this\n      var V2 = this.out_act;\n      var N = V.w.length;\n      V.dw = global.zeros(N); // zero out gradient wrt data\n      for(var i=0;i<N;i++) {\n        if(V2.w[i] <= 0) V.dw[i] = 0; // threshold\n        else V.dw[i] = V2.dw[i];\n      }\n    },\n    getParamsAndGrads: function() {\n      return [];\n    },\n    toJSON: function() {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      return json;\n    },\n    fromJSON: function(json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type; \n    }\n  }\n\n  // Implements Sigmoid nnonlinearity elementwise\n  // x -> 1/(1+e^(-x))\n  // so the output is between 0 and 1.\n  var SigmoidLayer = function(opt) {\n    var opt = opt || {};\n\n    // computed\n    this.out_sx = opt.in_sx;\n    this.out_sy = opt.in_sy;\n    this.out_depth = opt.in_depth;\n    this.layer_type = 'sigmoid';\n  }\n  SigmoidLayer.prototype = {\n    forward: function(V, is_training) {\n      this.in_act = V;\n      var V2 = V.cloneAndZero();\n      var N = V.w.length;\n      var V2w = V2.w;\n      var Vw = V.w;\n      for(var i=0;i<N;i++) { \n        V2w[i] = 1.0/(1.0+Math.exp(-Vw[i]));\n      }\n      this.out_act = V2;\n      return this.out_act;\n    },\n    backward: function() {\n      var V = this.in_act; // we need to set dw of this\n      var V2 = this.out_act;\n      var N = V.w.length;\n      V.dw = global.zeros(N); // zero out gradient wrt data\n      for(var i=0;i<N;i++) {\n        var v2wi = V2.w[i];\n        V.dw[i] =  v2wi * (1.0 - v2wi) * V2.dw[i];\n      }\n    },\n    getParamsAndGrads: function() {\n      return [];\n    },\n    toJSON: function() {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      return json;\n    },\n    fromJSON: function(json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type; \n    }\n  }\n\n  // Implements Maxout nnonlinearity that computes\n  // x -> max(x)\n  // where x is a vector of size group_size. Ideally of course,\n  // the input size should be exactly divisible by group_size\n  var MaxoutLayer = function(opt) {\n    var opt = opt || {};\n\n    // required\n    this.group_size = typeof opt.group_size !== 'undefined' ? opt.group_size : 2;\n\n    // computed\n    this.out_sx = opt.in_sx;\n    this.out_sy = opt.in_sy;\n    this.out_depth = Math.floor(opt.in_depth / this.group_size);\n    this.layer_type = 'maxout';\n\n    this.switches = global.zeros(this.out_sx*this.out_sy*this.out_depth); // useful for backprop\n  }\n  MaxoutLayer.prototype = {\n    forward: function(V, is_training) {\n      this.in_act = V;\n      var N = this.out_depth; \n      var V2 = new Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);\n\n      // optimization branch. If we're operating on 1D arrays we dont have\n      // to worry about keeping track of x,y,d coordinates inside\n      // input volumes. In convnets we do :(\n      if(this.out_sx === 1 && this.out_sy === 1) {\n        for(var i=0;i<N;i++) {\n          var ix = i * this.group_size; // base index offset\n          var a = V.w[ix];\n          var ai = 0;\n          for(var j=1;j<this.group_size;j++) {\n            var a2 = V.w[ix+j];\n            if(a2 > a) {\n              a = a2;\n              ai = j;\n            }\n          }\n          V2.w[i] = a;\n          this.switches[i] = ix + ai;\n        }\n      } else {\n        var n=0; // counter for switches\n        for(var x=0;x<V.sx;x++) {\n          for(var y=0;y<V.sy;y++) {\n            for(var i=0;i<N;i++) {\n              var ix = i * this.group_size;\n              var a = V.get(x, y, ix);\n              var ai = 0;\n              for(var j=1;j<this.group_size;j++) {\n                var a2 = V.get(x, y, ix+j);\n                if(a2 > a) {\n                  a = a2;\n                  ai = j;\n                }\n              }\n              V2.set(x,y,i,a);\n              this.switches[n] = ix + ai;\n              n++;\n            }\n          }\n        }\n\n      }\n      this.out_act = V2;\n      return this.out_act;\n    },\n    backward: function() {\n      var V = this.in_act; // we need to set dw of this\n      var V2 = this.out_act;\n      var N = this.out_depth;\n      V.dw = global.zeros(V.w.length); // zero out gradient wrt data\n\n      // pass the gradient through the appropriate switch\n      if(this.out_sx === 1 && this.out_sy === 1) {\n        for(var i=0;i<N;i++) {\n          var chain_grad = V2.dw[i];\n          V.dw[this.switches[i]] = chain_grad;\n        }\n      } else {\n        // bleh okay, lets do this the hard way\n        var n=0; // counter for switches\n        for(var x=0;x<V2.sx;x++) {\n          for(var y=0;y<V2.sy;y++) {\n            for(var i=0;i<N;i++) {\n              var chain_grad = V2.get_grad(x,y,i);\n              V.set_grad(x,y,this.switches[n],chain_grad);\n              n++;\n            }\n          }\n        }\n      }\n    },\n    getParamsAndGrads: function() {\n      return [];\n    },\n    toJSON: function() {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      json.group_size = this.group_size;\n      return json;\n    },\n    fromJSON: function(json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type; \n      this.group_size = json.group_size;\n      this.switches = global.zeros(this.group_size);\n    }\n  }\n\n  // a helper function, since tanh is not yet part of ECMAScript. Will be in v6.\n  function tanh(x) {\n    var y = Math.exp(2 * x);\n    return (y - 1) / (y + 1);\n  }\n  // Implements Tanh nnonlinearity elementwise\n  // x -> tanh(x) \n  // so the output is between -1 and 1.\n  var TanhLayer = function(opt) {\n    var opt = opt || {};\n\n    // computed\n    this.out_sx = opt.in_sx;\n    this.out_sy = opt.in_sy;\n    this.out_depth = opt.in_depth;\n    this.layer_type = 'tanh';\n  }\n  TanhLayer.prototype = {\n    forward: function(V, is_training) {\n      this.in_act = V;\n      var V2 = V.cloneAndZero();\n      var N = V.w.length;\n      for(var i=0;i<N;i++) { \n        V2.w[i] = tanh(V.w[i]);\n      }\n      this.out_act = V2;\n      return this.out_act;\n    },\n    backward: function() {\n      var V = this.in_act; // we need to set dw of this\n      var V2 = this.out_act;\n      var N = V.w.length;\n      V.dw = global.zeros(N); // zero out gradient wrt data\n      for(var i=0;i<N;i++) {\n        var v2wi = V2.w[i];\n        V.dw[i] = (1.0 - v2wi * v2wi) * V2.dw[i];\n      }\n    },\n    getParamsAndGrads: function() {\n      return [];\n    },\n    toJSON: function() {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      return json;\n    },\n    fromJSON: function(json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type; \n    }\n  }\n  \n  global.TanhLayer = TanhLayer;\n  global.MaxoutLayer = MaxoutLayer;\n  global.ReluLayer = ReluLayer;\n  global.SigmoidLayer = SigmoidLayer;\n\n})(convnetjs);\n\n(function(global) {\n  \"use strict\";\n  var Vol = global.Vol; // convenience\n\n  // An inefficient dropout layer\n  // Note this is not most efficient implementation since the layer before\n  // computed all these activations and now we're just going to drop them :(\n  // same goes for backward pass. Also, if we wanted to be efficient at test time\n  // we could equivalently be clever and upscale during train and copy pointers during test\n  // todo: make more efficient.\n  var DropoutLayer = function(opt) {\n    var opt = opt || {};\n\n    // computed\n    this.out_sx = opt.in_sx;\n    this.out_sy = opt.in_sy;\n    this.out_depth = opt.in_depth;\n    this.layer_type = 'dropout';\n    this.drop_prob = typeof opt.drop_prob !== 'undefined' ? opt.drop_prob : 0.5;\n    this.dropped = global.zeros(this.out_sx*this.out_sy*this.out_depth);\n  }\n  DropoutLayer.prototype = {\n    forward: function(V, is_training) {\n      this.in_act = V;\n      if(typeof(is_training)==='undefined') { is_training = false; } // default is prediction mode\n      var V2 = V.clone();\n      var N = V.w.length;\n      if(is_training) {\n        // do dropout\n        for(var i=0;i<N;i++) {\n          if(Math.random()<this.drop_prob) { V2.w[i]=0; this.dropped[i] = true; } // drop!\n          else {this.dropped[i] = false;}\n        }\n      } else {\n        // scale the activations during prediction\n        for(var i=0;i<N;i++) { V2.w[i]*=this.drop_prob; }\n      }\n      this.out_act = V2;\n      return this.out_act; // dummy identity function for now\n    },\n    backward: function() {\n      var V = this.in_act; // we need to set dw of this\n      var chain_grad = this.out_act;\n      var N = V.w.length;\n      V.dw = global.zeros(N); // zero out gradient wrt data\n      for(var i=0;i<N;i++) {\n        if(!(this.dropped[i])) { \n          V.dw[i] = chain_grad.dw[i]; // copy over the gradient\n        }\n      }\n    },\n    getParamsAndGrads: function() {\n      return [];\n    },\n    toJSON: function() {\n      var json = {};\n      json.out_depth = this.out_depth;\n      json.out_sx = this.out_sx;\n      json.out_sy = this.out_sy;\n      json.layer_type = this.layer_type;\n      json.drop_prob = this.drop_prob;\n      return json;\n    },\n    fromJSON: function(json) {\n      this.out_depth = json.out_depth;\n      this.out_sx = json.out_sx;\n      this.out_sy = json.out_sy;\n      this.layer_type = json.layer_type; \n      this.drop_prob = json.drop_prob;\n    }\n  }\n  \n\n  global.DropoutLayer = DropoutLayer;\n})(convnetjs);\n(function(global) {\n  \"use strict\";\n  var Vol = global.Vol; // convenience\n  \n  // a bit experimental layer for now. I think it works but I'm not 100%\n  // the gradient check is a bit funky. I'll look into this a bit later.\n  // Local Response Normalization in window, along depths of volumes\n  var LocalResponseNormalizationLayer = function(opt) {\n    var opt = opt || {};\n\n    // required\n    this.k = opt.k;\n    this.n = opt.n;\n    this.alpha = opt.alpha;\n    this.beta = opt.beta;\n\n    // computed\n    this.out_sx = opt.in_sx;\n    this.out_sy = opt.in_sy;\n    this.out_depth = opt.in_depth;\n    this.layer_type = 'lrn';\n\n    // checks\n    if(this.n%2 === 0) { console.log('WARNING n should be odd for LRN layer'); }\n  }\n  LocalResponseNormalizationLayer.prototype = {\n    forward: function(V, is_training) {\n      this.in_act = V;\n\n      var A = V.cloneAndZero();\n      this.S_cache_ = V.cloneAndZero();\n      var n2 = Math.floor(this.n/2);\n      for(var x=0;x<V.sx;x++) {\n        for(var y=0;y<V.sy;y++) {\n          for(var i=0;i<V.depth;i++) {\n\n            var ai = V.get(x,y,i);\n\n            // normalize in a window of size n\n            var den = 0.0;\n            for(var j=Math.max(0,i-n2);j<=Math.min(i+n2,V.depth-1);j++) {\n              var aa = V.get(x,y,j);\n              den += aa*aa;\n            }\n            den *= this.alpha / this.n;\n            den += this.k;\n            this.S_cache_.set(x,y,i,den); // will be useful for backprop\n            den = Math.pow(den, this.beta);\n            A.set(x,y,i,ai/den);\n          }\n        }\n      }\n\n      this.out_act = A;\n      return this.out_act; // dummy identity function for now\n    },\n    backward: function() { \n      // evaluate gradient wrt data\n      var V = this.in_act; // we need to set dw of this\n      V.dw = global.zeros(V.w.length); // zero out gradient wrt data\n      var A = this.out_act; // computed in forward pass \n\n      var n2 = Math.floor(this.n/2);\n      for(var x=0;x<V.sx;x++) {\n        for(var y=0;y<V.sy;y++) {\n          for(var i=0;i<V.depth;i++) {\n\n            var chain_grad = this.out_act.get_grad(x,y,i);\n            var S = this.S_cache_.get(x,y,i);\n            var SB = Math.pow(S, this.beta);\n            var SB2 = SB*SB;\n\n            // normalize in a window of size n\n            for(var j=Math.max(0,i-n2);j<=Math.min(i+n2,V.depth-1);j++) {              \n              var aj = V.get(x,y,j); \n              var g = -aj*this.beta*Math.pow(S,this.beta-1)*this.alpha/this.n*2*aj;\n              if(j===i) g+= SB;\n              g /= SB2;\n              g *= chain_grad;\n              V.add_grad(x,y,j,g);\n            }\n\n          }\n        }\n      }\n    },\n    getParamsAndGrads: function() { return []; },\n    toJSON: function() {\n      var json = {};\n      json.k = this.k;\n      json.n = this.n;\n      json.alpha = this.alpha; // normalize by size\n      json.beta = this.beta;\n      json.out_sx = this.out_sx; \n      json.out_sy = this.out_sy;\n      json.out_depth = this.out_depth;\n      json.layer_type = this.layer_type;\n      return json;\n    },\n    fromJSON: function(json) {\n      this.k = json.k;\n      this.n = json.n;\n      this.alpha = json.alpha; // normalize by size\n      this.beta = json.beta;\n      this.out_sx = json.out_sx; \n      this.out_sy = json.out_sy;\n      this.out_depth = json.out_depth;\n      this.layer_type = json.layer_type;\n    }\n  }\n  \n\n  global.LocalResponseNormalizationLayer = LocalResponseNormalizationLayer;\n})(convnetjs);\n(function(global) {\n  \"use strict\";\n  var Vol = global.Vol; // convenience\n  \n  // Net manages a set of layers\n  // For now constraints: Simple linear order of layers, first layer input last layer a cost layer\n  var Net = function(options) {\n    this.layers = [];\n  }\n\n  Net.prototype = {\n    \n    // takes a list of layer definitions and creates the network layer objects\n    makeLayers: function(defs) {\n\n      // few checks for now\n      if(defs.length<2) {console.log('ERROR! For now at least have input and softmax layers.');}\n      if(defs[0].type !== 'input') {console.log('ERROR! For now first layer should be input.');}\n\n      // desugar syntactic for adding activations and dropouts\n      var desugar = function() {\n        var new_defs = [];\n        for(var i=0;i<defs.length;i++) {\n          var def = defs[i];\n          \n          if(def.type==='softmax' || def.type==='svm') {\n            // add an fc layer here, there is no reason the user should\n            // have to worry about this and we almost always want to\n            new_defs.push({type:'fc', num_neurons: def.num_classes});\n          }\n\n          if(def.type==='regression') {\n            // add an fc layer here, there is no reason the user should\n            // have to worry about this and we almost always want to\n            new_defs.push({type:'fc', num_neurons: def.num_neurons});\n          }\n\n          if((def.type==='fc' || def.type==='conv') \n              && typeof(def.bias_pref) === 'undefined'){\n            def.bias_pref = 0.0;\n            if(typeof def.activation !== 'undefined' && def.activation === 'relu') {\n              def.bias_pref = 0.1; // relus like a bit of positive bias to get gradients early\n              // otherwise it's technically possible that a relu unit will never turn on (by chance)\n              // and will never get any gradient and never contribute any computation. Dead relu.\n            }\n          }\n          \n          if(typeof def.tensor !== 'undefined') {\n            // apply quadratic transform so that the upcoming multiply will include\n            // quadratic terms, equivalent to doing a tensor product\n            if(def.tensor) {\n              new_defs.push({type: 'quadtransform'});\n            }\n          }\n\n          new_defs.push(def);\n\n          if(typeof def.activation !== 'undefined') {\n            if(def.activation==='relu') { new_defs.push({type:'relu'}); }\n            else if (def.activation==='sigmoid') { new_defs.push({type:'sigmoid'}); }\n            else if (def.activation==='tanh') { new_defs.push({type:'tanh'}); }\n            else if (def.activation==='maxout') {\n              // create maxout activation, and pass along group size, if provided\n              var gs = def.group_size !== 'undefined' ? def.group_size : 2;\n              new_defs.push({type:'maxout', group_size:gs});\n            }\n            else { console.log('ERROR unsupported activation ' + def.activation); }\n          }\n          if(typeof def.drop_prob !== 'undefined' && def.type !== 'dropout') {\n            new_defs.push({type:'dropout', drop_prob: def.drop_prob});\n          }\n\n        }\n        return new_defs;\n      }\n      defs = desugar(defs);\n\n      // create the layers\n      this.layers = [];\n      for(var i=0;i<defs.length;i++) {\n        var def = defs[i];\n        if(i>0) {\n          var prev = this.layers[i-1];\n          def.in_sx = prev.out_sx;\n          def.in_sy = prev.out_sy;\n          def.in_depth = prev.out_depth;\n        }\n\n        switch(def.type) {\n          case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;\n          case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;\n          case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;\n          case 'input': this.layers.push(new global.InputLayer(def)); break;\n          case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;\n          case 'regression': this.layers.push(new global.RegressionLayer(def)); break;\n          case 'conv': this.layers.push(new global.ConvLayer(def)); break;\n          case 'pool': this.layers.push(new global.PoolLayer(def)); break;\n          case 'relu': this.layers.push(new global.ReluLayer(def)); break;\n          case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;\n          case 'tanh': this.layers.push(new global.TanhLayer(def)); break;\n          case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;\n          case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;\n          case 'svm': this.layers.push(new global.SVMLayer(def)); break;\n          default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');\n        }\n      }\n    },\n\n    // forward prop the network. A trainer will pass in is_training = true\n    forward: function(V, is_training) {\n      if(typeof(is_training)==='undefined') is_training = false;\n      var act = this.layers[0].forward(V, is_training);\n      for(var i=1;i<this.layers.length;i++) {\n        act = this.layers[i].forward(act, is_training);\n      }\n      return act;\n    },\n\n    getCostLoss: function(V, y) {\n      this.forward(V, false);\n      var N = this.layers.length;\n      var loss = this.layers[N-1].backward(y);\n      return loss;\n    },\n    \n    // backprop: compute gradients wrt all parameters\n    backward: function(y) {\n      var N = this.layers.length;\n      var loss = this.layers[N-1].backward(y); // last layer assumed softmax\n      for(var i=N-2;i>=0;i--) { // first layer assumed input\n        this.layers[i].backward();\n      }\n      return loss;\n    },\n    getParamsAndGrads: function() {\n      // accumulate parameters and gradients for the entire network\n      var response = [];\n      for(var i=0;i<this.layers.length;i++) {\n        var layer_reponse = this.layers[i].getParamsAndGrads();\n        for(var j=0;j<layer_reponse.length;j++) {\n          response.push(layer_reponse[j]);\n        }\n      }\n      return response;\n    },\n    getPrediction: function() {\n      var S = this.layers[this.layers.length-1]; // softmax layer\n      var p = S.out_act.w;\n      var maxv = p[0];\n      var maxi = 0;\n      for(var i=1;i<p.length;i++) {\n        if(p[i] > maxv) { maxv = p[i]; maxi = i;}\n      }\n      return maxi;\n    },\n    toJSON: function() {\n      var json = {};\n      json.layers = [];\n      for(var i=0;i<this.layers.length;i++) {\n        json.layers.push(this.layers[i].toJSON());\n      }\n      return json;\n    },\n    fromJSON: function(json) {\n      this.layers = [];\n      for(var i=0;i<json.layers.length;i++) {\n        var Lj = json.layers[i]\n        var t = Lj.layer_type;\n        var L;\n        if(t==='input') { L = new global.InputLayer(); }\n        if(t==='relu') { L = new global.ReluLayer(); }\n        if(t==='sigmoid') { L = new global.SigmoidLayer(); }\n        if(t==='tanh') { L = new global.TanhLayer(); }\n        if(t==='dropout') { L = new global.DropoutLayer(); }\n        if(t==='conv') { L = new global.ConvLayer(); }\n        if(t==='pool') { L = new global.PoolLayer(); }\n        if(t==='lrn') { L = new global.LocalResponseNormalizationLayer(); }\n        if(t==='softmax') { L = new global.SoftmaxLayer(); }\n        if(t==='regression') { L = new global.RegressionLayer(); }\n        if(t==='fc') { L = new global.FullyConnLayer(); }\n        if(t==='maxout') { L = new global.MaxoutLayer(); }\n        if(t==='quadtransform') { L = new global.QuadTransformLayer(); }\n        if(t==='svm') { L = new global.SVMLayer(); }\n        L.fromJSON(Lj);\n        this.layers.push(L);\n      }\n    }\n  }\n  \n\n  global.Net = Net;\n})(convnetjs);\n(function(global) {\n  \"use strict\";\n  var Vol = global.Vol; // convenience\n\n  var Trainer = function(net, options) {\n\n    this.net = net;\n\n    var options = options || {};\n    this.learning_rate = typeof options.learning_rate !== 'undefined' ? options.learning_rate : 0.01;\n    this.l1_decay = typeof options.l1_decay !== 'undefined' ? options.l1_decay : 0.0;\n    this.l2_decay = typeof options.l2_decay !== 'undefined' ? options.l2_decay : 0.0;\n    this.batch_size = typeof options.batch_size !== 'undefined' ? options.batch_size : 1;\n    this.method = typeof options.method !== 'undefined' ? options.method : 'sgd'; // sgd/adagrad/adadelta/windowgrad\n\n    this.momentum = typeof options.momentum !== 'undefined' ? options.momentum : 0.9;\n    this.ro = typeof options.ro !== 'undefined' ? options.ro : 0.95; // used in adadelta\n    this.eps = typeof options.eps !== 'undefined' ? options.eps : 1e-6; // used in adadelta\n\n    this.k = 0; // iteration counter\n    this.gsum = []; // last iteration gradients (used for momentum calculations)\n    this.xsum = []; // used in adadelta\n  }\n\n  Trainer.prototype = {\n    train: function(x, y) {\n\n      var start = new Date().getTime();\n      this.net.forward(x, true); // also set the flag that lets the net know we're just training\n      var end = new Date().getTime();\n      var fwd_time = end - start;\n\n      var start = new Date().getTime();\n      var cost_loss = this.net.backward(y);\n      var l2_decay_loss = 0.0;\n      var l1_decay_loss = 0.0;\n      var end = new Date().getTime();\n      var bwd_time = end - start;\n      \n      this.k++;\n      if(this.k % this.batch_size === 0) {\n\n        var pglist = this.net.getParamsAndGrads();\n\n        // initialize lists for accumulators. Will only be done once on first iteration\n        if(this.gsum.length === 0 && (this.method !== 'sgd' || this.momentum > 0.0)) {\n          // only vanilla sgd doesnt need either lists\n          // momentum needs gsum\n          // adagrad needs gsum\n          // adadelta needs gsum and xsum\n          for(var i=0;i<pglist.length;i++) {\n            this.gsum.push(global.zeros(pglist[i].params.length));\n            if(this.method === 'adadelta') {\n              this.xsum.push(global.zeros(pglist[i].params.length));\n            } else {\n              this.xsum.push([]); // conserve memory\n            }\n          }\n        }\n\n        // perform an update for all sets of weights\n        for(var i=0;i<pglist.length;i++) {\n          var pg = pglist[i]; // param, gradient, other options in future (custom learning rate etc)\n          var p = pg.params;\n          var g = pg.grads;\n\n          // learning rate for some parameters.\n          var l2_decay_mul = typeof pg.l2_decay_mul !== 'undefined' ? pg.l2_decay_mul : 1.0;\n          var l1_decay_mul = typeof pg.l1_decay_mul !== 'undefined' ? pg.l1_decay_mul : 1.0;\n          var l2_decay = this.l2_decay * l2_decay_mul;\n          var l1_decay = this.l1_decay * l1_decay_mul;\n\n          var plen = p.length;\n          for(var j=0;j<plen;j++) {\n            l2_decay_loss += l2_decay*p[j]*p[j]/2; // accumulate weight decay loss\n            l1_decay_loss += l1_decay*Math.abs(p[j]);\n            var l1grad = l1_decay * (p[j] > 0 ? 1 : -1);\n            var l2grad = l2_decay * (p[j]);\n\n            var gij = (l2grad + l1grad + g[j]) / this.batch_size; // raw batch gradient\n\n            var gsumi = this.gsum[i];\n            var xsumi = this.xsum[i];\n            if(this.method === 'adagrad') {\n              // adagrad update\n              gsumi[j] = gsumi[j] + gij * gij;\n              var dx = - this.learning_rate / Math.sqrt(gsumi[j] + this.eps) * gij;\n              p[j] += dx;\n            } else if(this.method === 'windowgrad') {\n              // this is adagrad but with a moving window weighted average\n              // so the gradient is not accumulated over the entire history of the run. \n              // it's also referred to as Idea #1 in Zeiler paper on Adadelta. Seems reasonable to me!\n              gsumi[j] = this.ro * gsumi[j] + (1-this.ro) * gij * gij;\n              var dx = - this.learning_rate / Math.sqrt(gsumi[j] + this.eps) * gij; // eps added for better conditioning\n              p[j] += dx;\n            } else if(this.method === 'adadelta') {\n              // assume adadelta if not sgd or adagrad\n              gsumi[j] = this.ro * gsumi[j] + (1-this.ro) * gij * gij;\n              var dx = - Math.sqrt((xsumi[j] + this.eps)/(gsumi[j] + this.eps)) * gij;\n              xsumi[j] = this.ro * xsumi[j] + (1-this.ro) * dx * dx; // yes, xsum lags behind gsum by 1.\n              p[j] += dx;\n            } else {\n              // assume SGD\n              if(this.momentum > 0.0) {\n                // momentum update\n                var dx = this.momentum * gsumi[j] - this.learning_rate * gij; // step\n                gsumi[j] = dx; // back this up for next iteration of momentum\n                p[j] += dx; // apply corrected gradient\n              } else {\n                // vanilla sgd\n                p[j] +=  - this.learning_rate * gij;\n              }\n            }\n            g[j] = 0.0; // zero out gradient so that we can begin accumulating anew\n          }\n        }\n      }\n\n      // appending softmax_loss for backwards compatibility, but from now on we will always use cost_loss\n      // in future, TODO: have to completely redo the way loss is done around the network as currently \n      // loss is a bit of a hack. Ideally, user should specify arbitrary number of loss functions on any layer\n      // and it should all be computed correctly and automatically. \n      return {fwd_time: fwd_time, bwd_time: bwd_time, \n              l2_decay_loss: l2_decay_loss, l1_decay_loss: l1_decay_loss,\n              cost_loss: cost_loss, softmax_loss: cost_loss, \n              loss: cost_loss + l1_decay_loss + l2_decay_loss}\n    }\n  }\n  \n  global.Trainer = Trainer;\n  global.SGDTrainer = Trainer; // backwards compatibility\n})(convnetjs);\n\n(function(global) {\n  \"use strict\";\n\n  // used utilities, make explicit local references\n  var randf = global.randf;\n  var randi = global.randi;\n  var Net = global.Net;\n  var Trainer = global.Trainer;\n  var maxmin = global.maxmin;\n  var randperm = global.randperm;\n  var weightedSample = global.weightedSample;\n  var getopt = global.getopt;\n  var arrUnique = global.arrUnique;\n\n  /*\n  A MagicNet takes data: a list of convnetjs.Vol(), and labels\n  which for now are assumed to be class indeces 0..K. MagicNet then:\n  - creates data folds for cross-validation\n  - samples candidate networks\n  - evaluates candidate networks on all data folds\n  - produces predictions by model-averaging the best networks\n  */\n  var MagicNet = function(data, labels, opt) {\n    var opt = opt || {};\n    if(typeof data === 'undefined') { data = []; }\n    if(typeof labels === 'undefined') { labels = []; }\n\n    // required inputs\n    this.data = data; // store these pointers to data\n    this.labels = labels;\n\n    // optional inputs\n    this.train_ratio = getopt(opt, 'train_ratio', 0.7);\n    this.num_folds = getopt(opt, 'num_folds', 10);\n    this.num_candidates = getopt(opt, 'num_candidates', 50); // we evaluate several in parallel\n    // how many epochs of data to train every network? for every fold?\n    // higher values mean higher accuracy in final results, but more expensive\n    this.num_epochs = getopt(opt, 'num_epochs', 50); \n    // number of best models to average during prediction. Usually higher = better\n    this.ensemble_size = getopt(opt, 'ensemble_size', 10);\n\n    // candidate parameters\n    this.batch_size_min = getopt(opt, 'batch_size_min', 10);\n    this.batch_size_max = getopt(opt, 'batch_size_max', 300);\n    this.l2_decay_min = getopt(opt, 'l2_decay_min', -4);\n    this.l2_decay_max = getopt(opt, 'l2_decay_max', 2);\n    this.learning_rate_min = getopt(opt, 'learning_rate_min', -4);\n    this.learning_rate_max = getopt(opt, 'learning_rate_max', 0);\n    this.momentum_min = getopt(opt, 'momentum_min', 0.9);\n    this.momentum_max = getopt(opt, 'momentum_max', 0.9);\n    this.neurons_min = getopt(opt, 'neurons_min', 5);\n    this.neurons_max = getopt(opt, 'neurons_max', 30);\n\n    // computed\n    this.folds = []; // data fold indices, gets filled by sampleFolds()\n    this.candidates = []; // candidate networks that are being currently evaluated\n    this.evaluated_candidates = []; // history of all candidates that were fully evaluated on all folds\n    this.unique_labels = arrUnique(labels);\n    this.iter = 0; // iteration counter, goes from 0 -> num_epochs * num_training_data\n    this.foldix = 0; // index of active fold\n\n    // callbacks\n    this.finish_fold_callback = null;\n    this.finish_batch_callback = null;\n\n    // initializations\n    if(this.data.length > 0) {\n      this.sampleFolds();\n      this.sampleCandidates();\n    }\n  };\n\n  MagicNet.prototype = {\n\n    // sets this.folds to a sampling of this.num_folds folds\n    sampleFolds: function() {\n      var N = this.data.length;\n      var num_train = Math.floor(this.train_ratio * N);\n      this.folds = []; // flush folds, if any\n      for(var i=0;i<this.num_folds;i++) {\n        var p = randperm(N);\n        this.folds.push({train_ix: p.slice(0, num_train), test_ix: p.slice(num_train, N)});\n      }\n    },\n\n    // returns a random candidate network\n    sampleCandidate: function() {\n      var input_depth = this.data[0].w.length;\n      var num_classes = this.unique_labels.length;\n\n      // sample network topology and hyperparameters\n      var layer_defs = [];\n      layer_defs.push({type:'input', out_sx:1, out_sy:1, out_depth: input_depth});\n      var nl = weightedSample([0,1,2,3], [0.2, 0.3, 0.3, 0.2]); // prefer nets with 1,2 hidden layers\n      for(var q=0;q<nl;q++) {\n        var ni = randi(this.neurons_min, this.neurons_max);\n        var act = ['tanh','maxout','relu'][randi(0,3)];\n        if(randf(0,1)<0.5) {\n          var dp = Math.random();\n          layer_defs.push({type:'fc', num_neurons: ni, activation: act, drop_prob: dp});\n        } else {\n          layer_defs.push({type:'fc', num_neurons: ni, activation: act});\n        }\n      }\n      layer_defs.push({type:'softmax', num_classes: num_classes});\n      var net = new Net();\n      net.makeLayers(layer_defs);\n\n      // sample training hyperparameters\n      var bs = randi(this.batch_size_min, this.batch_size_max); // batch size\n      var l2 = Math.pow(10, randf(this.l2_decay_min, this.l2_decay_max)); // l2 weight decay\n      var lr = Math.pow(10, randf(this.learning_rate_min, this.learning_rate_max)); // learning rate\n      var mom = randf(this.momentum_min, this.momentum_max); // momentum. Lets just use 0.9, works okay usually ;p\n      var tp = randf(0,1); // trainer type\n      var trainer_def;\n      if(tp<0.33) {\n        trainer_def = {method:'adadelta', batch_size:bs, l2_decay:l2};\n      } else if(tp<0.66) {\n        trainer_def = {method:'adagrad', learning_rate: lr, batch_size:bs, l2_decay:l2};\n      } else {\n        trainer_def = {method:'sgd', learning_rate: lr, momentum: mom, batch_size:bs, l2_decay:l2};\n      }\n      \n      var trainer = new Trainer(net, trainer_def);\n\n      var cand = {};\n      cand.acc = [];\n      cand.accv = 0; // this will maintained as sum(acc) for convenience\n      cand.layer_defs = layer_defs;\n      cand.trainer_def = trainer_def;\n      cand.net = net;\n      cand.trainer = trainer;\n      return cand;\n    },\n\n    // sets this.candidates with this.num_candidates candidate nets\n    sampleCandidates: function() {\n      this.candidates = []; // flush, if any\n      for(var i=0;i<this.num_candidates;i++) {\n        var cand = this.sampleCandidate();\n        this.candidates.push(cand);\n      }\n    },\n\n    step: function() {\n      \n      // run an example through current candidate\n      this.iter++;\n\n      // step all candidates on a random data point\n      var fold = this.folds[this.foldix]; // active fold\n      var dataix = fold.train_ix[randi(0, fold.train_ix.length)];\n      for(var k=0;k<this.candidates.length;k++) {\n        var x = this.data[dataix];\n        var l = this.labels[dataix];\n        this.candidates[k].trainer.train(x, l);\n      }\n\n      // process consequences: sample new folds, or candidates\n      var lastiter = this.num_epochs * fold.train_ix.length;\n      if(this.iter >= lastiter) {\n        // finished evaluation of this fold. Get final validation\n        // accuracies, record them, and go on to next fold.\n        var val_acc = this.evalValErrors();\n        for(var k=0;k<this.candidates.length;k++) {\n          var c = this.candidates[k];\n          c.acc.push(val_acc[k]);\n          c.accv += val_acc[k];\n        }\n        this.iter = 0; // reset step number\n        this.foldix++; // increment fold\n\n        if(this.finish_fold_callback !== null) {\n          this.finish_fold_callback();\n        }\n\n        if(this.foldix >= this.folds.length) {\n          // we finished all folds as well! Record these candidates\n          // and sample new ones to evaluate.\n          for(var k=0;k<this.candidates.length;k++) {\n            this.evaluated_candidates.push(this.candidates[k]);\n          }\n          // sort evaluated candidates according to accuracy achieved\n          this.evaluated_candidates.sort(function(a, b) { \n            return (a.accv / a.acc.length) \n                 > (b.accv / b.acc.length) \n                 ? -1 : 1;\n          });\n          // and clip only to the top few ones (lets place limit at 3*ensemble_size)\n          // otherwise there are concerns with keeping these all in memory \n          // if MagicNet is being evaluated for a very long time\n          if(this.evaluated_candidates.length > 3 * this.ensemble_size) {\n            this.evaluated_candidates = this.evaluated_candidates.slice(0, 3 * this.ensemble_size);\n          }\n          if(this.finish_batch_callback !== null) {\n            this.finish_batch_callback();\n          }\n          this.sampleCandidates(); // begin with new candidates\n          this.foldix = 0; // reset this\n        } else {\n          // we will go on to another fold. reset all candidates nets\n          for(var k=0;k<this.candidates.length;k++) {\n            var c = this.candidates[k];\n            var net = new Net();\n            net.makeLayers(c.layer_defs);\n            var trainer = new Trainer(net, c.trainer_def);\n            c.net = net;\n            c.trainer = trainer;\n          }\n        }\n      }\n    },\n\n    evalValErrors: function() {\n      // evaluate candidates on validation data and return performance of current networks\n      // as simple list\n      var vals = [];\n      var fold = this.folds[this.foldix]; // active fold\n      for(var k=0;k<this.candidates.length;k++) {\n        var net = this.candidates[k].net;\n        var v = 0.0;\n        for(var q=0;q<fold.test_ix.length;q++) {\n          var x = this.data[fold.test_ix[q]];\n          var l = this.labels[fold.test_ix[q]];\n          net.forward(x);\n          var yhat = net.getPrediction();\n          v += (yhat === l ? 1.0 : 0.0); // 0 1 loss\n        }\n        v /= fold.test_ix.length; // normalize\n        vals.push(v);\n      }\n      return vals;\n    },\n\n    // returns prediction scores for given test data point, as Vol\n    // uses an averaged prediction from the best ensemble_size models\n    // x is a Vol.\n    predict_soft: function(data) {\n      // forward prop the best networks\n      // and accumulate probabilities at last layer into a an output Vol\n      var nv = Math.min(this.ensemble_size, this.evaluated_candidates.length);\n      if(nv === 0) { return new convnetjs.Vol(0,0,0); } // not sure what to do here? we're not ready yet\n      var xout, n;\n      for(var j=0;j<nv;j++) {\n        var net = this.evaluated_candidates[j].net;\n        var x = net.forward(data);\n        if(j===0) { \n          xout = x; \n          n = x.w.length; \n        } else {\n          // add it on\n          for(var d=0;d<n;d++) {\n            xout.w[d] += x.w[d];\n          }\n        }\n      }\n      // produce average\n      for(var d=0;d<n;d++) {\n        xout.w[d] /= n;\n      }\n      return xout;\n    },\n\n    predict: function(data) {\n      var xout = this.predict_soft(data);\n      if(xout.w.length !== 0) {\n        var stats = maxmin(xout.w);\n        var predicted_label = stats.maxi; \n      } else {\n        var predicted_label = -1; // error out\n      }\n      return predicted_label;\n\n    },\n\n    toJSON: function() {\n      // dump the top ensemble_size networks as a list\n      var nv = Math.min(this.ensemble_size, this.evaluated_candidates.length);\n      var json = {};\n      json.nets = [];\n      for(var i=0;i<nv;i++) {\n        json.nets.push(this.evaluated_candidates[i].net.toJSON());\n      }\n      return json;\n    },\n\n    fromJSON: function(json) {\n      this.ensemble_size = json.nets.length;\n      this.evaluated_candidates = [];\n      for(var i=0;i<this.ensemble_size;i++) {\n        var net = new Net();\n        net.fromJSON(json.nets[i]);\n        var dummy_candidate = {};\n        dummy_candidate.net = net;\n        this.evaluated_candidates.push(dummy_candidate);\n      }\n    },\n\n    // callback functions\n    // called when a fold is finished, while evaluating a batch\n    onFinishFold: function(f) { this.finish_fold_callback = f; },\n    // called when a batch of candidates has finished evaluating\n    onFinishBatch: function(f) { this.finish_batch_callback = f; }\n    \n  };\n\n  global.MagicNet = MagicNet;\n})(convnetjs);\nthis.convnetjs = convnetjs;\n","/*\n (c) 2013, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n\nthis.simplify = (function () { 'use strict';\n\n// to suit your point format, run search/replace for '.x' and '.y';\n// for 3D version, see 3d branch (configurability would draw significant performance overhead)\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n\n    var dx = p1.x - p2.x,\n        dy = p1.y - p2.y;\n\n    return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, p1, p2) {\n\n    var x = p1.x,\n        y = p1.y,\n        dx = p2.x - x,\n        dy = p2.y - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = p2.x;\n            y = p2.y;\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = p.x - x;\n    dy = p.y - y;\n\n    return dx * dx + dy * dy;\n}\n// rest of the code doesn't care about point format\n\n// basic distance-based simplification\nfunction simplifyRadialDist(points, sqTolerance) {\n\n    var prevPoint = points[0],\n        newPoints = [prevPoint],\n        point;\n\n    for (var i = 1, len = points.length; i < len; i++) {\n        point = points[i];\n\n        if (getSqDist(point, prevPoint) > sqTolerance) {\n            newPoints.push(point);\n            prevPoint = point;\n        }\n    }\n\n    if (prevPoint !== point) newPoints.push(point);\n\n    return newPoints;\n}\n\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n    var maxSqDist = sqTolerance,\n        index;\n\n    for (var i = first + 1; i < last; i++) {\n        var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n        if (sqDist > maxSqDist) {\n            index = i;\n            maxSqDist = sqDist;\n        }\n    }\n\n    if (maxSqDist > sqTolerance) {\n        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n        simplified.push(points[index]);\n        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n    var last = points.length - 1;\n\n    var simplified = [points[0]];\n    simplifyDPStep(points, 0, last, sqTolerance, simplified);\n    simplified.push(points[last]);\n\n    return simplified;\n}\n\n// both algorithms combined for awesome performance\nfunction simplify(points, tolerance, highestQuality) {\n\n    if (points.length <= 2) return points;\n\n    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n    points = simplifyDouglasPeucker(points, sqTolerance);\n\n    return points;\n}\n\n// export as AMD module / Node module / browser or worker variable\nif (typeof define === 'function' && define.amd) define(function() { return simplify; });\nelse if (typeof module !== 'undefined') module.exports = simplify;\nelse return simplify;\n\n})();\n","/*!\nCopyright (C) 2010-2013 Raymond Hill: https://github.com/gorhill/Javascript-Voronoi\nMIT License: See https://github.com/gorhill/Javascript-Voronoi/LICENSE.md\n*/\n/*\nAuthor: Raymond Hill (rhill@raymondhill.net)\nContributor: Jesse Morgan (morgajel@gmail.com)\nFile: rhill-voronoi-core.js\nVersion: 0.98\nDate: January 21, 2013\nDescription: This is my personal Javascript implementation of\nSteven Fortune's algorithm to compute Voronoi diagrams.\n\nLicense: See https://github.com/gorhill/Javascript-Voronoi/LICENSE.md\nCredits: See https://github.com/gorhill/Javascript-Voronoi/CREDITS.md\nHistory: See https://github.com/gorhill/Javascript-Voronoi/CHANGELOG.md\n\n## Usage:\n\n  var sites = [{x:300,y:300}, {x:100,y:100}, {x:200,y:500}, {x:250,y:450}, {x:600,y:150}];\n  // xl, xr means x left, x right\n  // yt, yb means y top, y bottom\n  var bbox = {xl:0, xr:800, yt:0, yb:600};\n  var voronoi = new Voronoi();\n  // pass an object which exhibits xl, xr, yt, yb properties. The bounding\n  // box will be used to connect unbound edges, and to close open cells\n  result = voronoi.compute(sites, bbox);\n  // render, further analyze, etc.\n\nReturn value:\n  An object with the following properties:\n\n  result.vertices = an array of unordered, unique Voronoi.Vertex objects making\n    up the Voronoi diagram.\n  result.edges = an array of unordered, unique Voronoi.Edge objects making up\n    the Voronoi diagram.\n  result.cells = an array of Voronoi.Cell object making up the Voronoi diagram.\n    A Cell object might have an empty array of halfedges, meaning no Voronoi\n    cell could be computed for a particular cell.\n  result.execTime = the time it took to compute the Voronoi diagram, in\n    milliseconds.\n\nVoronoi.Vertex object:\n  x: The x position of the vertex.\n  y: The y position of the vertex.\n\nVoronoi.Edge object:\n  lSite: the Voronoi site object at the left of this Voronoi.Edge object.\n  rSite: the Voronoi site object at the right of this Voronoi.Edge object (can\n    be null).\n  va: an object with an 'x' and a 'y' property defining the start point\n    (relative to the Voronoi site on the left) of this Voronoi.Edge object.\n  vb: an object with an 'x' and a 'y' property defining the end point\n    (relative to Voronoi site on the left) of this Voronoi.Edge object.\n\n  For edges which are used to close open cells (using the supplied bounding\n  box), the rSite property will be null.\n\nVoronoi.Cell object:\n  site: the Voronoi site object associated with the Voronoi cell.\n  halfedges: an array of Voronoi.Halfedge objects, ordered counterclockwise,\n    defining the polygon for this Voronoi cell.\n\nVoronoi.Halfedge object:\n  site: the Voronoi site object owning this Voronoi.Halfedge object.\n  edge: a reference to the unique Voronoi.Edge object underlying this\n    Voronoi.Halfedge object.\n  getStartpoint(): a method returning an object with an 'x' and a 'y' property\n    for the start point of this halfedge. Keep in mind halfedges are always\n    countercockwise.\n  getEndpoint(): a method returning an object with an 'x' and a 'y' property\n    for the end point of this halfedge. Keep in mind halfedges are always\n    countercockwise.\n\nTODO: Identify opportunities for performance improvement.\n\nTODO: Let the user close the Voronoi cells, do not do it automatically. Not only let\n      him close the cells, but also allow him to close more than once using a different\n      bounding box for the same Voronoi diagram.\n*/\n\n/*global Math */\n\n// ---------------------------------------------------------------------------\n\nfunction Voronoi() {\n    this.vertices = null;\n    this.edges = null;\n    this.cells = null;\n    this.toRecycle = null;\n    this.beachsectionJunkyard = [];\n    this.circleEventJunkyard = [];\n    this.vertexJunkyard = [];\n    this.edgeJunkyard = [];\n    this.cellJunkyard = [];\n    }\n\n// ---------------------------------------------------------------------------\n\nVoronoi.prototype.reset = function() {\n    if (!this.beachline) {\n        this.beachline = new this.RBTree();\n        }\n    // Move leftover beachsections to the beachsection junkyard.\n    if (this.beachline.root) {\n        var beachsection = this.beachline.getFirst(this.beachline.root);\n        while (beachsection) {\n            this.beachsectionJunkyard.push(beachsection); // mark for reuse\n            beachsection = beachsection.rbNext;\n            }\n        }\n    this.beachline.root = null;\n    if (!this.circleEvents) {\n        this.circleEvents = new this.RBTree();\n        }\n    this.circleEvents.root = this.firstCircleEvent = null;\n    this.vertices = [];\n    this.edges = [];\n    this.cells = [];\n    };\n\nVoronoi.prototype.sqrt = Math.sqrt;\nVoronoi.prototype.abs = Math.abs;\nVoronoi.prototype.ε = Voronoi.ε = 1e-9;\nVoronoi.prototype.invε = Voronoi.invε = 1.0 / Voronoi.ε;\nVoronoi.prototype.equalWithEpsilon = function(a,b){return this.abs(a-b)<1e-9;};\nVoronoi.prototype.greaterThanWithEpsilon = function(a,b){return a-b>1e-9;};\nVoronoi.prototype.greaterThanOrEqualWithEpsilon = function(a,b){return b-a<1e-9;};\nVoronoi.prototype.lessThanWithEpsilon = function(a,b){return b-a>1e-9;};\nVoronoi.prototype.lessThanOrEqualWithEpsilon = function(a,b){return a-b<1e-9;};\n\n// ---------------------------------------------------------------------------\n// Red-Black tree code (based on C version of \"rbtree\" by Franck Bui-Huu\n// https://github.com/fbuihuu/libtree/blob/master/rb.c\n\nVoronoi.prototype.RBTree = function() {\n    this.root = null;\n    };\n\nVoronoi.prototype.RBTree.prototype.rbInsertSuccessor = function(node, successor) {\n    var parent;\n    if (node) {\n        // >>> rhill 2011-05-27: Performance: cache previous/next nodes\n        successor.rbPrevious = node;\n        successor.rbNext = node.rbNext;\n        if (node.rbNext) {\n            node.rbNext.rbPrevious = successor;\n            }\n        node.rbNext = successor;\n        // <<<\n        if (node.rbRight) {\n            // in-place expansion of node.rbRight.getFirst();\n            node = node.rbRight;\n            while (node.rbLeft) {node = node.rbLeft;}\n            node.rbLeft = successor;\n            }\n        else {\n            node.rbRight = successor;\n            }\n        parent = node;\n        }\n    // rhill 2011-06-07: if node is null, successor must be inserted\n    // to the left-most part of the tree\n    else if (this.root) {\n        node = this.getFirst(this.root);\n        // >>> Performance: cache previous/next nodes\n        successor.rbPrevious = null;\n        successor.rbNext = node;\n        node.rbPrevious = successor;\n        // <<<\n        node.rbLeft = successor;\n        parent = node;\n        }\n    else {\n        // >>> Performance: cache previous/next nodes\n        successor.rbPrevious = successor.rbNext = null;\n        // <<<\n        this.root = successor;\n        parent = null;\n        }\n    successor.rbLeft = successor.rbRight = null;\n    successor.rbParent = parent;\n    successor.rbRed = true;\n    // Fixup the modified tree by recoloring nodes and performing\n    // rotations (2 at most) hence the red-black tree properties are\n    // preserved.\n    var grandpa, uncle;\n    node = successor;\n    while (parent && parent.rbRed) {\n        grandpa = parent.rbParent;\n        if (parent === grandpa.rbLeft) {\n            uncle = grandpa.rbRight;\n            if (uncle && uncle.rbRed) {\n                parent.rbRed = uncle.rbRed = false;\n                grandpa.rbRed = true;\n                node = grandpa;\n                }\n            else {\n                if (node === parent.rbRight) {\n                    this.rbRotateLeft(parent);\n                    node = parent;\n                    parent = node.rbParent;\n                    }\n                parent.rbRed = false;\n                grandpa.rbRed = true;\n                this.rbRotateRight(grandpa);\n                }\n            }\n        else {\n            uncle = grandpa.rbLeft;\n            if (uncle && uncle.rbRed) {\n                parent.rbRed = uncle.rbRed = false;\n                grandpa.rbRed = true;\n                node = grandpa;\n                }\n            else {\n                if (node === parent.rbLeft) {\n                    this.rbRotateRight(parent);\n                    node = parent;\n                    parent = node.rbParent;\n                    }\n                parent.rbRed = false;\n                grandpa.rbRed = true;\n                this.rbRotateLeft(grandpa);\n                }\n            }\n        parent = node.rbParent;\n        }\n    this.root.rbRed = false;\n    };\n\nVoronoi.prototype.RBTree.prototype.rbRemoveNode = function(node) {\n    // >>> rhill 2011-05-27: Performance: cache previous/next nodes\n    if (node.rbNext) {\n        node.rbNext.rbPrevious = node.rbPrevious;\n        }\n    if (node.rbPrevious) {\n        node.rbPrevious.rbNext = node.rbNext;\n        }\n    node.rbNext = node.rbPrevious = null;\n    // <<<\n    var parent = node.rbParent,\n        left = node.rbLeft,\n        right = node.rbRight,\n        next;\n    if (!left) {\n        next = right;\n        }\n    else if (!right) {\n        next = left;\n        }\n    else {\n        next = this.getFirst(right);\n        }\n    if (parent) {\n        if (parent.rbLeft === node) {\n            parent.rbLeft = next;\n            }\n        else {\n            parent.rbRight = next;\n            }\n        }\n    else {\n        this.root = next;\n        }\n    // enforce red-black rules\n    var isRed;\n    if (left && right) {\n        isRed = next.rbRed;\n        next.rbRed = node.rbRed;\n        next.rbLeft = left;\n        left.rbParent = next;\n        if (next !== right) {\n            parent = next.rbParent;\n            next.rbParent = node.rbParent;\n            node = next.rbRight;\n            parent.rbLeft = node;\n            next.rbRight = right;\n            right.rbParent = next;\n            }\n        else {\n            next.rbParent = parent;\n            parent = next;\n            node = next.rbRight;\n            }\n        }\n    else {\n        isRed = node.rbRed;\n        node = next;\n        }\n    // 'node' is now the sole successor's child and 'parent' its\n    // new parent (since the successor can have been moved)\n    if (node) {\n        node.rbParent = parent;\n        }\n    // the 'easy' cases\n    if (isRed) {return;}\n    if (node && node.rbRed) {\n        node.rbRed = false;\n        return;\n        }\n    // the other cases\n    var sibling;\n    do {\n        if (node === this.root) {\n            break;\n            }\n        if (node === parent.rbLeft) {\n            sibling = parent.rbRight;\n            if (sibling.rbRed) {\n                sibling.rbRed = false;\n                parent.rbRed = true;\n                this.rbRotateLeft(parent);\n                sibling = parent.rbRight;\n                }\n            if ((sibling.rbLeft && sibling.rbLeft.rbRed) || (sibling.rbRight && sibling.rbRight.rbRed)) {\n                if (!sibling.rbRight || !sibling.rbRight.rbRed) {\n                    sibling.rbLeft.rbRed = false;\n                    sibling.rbRed = true;\n                    this.rbRotateRight(sibling);\n                    sibling = parent.rbRight;\n                    }\n                sibling.rbRed = parent.rbRed;\n                parent.rbRed = sibling.rbRight.rbRed = false;\n                this.rbRotateLeft(parent);\n                node = this.root;\n                break;\n                }\n            }\n        else {\n            sibling = parent.rbLeft;\n            if (sibling.rbRed) {\n                sibling.rbRed = false;\n                parent.rbRed = true;\n                this.rbRotateRight(parent);\n                sibling = parent.rbLeft;\n                }\n            if ((sibling.rbLeft && sibling.rbLeft.rbRed) || (sibling.rbRight && sibling.rbRight.rbRed)) {\n                if (!sibling.rbLeft || !sibling.rbLeft.rbRed) {\n                    sibling.rbRight.rbRed = false;\n                    sibling.rbRed = true;\n                    this.rbRotateLeft(sibling);\n                    sibling = parent.rbLeft;\n                    }\n                sibling.rbRed = parent.rbRed;\n                parent.rbRed = sibling.rbLeft.rbRed = false;\n                this.rbRotateRight(parent);\n                node = this.root;\n                break;\n                }\n            }\n        sibling.rbRed = true;\n        node = parent;\n        parent = parent.rbParent;\n    } while (!node.rbRed);\n    if (node) {node.rbRed = false;}\n    };\n\nVoronoi.prototype.RBTree.prototype.rbRotateLeft = function(node) {\n    var p = node,\n        q = node.rbRight, // can't be null\n        parent = p.rbParent;\n    if (parent) {\n        if (parent.rbLeft === p) {\n            parent.rbLeft = q;\n            }\n        else {\n            parent.rbRight = q;\n            }\n        }\n    else {\n        this.root = q;\n        }\n    q.rbParent = parent;\n    p.rbParent = q;\n    p.rbRight = q.rbLeft;\n    if (p.rbRight) {\n        p.rbRight.rbParent = p;\n        }\n    q.rbLeft = p;\n    };\n\nVoronoi.prototype.RBTree.prototype.rbRotateRight = function(node) {\n    var p = node,\n        q = node.rbLeft, // can't be null\n        parent = p.rbParent;\n    if (parent) {\n        if (parent.rbLeft === p) {\n            parent.rbLeft = q;\n            }\n        else {\n            parent.rbRight = q;\n            }\n        }\n    else {\n        this.root = q;\n        }\n    q.rbParent = parent;\n    p.rbParent = q;\n    p.rbLeft = q.rbRight;\n    if (p.rbLeft) {\n        p.rbLeft.rbParent = p;\n        }\n    q.rbRight = p;\n    };\n\nVoronoi.prototype.RBTree.prototype.getFirst = function(node) {\n    while (node.rbLeft) {\n        node = node.rbLeft;\n        }\n    return node;\n    };\n\nVoronoi.prototype.RBTree.prototype.getLast = function(node) {\n    while (node.rbRight) {\n        node = node.rbRight;\n        }\n    return node;\n    };\n\n// ---------------------------------------------------------------------------\n// Diagram methods\n\nVoronoi.prototype.Diagram = function(site) {\n    this.site = site;\n    };\n\n// ---------------------------------------------------------------------------\n// Cell methods\n\nVoronoi.prototype.Cell = function(site) {\n    this.site = site;\n    this.halfedges = [];\n    this.closeMe = false;\n    };\n\nVoronoi.prototype.Cell.prototype.init = function(site) {\n    this.site = site;\n    this.halfedges = [];\n    this.closeMe = false;\n    return this;\n    };\n\nVoronoi.prototype.createCell = function(site) {\n    var cell = this.cellJunkyard.pop();\n    if ( cell ) {\n        return cell.init(site);\n        }\n    return new this.Cell(site);\n    };\n\nVoronoi.prototype.Cell.prototype.prepareHalfedges = function() {\n    var halfedges = this.halfedges,\n        iHalfedge = halfedges.length,\n        edge;\n    // get rid of unused halfedges\n    // rhill 2011-05-27: Keep it simple, no point here in trying\n    // to be fancy: dangling edges are a typically a minority.\n    while (iHalfedge--) {\n        edge = halfedges[iHalfedge].edge;\n        if (!edge.vb || !edge.va) {\n            halfedges.splice(iHalfedge,1);\n            }\n        }\n\n    // rhill 2011-05-26: I tried to use a binary search at insertion\n    // time to keep the array sorted on-the-fly (in Cell.addHalfedge()).\n    // There was no real benefits in doing so, performance on\n    // Firefox 3.6 was improved marginally, while performance on\n    // Opera 11 was penalized marginally.\n    halfedges.sort(function(a,b){return b.angle-a.angle;});\n    return halfedges.length;\n    };\n\n// Return a list of the neighbor Ids\nVoronoi.prototype.Cell.prototype.getNeighborIds = function() {\n    var neighbors = [],\n        iHalfedge = this.halfedges.length,\n        edge;\n    while (iHalfedge--){\n        edge = this.halfedges[iHalfedge].edge;\n        if (edge.lSite !== null && edge.lSite.voronoiId != this.site.voronoiId) {\n            neighbors.push(edge.lSite.voronoiId);\n            }\n        else if (edge.rSite !== null && edge.rSite.voronoiId != this.site.voronoiId){\n            neighbors.push(edge.rSite.voronoiId);\n            }\n        }\n    return neighbors;\n    };\n\n// Compute bounding box\n//\nVoronoi.prototype.Cell.prototype.getBbox = function() {\n    var halfedges = this.halfedges,\n        iHalfedge = halfedges.length,\n        xmin = Infinity,\n        ymin = Infinity,\n        xmax = -Infinity,\n        ymax = -Infinity,\n        v, vx, vy;\n    while (iHalfedge--) {\n        v = halfedges[iHalfedge].getStartpoint();\n        vx = v.x;\n        vy = v.y;\n        if (vx < xmin) {xmin = vx;}\n        if (vy < ymin) {ymin = vy;}\n        if (vx > xmax) {xmax = vx;}\n        if (vy > ymax) {ymax = vy;}\n        // we dont need to take into account end point,\n        // since each end point matches a start point\n        }\n    return {\n        x: xmin,\n        y: ymin,\n        width: xmax-xmin,\n        height: ymax-ymin\n        };\n    };\n\n// Return whether a point is inside, on, or outside the cell:\n//   -1: point is outside the perimeter of the cell\n//    0: point is on the perimeter of the cell\n//    1: point is inside the perimeter of the cell\n//\nVoronoi.prototype.Cell.prototype.pointIntersection = function(x, y) {\n    // Check if point in polygon. Since all polygons of a Voronoi\n    // diagram are convex, then:\n    // http://paulbourke.net/geometry/polygonmesh/\n    // Solution 3 (2D):\n    //   \"If the polygon is convex then one can consider the polygon\n    //   \"as a 'path' from the first vertex. A point is on the interior\n    //   \"of this polygons if it is always on the same side of all the\n    //   \"line segments making up the path. ...\n    //   \"(y - y0) (x1 - x0) - (x - x0) (y1 - y0)\n    //   \"if it is less than 0 then P is to the right of the line segment,\n    //   \"if greater than 0 it is to the left, if equal to 0 then it lies\n    //   \"on the line segment\"\n    var halfedges = this.halfedges,\n        iHalfedge = halfedges.length,\n        halfedge,\n        p0, p1, r;\n    while (iHalfedge--) {\n        halfedge = halfedges[iHalfedge];\n        p0 = halfedge.getStartpoint();\n        p1 = halfedge.getEndpoint();\n        r = (y-p0.y)*(p1.x-p0.x)-(x-p0.x)*(p1.y-p0.y);\n        if (!r) {\n            return 0;\n            }\n        if (r > 0) {\n            return -1;\n            }\n        }\n    return 1;\n    };\n\n// ---------------------------------------------------------------------------\n// Edge methods\n//\n\nVoronoi.prototype.Vertex = function(x, y) {\n    this.x = x;\n    this.y = y;\n    };\n\nVoronoi.prototype.Edge = function(lSite, rSite) {\n    this.lSite = lSite;\n    this.rSite = rSite;\n    this.va = this.vb = null;\n    };\n\nVoronoi.prototype.Halfedge = function(edge, lSite, rSite) {\n    this.site = lSite;\n    this.edge = edge;\n    // 'angle' is a value to be used for properly sorting the\n    // halfsegments counterclockwise. By convention, we will\n    // use the angle of the line defined by the 'site to the left'\n    // to the 'site to the right'.\n    // However, border edges have no 'site to the right': thus we\n    // use the angle of line perpendicular to the halfsegment (the\n    // edge should have both end points defined in such case.)\n    if (rSite) {\n        this.angle = Math.atan2(rSite.y-lSite.y, rSite.x-lSite.x);\n        }\n    else {\n        var va = edge.va,\n            vb = edge.vb;\n        // rhill 2011-05-31: used to call getStartpoint()/getEndpoint(),\n        // but for performance purpose, these are expanded in place here.\n        this.angle = edge.lSite === lSite ?\n            Math.atan2(vb.x-va.x, va.y-vb.y) :\n            Math.atan2(va.x-vb.x, vb.y-va.y);\n        }\n    };\n\nVoronoi.prototype.createHalfedge = function(edge, lSite, rSite) {\n    return new this.Halfedge(edge, lSite, rSite);\n    };\n\nVoronoi.prototype.Halfedge.prototype.getStartpoint = function() {\n    return this.edge.lSite === this.site ? this.edge.va : this.edge.vb;\n    };\n\nVoronoi.prototype.Halfedge.prototype.getEndpoint = function() {\n    return this.edge.lSite === this.site ? this.edge.vb : this.edge.va;\n    };\n\n\n\n// this create and add a vertex to the internal collection\n\nVoronoi.prototype.createVertex = function(x, y) {\n    var v = this.vertexJunkyard.pop();\n    if ( !v ) {\n        v = new this.Vertex(x, y);\n        }\n    else {\n        v.x = x;\n        v.y = y;\n        }\n    this.vertices.push(v);\n    return v;\n    };\n\n// this create and add an edge to internal collection, and also create\n// two halfedges which are added to each site's counterclockwise array\n// of halfedges.\n\nVoronoi.prototype.createEdge = function(lSite, rSite, va, vb) {\n    var edge = this.edgeJunkyard.pop();\n    if ( !edge ) {\n        edge = new this.Edge(lSite, rSite);\n        }\n    else {\n        edge.lSite = lSite;\n        edge.rSite = rSite;\n        edge.va = edge.vb = null;\n        }\n\n    this.edges.push(edge);\n    if (va) {\n        this.setEdgeStartpoint(edge, lSite, rSite, va);\n        }\n    if (vb) {\n        this.setEdgeEndpoint(edge, lSite, rSite, vb);\n        }\n    this.cells[lSite.voronoiId].halfedges.push(this.createHalfedge(edge, lSite, rSite));\n    this.cells[rSite.voronoiId].halfedges.push(this.createHalfedge(edge, rSite, lSite));\n    return edge;\n    };\n\nVoronoi.prototype.createBorderEdge = function(lSite, va, vb) {\n    var edge = this.edgeJunkyard.pop();\n    if ( !edge ) {\n        edge = new this.Edge(lSite, null);\n        }\n    else {\n        edge.lSite = lSite;\n        edge.rSite = null;\n        }\n    edge.va = va;\n    edge.vb = vb;\n    this.edges.push(edge);\n    return edge;\n    };\n\nVoronoi.prototype.setEdgeStartpoint = function(edge, lSite, rSite, vertex) {\n    if (!edge.va && !edge.vb) {\n        edge.va = vertex;\n        edge.lSite = lSite;\n        edge.rSite = rSite;\n        }\n    else if (edge.lSite === rSite) {\n        edge.vb = vertex;\n        }\n    else {\n        edge.va = vertex;\n        }\n    };\n\nVoronoi.prototype.setEdgeEndpoint = function(edge, lSite, rSite, vertex) {\n    this.setEdgeStartpoint(edge, rSite, lSite, vertex);\n    };\n\n// ---------------------------------------------------------------------------\n// Beachline methods\n\n// rhill 2011-06-07: For some reasons, performance suffers significantly\n// when instanciating a literal object instead of an empty ctor\nVoronoi.prototype.Beachsection = function() {\n    };\n\n// rhill 2011-06-02: A lot of Beachsection instanciations\n// occur during the computation of the Voronoi diagram,\n// somewhere between the number of sites and twice the\n// number of sites, while the number of Beachsections on the\n// beachline at any given time is comparatively low. For this\n// reason, we reuse already created Beachsections, in order\n// to avoid new memory allocation. This resulted in a measurable\n// performance gain.\n\nVoronoi.prototype.createBeachsection = function(site) {\n    var beachsection = this.beachsectionJunkyard.pop();\n    if (!beachsection) {\n        beachsection = new this.Beachsection();\n        }\n    beachsection.site = site;\n    return beachsection;\n    };\n\n// calculate the left break point of a particular beach section,\n// given a particular sweep line\nVoronoi.prototype.leftBreakPoint = function(arc, directrix) {\n    // http://en.wikipedia.org/wiki/Parabola\n    // http://en.wikipedia.org/wiki/Quadratic_equation\n    // h1 = x1,\n    // k1 = (y1+directrix)/2,\n    // h2 = x2,\n    // k2 = (y2+directrix)/2,\n    // p1 = k1-directrix,\n    // a1 = 1/(4*p1),\n    // b1 = -h1/(2*p1),\n    // c1 = h1*h1/(4*p1)+k1,\n    // p2 = k2-directrix,\n    // a2 = 1/(4*p2),\n    // b2 = -h2/(2*p2),\n    // c2 = h2*h2/(4*p2)+k2,\n    // x = (-(b2-b1) + Math.sqrt((b2-b1)*(b2-b1) - 4*(a2-a1)*(c2-c1))) / (2*(a2-a1))\n    // When x1 become the x-origin:\n    // h1 = 0,\n    // k1 = (y1+directrix)/2,\n    // h2 = x2-x1,\n    // k2 = (y2+directrix)/2,\n    // p1 = k1-directrix,\n    // a1 = 1/(4*p1),\n    // b1 = 0,\n    // c1 = k1,\n    // p2 = k2-directrix,\n    // a2 = 1/(4*p2),\n    // b2 = -h2/(2*p2),\n    // c2 = h2*h2/(4*p2)+k2,\n    // x = (-b2 + Math.sqrt(b2*b2 - 4*(a2-a1)*(c2-k1))) / (2*(a2-a1)) + x1\n\n    // change code below at your own risk: care has been taken to\n    // reduce errors due to computers' finite arithmetic precision.\n    // Maybe can still be improved, will see if any more of this\n    // kind of errors pop up again.\n    var site = arc.site,\n        rfocx = site.x,\n        rfocy = site.y,\n        pby2 = rfocy-directrix;\n    // parabola in degenerate case where focus is on directrix\n    if (!pby2) {\n        return rfocx;\n        }\n    var lArc = arc.rbPrevious;\n    if (!lArc) {\n        return -Infinity;\n        }\n    site = lArc.site;\n    var lfocx = site.x,\n        lfocy = site.y,\n        plby2 = lfocy-directrix;\n    // parabola in degenerate case where focus is on directrix\n    if (!plby2) {\n        return lfocx;\n        }\n    var hl = lfocx-rfocx,\n        aby2 = 1/pby2-1/plby2,\n        b = hl/plby2;\n    if (aby2) {\n        return (-b+this.sqrt(b*b-2*aby2*(hl*hl/(-2*plby2)-lfocy+plby2/2+rfocy-pby2/2)))/aby2+rfocx;\n        }\n    // both parabolas have same distance to directrix, thus break point is midway\n    return (rfocx+lfocx)/2;\n    };\n\n// calculate the right break point of a particular beach section,\n// given a particular directrix\nVoronoi.prototype.rightBreakPoint = function(arc, directrix) {\n    var rArc = arc.rbNext;\n    if (rArc) {\n        return this.leftBreakPoint(rArc, directrix);\n        }\n    var site = arc.site;\n    return site.y === directrix ? site.x : Infinity;\n    };\n\nVoronoi.prototype.detachBeachsection = function(beachsection) {\n    this.detachCircleEvent(beachsection); // detach potentially attached circle event\n    this.beachline.rbRemoveNode(beachsection); // remove from RB-tree\n    this.beachsectionJunkyard.push(beachsection); // mark for reuse\n    };\n\nVoronoi.prototype.removeBeachsection = function(beachsection) {\n    var circle = beachsection.circleEvent,\n        x = circle.x,\n        y = circle.ycenter,\n        vertex = this.createVertex(x, y),\n        previous = beachsection.rbPrevious,\n        next = beachsection.rbNext,\n        disappearingTransitions = [beachsection],\n        abs_fn = Math.abs;\n\n    // remove collapsed beachsection from beachline\n    this.detachBeachsection(beachsection);\n\n    // there could be more than one empty arc at the deletion point, this\n    // happens when more than two edges are linked by the same vertex,\n    // so we will collect all those edges by looking up both sides of\n    // the deletion point.\n    // by the way, there is *always* a predecessor/successor to any collapsed\n    // beach section, it's just impossible to have a collapsing first/last\n    // beach sections on the beachline, since they obviously are unconstrained\n    // on their left/right side.\n\n    // look left\n    var lArc = previous;\n    while (lArc.circleEvent && abs_fn(x-lArc.circleEvent.x)<1e-9 && abs_fn(y-lArc.circleEvent.ycenter)<1e-9) {\n        previous = lArc.rbPrevious;\n        disappearingTransitions.unshift(lArc);\n        this.detachBeachsection(lArc); // mark for reuse\n        lArc = previous;\n        }\n    // even though it is not disappearing, I will also add the beach section\n    // immediately to the left of the left-most collapsed beach section, for\n    // convenience, since we need to refer to it later as this beach section\n    // is the 'left' site of an edge for which a start point is set.\n    disappearingTransitions.unshift(lArc);\n    this.detachCircleEvent(lArc);\n\n    // look right\n    var rArc = next;\n    while (rArc.circleEvent && abs_fn(x-rArc.circleEvent.x)<1e-9 && abs_fn(y-rArc.circleEvent.ycenter)<1e-9) {\n        next = rArc.rbNext;\n        disappearingTransitions.push(rArc);\n        this.detachBeachsection(rArc); // mark for reuse\n        rArc = next;\n        }\n    // we also have to add the beach section immediately to the right of the\n    // right-most collapsed beach section, since there is also a disappearing\n    // transition representing an edge's start point on its left.\n    disappearingTransitions.push(rArc);\n    this.detachCircleEvent(rArc);\n\n    // walk through all the disappearing transitions between beach sections and\n    // set the start point of their (implied) edge.\n    var nArcs = disappearingTransitions.length,\n        iArc;\n    for (iArc=1; iArc<nArcs; iArc++) {\n        rArc = disappearingTransitions[iArc];\n        lArc = disappearingTransitions[iArc-1];\n        this.setEdgeStartpoint(rArc.edge, lArc.site, rArc.site, vertex);\n        }\n\n    // create a new edge as we have now a new transition between\n    // two beach sections which were previously not adjacent.\n    // since this edge appears as a new vertex is defined, the vertex\n    // actually define an end point of the edge (relative to the site\n    // on the left)\n    lArc = disappearingTransitions[0];\n    rArc = disappearingTransitions[nArcs-1];\n    rArc.edge = this.createEdge(lArc.site, rArc.site, undefined, vertex);\n\n    // create circle events if any for beach sections left in the beachline\n    // adjacent to collapsed sections\n    this.attachCircleEvent(lArc);\n    this.attachCircleEvent(rArc);\n    };\n\nVoronoi.prototype.addBeachsection = function(site) {\n    var x = site.x,\n        directrix = site.y;\n\n    // find the left and right beach sections which will surround the newly\n    // created beach section.\n    // rhill 2011-06-01: This loop is one of the most often executed,\n    // hence we expand in-place the comparison-against-epsilon calls.\n    var lArc, rArc,\n        dxl, dxr,\n        node = this.beachline.root;\n\n    while (node) {\n        dxl = this.leftBreakPoint(node,directrix)-x;\n        // x lessThanWithEpsilon xl => falls somewhere before the left edge of the beachsection\n        if (dxl > 1e-9) {\n            // this case should never happen\n            // if (!node.rbLeft) {\n            //    rArc = node.rbLeft;\n            //    break;\n            //    }\n            node = node.rbLeft;\n            }\n        else {\n            dxr = x-this.rightBreakPoint(node,directrix);\n            // x greaterThanWithEpsilon xr => falls somewhere after the right edge of the beachsection\n            if (dxr > 1e-9) {\n                if (!node.rbRight) {\n                    lArc = node;\n                    break;\n                    }\n                node = node.rbRight;\n                }\n            else {\n                // x equalWithEpsilon xl => falls exactly on the left edge of the beachsection\n                if (dxl > -1e-9) {\n                    lArc = node.rbPrevious;\n                    rArc = node;\n                    }\n                // x equalWithEpsilon xr => falls exactly on the right edge of the beachsection\n                else if (dxr > -1e-9) {\n                    lArc = node;\n                    rArc = node.rbNext;\n                    }\n                // falls exactly somewhere in the middle of the beachsection\n                else {\n                    lArc = rArc = node;\n                    }\n                break;\n                }\n            }\n        }\n    // at this point, keep in mind that lArc and/or rArc could be\n    // undefined or null.\n\n    // create a new beach section object for the site and add it to RB-tree\n    var newArc = this.createBeachsection(site);\n    this.beachline.rbInsertSuccessor(lArc, newArc);\n\n    // cases:\n    //\n\n    // [null,null]\n    // least likely case: new beach section is the first beach section on the\n    // beachline.\n    // This case means:\n    //   no new transition appears\n    //   no collapsing beach section\n    //   new beachsection become root of the RB-tree\n    if (!lArc && !rArc) {\n        return;\n        }\n\n    // [lArc,rArc] where lArc == rArc\n    // most likely case: new beach section split an existing beach\n    // section.\n    // This case means:\n    //   one new transition appears\n    //   the left and right beach section might be collapsing as a result\n    //   two new nodes added to the RB-tree\n    if (lArc === rArc) {\n        // invalidate circle event of split beach section\n        this.detachCircleEvent(lArc);\n\n        // split the beach section into two separate beach sections\n        rArc = this.createBeachsection(lArc.site);\n        this.beachline.rbInsertSuccessor(newArc, rArc);\n\n        // since we have a new transition between two beach sections,\n        // a new edge is born\n        newArc.edge = rArc.edge = this.createEdge(lArc.site, newArc.site);\n\n        // check whether the left and right beach sections are collapsing\n        // and if so create circle events, to be notified when the point of\n        // collapse is reached.\n        this.attachCircleEvent(lArc);\n        this.attachCircleEvent(rArc);\n        return;\n        }\n\n    // [lArc,null]\n    // even less likely case: new beach section is the *last* beach section\n    // on the beachline -- this can happen *only* if *all* the previous beach\n    // sections currently on the beachline share the same y value as\n    // the new beach section.\n    // This case means:\n    //   one new transition appears\n    //   no collapsing beach section as a result\n    //   new beach section become right-most node of the RB-tree\n    if (lArc && !rArc) {\n        newArc.edge = this.createEdge(lArc.site,newArc.site);\n        return;\n        }\n\n    // [null,rArc]\n    // impossible case: because sites are strictly processed from top to bottom,\n    // and left to right, which guarantees that there will always be a beach section\n    // on the left -- except of course when there are no beach section at all on\n    // the beach line, which case was handled above.\n    // rhill 2011-06-02: No point testing in non-debug version\n    //if (!lArc && rArc) {\n    //    throw \"Voronoi.addBeachsection(): What is this I don't even\";\n    //    }\n\n    // [lArc,rArc] where lArc != rArc\n    // somewhat less likely case: new beach section falls *exactly* in between two\n    // existing beach sections\n    // This case means:\n    //   one transition disappears\n    //   two new transitions appear\n    //   the left and right beach section might be collapsing as a result\n    //   only one new node added to the RB-tree\n    if (lArc !== rArc) {\n        // invalidate circle events of left and right sites\n        this.detachCircleEvent(lArc);\n        this.detachCircleEvent(rArc);\n\n        // an existing transition disappears, meaning a vertex is defined at\n        // the disappearance point.\n        // since the disappearance is caused by the new beachsection, the\n        // vertex is at the center of the circumscribed circle of the left,\n        // new and right beachsections.\n        // http://mathforum.org/library/drmath/view/55002.html\n        // Except that I bring the origin at A to simplify\n        // calculation\n        var lSite = lArc.site,\n            ax = lSite.x,\n            ay = lSite.y,\n            bx=site.x-ax,\n            by=site.y-ay,\n            rSite = rArc.site,\n            cx=rSite.x-ax,\n            cy=rSite.y-ay,\n            d=2*(bx*cy-by*cx),\n            hb=bx*bx+by*by,\n            hc=cx*cx+cy*cy,\n            vertex = this.createVertex((cy*hb-by*hc)/d+ax, (bx*hc-cx*hb)/d+ay);\n\n        // one transition disappear\n        this.setEdgeStartpoint(rArc.edge, lSite, rSite, vertex);\n\n        // two new transitions appear at the new vertex location\n        newArc.edge = this.createEdge(lSite, site, undefined, vertex);\n        rArc.edge = this.createEdge(site, rSite, undefined, vertex);\n\n        // check whether the left and right beach sections are collapsing\n        // and if so create circle events, to handle the point of collapse.\n        this.attachCircleEvent(lArc);\n        this.attachCircleEvent(rArc);\n        return;\n        }\n    };\n\n// ---------------------------------------------------------------------------\n// Circle event methods\n\n// rhill 2011-06-07: For some reasons, performance suffers significantly\n// when instanciating a literal object instead of an empty ctor\nVoronoi.prototype.CircleEvent = function() {\n    // rhill 2013-10-12: it helps to state exactly what we are at ctor time.\n    this.arc = null;\n    this.rbLeft = null;\n    this.rbNext = null;\n    this.rbParent = null;\n    this.rbPrevious = null;\n    this.rbRed = false;\n    this.rbRight = null;\n    this.site = null;\n    this.x = this.y = this.ycenter = 0;\n    };\n\nVoronoi.prototype.attachCircleEvent = function(arc) {\n    var lArc = arc.rbPrevious,\n        rArc = arc.rbNext;\n    if (!lArc || !rArc) {return;} // does that ever happen?\n    var lSite = lArc.site,\n        cSite = arc.site,\n        rSite = rArc.site;\n\n    // If site of left beachsection is same as site of\n    // right beachsection, there can't be convergence\n    if (lSite===rSite) {return;}\n\n    // Find the circumscribed circle for the three sites associated\n    // with the beachsection triplet.\n    // rhill 2011-05-26: It is more efficient to calculate in-place\n    // rather than getting the resulting circumscribed circle from an\n    // object returned by calling Voronoi.circumcircle()\n    // http://mathforum.org/library/drmath/view/55002.html\n    // Except that I bring the origin at cSite to simplify calculations.\n    // The bottom-most part of the circumcircle is our Fortune 'circle\n    // event', and its center is a vertex potentially part of the final\n    // Voronoi diagram.\n    var bx = cSite.x,\n        by = cSite.y,\n        ax = lSite.x-bx,\n        ay = lSite.y-by,\n        cx = rSite.x-bx,\n        cy = rSite.y-by;\n\n    // If points l->c->r are clockwise, then center beach section does not\n    // collapse, hence it can't end up as a vertex (we reuse 'd' here, which\n    // sign is reverse of the orientation, hence we reverse the test.\n    // http://en.wikipedia.org/wiki/Curve_orientation#Orientation_of_a_simple_polygon\n    // rhill 2011-05-21: Nasty finite precision error which caused circumcircle() to\n    // return infinites: 1e-12 seems to fix the problem.\n    var d = 2*(ax*cy-ay*cx);\n    if (d >= -2e-12){return;}\n\n    var ha = ax*ax+ay*ay,\n        hc = cx*cx+cy*cy,\n        x = (cy*ha-ay*hc)/d,\n        y = (ax*hc-cx*ha)/d,\n        ycenter = y+by;\n\n    // Important: ybottom should always be under or at sweep, so no need\n    // to waste CPU cycles by checking\n\n    // recycle circle event object if possible\n    var circleEvent = this.circleEventJunkyard.pop();\n    if (!circleEvent) {\n        circleEvent = new this.CircleEvent();\n        }\n    circleEvent.arc = arc;\n    circleEvent.site = cSite;\n    circleEvent.x = x+bx;\n    circleEvent.y = ycenter+this.sqrt(x*x+y*y); // y bottom\n    circleEvent.ycenter = ycenter;\n    arc.circleEvent = circleEvent;\n\n    // find insertion point in RB-tree: circle events are ordered from\n    // smallest to largest\n    var predecessor = null,\n        node = this.circleEvents.root;\n    while (node) {\n        if (circleEvent.y < node.y || (circleEvent.y === node.y && circleEvent.x <= node.x)) {\n            if (node.rbLeft) {\n                node = node.rbLeft;\n                }\n            else {\n                predecessor = node.rbPrevious;\n                break;\n                }\n            }\n        else {\n            if (node.rbRight) {\n                node = node.rbRight;\n                }\n            else {\n                predecessor = node;\n                break;\n                }\n            }\n        }\n    this.circleEvents.rbInsertSuccessor(predecessor, circleEvent);\n    if (!predecessor) {\n        this.firstCircleEvent = circleEvent;\n        }\n    };\n\nVoronoi.prototype.detachCircleEvent = function(arc) {\n    var circleEvent = arc.circleEvent;\n    if (circleEvent) {\n        if (!circleEvent.rbPrevious) {\n            this.firstCircleEvent = circleEvent.rbNext;\n            }\n        this.circleEvents.rbRemoveNode(circleEvent); // remove from RB-tree\n        this.circleEventJunkyard.push(circleEvent);\n        arc.circleEvent = null;\n        }\n    };\n\n// ---------------------------------------------------------------------------\n// Diagram completion methods\n\n// connect dangling edges (not if a cursory test tells us\n// it is not going to be visible.\n// return value:\n//   false: the dangling endpoint couldn't be connected\n//   true: the dangling endpoint could be connected\nVoronoi.prototype.connectEdge = function(edge, bbox) {\n    // skip if end point already connected\n    var vb = edge.vb;\n    if (!!vb) {return true;}\n\n    // make local copy for performance purpose\n    var va = edge.va,\n        xl = bbox.xl,\n        xr = bbox.xr,\n        yt = bbox.yt,\n        yb = bbox.yb,\n        lSite = edge.lSite,\n        rSite = edge.rSite,\n        lx = lSite.x,\n        ly = lSite.y,\n        rx = rSite.x,\n        ry = rSite.y,\n        fx = (lx+rx)/2,\n        fy = (ly+ry)/2,\n        fm, fb;\n\n    // if we reach here, this means cells which use this edge will need\n    // to be closed, whether because the edge was removed, or because it\n    // was connected to the bounding box.\n    this.cells[lSite.voronoiId].closeMe = true;\n    this.cells[rSite.voronoiId].closeMe = true;\n\n    // get the line equation of the bisector if line is not vertical\n    if (ry !== ly) {\n        fm = (lx-rx)/(ry-ly);\n        fb = fy-fm*fx;\n        }\n\n    // remember, direction of line (relative to left site):\n    // upward: left.x < right.x\n    // downward: left.x > right.x\n    // horizontal: left.x == right.x\n    // upward: left.x < right.x\n    // rightward: left.y < right.y\n    // leftward: left.y > right.y\n    // vertical: left.y == right.y\n\n    // depending on the direction, find the best side of the\n    // bounding box to use to determine a reasonable start point\n\n    // rhill 2013-12-02:\n    // While at it, since we have the values which define the line,\n    // clip the end of va if it is outside the bbox.\n    // https://github.com/gorhill/Javascript-Voronoi/issues/15\n    // TODO: Do all the clipping here rather than rely on Liang-Barsky\n    // which does not do well sometimes due to loss of arithmetic\n    // precision. The code here doesn't degrade if one of the vertex is\n    // at a huge distance.\n\n    // special case: vertical line\n    if (fm === undefined) {\n        // doesn't intersect with viewport\n        if (fx < xl || fx >= xr) {return false;}\n        // downward\n        if (lx > rx) {\n            if (!va || va.y < yt) {\n                va = this.createVertex(fx, yt);\n                }\n            else if (va.y >= yb) {\n                return false;\n                }\n            vb = this.createVertex(fx, yb);\n            }\n        // upward\n        else {\n            if (!va || va.y > yb) {\n                va = this.createVertex(fx, yb);\n                }\n            else if (va.y < yt) {\n                return false;\n                }\n            vb = this.createVertex(fx, yt);\n            }\n        }\n    // closer to vertical than horizontal, connect start point to the\n    // top or bottom side of the bounding box\n    else if (fm < -1 || fm > 1) {\n        // downward\n        if (lx > rx) {\n            if (!va || va.y < yt) {\n                va = this.createVertex((yt-fb)/fm, yt);\n                }\n            else if (va.y >= yb) {\n                return false;\n                }\n            vb = this.createVertex((yb-fb)/fm, yb);\n            }\n        // upward\n        else {\n            if (!va || va.y > yb) {\n                va = this.createVertex((yb-fb)/fm, yb);\n                }\n            else if (va.y < yt) {\n                return false;\n                }\n            vb = this.createVertex((yt-fb)/fm, yt);\n            }\n        }\n    // closer to horizontal than vertical, connect start point to the\n    // left or right side of the bounding box\n    else {\n        // rightward\n        if (ly < ry) {\n            if (!va || va.x < xl) {\n                va = this.createVertex(xl, fm*xl+fb);\n                }\n            else if (va.x >= xr) {\n                return false;\n                }\n            vb = this.createVertex(xr, fm*xr+fb);\n            }\n        // leftward\n        else {\n            if (!va || va.x > xr) {\n                va = this.createVertex(xr, fm*xr+fb);\n                }\n            else if (va.x < xl) {\n                return false;\n                }\n            vb = this.createVertex(xl, fm*xl+fb);\n            }\n        }\n    edge.va = va;\n    edge.vb = vb;\n\n    return true;\n    };\n\n// line-clipping code taken from:\n//   Liang-Barsky function by Daniel White\n//   http://www.skytopia.com/project/articles/compsci/clipping.html\n// Thanks!\n// A bit modified to minimize code paths\nVoronoi.prototype.clipEdge = function(edge, bbox) {\n    var ax = edge.va.x,\n        ay = edge.va.y,\n        bx = edge.vb.x,\n        by = edge.vb.y,\n        t0 = 0,\n        t1 = 1,\n        dx = bx-ax,\n        dy = by-ay;\n    // left\n    var q = ax-bbox.xl;\n    if (dx===0 && q<0) {return false;}\n    var r = -q/dx;\n    if (dx<0) {\n        if (r<t0) {return false;}\n        if (r<t1) {t1=r;}\n        }\n    else if (dx>0) {\n        if (r>t1) {return false;}\n        if (r>t0) {t0=r;}\n        }\n    // right\n    q = bbox.xr-ax;\n    if (dx===0 && q<0) {return false;}\n    r = q/dx;\n    if (dx<0) {\n        if (r>t1) {return false;}\n        if (r>t0) {t0=r;}\n        }\n    else if (dx>0) {\n        if (r<t0) {return false;}\n        if (r<t1) {t1=r;}\n        }\n    // top\n    q = ay-bbox.yt;\n    if (dy===0 && q<0) {return false;}\n    r = -q/dy;\n    if (dy<0) {\n        if (r<t0) {return false;}\n        if (r<t1) {t1=r;}\n        }\n    else if (dy>0) {\n        if (r>t1) {return false;}\n        if (r>t0) {t0=r;}\n        }\n    // bottom        \n    q = bbox.yb-ay;\n    if (dy===0 && q<0) {return false;}\n    r = q/dy;\n    if (dy<0) {\n        if (r>t1) {return false;}\n        if (r>t0) {t0=r;}\n        }\n    else if (dy>0) {\n        if (r<t0) {return false;}\n        if (r<t1) {t1=r;}\n        }\n\n    // if we reach this point, Voronoi edge is within bbox\n\n    // if t0 > 0, va needs to change\n    // rhill 2011-06-03: we need to create a new vertex rather\n    // than modifying the existing one, since the existing\n    // one is likely shared with at least another edge\n    if (t0 > 0) {\n        edge.va = this.createVertex(ax+t0*dx, ay+t0*dy);\n        }\n\n    // if t1 < 1, vb needs to change\n    // rhill 2011-06-03: we need to create a new vertex rather\n    // than modifying the existing one, since the existing\n    // one is likely shared with at least another edge\n    if (t1 < 1) {\n        edge.vb = this.createVertex(ax+t1*dx, ay+t1*dy);\n        }\n\n    // va and/or vb were clipped, thus we will need to close\n    // cells which use this edge.\n    if ( t0 > 0 || t1 < 1 ) {\n        this.cells[edge.lSite.voronoiId].closeMe = true;\n        this.cells[edge.rSite.voronoiId].closeMe = true;\n    }\n\n    return true;\n    };\n\n// Connect/cut edges at bounding box\nVoronoi.prototype.clipEdges = function(bbox) {\n    // connect all dangling edges to bounding box\n    // or get rid of them if it can't be done\n    var edges = this.edges,\n        iEdge = edges.length,\n        edge,\n        abs_fn = Math.abs;\n\n    // iterate backward so we can splice safely\n    while (iEdge--) {\n        edge = edges[iEdge];\n        // edge is removed if:\n        //   it is wholly outside the bounding box\n        //   it is looking more like a point than a line\n        if (!this.connectEdge(edge, bbox) ||\n            !this.clipEdge(edge, bbox) ||\n            (abs_fn(edge.va.x-edge.vb.x)<1e-9 && abs_fn(edge.va.y-edge.vb.y)<1e-9)) {\n            edge.va = edge.vb = null;\n            edges.splice(iEdge,1);\n            }\n        }\n    };\n\n// Close the cells.\n// The cells are bound by the supplied bounding box.\n// Each cell refers to its associated site, and a list\n// of halfedges ordered counterclockwise.\nVoronoi.prototype.closeCells = function(bbox) {\n    var xl = bbox.xl,\n        xr = bbox.xr,\n        yt = bbox.yt,\n        yb = bbox.yb,\n        cells = this.cells,\n        iCell = cells.length,\n        cell,\n        iLeft,\n        halfedges, nHalfedges,\n        edge,\n        va, vb, vz,\n        lastBorderSegment,\n        abs_fn = Math.abs;\n\n    while (iCell--) {\n        cell = cells[iCell];\n        // prune, order halfedges counterclockwise, then add missing ones\n        // required to close cells\n        if (!cell.prepareHalfedges()) {\n            continue;\n            }\n        if (!cell.closeMe) {\n            continue;\n            }\n        // find first 'unclosed' point.\n        // an 'unclosed' point will be the end point of a halfedge which\n        // does not match the start point of the following halfedge\n        halfedges = cell.halfedges;\n        nHalfedges = halfedges.length;\n        // special case: only one site, in which case, the viewport is the cell\n        // ...\n\n        // all other cases\n        iLeft = 0;\n        while (iLeft < nHalfedges) {\n            va = halfedges[iLeft].getEndpoint();\n            vz = halfedges[(iLeft+1) % nHalfedges].getStartpoint();\n            // if end point is not equal to start point, we need to add the missing\n            // halfedge(s) up to vz\n            if (abs_fn(va.x-vz.x)>=1e-9 || abs_fn(va.y-vz.y)>=1e-9) {\n\n                // rhill 2013-12-02:\n                // \"Holes\" in the halfedges are not necessarily always adjacent.\n                // https://github.com/gorhill/Javascript-Voronoi/issues/16\n\n                // find entry point:\n                switch (true) {\n\n                    // walk downward along left side\n                    case this.equalWithEpsilon(va.x,xl) && this.lessThanWithEpsilon(va.y,yb):\n                        lastBorderSegment = this.equalWithEpsilon(vz.x,xl);\n                        vb = this.createVertex(xl, lastBorderSegment ? vz.y : yb);\n                        edge = this.createBorderEdge(cell.site, va, vb);\n                        iLeft++;\n                        halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));\n                        nHalfedges++;\n                        if ( lastBorderSegment ) { break; }\n                        va = vb;\n                        // fall through\n\n                    // walk rightward along bottom side\n                    case this.equalWithEpsilon(va.y,yb) && this.lessThanWithEpsilon(va.x,xr):\n                        lastBorderSegment = this.equalWithEpsilon(vz.y,yb);\n                        vb = this.createVertex(lastBorderSegment ? vz.x : xr, yb);\n                        edge = this.createBorderEdge(cell.site, va, vb);\n                        iLeft++;\n                        halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));\n                        nHalfedges++;\n                        if ( lastBorderSegment ) { break; }\n                        va = vb;\n                        // fall through\n\n                    // walk upward along right side\n                    case this.equalWithEpsilon(va.x,xr) && this.greaterThanWithEpsilon(va.y,yt):\n                        lastBorderSegment = this.equalWithEpsilon(vz.x,xr);\n                        vb = this.createVertex(xr, lastBorderSegment ? vz.y : yt);\n                        edge = this.createBorderEdge(cell.site, va, vb);\n                        iLeft++;\n                        halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));\n                        nHalfedges++;\n                        if ( lastBorderSegment ) { break; }\n                        va = vb;\n                        // fall through\n\n                    // walk leftward along top side\n                    case this.equalWithEpsilon(va.y,yt) && this.greaterThanWithEpsilon(va.x,xl):\n                        lastBorderSegment = this.equalWithEpsilon(vz.y,yt);\n                        vb = this.createVertex(lastBorderSegment ? vz.x : xl, yt);\n                        edge = this.createBorderEdge(cell.site, va, vb);\n                        iLeft++;\n                        halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));\n                        nHalfedges++;\n                        if ( lastBorderSegment ) { break; }\n                        va = vb;\n                        // fall through\n\n                        // walk downward along left side\n                        lastBorderSegment = this.equalWithEpsilon(vz.x,xl);\n                        vb = this.createVertex(xl, lastBorderSegment ? vz.y : yb);\n                        edge = this.createBorderEdge(cell.site, va, vb);\n                        iLeft++;\n                        halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));\n                        nHalfedges++;\n                        if ( lastBorderSegment ) { break; }\n                        va = vb;\n                        // fall through\n\n                        // walk rightward along bottom side\n                        lastBorderSegment = this.equalWithEpsilon(vz.y,yb);\n                        vb = this.createVertex(lastBorderSegment ? vz.x : xr, yb);\n                        edge = this.createBorderEdge(cell.site, va, vb);\n                        iLeft++;\n                        halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));\n                        nHalfedges++;\n                        if ( lastBorderSegment ) { break; }\n                        va = vb;\n                        // fall through\n\n                        // walk upward along right side\n                        lastBorderSegment = this.equalWithEpsilon(vz.x,xr);\n                        vb = this.createVertex(xr, lastBorderSegment ? vz.y : yt);\n                        edge = this.createBorderEdge(cell.site, va, vb);\n                        iLeft++;\n                        halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));\n                        nHalfedges++;\n                        if ( lastBorderSegment ) { break; }\n                        // fall through\n\n                    default:\n                        throw \"Voronoi.closeCells() > this makes no sense!\";\n                    }\n                }\n            iLeft++;\n            }\n        cell.closeMe = false;\n        }\n    };\n\n// ---------------------------------------------------------------------------\n// Debugging helper\n/*\nVoronoi.prototype.dumpBeachline = function(y) {\n    console.log('Voronoi.dumpBeachline(%f) > Beachsections, from left to right:', y);\n    if ( !this.beachline ) {\n        console.log('  None');\n        }\n    else {\n        var bs = this.beachline.getFirst(this.beachline.root);\n        while ( bs ) {\n            console.log('  site %d: xl: %f, xr: %f', bs.site.voronoiId, this.leftBreakPoint(bs, y), this.rightBreakPoint(bs, y));\n            bs = bs.rbNext;\n            }\n        }\n    };\n*/\n\n// ---------------------------------------------------------------------------\n// Helper: Quantize sites\n\n// rhill 2013-10-12:\n// This is to solve https://github.com/gorhill/Javascript-Voronoi/issues/15\n// Since not all users will end up using the kind of coord values which would\n// cause the issue to arise, I chose to let the user decide whether or not\n// he should sanitize his coord values through this helper. This way, for\n// those users who uses coord values which are known to be fine, no overhead is\n// added.\n\nVoronoi.prototype.quantizeSites = function(sites) {\n    var ε = this.ε,\n        n = sites.length,\n        site;\n    while ( n-- ) {\n        site = sites[n];\n        site.x = Math.floor(site.x / ε) * ε;\n        site.y = Math.floor(site.y / ε) * ε;\n        }\n    };\n\n// ---------------------------------------------------------------------------\n// Helper: Recycle diagram: all vertex, edge and cell objects are\n// \"surrendered\" to the Voronoi object for reuse.\n// TODO: rhill-voronoi-core v2: more performance to be gained\n// when I change the semantic of what is returned.\n\nVoronoi.prototype.recycle = function(diagram) {\n    if ( diagram ) {\n        if ( diagram instanceof this.Diagram ) {\n            this.toRecycle = diagram;\n            }\n        else {\n            throw 'Voronoi.recycleDiagram() > Need a Diagram object.';\n            }\n        }\n    };\n\n// ---------------------------------------------------------------------------\n// Top-level Fortune loop\n\n// rhill 2011-05-19:\n//   Voronoi sites are kept client-side now, to allow\n//   user to freely modify content. At compute time,\n//   *references* to sites are copied locally.\n\nVoronoi.prototype.compute = function(sites, bbox) {\n    // to measure execution time\n    var startTime = new Date();\n\n    // init internal state\n    this.reset();\n\n    // any diagram data available for recycling?\n    // I do that here so that this is included in execution time\n    if ( this.toRecycle ) {\n        this.vertexJunkyard = this.vertexJunkyard.concat(this.toRecycle.vertices);\n        this.edgeJunkyard = this.edgeJunkyard.concat(this.toRecycle.edges);\n        this.cellJunkyard = this.cellJunkyard.concat(this.toRecycle.cells);\n        this.toRecycle = null;\n        }\n\n    // Initialize site event queue\n    var siteEvents = sites.slice(0);\n    siteEvents.sort(function(a,b){\n        var r = b.y - a.y;\n        if (r) {return r;}\n        return b.x - a.x;\n        });\n\n    // process queue\n    var site = siteEvents.pop(),\n        siteid = 0,\n        xsitex, // to avoid duplicate sites\n        xsitey,\n        cells = this.cells,\n        circle;\n\n    // main loop\n    for (;;) {\n        // we need to figure whether we handle a site or circle event\n        // for this we find out if there is a site event and it is\n        // 'earlier' than the circle event\n        circle = this.firstCircleEvent;\n\n        // add beach section\n        if (site && (!circle || site.y < circle.y || (site.y === circle.y && site.x < circle.x))) {\n            // only if site is not a duplicate\n            if (site.x !== xsitex || site.y !== xsitey) {\n                // first create cell for new site\n                cells[siteid] = this.createCell(site);\n                site.voronoiId = siteid++;\n                // then create a beachsection for that site\n                this.addBeachsection(site);\n                // remember last site coords to detect duplicate\n                xsitey = site.y;\n                xsitex = site.x;\n                }\n            site = siteEvents.pop();\n            }\n\n        // remove beach section\n        else if (circle) {\n            this.removeBeachsection(circle.arc);\n            }\n\n        // all done, quit\n        else {\n            break;\n            }\n        }\n\n    // wrapping-up:\n    //   connect dangling edges to bounding box\n    //   cut edges as per bounding box\n    //   discard edges completely outside bounding box\n    //   discard edges which are point-like\n    this.clipEdges(bbox);\n\n    //   add missing edges in order to close opened cells\n    this.closeCells(bbox);\n\n    // to measure execution time\n    var stopTime = new Date();\n\n    // prepare return values\n    var diagram = new this.Diagram();\n    diagram.cells = this.cells;\n    diagram.edges = this.edges;\n    diagram.vertices = this.vertices;\n    diagram.execTime = stopTime.getTime()-startTime.getTime();\n\n    // clean up\n    this.reset();\n\n    return diagram;\n    };\n\n/******************************************************************************/\n\nif ( typeof module !== 'undefined' ) {\n    module.exports = Voronoi;\n}\nthis.Voronoi = Voronoi;\n","const {\n  distToPath,\n  getCosSimAroundPoint,\n  getLinesIntersectPoint,\n  getOutlinePoints,\n  extendPointOnLine,\n  estimateTanPoints,\n  roundPathPoints,\n  ptEq,\n  dist,\n} = require('./utils');\n\n\nCLIP_THRESH = 2;\nLOWER_COS_SIM_THRESH = 0.89;\nUPPER_COS_SIM_THRESH = 0.97;\n\n// A bridge is a place in the pathstring where 2 strokes intersect. It can either be 1 stroke clipping\n// another, or it can be strokes passing through each other. In the pathstring from makemeahanzi, any\n// L # # in the pathstring is a\nclass Bridge {\n  constructor(points, pointString, stroke) {\n    this.points = points;\n    this.pointString = pointString;\n    this.stroke = stroke;\n    this.estTanPoints = estimateTanPoints(stroke.outline, points);\n  }\n\n  getClips() {\n    // this clip point is super tiny, it's probably just a glitch, skip it\n    if (dist(this.points[0], this.points[1]) < 3.1) return [];\n    const cosSim0 = getCosSimAroundPoint(this.points[0], this.stroke.outline);\n    const cosSim1 = getCosSimAroundPoint(this.points[1], this.stroke.outline);\n    // If the angle around the bridge points looks flat, it's probably an intersection.\n    if (Math.min(cosSim0, cosSim1) > LOWER_COS_SIM_THRESH && Math.max(cosSim0, cosSim1) > UPPER_COS_SIM_THRESH) {\n      return [];\n    }\n    return this.stroke.character.strokes.filter(stroke => {\n      if (stroke === this.stroke) return false;\n      const dist0 = distToPath(this.points[0], stroke.outline);\n      const dist1 = distToPath(this.points[1], stroke.outline);\n      return dist0 <= CLIP_THRESH && dist1 <= CLIP_THRESH;\n    }).map(clippingStroke => new Clip(this, clippingStroke));\n  }\n}\n\nclass Clip {\n  constructor(bridge, clippingStroke) {\n    this.points = bridge.points;\n    this.estTanPoints = bridge.estTanPoints;\n    this.pointString = bridge.pointString;\n    this.clippedBy = [clippingStroke];\n    this.isDouble = false;\n  }\n\n  canMerge(otherClip) {\n    return ptEq(this.points[1], otherClip.points[0]);\n  }\n\n  mergeIntoDouble(otherClip) {\n    this.isDouble = true;\n    this.clippedBy = this.clippedBy.concat(otherClip.clippedBy);\n    this.middlePoint = otherClip.points[0];\n    this.points[1] = otherClip.points[1];\n    this.estTanPoints[1] = otherClip.estTanPoints[1];\n    this.pointString += otherClip.pointString.replace(/.*L/, ' L');\n  }\n\n  getNewStrokeTip() {\n    const maxControlPoint = getLinesIntersectPoint(\n      this.estTanPoints[0],\n      this.points[0],\n      this.estTanPoints[1],\n      this.points[1],\n    );\n\n    const maxDistControl0 = dist(maxControlPoint, this.points[0]);\n    const maxDistControl1 = dist(maxControlPoint, this.points[1]);\n    let distControl0 = Math.min(maxDistControl0, 30);\n    let distControl1 = Math.min(maxDistControl1, 30);\n\n    // if the 2 lines are parallel, there will be no intersection point. Just use 30 in that case.\n    if (isNaN(distControl0)) distControl0 = 30;\n    if (isNaN(distControl1)) distControl1 = 30;\n\n    if (this.isDouble) {\n      const midDist0 = dist(this.middlePoint, this.points[0]);\n      const midDist1 = dist(this.middlePoint, this.points[1]);\n      distControl0 = Math.max(midDist0 * 1.4, distControl0);\n      distControl1 = Math.max(midDist1 * 1.4, distControl1);\n    }\n\n    const controlPoint0 = extendPointOnLine(this.estTanPoints[0], this.points[0], distControl0);\n    const controlPoint1 = extendPointOnLine(this.estTanPoints[1], this.points[1], distControl1);\n\n    const pString = point => `${Math.round(point.x)} ${Math.round(point.y)}`;\n\n    return `${pString(this.points[0])} C ${pString(controlPoint0)} ${pString(controlPoint1)} ${pString(this.points[1])}`;\n  }\n}\n\nclass Stroke {\n  constructor(pathString, character, strokeNum) {\n    this.pathString = pathString;\n    this.outline = getOutlinePoints(pathString);\n    this.character = character;\n    this.strokeNum = strokeNum;\n  }\n\n  getBridges() {\n    const pointStringParts = this.pathString.match(/-?\\d+(?:\\.\\d+)? -?\\d+(?:\\.\\d+)? L/ig);\n    if (!pointStringParts) return [];\n    return pointStringParts.map(pointStringPart => {\n      const fullPointStringRegex = new RegExp(`${pointStringPart} -?\\\\d+(?:\\\\.\\\\d+)? -?\\\\d+(?:\\\\.\\\\d+)?`);\n      const pointString = this.pathString.match(fullPointStringRegex)[0];\n      const parts = pointString.split(/\\sL?\\s?/).map(num => parseFloat(num));\n      const points = [{x: parts[0], y: parts[1]}, {x: parts[2], y: parts[3]}];\n      return new Bridge(points, pointString, this);\n    });\n  }\n\n  fixPathString() {\n    const bridges = this.getBridges();\n    let clips = [];\n    bridges.forEach(bridge => {\n      bridge.getClips().forEach(clip => {\n        const lastClip = clips[clips.length - 1];\n        if (lastClip && lastClip.canMerge(clip)) {\n          lastClip.mergeIntoDouble(clip);\n        } else {\n          clips.push(clip);\n        }\n      });\n    });\n\n    let modifiedPathString = this.pathString;\n    clips.forEach(clip => {\n      const newTip = clip.getNewStrokeTip();\n      modifiedPathString = roundPathPoints(modifiedPathString.replace(clip.pointString, newTip));\n    });\n\n    return {\n      isModified: clips.length > 0,\n      isDoubleClipped: !!clips.find(clip => clip.isDouble),\n      pathString: modifiedPathString,\n      strokeNum: this.strokeNum,\n    };\n  }\n}\n\nclass Character {\n  constructor(pathStrings) {\n    this.strokes = pathStrings.map((path, i) => new Stroke(path, this, i));\n  }\n}\n\nconst fixStrokesWithDetails = (strokePathStrings) => {\n  const character = new Character(strokePathStrings);\n  const fixedStrokesInfo = character.strokes.map(stroke => stroke.fixPathString());\n\n  return {\n    modified: !!fixedStrokesInfo.find(summary => summary.isModified),\n    hasDoubleClippedStroke: !!fixedStrokesInfo.find(summary => summary.isDoubleClipped),\n    modifiedStrokes: fixedStrokesInfo.filter(summary => summary.isModified).map(summary => summary.strokeNum),\n    strokes: fixedStrokesInfo.map(summary => summary.pathString),\n  };\n};\n\nconst fixStrokesOnce = (strokes) => {\n  const corrected = fixStrokesWithDetails(strokes);\n  return corrected.modified ? corrected.strokes : strokes;\n}\n\nconst fixStrokes = (strokes) => fixStrokesOnce(fixStrokesOnce(strokes));\n\nmodule.exports = {fixStrokes};\n","const svgPathUtils = require('point-at-length');\n\nconst dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\nconst norm = (vect) => dist(vect, {x: 0, y: 0});\nconst subtract = (p1, p2) => ({x: p1.x - p2.x, y: p1.y - p2.y});\nconst ptEq = (p1, p2) => p1.x === p2.x && p1.y === p2.y;\n\nconst getOutlinePoints = (pathString, count = 1000) => {\n  const path = svgPathUtils(pathString);\n  const delta = path.length() / count;\n  const outline = [];\n  for (let i = 0; i < count; i += 1) {\n    const svgPoint = path.at(i * delta);\n    outline.push({x: svgPoint[0], y: svgPoint[1]});\n  }\n  return outline;\n};\n\n// get the intersection point of 2 lines defined by 2 points each\n// from https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\nconst getLinesIntersectPoint = (l1p1, l1p2, l2p1, l2p2) => {\n  const x1 = l1p1.x;\n  const x2 = l1p2.x;\n  const x3 = l2p1.x;\n  const x4 = l2p2.x;\n  const y1 = l1p1.y;\n  const y2 = l1p2.y;\n  const y3 = l2p1.y;\n  const y4 = l2p2.y;\n  const xNumerator = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);\n  const yNumerator = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);\n  const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n  return {x: xNumerator / denominator, y: yNumerator / denominator};\n};\n\nconst getPointIndex = (point, pathOutline) => {\n  const dists = pathOutline.map(outlinePoint => dist(point, outlinePoint));\n  const min = Math.min(...dists);\n  return dists.indexOf(min);\n};\n\nconst getIndexAtDelta = (index, delta, pathOutline) => {\n  return (pathOutline.length + index + delta) % pathOutline.length;\n};\n\nconst getCosSimAroundPoint = (point, pathOutline) => {\n  // if this is 1, the point is on a flat line.\n  const pointIndex = getPointIndex(point, pathOutline);\n  const preIndex = getIndexAtDelta(pointIndex, -3, pathOutline);\n  const postIndex = getIndexAtDelta(pointIndex, 3, pathOutline);\n  const vect1 = subtract(pathOutline[pointIndex], pathOutline[preIndex]);\n  const vect2 = subtract(pathOutline[postIndex], pathOutline[pointIndex]);\n  return (vect1.x * vect2.x + vect1.y * vect2.y) / (norm(vect1) * norm(vect2));\n};\n\n// return a new point, p3, which is on the same line as p1 and p2, but distance away\n// from p2. p1, p2, p3 will always lie on the line in that order\nconst extendPointOnLine = (p1, p2, distance) => {\n  const vect = subtract(p2, p1);\n  const mag = distance / norm(vect);\n  return {x: p2.x + mag * vect.x, y: p2.y + mag * vect.y};\n};\n\nconst distToPath = (point, pathOutline) => {\n  const dists = pathOutline.map(outlinePoint => dist(point, outlinePoint));\n  return Math.min(...dists);\n};\n\nconst roundPathPoints = (pathString) => {\n  const floats = pathString.match(/\\d+\\.\\d+/ig);\n  if (!floats) return pathString;\n  let fixedPathString = pathString;\n  floats.forEach(float => {\n    fixedPathString = fixedPathString.replace(float, Math.round(parseFloat(float)));\n  });\n  return fixedPathString;\n};\n\nconst estimateTanPoints = (pathOutline, clipPoints) => {\n  const cpIndex0 = getPointIndex(clipPoints[0], pathOutline);\n  const cpIndex1 = getPointIndex(clipPoints[1], pathOutline);\n  return [\n    pathOutline[getIndexAtDelta(cpIndex0, -15, pathOutline)],\n    pathOutline[getIndexAtDelta(cpIndex1, 15, pathOutline)],\n  ];\n};\n\nmodule.exports = {\n  distToPath,\n  getCosSimAroundPoint,\n  getOutlinePoints,\n  getLinesIntersectPoint,\n  extendPointOnLine,\n  estimateTanPoints,\n  dist,\n  ptEq,\n  roundPathPoints,\n};\n","const kIdPrefix = 'make-me-a-hanzi';\nconst kWidth = 128;\n\nconst distance2 = (point1, point2) => {\n  const diff = [point1[0] - point2[0], point1[1] - point2[1]];\n  return diff[0]*diff[0] + diff[1]*diff[1];\n}\n\nconst getMedianLength = (median) => {\n  let result = 0;\n  for (let i = 0; i < median.length - 1; i++) {\n    result += Math.sqrt(distance2(median[i], median[i + 1]));\n  }\n  return result;\n}\n\nconst getMedianPath = (median) => {\n  const result = [];\n  for (let point of median) {\n    result.push(result.length === 0 ? 'M' : 'L');\n    result.push('' + point[0]);\n    result.push('' + point[1]);\n  }\n  return result.join(' ');\n}\n\n\nconst getAnimationData = (strokes, medians, options) => {\n  options = options || {};\n  const delay = 1024 * (options.delay || 0.3);\n  const speed = 1024 * (options.speed || 0.02);\n\n  const lengths = medians.map((x) => getMedianLength(x) + kWidth)\n                         .map(Math.round);\n  const paths = medians.map(getMedianPath);\n\n  const animations = [];\n  let total_duration = 0;\n  for (let i = 0; i < strokes.length; i++) {\n    const offset = lengths[i] + kWidth;\n    const duration = (delay + offset) / speed / 60;\n    const fraction = Math.round(100 * offset / (delay + offset));\n    animations.push({\n      animation_id: `${kIdPrefix}-animation-${i}`,\n      clip_id: `${kIdPrefix}-clip-${i}`,\n      d: paths[i],\n      delay: `${total_duration}s`,\n      duration: `${duration}s`,\n      fraction: `${fraction}%`,\n      keyframes: `keyframes${i}`,\n      length: lengths[i],\n      offset: offset,\n      spacing: 2 * lengths[i],\n      stroke: strokes[i],\n      width: kWidth,\n    });\n    total_duration += duration;\n  }\n\n  return {animations: animations, strokes: strokes};\n}\n\nexport {getAnimationData};\n","// Prints the message and throws an error if the conditionis false.\nconst assert = (condition, message) => {\n  if (!condition) {\n    console.error(message);\n    throw new Error;\n  }\n}\n\nconst isNumber = (x) => Number.isFinite(x) && !Number.isNaN(x);\n\nconst maybeRequire = (module) => Meteor.isServer ? Npm.require(module) : null;\n\nlet getPWD = null;\n\nif (Meteor.isServer) {\n  Meteor.npmRequire('es6-shim');\n  const path = Npm.require('path');\n\n  getPWD = () => {\n    // TODO(skishore): The next line makes assumptions about the Meteor build\n    // directory's structure. We should replace it with a Meteor-provided API.\n    return process.env && process.env.PWD ?\n        process.env.PWD : path.join(process.cwd(), '../../../..');\n  }\n}\n\n// Returns a list of the unique values in the given array, ordered by their\n// first appearance in the array.\nArray.prototype.unique = function() {\n  const result = [];\n  const seen = {};\n  this.map((x) => {\n    if (!seen[x]) {\n      result.push(x);\n      seen[x] = true;\n    }\n  });\n  return result;\n}\n\n// Given a string and a dict mapping characters to other characters, return a\n// string with that mapping applied to each of its characters.\nString.prototype.applyMapping = function(mapping) {\n  let result = '';\n  for (let i = 0; i < this.length; i++) {\n    result += mapping[this[i]] ? mapping[this[i]] : this[i];\n  }\n  return result;\n}\n\n// Helper methods for use with angles, which are floats in [-pi, pi).\nconst Angle = {\n  subtract: (angle1, angle2) => {\n    var result = angle1 - angle2;\n    if (result < -Math.PI) {\n      result += 2*Math.PI;\n    }\n    if (result >= Math.PI) {\n      result -= 2*Math.PI;\n    }\n    return result;\n  },\n  penalty: (diff) => diff*diff,\n};\n\n// Helper methods for use with \"points\", which are pairs of integers.\nconst Point = {\n  add: (point1, point2) => [point1[0] + point2[0], point1[1] + point2[1]],\n  angle: (point) => Math.atan2(point[1], point[0]),\n  clone: (point) => [point[0], point[1]],\n  distance2(point1, point2) {\n    var diff = Point.subtract(point1, point2);\n    return Math.pow(diff[0], 2) + Math.pow(diff[1], 2);\n  },\n  dot: (point1, point2) => point1[0]*point2[0] + point1[1]*point2[1],\n  equal: (point1, point2) => point1[0] === point2[0] && point1[1] === point2[1],\n  key: (point) => point.join(','),\n  midpoint: (point1, point2) => {\n    return [(point1[0] + point2[0])/2, (point1[1] + point2[1])/2];\n  },\n  subtract: (point1, point2) => [point1[0] - point2[0], point1[1] - point2[1]],\n  valid: (point) => isNumber(point[0]) && isNumber(point[1]),\n};\n\nexport {assert, getPWD, maybeRequire, Angle, Point};\n","import {assert, getPWD, maybeRequire} from '/lib/base';\n\nconst fs = maybeRequire('fs');\nconst path = maybeRequire('path');\n\nconst CHARACTER_FIELDS = ['character', 'decomposition', 'definition',\n                          'frequency', 'kangxi_index', 'pinyin',\n                          'simplified', 'strokes', 'traditional'];\n\nconst cjklib = {\n  characters: {},\n  gb2312: {},\n  promise: undefined,\n  radicals: {\n    primary_radical: {},\n    index_to_radical_map: {},\n    radical_to_index_map: {},\n    radical_to_character_map: {},\n  },\n  getCharacterData(character) {\n    const result = {};\n    CHARACTER_FIELDS.map((field) =>\n        result[field] = cjklib.characters[field][character]);\n    result.character = character;\n    result.traditional = result.traditional || [];\n    return result;\n  },\n};\n\nCHARACTER_FIELDS.map((field) => cjklib.characters[field] = {});\n\n// Input: String contents of a cjklib data file.\n// Output: a list of rows, each of which is a list of String columns.\nconst getCJKLibRows = (data) => {\n  const lines = data.split('\\n');\n  return lines.filter((line) => line.length > 0 && line[0] !== '#')\n              .map((line) => line.split(',').map(\n                  (entry) => entry.replace(/[\"']/g, '')));\n}\n\n// Input: String contents of a TSV data file.\n// Output: a list of rows, each of which is a list of String columns.\nconst getFrequencyRows = (data) => {\n  const lines = data.split('\\n');\n  return lines.filter((line) => line.length > 0 && line[0] !== '#')\n              .map((line) => line.split('\\t'));\n}\n\n// Input: String contents of a Unihan data file.\n// Output: a list of rows, each of which is a list of String columns.\nconst getUnihanRows = (data) => {\n  const lines = data.split('\\n');\n  return lines.filter((line) => line.length > 0 && line[0] !== '#')\n              .map((line) => line.split('\\t'));\n}\n\n// Input: a String of the form 'U+<hex>' representing a Unicode codepoint.\n// Output: the character at that codepoint\nconst parseUnicodeStr =\n    (str) => String.fromCodePoint(parseInt(str.substr(2), 16));\n\n// Input: the path to a Unihan data file, starting from the public directory.\n// Output: Promise that resolves to the String contents of that file.\nconst readFile = (filename) => new Promise((resolve, reject) => {\n  if (Meteor.isServer) {\n    const filepath = path.join(getPWD(), 'public', filename);\n    fs.readFile(filepath, 'utf8', (error, data) => {\n      if (error) throw error;\n      resolve(data);\n    });\n  } else {\n    $.get(filename, (data, code) => {\n      if (code !== 'success') throw new Error(code);\n      resolve(data);\n    });\n  }\n});\n\n// Promises that fill data from specific tables.\n\n// Output: Promise that fills result with a mapping character -> decomposition.\n// The decompositions are formatted using Ideographic Description Sequence\n// symbols - see the Unicode standard for more details.\nconst fillDecompositions = (decompositions, glyphs, result) => {\n  return Promise.all([decompositions, glyphs]).then(([rows, glyphs]) => {\n    rows.filter((row) => parseInt(row[2], 10) === (glyphs[row[0]] || 0))\n        .map((row) => result[row[0]] = row[1]);\n  });\n}\n\n// Output: Promise that fills result with a mapping character -> Pinyin.\nconst fillDefinitions = (readings, result) => {\n  return readings.then((rows) => {\n    rows.filter((row) => row[1] === 'kDefinition')\n        .map((row) => result[parseUnicodeStr(row[0])] = row[2]);\n  });\n}\n\n// Output: Promise that fills result with a mapping character -> frequency rank.\nconst fillFrequencies = (readings, result) => {\n  return readings.then((rows) => {\n    rows.map((row) => result[row[1]] = parseInt(row[0], 10));\n  });\n}\n\n// Output: Promise that fills result with a mapping character -> Kangxi radical-\n// stroke count, which is a pair of integers [radical, extra_strokes].\nconst fillKangxiIndex = (readings, result) => {\n  return readings.then((rows) => {\n    const getIndex = (adotb) => adotb.split('.').map((x) => parseInt(x, 10));\n    rows.filter((row) => row[1] === 'kRSKangXi')\n        .map((row) => result[parseUnicodeStr(row[0])] = getIndex(row[2]));\n  });\n}\n\n// Output: Promise that fills result with a mapping character -> Pinyin.\nconst fillPinyin = (readings, result) => {\n  return readings.then((rows) => {\n    rows.filter((row) => row[1] === 'kMandarin')\n        .map((row) => result[parseUnicodeStr(row[0])] = row[2]);\n  });\n}\n\n// Output: Promise that fills result with a mapping character -> stroke count.\nconst fillStrokeCounts = (dictionary_like_data, result) => {\n  return dictionary_like_data.then((rows) => {\n    rows.filter((row) => row[1] === 'kTotalStrokes')\n        .map((row) => result[parseUnicodeStr(row[0])] = parseInt(row[2], 10));\n  });\n}\n\n// Output: Promise that fills multiple dictionaries in the result:\n//   - index_to_radical_map: Map from index -> list of radicals at that index\n//   - radical_to_index_map: Map from radical -> index of that radical\n//   - primary_radical: Map from index -> primary radical at that index\nconst fillRadicalData = (locale, radicals, result) => {\n  return radicals.then((rows) => {\n    rows.map((row) => {\n      if (!result.index_to_radical_map.hasOwnProperty(row[0])) {\n        result.index_to_radical_map[row[0]] = [];\n      }\n      result.index_to_radical_map[row[0]].push(row[1]);\n      result.radical_to_index_map[row[1]] = row[0];\n      if (row[2] === 'R' && row[3].indexOf(locale) >= 0) {\n        result.primary_radical[row[0]] = row[1];\n      }\n    });\n  });\n}\n\n// Output: Promise that fills result with a map from Unicode radical-codeblock\n// character -> equivalent Unicode CJK-codeblock (hopefully, GB2312) character.\n// There may be Unicode radical characters without a CJK equivalent.\nconst fillRadicalToCharacterMap =\n    (locale, radical_equivalent_characters, result) => {\n  return radical_equivalent_characters.then((rows) => {\n    rows.filter((row) => row[2].indexOf(locale) >= 0)\n        .map((row) => result[row[0]] = row[1]);\n  });\n}\n\n// Output: Promise that fills the two maps with pointers from a given character\n// to its simplified and traditional variants.\nconst fillVariants = (simplified, traditional, variants) => {\n  return variants.then((rows) => {\n    rows.map((row) => {\n      if ((row[1] !== 'kSimplifiedVariant' &&\n           row[1] !== 'kTraditionalVariant') ||\n          row[0] === row[2] || row[0] === 'U+2B5B8') {\n        // Unicode introduced an extra character U+2B5B8 matching U+613F.\n        return;\n      }\n      let source = parseUnicodeStr(row[0]);\n      let target = parseUnicodeStr(row[2]);\n      const split = row[2].split(' ');\n      // A number of characters have multiple simplified variants. Of these,\n      // we should only use one of them, usually the first, but in three cases,\n      // the second.\n      if (split.length === 2 &&\n          ['U+937E', 'U+949F', 'U+9918'].indexOf(row[0]) >= 0) {\n        target = parseUnicodeStr(split[1]);\n      }\n      if (source === target) {\n        return;\n      } else if (row[1] === 'kTraditionalVariant') {\n        const swap = target;\n        target = source;\n        source = swap;\n      }\n      // The mapping from traditional characters to simplified characters is\n      // many to one, so we can only assert that simplified[source] is unique.\n      assert(!simplified[source] || simplified[source] === target);\n      simplified[source] = target;\n      traditional[target] = _.unique(\n          (traditional[target] || []).concat([source]));\n    });\n  });\n}\n\n// Given the data from the GB2312 data file, fills the GB2312 result map.\nconst fillGB2312 = (data, result) => {\n  Array.from(data).map((character) => {\n    if (character === '\\n') return;\n    assert(character.length === 1);\n    const codepoint = character.codePointAt(0);\n    assert(0x4e00 <= codepoint && codepoint <= 0x9fff);\n    result[character] = true;\n  });\n  assert(Object.keys(result).length === 6763);\n}\n\n// Given the rows of the locale-character map from the cjklib data, returns a\n// mapping from characters to the appropriate glyph in that locale.\nconst parseLocaleGlyphMap = (locale, rows) => {\n  const result = {};\n  rows.filter((row) => row[2].indexOf(locale) >= 0)\n      .map((row) => result[row[0]] = parseInt(row[1], 10));\n  return result;\n}\n\n// Methods used for final post-processing of the loaded datasets.\n\nconst cleanupCJKLibData = () => {\n  const characters = cjklib.characters;\n  const radicals = cjklib.radicals;\n  const convert_astral_characters = (x) => x.length === 1 ? x : '？'\n  const radical_to_character = (x) => radicals.radical_to_character_map[x] || x;\n  Object.keys(characters.decomposition).map((character) => {\n    // Convert any 'astral characters' - that is, characters outside the Basic\n    // Multilingual Plane - to wide question marks and replace radicals with an\n    // equivalent character with that character.\n    const decomposition = characters.decomposition[character];\n    characters.decomposition[character] =\n        Array.from(decomposition).map(convert_astral_characters)\n                                 .map(radical_to_character).join('');\n  });\n  for (let i = 1; i <= 214; i++) {\n    // All primary radicals should have an equivalent character form.\n    const primary = radicals.primary_radical[i];\n    assert(radicals.radical_to_character_map.hasOwnProperty(primary));\n    radicals.primary_radical[i] = radicals.radical_to_character_map[primary];\n    radicals.index_to_radical_map[i] =\n        radicals.index_to_radical_map[i].map(radical_to_character).unique();\n  }\n  Object.keys(radicals.radical_to_index_map).map((radical) => {\n    const character = radical_to_character(radical);\n    if (character !== radical) {\n      radicals.radical_to_index_map[character] =\n          radicals.radical_to_index_map[radical];\n      delete radicals.radical_to_index_map[radical];\n    }\n  });\n  delete radicals.radical_to_character_map;\n}\n\nMeteor.startup(() => {\n  // cjklib database data.\n  const locale = 'C';\n  const decomposition =\n      readFile('cjklib/characterdecomposition.csv').then(getCJKLibRows);\n  const glyphs = readFile('cjklib/localecharacterglyph.csv')\n                     .then(getCJKLibRows)\n                     .then(parseLocaleGlyphMap.bind(null, locale));\n  const radicals = readFile('cjklib/kangxiradical.csv').then(getCJKLibRows);\n  const radical_equivalent_characters =\n      readFile('cjklib/radicalequivalentcharacter.csv').then(getCJKLibRows);\n  const radical_isolated_characters =\n      readFile('cjklib/kangxiradicalisolatedcharacter.csv').then(getCJKLibRows);\n\n  // Jun Da's character frequency data, used only for prioritization.\n  const frequencies = readFile('junda/character_frequency.tsv')\n                          .then(getFrequencyRows);\n\n  // Unihan database data.\n  const dictionary_like_data =\n      readFile('unihan/Unihan_DictionaryLikeData.txt').then(getUnihanRows);\n  const radical_stroke_counts =\n      readFile('unihan/Unihan_RadicalStrokeCounts.txt').then(getUnihanRows);\n  const readings = readFile('unihan/Unihan_Readings.txt').then(getUnihanRows);\n  const variants = readFile('unihan/Unihan_Variants.txt').then(getUnihanRows);\n\n  cjklib.promise = Promise.all([\n      // Per-character data.\n      fillDecompositions(decomposition, glyphs,\n                         cjklib.characters.decomposition),\n      fillDefinitions(readings, cjklib.characters.definition),\n      fillFrequencies(frequencies, cjklib.characters.frequency),\n      fillKangxiIndex(radical_stroke_counts, cjklib.characters.kangxi_index),\n      fillPinyin(readings, cjklib.characters.pinyin),\n      fillStrokeCounts(dictionary_like_data, cjklib.characters.strokes),\n      // Per-radical data.\n      fillRadicalData(locale, radicals, cjklib.radicals),\n      fillRadicalData(locale, radical_isolated_characters, cjklib.radicals),\n      fillRadicalToCharacterMap(locale, radical_equivalent_characters,\n                                cjklib.radicals.radical_to_character_map),\n      fillVariants(cjklib.characters.simplified,\n                   cjklib.characters.traditional, variants),\n      // Extract the list of characters in the GB2312 character set.\n      readFile('gb2312').then((data) => fillGB2312(data, cjklib.gb2312)),\n  ]).then(cleanupCJKLibData);\n  cjklib.promise.catch(console.error.bind(console));\n});\n\nexport {cjklib};\n","import {NEURAL_NET_TRAINED_FOR_STROKE_EXTRACTION} from '/lib/net';\nimport {stroke_extractor} from '/lib/stroke_extractor';\n\nMeteor.startup(() => {\n  const input = new convnetjs.Vol(1, 1, 8 /* feature vector dimensions */);\n  const net = new convnetjs.Net();\n  net.fromJSON(NEURAL_NET_TRAINED_FOR_STROKE_EXTRACTION);\n  const weight = 0.8;\n\n  const trainedClassifier = (features) => {\n    input.w = features;\n    const softmax = net.forward(input).w;\n    return softmax[1] - softmax[0];\n  }\n\n  stroke_extractor.combinedClassifier = (features) => {\n    return stroke_extractor.handTunedClassifier(features) +\n           weight*trainedClassifier(features);\n  }\n});\n","import {assert} from '/lib/base';\n\nconst decomposition_util = {};\n\ndecomposition_util.ids_data = {\n  '⿰': {label: 'Left-to-right', arity: 2},\n  '⿱': {label: 'Top-to-bottom', arity: 2},\n  '⿴': {label: 'Surround', arity: 2},\n  '⿵': {label: 'Surround-from-above', arity: 2},\n  '⿶': {label: 'Surround-from-below', arity: 2},\n  '⿷': {label: 'Surround-from-left', arity: 2},\n  '⿸': {label: 'Surround-from-upper-left', arity: 2},\n  '⿹': {label: 'Surround-from-upper-right', arity: 2},\n  '⿺': {label: 'Surround-from-lower-left', arity: 2},\n  '⿻': {label: 'Overlaid', arity: 2},\n  '⿳': {label: 'Top-to-middle-to-bottom', arity: 3},\n  '⿲': {label: 'Left-to-middle-to-right', arity: 3},\n}\ndecomposition_util.ideograph_description_characters =\n    Object.keys(decomposition_util.ids_data);\n\nconst UNKNOWN_COMPONENT = '？';\n\nconst augmentTreeWithPathData = (tree, path) => {\n  tree.path = path;\n  const children = (tree.children || []).length;\n  for (let i = 0; i < children; i++) {\n    augmentTreeWithPathData(tree.children[i], path.concat([i]));\n  }\n  return tree;\n}\n\nconst parseSubtree = (decomposition, index) => {\n  assert(index[0] < decomposition.length,\n         `Not enough characters in ${decomposition}.`);\n  const current = decomposition[index[0]];\n  index[0] += 1;\n  if (decomposition_util.ids_data.hasOwnProperty(current)) {\n    const result = {type: 'compound', value: current, children: []};\n    for (let i = 0; i < decomposition_util.ids_data[current].arity; i++) {\n      result.children.push(parseSubtree(decomposition, index));\n    }\n    return result;\n  } else if (current === UNKNOWN_COMPONENT) {\n    return {type: 'character', value: '?'};\n  }\n  // Characters may be followed by a [x] annotation that records which variant\n  // of the character to use at that position. We ignore these annotations.\n  if (decomposition[index[0]] === '[') {\n    assert('0123456789'.indexOf(decomposition[index[0] + 1]) >= 0);\n    assert(decomposition[index[0] + 2] === ']');\n    index[0] += 3;\n  }\n  return {type: 'character', value: current};\n}\n\nconst serializeSubtree = (subtree, result) => {\n  result[0] += subtree.value === '?' ? UNKNOWN_COMPONENT : subtree.value;\n  const children = subtree.children ? subtree.children.length : 0;\n  for (let i = 0; i < children; i++) {\n    serializeSubtree(subtree.children[i], result);\n  }\n}\n\ndecomposition_util.collectComponents = (tree, result) => {\n  result = result || [];\n  if (tree.type === 'character' && tree.value !== '?') {\n    result.push(tree.value);\n  }\n  for (let child of tree.children || []) {\n    decomposition_util.collectComponents(child, result);\n  }\n  return result;\n}\n\ndecomposition_util.convertDecompositionToTree = (decomposition) => {\n  const index = [0];\n  decomposition = decomposition || UNKNOWN_COMPONENT;\n  const result = parseSubtree(decomposition, index);\n  assert(index[0] === decomposition.length,\n         `Too many characters in ${decomposition}.`);\n  return augmentTreeWithPathData(result, []);\n}\n\ndecomposition_util.convertTreeToDecomposition = (tree) => {\n  const result = [''];\n  serializeSubtree(tree, result);\n  return result[0];\n}\n\ndecomposition_util.getSubtree = (tree, path) => {\n  let subtree = tree;\n  for (let index of path) {\n    assert(0 <= index && index < subtree.children.length);\n    subtree = subtree.children[index];\n  }\n  return subtree;\n}\n\nexport {decomposition_util};\n","import {assert} from '/lib/base';\nimport {cjklib} from '/lib/cjklib';\n\nconst defaultGlyph = (character) => {\n  if (!character) return;\n  assert(character.length === 1);\n  const data = cjklib.getCharacterData(character);\n  const result = {\n    character: character,\n    codepoint: character.codePointAt(0),\n    metadata: {\n      frequency: data.frequency,\n      kangxi_index: data.kangxi_index,\n    },\n    stages: {},\n    simplified: data.simplified,\n    traditional: data.traditional,\n  }\n  if (data.simplified) {\n    const glyph = Glyphs.get(data.simplified);\n    const base = cjklib.getCharacterData(data.simplified);\n    if (glyph.stages.verified) {\n      const metadata = glyph.metadata;\n      result.metadata.definition = metadata.definition || base.definition;\n      result.metadata.pinyin = metadata.pinyin || base.pinyin;\n    }\n  }\n  return result;\n}\n\nconst Glyphs = new Mongo.Collection('glyphs');\nconst Progress = new Mongo.Collection('progress');\n\nGlyphs.clearDependencies = (character) => {\n  const stack = [character];\n  const visited = {};\n  visited[character] = true;\n  while (stack.length > 0) {\n    const current = stack.pop();\n    const dependencies = Glyphs.find({\n      'stages.analysis.decomposition': {$regex: `.*${current}.*`},\n      'stages.order': {$ne: null},\n    }, {character: 1}).fetch();\n    dependencies.map((x) => x.character).filter((x) => !visited[x]).map((x) => {\n      stack.push(x);\n      visited[x] = true;\n    });\n  }\n  delete visited[character];\n  Glyphs.update({character: {$in: Object.keys(visited)}},\n                {$set: {'stages.order': null, 'stages.verified': null}},\n                {multi: true});\n}\n\nGlyphs.get = (character) =>\n    Glyphs.findOne({character: character}) || defaultGlyph(character);\n\nGlyphs.getAll = (characters) => Glyphs.find({character: {$in: characters}});\n\nGlyphs.getNext = (glyph, clause) => {\n  clause = clause || {};\n  const codepoint = glyph ? glyph.codepoint : undefined;\n  const condition = _.extend({codepoint: {$gt: codepoint}}, clause);\n  const next = Glyphs.findOne(condition, {sort: {codepoint: 1}});\n  return next ? next : Glyphs.findOne(clause, {sort: {codepoint: 1}});\n}\n\nGlyphs.getNextUnverified = (glyph) => {\n  return Glyphs.getNext(glyph, {'stages.verified': null});\n}\n\nGlyphs.getNextVerified = (glyph) => {\n  return Glyphs.getNext(glyph, {'stages.verified': {$ne: null}});\n}\n\nGlyphs.getPrevious = (glyph, clause) => {\n  clause = clause || {};\n  const codepoint = glyph ? glyph.codepoint : undefined;\n  const condition = _.extend({codepoint: {$lt: codepoint}}, clause);\n  const previous = Glyphs.findOne(condition, {sort: {codepoint: -1}});\n  return previous ? previous : Glyphs.findOne(clause, {sort: {codepoint: -1}});\n}\n\nGlyphs.getPreviousUnverified = (glyph) => {\n  return Glyphs.getPrevious(glyph, {'stages.verified': null});\n}\n\nGlyphs.getPreviousVerified = (glyph) => {\n  return Glyphs.getPrevious(glyph, {'stages.verified': {$ne: null}});\n}\n\nGlyphs.loadAll = (characters) => {\n  for (let character of characters) {\n    const glyph = Glyphs.get(character);\n    if (!glyph.stages.verified) {\n      Glyphs.upsert({character: glyph.character}, glyph);\n    }\n  }\n  Progress.refresh();\n}\n\nGlyphs.save = (glyph) => {\n  check(glyph.character, String);\n  assert(glyph.character.length === 1);\n  const current = Glyphs.get(glyph.character);\n  if (current && current.stages.verified && !glyph.stages.verified) {\n    Glyphs.clearDependencies(glyph.character);\n  }\n  Glyphs.syncDefinitionAndPinyin(glyph);\n  if (glyph.stages.path && !glyph.stages.path.sentinel) {\n    Glyphs.upsert({character: glyph.character}, glyph);\n  } else {\n    Glyphs.remove({character: glyph.character});\n  }\n  Progress.refresh();\n}\n\nGlyphs.syncDefinitionAndPinyin = (glyph) => {\n  const data = cjklib.getCharacterData(glyph.character);\n  const base = cjklib.getCharacterData(data.simplified || glyph.character);\n  const targets = [base.character].concat(base.traditional);\n  if (targets.length === 1 || '干么着复'.indexOf(targets[0]) >= 0) {\n    return;\n  }\n  const definition = glyph.metadata.definition || data.definition;\n  const pinyin = glyph.metadata.pinyin || data.pinyin;\n  Glyphs.update({character: {$in: targets}}, {$set: {\n    'metadata.definition': definition,\n    'metadata.pinyin': pinyin,\n  }}, {multi: true});\n}\n\nProgress.refresh = () => {\n  const total = Glyphs.find().count();\n  const complete = Glyphs.find({'stages.verified': {$ne: null}}).count();\n  Progress.upsert({}, {total: total, complete: complete, backup: false});\n}\n\nif (Meteor.isServer) {\n  // Construct indices on the Glyphs table.\n  Glyphs._ensureIndex({character: 1}, {unique: true});\n  Glyphs._ensureIndex({codepoint: 1}, {unique: true});\n  Glyphs._ensureIndex({'stages.verified': 1});\n\n  // Refresh the Progress counter.\n  Progress.refresh();\n\n  // Register the methods above so they are available to the client.\n  const methods = {};\n  const method_names = [\n      'get', 'getNext', 'getNextUnverified', 'getNextVerified',\n      'getPrevious', 'getPreviousUnverified', 'getPreviousVerified', 'save'];\n  method_names.map((name) => methods[`${name}Glyph`] = Glyphs[name]);\n  methods.loadAllGlyphs = Glyphs.loadAll;\n  methods.saveGlyphs = (glyphs) => glyphs.map(Glyphs.save);\n  Meteor.methods(methods);\n\n  // Publish accessors that will get all glyphs in a list and get the progress.\n  Meteor.publish('getAllGlyphs', Glyphs.getAll);\n  Meteor.publish('getProgress', Progress.find.bind(Progress));\n}\n\nexport {Glyphs, Progress};\n","// This algorithm was pulled from another one of my projects. -skishore\n//   https://github.com/skishore/tesseract/blob/master/coffee/hungarian.coffee\n\nvar bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nconst Hungarian = (function() {\n  function Hungarian(cost_matrix) {\n    var i, j, last_matched, len, ref, ref1, results, row, x, y;\n    this.cost_matrix = cost_matrix;\n    this.get_final_score = bind(this.get_final_score, this);\n    this.update_labels = bind(this.update_labels, this);\n    this.find_root_and_slacks = bind(this.find_root_and_slacks, this);\n    this.augment = bind(this.augment, this);\n    this.match = bind(this.match, this);\n    this.cost = bind(this.cost, this);\n    this.find_greedy_solution = bind(this.find_greedy_solution, this);\n    this.reduce_cost_matrix = bind(this.reduce_cost_matrix, this);\n    this.n = this.cost_matrix.length;\n    ref = this.cost_matrix;\n    for (i = 0, len = ref.length; i < len; i++) {\n      row = ref[i];\n      if (row.length !== this.n) {\n        throw new Error(\"Malforrmed cost_matrix: \" + this.cost_matrix);\n      }\n    }\n    this.range = (function() {\n      results = [];\n      for (var j = 0, ref1 = this.n; 0 <= ref1 ? j < ref1 : j > ref1; 0 <= ref1 ? j++ : j--){ results.push(j); }\n      return results;\n    }).apply(this);\n    this.matched = 0;\n    this.x_label = (function() {\n      var k, len1, ref2, results1;\n      ref2 = this.range;\n      results1 = [];\n      for (k = 0, len1 = ref2.length; k < len1; k++) {\n        x = ref2[k];\n        results1.push(0);\n      }\n      return results1;\n    }).call(this);\n    this.y_label = (function() {\n      var k, len1, ref2, results1;\n      ref2 = this.range;\n      results1 = [];\n      for (k = 0, len1 = ref2.length; k < len1; k++) {\n        y = ref2[k];\n        results1.push(0);\n      }\n      return results1;\n    }).call(this);\n    this.x_match = (function() {\n      var k, len1, ref2, results1;\n      ref2 = this.range;\n      results1 = [];\n      for (k = 0, len1 = ref2.length; k < len1; k++) {\n        x = ref2[k];\n        results1.push(-1);\n      }\n      return results1;\n    }).call(this);\n    this.y_match = (function() {\n      var k, len1, ref2, results1;\n      ref2 = this.range;\n      results1 = [];\n      for (k = 0, len1 = ref2.length; k < len1; k++) {\n        y = ref2[k];\n        results1.push(-1);\n      }\n      return results1;\n    }).call(this);\n    this.reduce_cost_matrix();\n    this.find_greedy_solution();\n    while (this.matched < this.n) {\n      last_matched = this.matched;\n      this.augment();\n      if (this.matched <= last_matched) {\n        throw new Error(\"Augmentation round did not increase matched!\");\n      }\n    }\n  }\n\n  Hungarian.prototype.reduce_cost_matrix = function() {\n    var i, j, k, l, len, len1, len2, len3, max_cost, ref, ref1, ref2, ref3, row, x, y;\n    this.cost_matrix = (function() {\n      var i, len, ref, results;\n      ref = this.cost_matrix;\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        row = ref[i];\n        results.push(row.slice());\n      }\n      return results;\n    }).call(this);\n    ref = this.range;\n    for (i = 0, len = ref.length; i < len; i++) {\n      x = ref[i];\n      max_cost = Math.max.apply(0, (function() {\n        var j, len1, ref1, results;\n        ref1 = this.range;\n        results = [];\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          y = ref1[j];\n          results.push(this.cost_matrix[x][y]);\n        }\n        return results;\n      }).call(this));\n      ref1 = this.range;\n      for (j = 0, len1 = ref1.length; j < len1; j++) {\n        y = ref1[j];\n        this.cost_matrix[x][y] -= max_cost;\n      }\n      this.x_label[x] = 0;\n    }\n    ref2 = this.range;\n    for (k = 0, len2 = ref2.length; k < len2; k++) {\n      y = ref2[k];\n      max_cost = Math.max.apply(0, (function() {\n        var l, len3, ref3, results;\n        ref3 = this.range;\n        results = [];\n        for (l = 0, len3 = ref3.length; l < len3; l++) {\n          x = ref3[l];\n          results.push(this.cost_matrix[x][y]);\n        }\n        return results;\n      }).call(this));\n      ref3 = this.range;\n      for (l = 0, len3 = ref3.length; l < len3; l++) {\n        x = ref3[l];\n        this.cost_matrix[x][y] -= max_cost;\n      }\n      this.y_label[y] = 0;\n    }\n  };\n\n  Hungarian.prototype.find_greedy_solution = function() {\n    var i, len, ref, results, x, y;\n    ref = this.range;\n    results = [];\n    for (i = 0, len = ref.length; i < len; i++) {\n      x = ref[i];\n      results.push((function() {\n        var j, len1, ref1, results1;\n        ref1 = this.range;\n        results1 = [];\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          y = ref1[j];\n          if (this.x_match[x] === -1 && this.y_match[y] === -1 && (this.cost(x, y)) === 0) {\n            this.match(x, y);\n            results1.push(this.matched += 1);\n          } else {\n            results1.push(void 0);\n          }\n        }\n        return results1;\n      }).call(this));\n    }\n    return results;\n  };\n\n  Hungarian.prototype.cost = function(x, y) {\n    return this.cost_matrix[x][y] - this.x_label[x] - this.y_label[y];\n  };\n\n  Hungarian.prototype.match = function(x, y) {\n    this.x_match[x] = y;\n    return this.y_match[y] = x;\n  };\n\n  Hungarian.prototype.augment = function() {\n    var cur_x, cur_y, delta, delta_x, delta_y, i, j, len, len1, new_slack, next_y, ref, ref1, ref2, root, slack, slack_x, x, x_in_tree, y, y_parent;\n    x_in_tree = (function() {\n      var i, len, ref, results;\n      ref = this.range;\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        x = ref[i];\n        results.push(false);\n      }\n      return results;\n    }).call(this);\n    y_parent = (function() {\n      var i, len, ref, results;\n      ref = this.range;\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        y = ref[i];\n        results.push(-1);\n      }\n      return results;\n    }).call(this);\n    ref = this.find_root_and_slacks(), root = ref[0], slack = ref[1], slack_x = ref[2];\n    x_in_tree[root] = true;\n    while (true) {\n      delta = Infinity;\n      ref1 = this.range;\n      for (i = 0, len = ref1.length; i < len; i++) {\n        y = ref1[i];\n        if (y_parent[y] < 0 && slack[y] < delta) {\n          delta = slack[y];\n          delta_x = slack_x[y];\n          delta_y = y;\n        }\n      }\n      this.update_labels(delta, x_in_tree, y_parent, slack);\n      y_parent[delta_y] = delta_x;\n      if (this.y_match[delta_y] < 0) {\n        cur_y = delta_y;\n        while (cur_y >= 0) {\n          cur_x = y_parent[cur_y];\n          next_y = this.x_match[cur_x];\n          this.match(cur_x, cur_y);\n          cur_y = next_y;\n        }\n        this.matched += 1;\n        return;\n      }\n      x = this.y_match[delta_y];\n      x_in_tree[x] = true;\n      ref2 = this.range;\n      for (j = 0, len1 = ref2.length; j < len1; j++) {\n        y = ref2[j];\n        if (y_parent[y] < 0) {\n          new_slack = -(this.cost(x, y));\n          if (slack[y] > new_slack) {\n            slack[y] = new_slack;\n            slack_x[y] = x;\n          }\n        }\n      }\n    }\n  };\n\n  Hungarian.prototype.find_root_and_slacks = function() {\n    var i, len, ref, x, y;\n    ref = this.range;\n    for (i = 0, len = ref.length; i < len; i++) {\n      x = ref[i];\n      if (this.x_match[x] < 0) {\n        return [\n          x, (function() {\n            var j, len1, ref1, results;\n            ref1 = this.range;\n            results = [];\n            for (j = 0, len1 = ref1.length; j < len1; j++) {\n              y = ref1[j];\n              results.push(-(this.cost(x, y)));\n            }\n            return results;\n          }).call(this), (function() {\n            var j, len1, ref1, results;\n            ref1 = this.range;\n            results = [];\n            for (j = 0, len1 = ref1.length; j < len1; j++) {\n              y = ref1[j];\n              results.push(x);\n            }\n            return results;\n          }).call(this)\n        ];\n      }\n    }\n  };\n\n  Hungarian.prototype.update_labels = function(delta, x_in_tree, y_parent, slack) {\n    var i, j, len, len1, ref, ref1, results, x, y;\n    ref = this.range;\n    for (i = 0, len = ref.length; i < len; i++) {\n      x = ref[i];\n      if (x_in_tree[x]) {\n        this.x_label[x] -= delta;\n      }\n    }\n    ref1 = this.range;\n    results = [];\n    for (j = 0, len1 = ref1.length; j < len1; j++) {\n      y = ref1[j];\n      if (y_parent[y] < 0) {\n        results.push(slack[y] -= delta);\n      } else {\n        results.push(this.y_label[y] += delta);\n      }\n    }\n    return results;\n  };\n\n  Hungarian.prototype.get_final_score = function(original_matrix) {\n    var x;\n    return Util.sum((function() {\n      var i, len, ref, results;\n      ref = this.range;\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        x = ref[i];\n        results.push(original_matrix[x][this.x_match[x]]);\n      }\n      return results;\n    }).call(this));\n  };\n\n  return Hungarian;\n\n})();\n\nexport {Hungarian};\n","import simplify from '/lib/external/simplify/1.2.2/simplify';\n\nimport {assert, Point} from '/lib/base';\nimport {svg} from '/lib/svg';\n\nconst size = 1024;\nconst rise = 900;\nconst num_to_match = 8;\n\nlet voronoi = undefined;\n\nconst filterMedian = (median, n) => {\n  const distances = _.range(median.length - 1).map(\n      (i) => Math.sqrt(Point.distance2(median[i], median[i + 1])));\n  let total = 0;\n  distances.map((x) => total += x);\n  const result = [];\n  let index = 0;\n  let position = median[0];\n  let total_so_far = 0;\n  for (let i of _.range(n - 1)) {\n    const target = i*total/(n - 1);\n    while (total_so_far < target) {\n      const step = Math.sqrt(Point.distance2(position, median[index + 1]));\n      if (total_so_far + step < target) {\n        index += 1;\n        position = median[index];\n        total_so_far += step;\n      } else {\n        const t = (target - total_so_far)/step;\n        position = [(1 - t)*position[0] + t*median[index + 1][0],\n                    (1 - t)*position[1] + t*median[index + 1][1]];\n        total_so_far = target;\n      }\n    }\n    result.push(Point.clone(position));\n  }\n  result.push(median[median.length - 1]);\n  return result;\n}\n\nconst findLongestShortestPath = (adjacency, vertices, node) => {\n  const path = findPathFromFurthestNode(adjacency, vertices, node);\n  return findPathFromFurthestNode(adjacency, vertices, path[0]);\n}\n\nconst findPathFromFurthestNode = (adjacency, vertices, node, visited) => {\n  visited = visited || {};\n  visited[node] = true;\n  let result = [];\n  result.distance = 0;\n  for (let neighbor of adjacency[node] || []) {\n    if (!visited[neighbor]) {\n      const candidate = findPathFromFurthestNode(\n          adjacency, vertices, neighbor, visited);\n      candidate.distance +=\n          Math.sqrt(Point.distance2(vertices[node], vertices[neighbor]));\n      if (candidate.distance > result.distance) {\n        result = candidate;\n      }\n    }\n  }\n  result.push(node);\n  return result;\n}\n\nconst findStrokeMedian = (stroke) => {\n  const paths = svg.convertSVGPathToPaths(stroke);\n  assert(paths.length === 1, `Got stroke with multiple loops: ${stroke}`);\n\n  let polygon = undefined;\n  let diagram = undefined;\n  for (let approximation of [16, 64]) {\n    polygon = svg.getPolygonApproximation(paths[0], approximation);\n    voronoi = voronoi || new Voronoi;\n    const sites = polygon.map((point) => ({x: point[0], y: point[1]}));\n    const bounding_box = {xl: -size, xr: size, yt: -size, yb: size};\n    try {\n      diagram = voronoi.compute(sites, bounding_box);\n      break;\n    } catch(error) {\n      console.error(`WARNING: Voronoi computation failed at ${approximation}.`);\n    }\n  }\n  assert(diagram, 'Voronoi computation failed completely!');\n\n  diagram.vertices.map((x, i) => {\n    x.include = svg.polygonContainsPoint(polygon, [x.x, x.y]);\n    x.index = i;\n  });\n  const vertices = diagram.vertices.map((x) => [x.x, x.y].map(Math.round));\n  const edges = diagram.edges.map((x) => [x.va.index, x.vb.index]).filter(\n      (x) => diagram.vertices[x[0]].include && diagram.vertices[x[1]].include);\n  voronoi.recycle(diagram);\n\n  assert(edges.length > 0);\n  const adjacency = {};\n  for (let edge of edges) {\n    adjacency[edge[0]] = adjacency[edge[0]] || [];\n    adjacency[edge[0]].push(edge[1]);\n    adjacency[edge[1]] = adjacency[edge[1]] || [];\n    adjacency[edge[1]].push(edge[0]);\n  }\n  const root = edges[0][0];\n  const path = findLongestShortestPath(adjacency, vertices, root);\n  const points = path.map((i) => vertices[i]);\n\n  const tolerance = 4;\n  const simple = simplify(points.map((x) => ({x: x[0], y: x[1]})), tolerance);\n  return simple.map((x) => [x.x, x.y]);\n}\n\nconst normalizeForMatch = (median) => {\n  return filterMedian(median, num_to_match).map(\n      (x) => [x[0]/size, (rise - x[1])/size]);\n}\n\nconst median_util = {\n  findStrokeMedian: findStrokeMedian,\n  normalizeForMatch: normalizeForMatch,\n};\n\nexport {median_util};\n","const NEURAL_NET_TRAINED_FOR_STROKE_EXTRACTION = {\"layers\":[{\"out_depth\":8,\"out_sx\":1,\"out_sy\":1,\"layer_type\":\"input\"},{\"out_depth\":8,\"out_sx\":1,\"out_sy\":1,\"layer_type\":\"fc\",\"num_inputs\":8,\"l1_decay_mul\":0,\"l2_decay_mul\":1,\"filters\":[{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":-0.3044261605666167,\"1\":-0.14834922423083324,\"2\":0.20219401661574177,\"3\":0.5503522616459873,\"4\":0.45502127328350234,\"5\":0.2625745186594936,\"6\":0.012889731022695689,\"7\":-0.2675923800252626,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":183,\"1\":140,\"2\":235,\"3\":220,\"4\":183,\"5\":123,\"6\":211,\"7\":191,\"8\":214,\"9\":172,\"10\":58,\"11\":125,\"12\":27,\"13\":253,\"14\":194,\"15\":191,\"16\":244,\"17\":222,\"18\":103,\"19\":88,\"20\":126,\"21\":225,\"22\":201,\"23\":63,\"24\":164,\"25\":146,\"26\":161,\"27\":88,\"28\":124,\"29\":156,\"30\":225,\"31\":63,\"32\":183,\"33\":41,\"34\":239,\"35\":139,\"36\":17,\"37\":31,\"38\":221,\"39\":63,\"40\":43,\"41\":243,\"42\":153,\"43\":90,\"44\":5,\"45\":206,\"46\":208,\"47\":63,\"48\":29,\"49\":223,\"50\":146,\"51\":105,\"52\":238,\"53\":101,\"54\":138,\"55\":63,\"56\":243,\"57\":129,\"58\":55,\"59\":202,\"60\":59,\"61\":32,\"62\":209,\"63\":191,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}},{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":-0.5596639882456166,\"1\":-0.2794084096442046,\"2\":-0.1125698422524117,\"3\":-0.08850676702777903,\"4\":0.06317601682543969,\"5\":-0.18247248453514878,\"6\":0.2940108272454184,\"7\":0.9861821092760742,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":121,\"1\":113,\"2\":200,\"3\":115,\"4\":196,\"5\":232,\"6\":225,\"7\":191,\"8\":251,\"9\":140,\"10\":105,\"11\":207,\"12\":211,\"13\":225,\"14\":209,\"15\":191,\"16\":206,\"17\":111,\"18\":253,\"19\":142,\"20\":96,\"21\":209,\"22\":188,\"23\":191,\"24\":143,\"25\":231,\"26\":219,\"27\":37,\"28\":97,\"29\":168,\"30\":182,\"31\":191,\"32\":166,\"33\":36,\"34\":40,\"35\":174,\"36\":77,\"37\":44,\"38\":176,\"39\":63,\"40\":69,\"41\":201,\"42\":191,\"43\":36,\"44\":66,\"45\":91,\"46\":199,\"47\":191,\"48\":54,\"49\":24,\"50\":236,\"51\":201,\"52\":18,\"53\":209,\"54\":210,\"55\":63,\"56\":147,\"57\":182,\"58\":103,\"59\":200,\"60\":205,\"61\":142,\"62\":239,\"63\":63,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}},{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":-0.4293240703659736,\"1\":0.48799666353430715,\"2\":-0.011221411170891243,\"3\":0.016759551491042825,\"4\":-0.10178241490300455,\"5\":-0.05938636975897821,\"6\":-0.7140555216543757,\"7\":-0.13033896328056724,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":157,\"1\":224,\"2\":102,\"3\":170,\"4\":11,\"5\":122,\"6\":219,\"7\":191,\"8\":60,\"9\":247,\"10\":155,\"11\":91,\"12\":86,\"13\":59,\"14\":223,\"15\":63,\"16\":118,\"17\":154,\"18\":243,\"19\":79,\"20\":64,\"21\":251,\"22\":134,\"23\":191,\"24\":71,\"25\":217,\"26\":50,\"27\":118,\"28\":106,\"29\":41,\"30\":145,\"31\":63,\"32\":136,\"33\":249,\"34\":80,\"35\":143,\"36\":105,\"37\":14,\"38\":186,\"39\":191,\"40\":152,\"41\":205,\"42\":226,\"43\":231,\"44\":227,\"45\":103,\"46\":174,\"47\":191,\"48\":151,\"49\":20,\"50\":33,\"51\":247,\"52\":138,\"53\":217,\"54\":230,\"55\":191,\"56\":91,\"57\":160,\"58\":87,\"59\":120,\"60\":242,\"61\":174,\"62\":192,\"63\":191,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}},{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":0.004132243204399921,\"1\":0.31644328046013015,\"2\":-0.4246219644532225,\"3\":0.021888719524958525,\"4\":-0.5736499683744954,\"5\":-0.1285778687631867,\"6\":-0.17633637428199953,\"7\":-0.09184800562849475,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":192,\"1\":147,\"2\":192,\"3\":150,\"4\":248,\"5\":236,\"6\":112,\"7\":63,\"8\":174,\"9\":95,\"10\":39,\"11\":81,\"12\":155,\"13\":64,\"14\":212,\"15\":63,\"16\":243,\"17\":89,\"18\":159,\"19\":154,\"20\":1,\"21\":45,\"22\":219,\"23\":191,\"24\":33,\"25\":71,\"26\":11,\"27\":26,\"28\":255,\"29\":105,\"30\":150,\"31\":63,\"32\":245,\"33\":162,\"34\":176,\"35\":45,\"36\":87,\"37\":91,\"38\":226,\"39\":191,\"40\":225,\"41\":227,\"42\":169,\"43\":86,\"44\":61,\"45\":117,\"46\":192,\"47\":191,\"48\":171,\"49\":117,\"50\":81,\"51\":184,\"52\":48,\"53\":146,\"54\":198,\"55\":191,\"56\":195,\"57\":144,\"58\":96,\"59\":212,\"60\":89,\"61\":131,\"62\":183,\"63\":191,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}},{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":0.09461892805990832,\"1\":-0.6329745552844204,\"2\":-0.7923676394624737,\"3\":-0.08606445900172546,\"4\":0.11603124920286288,\"5\":0.029252054814320392,\"6\":-0.03747907757038657,\"7\":-0.6005289047981558,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":238,\"1\":145,\"2\":153,\"3\":49,\"4\":242,\"5\":56,\"6\":184,\"7\":63,\"8\":2,\"9\":178,\"10\":196,\"11\":218,\"12\":83,\"13\":65,\"14\":228,\"15\":191,\"16\":40,\"17\":205,\"18\":60,\"19\":97,\"20\":19,\"21\":91,\"22\":233,\"23\":191,\"24\":226,\"25\":165,\"26\":194,\"27\":4,\"28\":82,\"29\":8,\"30\":182,\"31\":191,\"32\":39,\"33\":236,\"34\":163,\"35\":84,\"36\":57,\"37\":180,\"38\":189,\"39\":63,\"40\":169,\"41\":190,\"42\":18,\"43\":43,\"44\":64,\"45\":244,\"46\":157,\"47\":63,\"48\":220,\"49\":234,\"50\":229,\"51\":40,\"52\":117,\"53\":48,\"54\":163,\"55\":191,\"56\":21,\"57\":37,\"58\":205,\"59\":100,\"60\":136,\"61\":55,\"62\":227,\"63\":191,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}},{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":0.42277438855180405,\"1\":1.4138688143060145,\"2\":-0.3778547415032166,\"3\":-0.012023049493322651,\"4\":0.11825224526479829,\"5\":-0.4434819918251306,\"6\":-0.6772974432572635,\"7\":-0.14741163123927092,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":56,\"1\":166,\"2\":26,\"3\":79,\"4\":188,\"5\":14,\"6\":219,\"7\":63,\"8\":68,\"9\":117,\"10\":228,\"11\":231,\"12\":52,\"13\":159,\"14\":246,\"15\":63,\"16\":53,\"17\":69,\"18\":89,\"19\":167,\"20\":197,\"21\":46,\"22\":216,\"23\":191,\"24\":118,\"25\":224,\"26\":249,\"27\":98,\"28\":138,\"29\":159,\"30\":136,\"31\":191,\"32\":225,\"33\":67,\"34\":23,\"35\":118,\"36\":199,\"37\":69,\"38\":190,\"39\":63,\"40\":126,\"41\":63,\"42\":208,\"43\":74,\"44\":2,\"45\":98,\"46\":220,\"47\":191,\"48\":35,\"49\":138,\"50\":14,\"51\":176,\"52\":107,\"53\":172,\"54\":229,\"55\":191,\"56\":204,\"57\":128,\"58\":156,\"59\":99,\"60\":98,\"61\":222,\"62\":194,\"63\":191,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}},{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":1.1993670420146874,\"1\":0.3223431096192715,\"2\":-0.36861400047798204,\"3\":-0.08038294233717612,\"4\":0.2711210775205418,\"5\":0.42879169827918595,\"6\":0.6376085656983045,\"7\":0.03756028253259824,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":72,\"1\":167,\"2\":213,\"3\":126,\"4\":155,\"5\":48,\"6\":243,\"7\":63,\"8\":56,\"9\":247,\"10\":121,\"11\":254,\"12\":68,\"13\":161,\"14\":212,\"15\":63,\"16\":111,\"17\":164,\"18\":57,\"19\":45,\"20\":95,\"21\":151,\"22\":215,\"23\":191,\"24\":167,\"25\":146,\"26\":126,\"27\":252,\"28\":249,\"29\":147,\"30\":180,\"31\":191,\"32\":158,\"33\":63,\"34\":77,\"35\":56,\"36\":12,\"37\":90,\"38\":209,\"39\":63,\"40\":32,\"41\":242,\"42\":57,\"43\":188,\"44\":82,\"45\":113,\"46\":219,\"47\":63,\"48\":161,\"49\":91,\"50\":42,\"51\":20,\"52\":74,\"53\":103,\"54\":228,\"55\":63,\"56\":127,\"57\":73,\"58\":54,\"59\":242,\"60\":25,\"61\":59,\"62\":163,\"63\":63,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}},{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":0.13967402583430144,\"1\":-0.11357850366802424,\"2\":-0.5746610827627967,\"3\":-0.5717582875884522,\"4\":-0.1898576928922138,\"5\":-0.18657398702306335,\"6\":0.7165884005339106,\"7\":-0.6224249593531741,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":200,\"1\":140,\"2\":135,\"3\":166,\"4\":214,\"5\":224,\"6\":193,\"7\":63,\"8\":72,\"9\":100,\"10\":200,\"11\":22,\"12\":123,\"13\":19,\"14\":189,\"15\":191,\"16\":82,\"17\":1,\"18\":152,\"19\":163,\"20\":159,\"21\":99,\"22\":226,\"23\":191,\"24\":132,\"25\":25,\"26\":77,\"27\":9,\"28\":216,\"29\":75,\"30\":226,\"31\":191,\"32\":97,\"33\":219,\"34\":238,\"35\":194,\"36\":65,\"37\":77,\"38\":200,\"39\":191,\"40\":127,\"41\":49,\"42\":70,\"43\":10,\"44\":168,\"45\":225,\"46\":199,\"47\":191,\"48\":23,\"49\":142,\"50\":31,\"51\":204,\"52\":74,\"53\":238,\"54\":230,\"55\":63,\"56\":54,\"57\":90,\"58\":148,\"59\":191,\"60\":231,\"61\":234,\"62\":227,\"63\":191,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}}],\"biases\":{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":0.2562049254190115,\"1\":-0.5455393081802729,\"2\":0.10903726980643962,\"3\":-0.16355954769541572,\"4\":0.08992117884673975,\"5\":0.5185622512844232,\"6\":-0.46073562437071663,\"7\":0.38509647559811017,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":232,\"1\":235,\"2\":239,\"3\":87,\"4\":169,\"5\":101,\"6\":208,\"7\":63,\"8\":182,\"9\":34,\"10\":234,\"11\":217,\"12\":14,\"13\":117,\"14\":225,\"15\":191,\"16\":27,\"17\":33,\"18\":221,\"19\":211,\"20\":221,\"21\":233,\"22\":187,\"23\":63,\"24\":73,\"25\":114,\"26\":38,\"27\":238,\"28\":132,\"29\":239,\"30\":196,\"31\":191,\"32\":206,\"33\":80,\"34\":93,\"35\":10,\"36\":19,\"37\":5,\"38\":183,\"39\":63,\"40\":140,\"41\":157,\"42\":198,\"43\":220,\"44\":15,\"45\":152,\"46\":224,\"47\":63,\"48\":65,\"49\":143,\"50\":177,\"51\":69,\"52\":177,\"53\":124,\"54\":221,\"55\":191,\"56\":113,\"57\":235,\"58\":31,\"59\":176,\"60\":107,\"61\":165,\"62\":216,\"63\":63,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}}},{\"out_depth\":8,\"out_sx\":1,\"out_sy\":1,\"layer_type\":\"tanh\"},{\"out_depth\":8,\"out_sx\":1,\"out_sy\":1,\"layer_type\":\"fc\",\"num_inputs\":8,\"l1_decay_mul\":0,\"l2_decay_mul\":1,\"filters\":[{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":-0.38832824611419614,\"1\":0.5331207710690121,\"2\":-0.16958013252471874,\"3\":-0.03763800230330026,\"4\":-0.30277152771651167,\"5\":-0.03899235791753754,\"6\":0.4840579241426027,\"7\":-0.5416342032769544,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":208,\"1\":26,\"2\":75,\"3\":183,\"4\":94,\"5\":218,\"6\":216,\"7\":191,\"8\":37,\"9\":233,\"10\":145,\"11\":74,\"12\":83,\"13\":15,\"14\":225,\"15\":63,\"16\":149,\"17\":92,\"18\":159,\"19\":65,\"20\":205,\"21\":180,\"22\":197,\"23\":191,\"24\":29,\"25\":122,\"26\":245,\"27\":201,\"28\":73,\"29\":69,\"30\":163,\"31\":191,\"32\":183,\"33\":243,\"34\":108,\"35\":212,\"36\":155,\"37\":96,\"38\":211,\"39\":191,\"40\":226,\"41\":120,\"42\":25,\"43\":108,\"44\":206,\"45\":246,\"46\":163,\"47\":191,\"48\":229,\"49\":249,\"50\":99,\"51\":22,\"52\":206,\"53\":250,\"54\":222,\"55\":63,\"56\":111,\"57\":6,\"58\":175,\"59\":64,\"60\":17,\"61\":85,\"62\":225,\"63\":191,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}},{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":-0.11439407632270632,\"1\":-1.2819890886327963,\"2\":0.14634106395136273,\"3\":0.14304395032875164,\"4\":0.2297327647600765,\"5\":0.4348725634157742,\"6\":-0.26416425812412686,\"7\":0.058453811796899485,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":196,\"1\":130,\"2\":169,\"3\":32,\"4\":238,\"5\":72,\"6\":189,\"7\":191,\"8\":119,\"9\":27,\"10\":152,\"11\":253,\"12\":6,\"13\":131,\"14\":244,\"15\":191,\"16\":57,\"17\":209,\"18\":221,\"19\":209,\"20\":77,\"21\":187,\"22\":194,\"23\":63,\"24\":205,\"25\":188,\"26\":70,\"27\":160,\"28\":67,\"29\":79,\"30\":194,\"31\":63,\"32\":147,\"33\":106,\"34\":187,\"35\":27,\"36\":226,\"37\":103,\"38\":205,\"39\":63,\"40\":148,\"41\":25,\"42\":115,\"43\":187,\"44\":243,\"45\":212,\"46\":219,\"47\":63,\"48\":21,\"49\":147,\"50\":90,\"51\":52,\"52\":17,\"53\":232,\"54\":208,\"55\":191,\"56\":180,\"57\":10,\"58\":253,\"59\":115,\"60\":168,\"61\":237,\"62\":173,\"63\":63,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}},{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":-0.1406881916489247,\"1\":0.9405578660965507,\"2\":0.004901858025518234,\"3\":-0.2326645372062353,\"4\":-0.21448421502002576,\"5\":-1.0893898213683164,\"6\":-0.3778283066766321,\"7\":-0.37747385299064595,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":178,\"1\":98,\"2\":8,\"3\":23,\"4\":18,\"5\":2,\"6\":194,\"7\":191,\"8\":221,\"9\":42,\"10\":92,\"11\":207,\"12\":12,\"13\":25,\"14\":238,\"15\":63,\"16\":254,\"17\":58,\"18\":140,\"19\":126,\"20\":248,\"21\":19,\"22\":116,\"23\":63,\"24\":82,\"25\":176,\"26\":30,\"27\":153,\"28\":243,\"29\":199,\"30\":205,\"31\":191,\"32\":139,\"33\":118,\"34\":130,\"35\":0,\"36\":56,\"37\":116,\"38\":203,\"39\":191,\"40\":137,\"41\":244,\"42\":117,\"43\":5,\"44\":36,\"45\":110,\"46\":241,\"47\":191,\"48\":231,\"49\":119,\"50\":43,\"51\":199,\"52\":86,\"53\":46,\"54\":216,\"55\":191,\"56\":234,\"57\":39,\"58\":108,\"59\":23,\"60\":136,\"61\":40,\"62\":216,\"63\":191,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}},{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":0.3710384010689571,\"1\":-0.6190881680177,\"2\":0.41162941225861827,\"3\":-0.543618129725223,\"4\":0.6163330090258718,\"5\":0.7949110806898168,\"6\":-0.7884090007104152,\"7\":0.38478012561877223,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":239,\"1\":174,\"2\":137,\"3\":217,\"4\":23,\"5\":191,\"6\":215,\"7\":63,\"8\":25,\"9\":64,\"10\":95,\"11\":253,\"12\":145,\"13\":207,\"14\":227,\"15\":191,\"16\":230,\"17\":60,\"18\":238,\"19\":227,\"20\":34,\"21\":88,\"22\":218,\"23\":63,\"24\":49,\"25\":215,\"26\":21,\"27\":217,\"28\":81,\"29\":101,\"30\":225,\"31\":191,\"32\":186,\"33\":195,\"34\":166,\"35\":0,\"36\":0,\"37\":185,\"38\":227,\"39\":63,\"40\":18,\"41\":78,\"42\":217,\"43\":92,\"44\":233,\"45\":111,\"46\":233,\"47\":63,\"48\":118,\"49\":139,\"50\":61,\"51\":131,\"52\":165,\"53\":58,\"54\":233,\"55\":191,\"56\":205,\"57\":188,\"58\":235,\"59\":209,\"60\":60,\"61\":160,\"62\":216,\"63\":63,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}},{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":0.2740006754893999,\"1\":-0.8544168596508195,\"2\":0.07387149782516346,\"3\":-0.18854684467760982,\"4\":0.5306163852118577,\"5\":0.5217519355682549,\"6\":-0.16672917486486497,\"7\":0.23335567893271977,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":182,\"1\":196,\"2\":19,\"3\":33,\"4\":58,\"5\":137,\"6\":209,\"7\":63,\"8\":200,\"9\":61,\"10\":171,\"11\":6,\"12\":98,\"13\":87,\"14\":235,\"15\":191,\"16\":41,\"17\":255,\"18\":67,\"19\":19,\"20\":62,\"21\":233,\"22\":178,\"23\":63,\"24\":243,\"25\":192,\"26\":211,\"27\":145,\"28\":77,\"29\":34,\"30\":200,\"31\":191,\"32\":4,\"33\":157,\"34\":166,\"35\":54,\"36\":207,\"37\":250,\"38\":224,\"39\":63,\"40\":200,\"41\":125,\"42\":124,\"43\":29,\"44\":49,\"45\":178,\"46\":224,\"47\":63,\"48\":97,\"49\":181,\"50\":170,\"51\":176,\"52\":97,\"53\":87,\"54\":197,\"55\":191,\"56\":79,\"57\":11,\"58\":173,\"59\":80,\"60\":153,\"61\":222,\"62\":205,\"63\":63,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}},{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":-0.1906626781357325,\"1\":0.4709381707241033,\"2\":0.24160919622692853,\"3\":0.6311757769867091,\"4\":-0.3203913931138507,\"5\":-0.5879387228046364,\"6\":0.39346084678734317,\"7\":-0.3561015790308374,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":78,\"1\":147,\"2\":148,\"3\":119,\"4\":162,\"5\":103,\"6\":200,\"7\":191,\"8\":123,\"9\":173,\"10\":108,\"11\":218,\"12\":217,\"13\":35,\"14\":222,\"15\":63,\"16\":131,\"17\":143,\"18\":26,\"19\":214,\"20\":12,\"21\":237,\"22\":206,\"23\":63,\"24\":5,\"25\":238,\"26\":5,\"27\":139,\"28\":151,\"29\":50,\"30\":228,\"31\":63,\"32\":240,\"33\":1,\"34\":214,\"35\":230,\"36\":74,\"37\":129,\"38\":212,\"39\":191,\"40\":252,\"41\":238,\"42\":79,\"43\":222,\"44\":100,\"45\":208,\"46\":226,\"47\":191,\"48\":154,\"49\":81,\"50\":77,\"51\":103,\"52\":118,\"53\":46,\"54\":217,\"55\":63,\"56\":50,\"57\":115,\"58\":255,\"59\":70,\"60\":94,\"61\":202,\"62\":214,\"63\":191,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}},{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":-0.052332119821916476,\"1\":0.5000167096781711,\"2\":0.26266568911062693,\"3\":0.26506535297601835,\"4\":-0.25463287277049923,\"5\":0.08282611179305391,\"6\":0.9396179911813585,\"7\":-0.5542899781400487,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":102,\"1\":186,\"2\":84,\"3\":142,\"4\":70,\"5\":203,\"6\":170,\"7\":191,\"8\":66,\"9\":174,\"10\":240,\"11\":10,\"12\":35,\"13\":0,\"14\":224,\"15\":63,\"16\":136,\"17\":187,\"18\":32,\"19\":192,\"20\":131,\"21\":207,\"22\":208,\"23\":63,\"24\":165,\"25\":107,\"26\":149,\"27\":171,\"28\":212,\"29\":246,\"30\":208,\"31\":63,\"32\":237,\"33\":74,\"34\":66,\"35\":173,\"36\":231,\"37\":75,\"38\":208,\"39\":191,\"40\":10,\"41\":240,\"42\":103,\"43\":145,\"44\":23,\"45\":52,\"46\":181,\"47\":63,\"48\":200,\"49\":109,\"50\":219,\"51\":191,\"52\":89,\"53\":17,\"54\":238,\"55\":63,\"56\":7,\"57\":150,\"58\":19,\"59\":86,\"60\":190,\"61\":188,\"62\":225,\"63\":191,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}},{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":0.5183573300646674,\"1\":-0.8084279309930922,\"2\":0.17564116878772115,\"3\":-0.4120839198806116,\"4\":0.5760434856452349,\"5\":0.35578634913953205,\"6\":-0.3705548599822078,\"7\":0.44300177295886806,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":195,\"1\":160,\"2\":136,\"3\":28,\"4\":98,\"5\":150,\"6\":224,\"7\":63,\"8\":142,\"9\":57,\"10\":153,\"11\":64,\"12\":164,\"13\":222,\"14\":233,\"15\":191,\"16\":27,\"17\":34,\"18\":227,\"19\":233,\"20\":104,\"21\":123,\"22\":198,\"23\":63,\"24\":191,\"25\":15,\"26\":198,\"27\":59,\"28\":149,\"29\":95,\"30\":218,\"31\":191,\"32\":179,\"33\":113,\"34\":125,\"35\":191,\"36\":242,\"37\":110,\"38\":226,\"39\":63,\"40\":199,\"41\":184,\"42\":122,\"43\":27,\"44\":52,\"45\":197,\"46\":214,\"47\":63,\"48\":21,\"49\":214,\"50\":63,\"51\":187,\"52\":43,\"53\":183,\"54\":215,\"55\":191,\"56\":45,\"57\":106,\"58\":187,\"59\":27,\"60\":36,\"61\":90,\"62\":220,\"63\":63,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}}],\"biases\":{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":0.013187463476726313,\"1\":-0.007630520124428615,\"2\":-0.27144190488489406,\"3\":-0.30429595726968894,\"4\":-0.05004981783245224,\"5\":0.07003641753819947,\"6\":-0.09093686693747323,\"7\":0.05757614475366814,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":83,\"1\":65,\"2\":204,\"3\":98,\"4\":7,\"5\":2,\"6\":139,\"7\":63,\"8\":200,\"9\":155,\"10\":44,\"11\":38,\"12\":46,\"13\":65,\"14\":127,\"15\":191,\"16\":234,\"17\":166,\"18\":15,\"19\":222,\"20\":77,\"21\":95,\"22\":209,\"23\":191,\"24\":30,\"25\":208,\"26\":49,\"27\":192,\"28\":149,\"29\":121,\"30\":211,\"31\":191,\"32\":36,\"33\":180,\"34\":133,\"35\":53,\"36\":33,\"37\":160,\"38\":169,\"39\":191,\"40\":122,\"41\":6,\"42\":219,\"43\":26,\"44\":232,\"45\":237,\"46\":177,\"47\":63,\"48\":77,\"49\":69,\"50\":127,\"51\":117,\"52\":163,\"53\":71,\"54\":183,\"55\":191,\"56\":50,\"57\":88,\"58\":126,\"59\":213,\"60\":158,\"61\":122,\"62\":173,\"63\":63,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}}},{\"out_depth\":8,\"out_sx\":1,\"out_sy\":1,\"layer_type\":\"tanh\"},{\"out_depth\":2,\"out_sx\":1,\"out_sy\":1,\"layer_type\":\"fc\",\"num_inputs\":8,\"l1_decay_mul\":0,\"l2_decay_mul\":1,\"filters\":[{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":1.0172730016739508,\"1\":-0.13221137581570833,\"2\":0.9395466221657038,\"3\":-1.6251860610880569,\"4\":-1.2388309137808013,\"5\":0.8533890654636394,\"6\":0.7649152131278658,\"7\":-1.7907313802649556,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":167,\"1\":177,\"2\":20,\"3\":14,\"4\":192,\"5\":70,\"6\":240,\"7\":63,\"8\":37,\"9\":209,\"10\":164,\"11\":103,\"12\":77,\"13\":236,\"14\":192,\"15\":191,\"16\":96,\"17\":155,\"18\":232,\"19\":19,\"20\":196,\"21\":16,\"22\":238,\"23\":63,\"24\":185,\"25\":156,\"26\":100,\"27\":25,\"28\":195,\"29\":0,\"30\":250,\"31\":191,\"32\":188,\"33\":101,\"34\":63,\"35\":93,\"36\":64,\"37\":210,\"38\":243,\"39\":191,\"40\":76,\"41\":197,\"42\":221,\"43\":149,\"44\":246,\"45\":78,\"46\":235,\"47\":63,\"48\":16,\"49\":27,\"50\":19,\"51\":120,\"52\":47,\"53\":122,\"54\":232,\"55\":63,\"56\":244,\"57\":138,\"58\":162,\"59\":242,\"60\":213,\"61\":166,\"62\":252,\"63\":191,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}},{\"sx\":1,\"sy\":1,\"depth\":8,\"w\":{\"0\":-1.252270530582403,\"1\":0.7285270999976606,\"2\":0.023798576828390303,\"3\":1.064484519454345,\"4\":0.246286754788085,\"5\":-1.2474340354253382,\"6\":-0.3051491951725839,\"7\":1.4177785201450572,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":43,\"1\":137,\"2\":233,\"3\":210,\"4\":76,\"5\":9,\"6\":244,\"7\":191,\"8\":105,\"9\":171,\"10\":151,\"11\":16,\"12\":24,\"13\":80,\"14\":231,\"15\":63,\"16\":172,\"17\":87,\"18\":173,\"19\":116,\"20\":167,\"21\":94,\"22\":152,\"23\":63,\"24\":154,\"25\":121,\"26\":98,\"27\":235,\"28\":32,\"29\":8,\"30\":241,\"31\":63,\"32\":163,\"33\":91,\"34\":160,\"35\":10,\"36\":83,\"37\":134,\"38\":207,\"39\":63,\"40\":43,\"41\":27,\"42\":33,\"43\":100,\"44\":125,\"45\":245,\"46\":243,\"47\":191,\"48\":158,\"49\":175,\"50\":106,\"51\":125,\"52\":144,\"53\":135,\"54\":211,\"55\":191,\"56\":165,\"57\":232,\"58\":143,\"59\":135,\"60\":56,\"61\":175,\"62\":246,\"63\":63,\"byteLength\":64},\"length\":8,\"byteOffset\":0,\"byteLength\":64}}],\"biases\":{\"sx\":1,\"sy\":1,\"depth\":2,\"w\":{\"0\":-0.008745691297802017,\"1\":0.00874569129780175,\"BYTES_PER_ELEMENT\":8,\"buffer\":{\"0\":71,\"1\":251,\"2\":214,\"3\":208,\"4\":66,\"5\":233,\"6\":129,\"7\":191,\"8\":173,\"9\":250,\"10\":214,\"11\":208,\"12\":66,\"13\":233,\"14\":129,\"15\":63,\"byteLength\":16},\"length\":2,\"byteOffset\":0,\"byteLength\":16}}},{\"out_depth\":2,\"out_sx\":1,\"out_sy\":1,\"layer_type\":\"softmax\",\"num_inputs\":2}]};\n\nexport {NEURAL_NET_TRAINED_FOR_STROKE_EXTRACTION};\n","import {assert} from '/lib/base';\n\nconst vowel_to_tone =\n    {0: \"aeiouü\", 1: \"āēīōūǖ\", 2: \"áéíóúǘ\", 3: \"ǎěǐǒǔǚ\", 4: \"àèìòùǜ\"};\n\nconst tokenSet = (tokens) => {\n  const result = {};\n  tokens.split(' ').map((x) => result[x] = true);\n  return result;\n}\n\nconst consonants = tokenSet('b p m f d t n l g k h j q x zh ch sh r z c s y w');\nconst vowels = tokenSet('a ai an ang ao e ei en eng er i ia ian iang iao ie ' +\n                        'in ing io iong iu o ong ou u ua uai uan uang ue ui ' +\n                        'un uo v van vn');\nconst two_syllables = tokenSet('ia ian iang iao ie io iong iu ua uai uan ' +\n                               'uang ue ui uo van');\n\nconst pinyin_util = {};\n\npinyin_util.dropTones = (pinyin, append_number) => {\n  for (let i = 0; i < pinyin.length; i++) {\n    for (let option = 1; option <= 4; option++) {\n      const index = vowel_to_tone[option].indexOf(pinyin[i]);\n      if (index >= 0) {\n        const toneless = 'aeiouv'[index];\n        pinyin = pinyin.substr(0, i) + toneless + pinyin.substr(i + 1);\n        if (append_number) {\n          return `${pinyin}${option}`;\n        }\n      }\n    }\n  }\n  return pinyin;\n}\n\npinyin_util.numberedPinyinToTonePinyin = (numbered) => {\n  assert(numbered && numbered === numbered.toLowerCase());\n  let tone = 0;\n  if ('01234'.indexOf(numbered[numbered.length - 1]) >= 0) {\n    tone = parseInt(numbered[numbered.length - 1], 10);\n    numbered = numbered.substr(0, numbered.length - 1);\n  }\n  for (let i = 0; i < numbered.length; i++) {\n    for (let option = 1; option <= 4; option++) {\n      const index = vowel_to_tone[option].indexOf(numbered[i]);\n      if (index >= 0) {\n        tone = option;\n        const toneless = 'aeiouv'[index];\n        numbered = numbered.substr(0, i) + toneless + numbered.substr(i + 1);\n      }\n    }\n  }\n  let consonant = '';\n  for (let i = 1; i < numbered.length; i++) {\n    const candidate = numbered.substr(0, i);\n    if (consonants[candidate]) {\n      consonant = candidate;\n    } else {\n      break;\n    }\n  }\n  let vowel = numbered.substr(consonant.length);\n  assert((!consonant || consonants[consonant]) && vowels[vowel]);\n  if (two_syllables[vowel]) {\n    const index = 'aeiouv'.indexOf(vowel[1]);\n    vowel = vowel[0] + vowel_to_tone[tone][index] + vowel.substr(2);\n  } else {\n    const index = 'aeiouv'.indexOf(vowel[0]);\n    assert(index >= 0);\n    vowel = vowel_to_tone[tone][index] + vowel.substr(1);\n  }\n  return consonant + vowel.replace('v', 'ü');\n}\n\npinyin_util.tonePinyinToNumberedPinyin = (tone) => {\n  return pinyin_util.dropTones(tone, true /* append_number */);\n}\n\nexport {pinyin_util};\n","import {assert, Angle, Point} from '/lib/base';\nimport {Hungarian} from '/lib/hungarian';\nimport {svg} from '/lib/svg';\n\nconst MAX_BRIDGE_DISTANCE = 64;\nconst MIN_CORNER_ANGLE = 0.1*Math.PI;\nconst MIN_CORNER_TANGENT_DISTANCE = 4;\nconst REVERSAL_PENALTY = 0.5;\n\n// Errors out if the bridges are invalid in some gross way.\nconst checkBridge = (bridge) => {\n  assert(Point.valid(bridge[0]) && Point.valid(bridge[1]));\n  assert(!Point.equal(bridge[0], bridge[1]));\n}\n\n// Returns the list of bridges on the path with the given endpoints. We strip\n// nearly all of the metadata out of this list to make it easy to hand-correct.\n// The list that we return is simply a list of pairs of points.\nconst getBridges = (endpoints, classifier) => {\n  const result = [];\n  const corners = endpoints.filter((x) => x.corner);\n  const matching = matchCorners(corners, classifier);\n  for (let i = 0; i < corners.length; i++) {\n    const j = matching[i];\n    if (j <= i && matching[j] === i) {\n      continue;\n    }\n    result.push([Point.clone(corners[i].point), Point.clone(corners[j].point)]);\n  }\n  result.map(checkBridge);\n  return result;\n}\n\n// Returns a list of angle and distance features between two corners.\nconst getFeatures = (ins, out) => {\n  const diff = Point.subtract(out.point, ins.point);\n  const trivial = Point.equal(diff, [0, 0]);\n  const angle = Math.atan2(diff[1], diff[0]);\n  const distance = Math.sqrt(Point.distance2(out.point, ins.point));\n  return [\n    Angle.subtract(angle, ins.angles[0]),\n    Angle.subtract(out.angles[1], angle),\n    Angle.subtract(ins.angles[1], angle),\n    Angle.subtract(angle, out.angles[0]),\n    Angle.subtract(ins.angles[1], ins.angles[0]),\n    Angle.subtract(out.angles[1], out.angles[0]),\n    (trivial ? 1 : 0),\n    distance/MAX_BRIDGE_DISTANCE,\n  ];\n}\n\n// A hand-tuned classifier that uses the features above to return a score for\n// connecting two corners by a bridge. This classifier throws out most data.\nconst handTunedClassifier = (features) => {\n  if (features[6] > 0) {\n    return -Angle.penalty(features[4]);\n  }\n  let angle_penalty = Angle.penalty(features[0]) + Angle.penalty(features[1]);\n  const distance_penalty = features[7];\n  if (features[0] > 0 && features[1] > 0 &&\n      features[2] + features[3] < -0.5*Math.PI) {\n    angle_penalty = angle_penalty/16;\n  }\n  return -(angle_penalty + distance_penalty);\n}\n\n// Takes a list of corners and returns a bipartite matching between them.\n// If matching[i] === j, then corners[i] is matched with corners[j] - that is,\n// we should construct a bridge from corners[i].point to corners[j].point.\nconst matchCorners = (corners, classifier) => {\n  const matrix = [];\n  for (let i = 0; i < corners.length; i++) {\n    matrix.push([]);\n    for (let j = 0; j < corners.length; j++) {\n      matrix[i].push(scoreCorners(corners[i], corners[j], classifier));\n    }\n  }\n  for (let i = 0; i < corners.length; i++) {\n    for (let j = 0; j < corners.length; j++) {\n      const reversed_score = matrix[j][i] - REVERSAL_PENALTY;\n      if (reversed_score > matrix[i][j]) {\n        matrix[i][j] = reversed_score;\n      }\n    }\n  }\n  return (new Hungarian(matrix)).x_match;\n}\n\n// Takes two corners and returns the score assigned to constructing a bridge\n// from one corner to the other. The score is directed: the bridge from ins to\n// out may be weighted higher than from out to ins.\nconst scoreCorners = (ins, out, classifier) => {\n  return classifier(getFeatures(ins, out));\n}\n\n// Stores angle and distance metadata around an SVG path segment's start point.\n// This endpoint may be a 'corner', which is true if the path bends sharply in\n// the negative (clockwise) direction at that point.\nfunction Endpoint(paths, index) {\n  this.index = index;\n  const path = paths[index[0]];\n  const n = path.length;\n  this.indices = [[index[0], (index[1] + n - 1) % n], index];\n  this.segments = [path[(index[1] + n - 1) % n], path[index[1]]];\n  this.point = this.segments[0].end;\n  assert(Point.valid(this.point), this.point);\n  assert(Point.equal(this.point, this.segments[1].start), path);\n  this.tangents = [\n    Point.subtract(this.segments[0].end, this.segments[0].start),\n    Point.subtract(this.segments[1].end, this.segments[1].start),\n  ];\n  const threshold = Math.pow(MIN_CORNER_TANGENT_DISTANCE, 2);\n  if (this.segments[0].control !== undefined &&\n      Point.distance2(this.point, this.segments[0].control) > threshold) {\n    this.tangents[0] = Point.subtract(this.point, this.segments[0].control);\n  }\n  if (this.segments[1].control !== undefined &&\n      Point.distance2(this.point, this.segments[1].control) > threshold) {\n    this.tangents[1] = Point.subtract(this.segments[1].control, this.point);\n  }\n  this.angles = this.tangents.map(Point.angle);\n  const diff = Angle.subtract(this.angles[1], this.angles[0]);\n  this.corner = diff < -MIN_CORNER_ANGLE;\n  return this;\n}\n\n// Code for the stroke extraction step follows.\n\nconst addEdgeToAdjacency = (edge, adjacency) => {\n  assert(edge.length === 2);\n  adjacency[edge[0]] = adjacency[edge[0]] || [];\n  if (adjacency[edge[0]].indexOf(edge[1]) < 0) {\n    adjacency[edge[0]].push(edge[1]);\n  }\n}\n\nconst extractStroke = (paths, endpoint_map, bridge_adjacency, log,\n                       extracted_indices, start, attempt_one) => {\n  const result = [];\n  const visited = {};\n  let current = start;\n\n  // A list of line segments that were added to the path but that were not\n  // part of the original stroke data. None of these should intersect.\n  const line_segments = [];\n  let self_intersecting = false;\n\n  const advance = (index) =>\n      [index[0], (index[1] + 1) % paths[index[0]].length];\n\n  const angle = (index1, index2) => {\n    const diff = Point.subtract(endpoint_map[Point.key(index2)].point,\n                                endpoint_map[Point.key(index1)].point);\n    assert(diff[0] !== 0 || diff[1] !== 0);\n    const angle = Math.atan2(diff[1], diff[0]);\n    return Angle.subtract(angle,  endpoint.angles[0]);\n  }\n\n  const getIntersection = (segment1, segment2) => {\n    const diff1 = Point.subtract(segment1[1], segment1[0]);\n    const diff2 = Point.subtract(segment2[1], segment2[0]);\n    const cross = diff1[0]*diff2[1] - diff1[1]*diff2[0];\n    if (cross === 0) {\n      return undefined;\n    }\n    const v = Point.subtract(segment1[0], segment2[0]);\n    const s = (diff1[0]*v[1] - diff1[1]*v[0])/cross;\n    const t = (diff2[0]*v[1] - diff2[1]*v[0])/cross;\n    if (0 < s && s < 1 && 0 < t && t < 1) {\n      return [segment1[0][0] + t*diff1[0], segment1[0][1] + t*diff1[1]];\n    }\n    return undefined;\n  }\n\n  const indexToPoint = (index) => endpoint_map[Point.key(index)].point;\n\n  const pushLineSegments = (points) => {\n    const old_lines = line_segments.length;\n    for (let i = 0; i < points.length - 1; i++) {\n      line_segments.push([points[i], points[i + 1]]);\n      result.push({\n        start: Point.clone(points[i]),\n        end: Point.clone(points[i + 1]),\n        control: undefined,\n      });\n    }\n    // Log an error if this stroke is self-intersecting.\n    if (!self_intersecting) {\n      for (let i = 0; i < old_lines; i++) {\n        for (let j = old_lines; j < line_segments.length; j++) {\n          if (getIntersection(line_segments[i], line_segments[j])) {\n            self_intersecting = true;\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  // Here there be dragons!\n  // TODO(skishore): Document the point of the geometry in this function.\n  const selectBridge = (endpoint, options) => {\n    if (options.length === 1 && extracted_indices[Point.key(options[0])]) {\n      // Handle star-shaped strokes where one stroke ends at the intersection\n      // of the bridges used by two other strokes.\n      const indices1 = [endpoint.index, options[0]];\n      const segment1 = indices1.map(indexToPoint);\n      for (let key in bridge_adjacency) {\n        if (Point.equal(endpoint_map[key].index, indices1[0])) {\n          continue;\n        }\n        for (let i = 0; i < bridge_adjacency[key].length; i++) {\n          if (Point.equal(bridge_adjacency[key][i], segment1[0])) {\n            continue;\n          }\n          // Compute the other bridge segment and check if it intersects.\n          const indices2 = [endpoint_map[key].index, bridge_adjacency[key][i]];\n          const segment2 = indices2.map(indexToPoint);\n          if (Point.equal(indices2[0], indices1[1]) &&\n              !extracted_indices[Point.key(indices2[1])]) {\n            pushLineSegments([segment1[0], segment1[1], segment2[1]]);\n            return indices2[1];\n          } else if (Point.equal(indices2[1], indices1[1]) &&\n                     !extracted_indices[Point.key(indices2[0])]) {\n            pushLineSegments([segment1[0], segment1[1], segment2[0]]);\n            return indices2[0];\n          }\n          const intersection = getIntersection(segment1, segment2);\n          if (intersection !== undefined) {\n            const angle1 = angle(indices1[0], indices1[1]);\n            const angle2 = angle(indices2[0], indices2[1]);\n            if (Angle.subtract(angle2, angle1) < 0) {\n              indices2.reverse();\n              segment2.reverse();\n            }\n            pushLineSegments([segment1[0], intersection, segment2[1]]);\n            return indices2[1];\n          }\n        }\n      }\n    } else {\n      // Handle segments where the correct path is to follow a dead-end bridge,\n      // even if there is another bridge that is more aligned with the stroke.\n      for (let i = 0; i < options.length; i++) {\n        const key = Point.key(options[i]);\n        if (!extracted_indices[key]) {\n          return options[i];\n        }\n      }\n    }\n    return options[0];\n  }\n\n  while (true) {\n    // Add the current path segment to the path.\n    result.push(paths[current[0]][current[1]]);\n    visited[Point.key(current)] = true;\n    current = advance(current);\n    // If there are bridges at the start of the next path segment, follow the\n    // one that makes the largest angle with the current path. The ordering\n    // criterion enforce that we try to cross aligned bridges.\n    const key = Point.key(current);\n    if (bridge_adjacency.hasOwnProperty(key)) {\n      var endpoint = endpoint_map[key];\n      const options = bridge_adjacency[key].sort(\n          (a, b) => angle(endpoint.index, a) - angle(endpoint.index, b));\n      // HACK(skishore): The call to selectBridge may update the result.\n      // When a stroke is formed by computing a bridge intersection, then the\n      // two bridge fragments are added in selectBridge.\n      const result_length = result.length;\n      const next = (attempt_one ? options[0] : selectBridge(endpoint, options));\n      if (result.length === result_length) {\n        pushLineSegments([endpoint.point, endpoint_map[Point.key(next)].point]);\n      }\n      current = next;\n    }\n    // Check if we have either closed the loop or hit an extracted segment.\n    const new_key = Point.key(current);\n    if (Point.equal(current, start)) {\n      if (self_intersecting) {\n        log.push({cls: 'error',\n                  message: 'Extracted a self-intersecting stroke.'});\n      }\n      let num_segments_on_path = 0;\n      for (let index in visited) {\n        extracted_indices[index] = true;\n        num_segments_on_path += 1;\n      }\n      // Single-segment strokes may be due to graphical artifacts in the font.\n      // We drop them to remove these artifacts.\n      if (num_segments_on_path === 1) {\n        log.push({cls: 'success', message: 'Dropping single-segment stroke.'});\n        return undefined;\n      }\n      return result;\n    } else if (extracted_indices[new_key] || visited[new_key]) {\n      return undefined;\n    }\n  }\n}\n\nconst extractStrokes = (paths, endpoints, bridges, log) => {\n  // Build up the necessary hash tables and adjacency lists needed to run the\n  // stroke extraction loop.\n  const endpoint_map = {};\n  const endpoint_position_map = {};\n  for (let endpoint of endpoints) {\n    endpoint_map[Point.key(endpoint.index)] = endpoint;\n    endpoint_position_map[Point.key(endpoint.point)] = endpoint;\n  }\n  bridges.map(checkBridge);\n  const bridge_adjacency = {};\n  for (let bridge of bridges) {\n    const keys = bridge.map(Point.key);\n    assert(endpoint_position_map.hasOwnProperty(keys[0]));\n    assert(endpoint_position_map.hasOwnProperty(keys[1]));\n    const xs = keys.map((x) => endpoint_position_map[x].index);\n    addEdgeToAdjacency([Point.key(xs[0]), xs[1]], bridge_adjacency);\n    addEdgeToAdjacency([Point.key(xs[1]), xs[0]], bridge_adjacency);\n  }\n  // Actually extract strokes. Any given path segment index should appear on\n  // exactly one stroke; if it is not on a stroke, we log a warning.\n  const extracted_indices = {};\n  const strokes = [];\n  for (let attempt = 0; attempt < 3; attempt++) {\n    let missed = false;\n    for (var i = 0; i < paths.length; i++) {\n      for (var j = 0; j < paths[i].length; j++) {\n        const index = [i, j];\n        if (extracted_indices[Point.key(index)]) {\n          continue;\n        }\n        const attempt_one = attempt === 0;\n        const stroke = extractStroke(paths, endpoint_map, bridge_adjacency, log,\n                                     extracted_indices, index, attempt_one);\n        if (stroke === undefined) {\n          missed = true;\n          continue;\n        }\n        strokes.push(stroke);\n      }\n    }\n    if (!missed) {\n      return strokes;\n    }\n  }\n  log.push({cls: 'error',\n            message: 'Stroke extraction missed some path segments.'});\n  return strokes;\n}\n\n// Exports go below this fold.\n\nconst stroke_extractor = {};\n\nstroke_extractor.getBridges = (path, classifier) => {\n  const paths = svg.convertSVGPathToPaths(path);\n  const endpoints = [];\n  for (let i = 0; i < paths.length; i++) {\n    for (let j = 0; j < paths[i].length; j++) {\n      endpoints.push(new Endpoint(paths, [i, j]));\n    }\n  }\n  classifier = classifier || stroke_extractor.combinedClassifier;\n  const bridges = getBridges(endpoints, classifier);\n  return {endpoints: endpoints, bridges: bridges};\n}\n\nstroke_extractor.getStrokes = (path, bridges) => {\n  const paths = svg.convertSVGPathToPaths(path);\n  const endpoints = [];\n  for (let i = 0; i < paths.length; i++) {\n    for (let j = 0; j < paths[i].length; j++) {\n      endpoints.push(new Endpoint(paths, [i, j]));\n    }\n  }\n  const log = [];\n  const stroke_paths = extractStrokes(paths, endpoints, bridges, log);\n  const strokes = stroke_paths.map((x) => svg.convertPathsToSVGPath([x]));\n  return {log: log, strokes: strokes};\n}\n\nstroke_extractor.handTunedClassifier = handTunedClassifier;\n\nexport {stroke_extractor};\n","import {assert, Point} from '/lib/base';\n\nconst svg = {};\n\n// A normal-form SVG path string is a data string with the following properties:\n//   - Every command in the path is in ['L', 'M', 'Q', 'Z'].\n//   - Adjacent tokens in the path are separated by exactly one space.\n//   - There is exactly one 'Z', and it is the last command.\n//\n// A segment is a section of a path, represented as an object that has a start,\n// an end, and possibly a control, all of which are valid Points (that is, pairs\n// of Numbers).\n//\n// A path is a list of segments which is non-empty and closed - that is, the end\n// of the last segment on the path is the start of the first.\n\n// Returns twice the area contained in the polygon. The result is positive iff\n// the polygon winds in the counter-clockwise direction.\nconst get2xArea = (polygon) => {\n  let area = 0;\n  for (var i = 0; i < polygon.length; i++) {\n    const p1 = polygon[i];\n    const p2 = polygon[(i + 1) % polygon.length];\n    area += (p2[0] + p1[0])*(p2[1] - p1[1]);\n  }\n  return area;\n}\n\n// Takes a list of paths and orients them so that exterior contours are oriented\n// counter-clockwise and interior contours clockwise.\nconst orientPaths = (paths, approximation_error) => {\n  const polygons = paths.map(svg.getPolygonApproximation);\n  for (var i = 0; i < paths.length; i++) {\n    const path = paths[i];\n    let contains = 0;\n    for (let j = 0; j < paths.length; j++) {\n      if (j === i) {\n        continue;\n      } else if (svg.polygonContainsPoint(polygons[j], path[0].start)) {\n        contains += 1;\n      }\n    }\n    const area = get2xArea(polygons[i]);\n    // The path is an external path iff it is contained in an even number of\n    // other paths. It is counter-clockwise iff its area is positive. The path\n    // should be reversed if (CCW && internal) || (CW && external).\n    const should_reverse = (area > 0) !== (contains % 2 === 0);\n    if (should_reverse) {\n      for (let segment of path) {\n        [segment.start, segment.end] = [segment.end, segment.start];\n      }\n      path.reverse();\n    }\n  }\n  return paths;\n}\n\n// Takes a normal-form SVG path string and converts it to a list of paths.\nconst splitPath = (path) => {\n  assert(path.length > 0);\n  assert(path[0] === 'M', `Path did not start with M: ${path}`);\n  assert(path[path.length - 1] === 'Z', `Path did not end with Z: ${path}`);\n  const terms = path.split(' ');\n  const result = [];\n  let start = undefined;\n  let current = undefined;\n  for (let i = 0; i < terms.length; i++) {\n    const command = terms[i];\n    assert(command.length > 0, `Path includes empty command: ${path}`);\n    assert('LMQZ'.indexOf(command) >= 0, command);\n    if (command === 'M' || command === 'Z') {\n      if (current !== undefined) {\n        assert(Point.equal(current, start), `Path has open contour: ${path}`);\n        assert(result[result.length - 1].length > 0,\n               `Path has empty contour: ${path}`);\n        if (command === 'Z') {\n          assert(i === terms.length - 1, `Path ended early: ${path}`);\n          return result;\n        }\n      }\n      result.push([]);\n      assert(i < terms.length - 2, `Missing point on path: ${path}`);\n      start = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n      assert(Point.valid(start));\n      i += 2;\n      current = Point.clone(start);\n      continue;\n    }\n    let control = undefined;\n    if (command === 'Q') {\n      assert(i < terms.length - 2, `Missing point on path: ${path}`);\n      control = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n      assert(Point.valid(control));\n      i += 2;\n    }\n    assert(i < terms.length - 2, `Missing point on path: ${path}`);\n    const end = [parseFloat(terms[i + 1], 10), parseFloat(terms[i + 2], 10)];\n    assert(Point.valid(end));\n    i += 2;\n    if (Point.equal(current, end)) {\n      continue;\n    }\n    if (control !== undefined &&\n        (Point.equal(control, current) || Point.equal(control, end))) {\n      control = undefined;\n    }\n    result[result.length - 1].push({\n      start: Point.clone(current),\n      control: control,\n      end: end,\n    });\n    current = Point.clone(end);\n  }\n}\n\n// Takes a TrueType font command list (as provided by opentype.js) and returns\n// a normal-form SVG path string as defined above.\nsvg.convertCommandsToPath = (commands) => {\n  const terms = [];\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    assert('LMQZ'.indexOf(command.type) >= 0, command.type);\n    if (command.type === 'Z') {\n      assert(i === commands.length - 1);\n      break;\n    }\n    terms.push(command.type);\n    assert((command.x1 !== undefined) === (command.type === 'Q'));\n    if (command.x1 !== undefined) {\n      terms.push(command.x1);\n      terms.push(command.y1);\n    }\n    assert(command.x !== undefined);\n    terms.push(command.x);\n    terms.push(command.y);\n  }\n  terms.push('Z');\n  return terms.join(' ');\n}\n\n// Converts a normal-form SVG path string to a list of paths. The paths obey an\n// orientation constraint: the external paths are oriented counter-clockwise,\n// while the internal paths are oriented clockwise.\nsvg.convertSVGPathToPaths = (path) => {\n  return orientPaths(splitPath(path));\n}\n\n// Takes the given list of paths and returns a normal-form SVG path string.\nsvg.convertPathsToSVGPath = (paths) => {\n  const terms = [];\n  for (let path of paths) {\n    assert(path.length > 0);\n    terms.push('M');\n    terms.push(path[0].start[0]);\n    terms.push(path[0].start[1]);\n    for (let segment of path) {\n      if (segment.control === undefined) {\n        terms.push('L');\n      } else {\n        terms.push('Q');\n        terms.push(segment.control[0]);\n        terms.push(segment.control[1]);\n      }\n      terms.push(segment.end[0]);\n      terms.push(segment.end[1]);\n    }\n  }\n  terms.push('Z');\n  return terms.join(' ');\n}\n\n// Takes a path (a list of segments) and returns a polygon approximation to it.\n// The polygon is given as a list of pairs of points.\n//\n// The approximation error is an upper-bound on the distance between consecutive\n// points in the polygon approximation used to compute the area. The default\n// error of 64 is chosen because the glyphs have a total size of 1024x1024.\nsvg.getPolygonApproximation = (path, approximation_error) => {\n  const result = [];\n  approximation_error = approximation_error || 64;\n  for (let x of path) {\n    const control = x.control || Point.midpoint(x.start, x.end);\n    const distance = Math.sqrt(Point.distance2(x.start, x.end));\n    const num_points = Math.floor(distance/approximation_error);\n    for (let i = 0; i < num_points; i++) {\n      const t = (i + 1)/(num_points + 1);\n      const s = 1 - t;\n      result.push([s*s*x.start[0] + 2*s*t*control[0] + t*t*x.end[0],\n                   s*s*x.start[1] + 2*s*t*control[1] + t*t*x.end[1]]);\n    }\n    result.push(x.end);\n  }\n  return result;\n}\n\n// Returns true if the given point is contained inside the given polygon.\nsvg.polygonContainsPoint = (polygon, point) => {\n  const x = point[0];\n  const y = point[1];\n  let crossings = 0;\n  for (let i = 0; i < polygon.length; i++) {\n    const segment = {start: polygon[i], end: polygon[(i + 1) % polygon.length]};\n    if ((segment.start[0] < x && x < segment.end[0]) ||\n        (segment.start[0] > x && x > segment.end[0])) {\n      const t = (x - segment.end[0])/(segment.start[0] - segment.end[0]);\n      const cy = t*segment.start[1] + (1 - t)*segment.end[1];\n      if (y > cy) {\n        crossings += 1;\n      }\n    } else if (segment.start[0] === x && segment.start[1] <= y) {\n      if (segment.end[0] > x) {\n        crossings += 1;\n      }\n      const last = polygon[(i + polygon.length - 1) % (polygon.length)];\n      if (last[0] > x) {\n        crossings += 1;\n      }\n    }\n  }\n  return crossings % 2 === 1;\n}\n\nexport {svg};\n","import {Glyphs} from '/lib/glyphs';\n\nMeteor.publish('index', Glyphs.findGlyphsForRadical);\n","import {getAnimationData} from '/lib/animation';\nimport {assert, getPWD, Point} from '/lib/base';\nimport {cjklib} from '/lib/cjklib';\nimport {Glyphs} from '/lib/glyphs';\nimport {fixStrokes} from '/lib/stroke_caps/fixStrokes';\nimport {stroke_extractor} from '/lib/stroke_extractor';\nimport {svg} from '/lib/svg';\n\nconst addFrequencyField = (glyph) => {\n  const data = cjklib.getCharacterData(glyph.character);\n  glyph.metadata.frequency = data.frequency;\n  Glyphs.save(glyph);\n}\n\nconst addSimplifiedAndTraditionalFields = (glyph) => {\n  const data = cjklib.getCharacterData(glyph.character);\n  glyph.simplified = data.simplified;\n  glyph.traditional = data.traditional;\n  Glyphs.save(glyph);\n}\n\nconst addStrokeCaps = (glyph) => {\n  const raw = glyph.stages.strokes;\n  if (raw.raw || raw.corrected) return;\n  glyph.stages.strokes = {corrected: fixStrokes(raw), raw};\n  Glyphs.save(glyph);\n}\n\nconst checkStrokeExtractorStability = (glyph) => {\n  const strokes = stroke_extractor.getStrokes(\n      glyph.stages.path, glyph.stages.bridges);\n  if (!_.isEqual(strokes.strokes.sort(), glyph.stages.strokes.sort())) {\n    console.log(`Different strokes for ${glyph.character}`);\n  }\n}\n\nconst convertOldPathSchemaToSVGPath = (path) => {\n  const terms = [];\n  for (let segment of path) {\n    assert('LMQZ'.indexOf(segment.type) >= 0, segment.type);\n    terms.push(segment.type);\n    if (segment.x1 !== undefined) {\n      terms.push(segment.x1);\n      terms.push(segment.y1);\n    }\n    if (segment.x !== undefined) {\n      terms.push(segment.x);\n      terms.push(segment.y);\n    }\n  }\n  return terms.join(' ');\n}\n\nconst dumpGlyph = (dictionary, graphics) => (glyph) => {\n  if (!glyph.stages.verified) {\n    return;\n  }\n  const analysis = glyph.stages.analysis;\n  const order = glyph.stages.order;\n  const data = cjklib.getCharacterData(glyph.character);\n  const pinyin = (glyph.metadata.pinyin || data.pinyin || '')\n                     .split(',').map((x) => x.trim()).filter((x) => x);\n  const strokes = order.map((x) => glyph.stages.strokes.corrected[x.stroke]);\n  const medians = order.map((x) => x.median);\n  strokes.map((x) => assert(x));\n  medians.map((x) => assert(x));\n  const has_etymology =\n      analysis.etymology.hint || (analysis.etymology.type === 'pictophonetic');\n\n  dictionary.write(JSON.stringify({\n    character: glyph.character,\n    definition: glyph.metadata.definition || data.definition,\n    pinyin: pinyin,\n    decomposition: analysis.decomposition || '？',\n    etymology: has_etymology ? analysis.etymology : undefined,\n    radical: analysis.radical,\n    matches: order.map((x) => x.match),\n  }) + '\\n');\n  graphics.write(JSON.stringify({\n    character: glyph.character,\n    strokes: strokes,\n    medians: medians,\n  }) + '\\n');\n}\n\nconst fixBrokenMedians = (glyph, threshold) => {\n  threshold = threshold || 16;\n  for (let stroke of glyph.stages.order) {\n    const distance = Math.sqrt(Point.distance2(\n        stroke.median[0], stroke.median[stroke.median.length - 1]));\n    if (distance < threshold) {\n      console.log(`Found broken median in ${glyph.character}`);\n      const paths = svg.convertSVGPathToPaths(\n          glyph.stages.strokes[stroke.stroke]);\n      assert(paths.length === 1);\n      const polygon = svg.getPolygonApproximation(paths[0], threshold);\n      let best_point = null;\n      let best_value = -Infinity;\n      for (let point of polygon) {\n        const value = Point.distance2(point, stroke.median[0])\n        if (value > best_value) {\n          best_point = point;\n          best_value = value;\n        }\n      }\n      assert(best_point !== null);\n      stroke.median = [best_point, stroke.median[0]];\n      Glyphs.save(glyph);\n    }\n  }\n}\n\nconst migrateOldGlyphSchemaToNew = (glyph) => {\n  const codepoint = parseInt(glyph.name.substr(3), 16);\n  const character = String.fromCodePoint(codepoint);\n  const data = cjklib.getCharacterData(character);\n  assert(glyph.manual && glyph.manual.verified !== undefined,\n         `Glyph ${character} was not verified.`);\n  // Pull definition and pinyin from simplified character, if available.\n  let definition = undefined;\n  let pinyin = undefined;\n  if (data.simplified) {\n    const simplified = Glyphs.get(data.simplified);\n    const metadata = (simplified || {metadata: {}}).metadata;\n    const base = cjklib.getCharacterData(data.simplified);\n    definition = metadata.definition || base.definition;\n    pinyin = metadata.pinyin || base.pinyin;\n  }\n  const result = {\n    character: character,\n    codepoint: codepoint,\n    metadata: {\n      definition: definition,\n      frequency: data.frequency,\n      kangxi_index: data.kangxi_index,\n      pinyin: pinyin,\n      strokes: undefined,\n    },\n    stages: {\n      path: convertOldPathSchemaToSVGPath(glyph.path),\n      bridges: glyph.manual.bridges,\n      strokes: glyph.derived.strokes,\n      analysis: undefined,\n      order: undefined,\n      verified: undefined,\n    },\n    simplified: data.simplified,\n    traditional: data.traditional,\n  };\n  assert(result.stages.path !== undefined);\n  assert(result.stages.bridges !== undefined);\n  assert(result.stages.strokes !== undefined);\n  return result;\n}\n\n// Meteor methods that make use of the migration system follow.\n\nconst dumpToNewSchemaJSON = () => {\n  const fs = Npm.require('fs');\n  const path = Npm.require('path');\n  const pwd = getPWD();\n  const dictionary = fs.createWriteStream(path.join(pwd, 'dictionary.txt'));\n  const graphics = fs.createWriteStream(path.join(pwd, 'graphics.txt'));\n  runMigration(dumpGlyph(dictionary, graphics), (() => {\n    dictionary.end();\n    graphics.end();\n  }));\n}\n\nconst exportSVGs = () => {\n  const fs = Npm.require('fs');\n  const path = Npm.require('path');\n  const pwd = getPWD();\n  const directory = path.join(pwd, '.svgs');\n  fs.mkdirSync(directory);\n  runMigration((glyph) => {\n    const codepoint = glyph.character.codePointAt(0);\n    const medians = glyph.stages.order.map((x) => x.median);\n    const strokes = glyph.stages.order.map(\n        (x) => glyph.stages.strokes.corrected[x.stroke]);\n    const raw = SSR.render('animation', getAnimationData(strokes, medians));\n    const svg = raw.replace(/\\n  /g, '\\n').split('\\n').slice(1, -2).join('\\n');\n    fs.writeFileSync(path.join(directory, `${codepoint}.svg`), svg);\n  }, () => {});\n}\n\nconst loadFromOldSchemaJSON = (filename) => {\n  const fs = Npm.require('fs');\n  const path = Npm.require('path');\n  const filepath = path.join(getPWD(), 'public', filename);\n  fs.readFile(filepath, 'utf8', Meteor.bindEnvironment((error, data) => {\n    if (error) throw error;\n    const lines = data.split('\\n').filter((x) => x.length > 0);\n    console.log(`Loaded ${lines.length} old-schema glyphs.`);\n    let migrated = 0;\n    let definition = 0;\n    let pinyin = 0;\n    for (var line of lines) {\n      try {\n        const old_glyph = JSON.parse(line);\n        const new_glyph = migrateOldGlyphSchemaToNew(old_glyph);\n        const glyph = Glyphs.get(new_glyph.character);\n        if (glyph && glyph.stages.verified) {\n          console.log(`Glyph already verified: ${glyph.character}`);\n          continue;\n        }\n        Glyphs.save(new_glyph);\n        migrated += 1;\n        definition += new_glyph.metadata.definition ? 1 : 0;\n        pinyin += new_glyph.metadata.pinyin ? 1 : 0;\n      } catch (error) {\n        console.error(error);\n      }\n    }\n    console.log(`Successfully migrated ${migrated} glyphs.`);\n    console.log(`Pulled definitions for ${definition} glyphs.`);\n    console.log(`Pulled pinyin for ${pinyin} glyphs.`);\n  }));\n}\n\n// Runs the given per-glyph callback for each glyph in the database.\n// When all the glyphs are migrated, runs the completion callback.\nconst runMigration = (per_glyph_callback, completion_callback) => {\n  console.log('Running migration...');\n  if (per_glyph_callback) {\n    const codepoints =\n        Glyphs.find({}, {fields: {codepoint: 1}, sort: {codepoint: 1}}).fetch();\n    for (let i = 0; i < codepoints.length; i++) {\n      const glyph = Glyphs.findOne({codepoint: codepoints[i].codepoint});\n      assert(glyph, 'Glyphs changed during migration!');\n      per_glyph_callback(glyph);\n      if ((i + 1) % 1000 === 0) {\n        console.log(`Migrated ${i + 1} glyphs.`);\n      }\n    }\n  }\n  if (completion_callback) {\n    completion_callback();\n  }\n  console.log('Migration complete.');\n}\n\nMeteor.methods({\n  'export': () => {\n    cjklib.promise.then(Meteor.bindEnvironment(dumpToNewSchemaJSON))\n                  .catch(console.error.bind(console));\n  },\n  'exportSVGs': exportSVGs,\n  'loadFromOldSchemaJSON': (filename) => {\n    cjklib.promise.then(\n        Meteor.bindEnvironment(() => loadFromOldSchemaJSON(filename)))\n                  .catch(console.error.bind(console));\n  },\n});\n\nMeteor.startup(() => {\n  SSR.compileTemplate('animation', Assets.getText('animation.html'));\n  const completion_callback = undefined;\n  const per_glyph_callback = undefined;\n  if (!per_glyph_callback && !completion_callback) {\n    return;\n  }\n  console.log('Preparing for migration...');\n  const migration = () => runMigration(per_glyph_callback, completion_callback);\n  cjklib.promise.then(Meteor.bindEnvironment(migration))\n                .catch(console.error.bind(console));\n});\n","import {getPWD} from '/lib/base';\nimport {Progress} from '/lib/glyphs';\n\nconst child_process = Npm.require('child_process');\nconst path = Npm.require('path');\n\nconst getBackupPath = () => {\n  return path.join(getPWD(), 'server', 'backup');\n}\n\nMeteor.methods({\n  backup() {\n    const path = getBackupPath();\n    child_process.spawn('mongodump', ['--port', '3001', '--out', path]);\n    Progress.update({}, {$set: {backup: true}});\n  },\n  restore() {\n    const path = getBackupPath();\n    console.log(path);\n    child_process.spawn('mongorestore', ['--port', '3001', '--drop', path]);\n  },\n});\n","import {assert} from '/lib/base';\nimport {Glyphs} from '/lib/glyphs';\n\nfunction evaluate(glyphs, classifier) {\n  var num_correct = 0;\n  for (var i = 0; i < glyphs.length; i++) {\n    if (check_classifier_on_glyph(glyphs[i], classifier)) {\n      num_correct += 1;\n    }\n  }\n  return num_correct/glyphs.length;\n}\n\nfunction train_neural_net() {\n  var glyphs = Glyphs.find({'manual.verified': true}).fetch();\n  var sample = _.sample(glyphs, 400);\n  console.log('Hand-tuned accuracy:', evaluate(sample, hand_tuned_classifier));\n\n  var training_data = [];\n  for (var i = 0; i < glyphs.length; i++) {\n    var glyph_data = get_glyph_training_data(glyphs[i]);\n    var positive_data = glyph_data.filter(function(x) { return x[1] > 0; });\n    var negative_data = glyph_data.filter(function(x) { return x[1] === 0; });\n    if (positive_data.length > negative_data.length) {\n      positive_data = _.sample(positive_data, negative_data.length);\n    } else {\n      negative_data = _.sample(negative_data, positive_data.length);\n    }\n    glyph_data = negative_data.concat(positive_data);\n    for (var j = 0; j < glyph_data.length; j++) {\n      training_data.push(glyph_data[j]);\n    }\n  }\n  console.log('Got ' + training_data.length + ' rows of training data.');\n\n  var net = new convnetjs.Net();\n  net.makeLayers([\n    {type: 'input', out_sx: 1, out_sy: 1, out_depth: 8},\n    {type: 'fc', num_neurons: 8, activation: 'tanh'},\n    {type: 'fc', num_neurons: 8, activation: 'tanh'},\n    {type: 'softmax', num_classes: 2},\n  ]);\n  var trainer = new convnetjs.Trainer(\n      net, {method: 'adadelta', l2_decay: 0.001, batch_size: 10});\n  var input = new convnetjs.Vol(1, 1, 8);\n  for (var iteration = 0; iteration < 10; iteration++) {\n    var loss = 0;\n    var round_data = _.sample(training_data, 4000);\n    for (var i = 0; i < round_data.length; i++) {\n      assert(input.w.length === round_data[i][0].length);\n      input.w = round_data[i][0];\n      var stats = trainer.train(input, round_data[i][1]);\n      assert(!isNaN(stats.loss))\n      loss += stats.loss;\n    }\n    console.log('Iteration', iteration, 'mean loss:', loss/round_data.length);\n  }\n  console.log('Trained neural network:', JSON.stringify(net.toJSON()));\n\n  function net_classifier(features) {\n    assert(input.w.length === features.length);\n    input.w = features;\n    var softmax = net.forward(input).w;\n    assert(softmax.length === 2);\n    return softmax[1] - softmax[0];\n  }\n  console.log('Neural-net accuracy:', evaluate(sample, net_classifier));\n\n  function combined_classifier(weight) {\n    return function(features) {\n      return hand_tuned_classifier(features) + weight*net_classifier(features);\n    }\n  }\n  var weights = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1];\n  for (var i = 0; i < weights.length; i++) {\n    console.log('Weight',  weights[i], 'combined accuracy:',\n                evaluate(sample, combined_classifier(weights[i])));\n  }\n}\n"]}}]